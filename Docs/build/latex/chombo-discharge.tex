%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=2,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Introduction}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{chombo-discharge Documentation}
\date{May 30, 2022}
\release{}
\author{Robert Marskar}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\begin{sphinxadmonition}{important}{Important:}
\sphinxstylestrong{This is an alpha release. Development is still in progress, and various bugs may be present. User interfaces can and will change.}
\end{sphinxadmonition}



\begin{sphinxadmonition}{important}{Important:}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is a modular and scalable research code for Cartesian two\sphinxhyphen{} and three\sphinxhyphen{}dimensional simulations of low\sphinxhyphen{}temperature plasmas in complex geometries.
The code is hosted at \sphinxhref{https://github.com/chombo-discharge/chombo-discharge}{GitHub} together with the source files for this documentation.
\end{sphinxadmonition}

\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} features include:
\begin{itemize}
\item {} 
Fully written in C++.

\item {} 
Support for complex geometries.

\item {} 
Scalar advection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction processes.

\item {} 
Electrostatics with support for electrodes and dielectrics.

\item {} 
Radiative transport as a diffusion or Monte Carlo process.

\item {} 
Particle\sphinxhyphen{}mesh operations (like Particle\sphinxhyphen{}In\sphinxhyphen{}Cell)

\item {} 
Parallel I/O with HDF5.

\item {} 
Dual\sphinxhyphen{}grid simulations with individual load balancing of fluid and particles.

\item {} 
Various multi\sphinxhyphen{}physics interfaces that use the above solvers.

\item {} 
Various time integration schemes.

\end{itemize}

Numerical solvers are designed to run either on their own, or as a part of a larger application.

For scalability, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is built on top of \sphinxhref{https://commons.lbl.gov/display/chombo/Chombo+-+Software+for+Adaptive+Solutions+of+Partial+Differential+Equations}{Chombo 3}, and therefore additionally features
\begin{itemize}
\item {} 
Cut\sphinxhyphen{}cell representation of multi\sphinxhyphen{}material geometries.

\item {} 
Patch based adaptive mesh refinement.

\item {} 
Weak and strong scalability to thousands of computer cores.

\end{itemize}

Our goal is that users will be able to use \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} without modifying the underlying solvers.
There are interfaces for describing e.g. the plasma physics, boundary conditions, mesh refinement, etc.
As \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} evolves, so will these interfaces.
We aim for (but cannot guarantee) backward compatibility such that existing \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} models can be run on future versions of \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.




\chapter{Introduction}
\label{\detokenize{index:introduction}}

\section{Using this documentation}
\label{\detokenize{Base/Documentation:using-this-documentation}}\label{\detokenize{Base/Documentation::doc}}
This documentation is the user documentation for \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
It includes an explanation of the data structures, algorithms, and code design.

This documentation is built as a part of the continuous integration (CI) at GitHub, and is automatically kept up\sphinxhyphen{}to\sphinxhyphen{}date with the latest version of \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
It was built using \sphinxtitleref{reStructuredText} with \sphinxtitleref{Sphinx}, and is HTML browser\sphinxhyphen{}friendly.


\subsection{Doxygen documentation}
\label{\detokenize{Base/Documentation:doxygen-documentation}}
A separate Doxygen documentation of the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} code is found at \sphinxurl{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/index.html}


\section{Overview}
\label{\detokenize{Base/Overview:overview}}\label{\detokenize{Base/Overview:chap-overview}}\label{\detokenize{Base/Overview::doc}}

\subsection{History}
\label{\detokenize{Base/Overview:history}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is aimed at solving discharge problems.
It was originally developed at SINTEF Energy Research between 2015\sphinxhyphen{}2018, and aimed at simulating discharges in high\sphinxhyphen{}voltage engineering.
Further development was started in 2021, where much of the code was redesigned for improved modularity and performance.


\subsection{Key functionalities}
\label{\detokenize{Base/Overview:key-functionalities}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} uses a Cartesian embedded boundary (EB) grid formulation and adaptive mesh refinement (AMR) formalism where the grids frequently change and are adapted to the solution as simulations progress.
Key functionalities are provided in \hyperref[\detokenize{Base/Overview:tab-keycapabilities}]{Table \ref{\detokenize{Base/Overview:tab-keycapabilities}}}.

\begin{sphinxadmonition}{important}{Important:}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is \sphinxstylestrong{not} a black\sphinxhyphen{}box model for discharge applications.
It is an evolving research code with occasionally expanded capabilities, API changes, and performance improvements.
Although problems can be set up through our Python toos, users should nonetheless be willing to take time to understand how the code works.
In particular, developers should invest some effort in understanding the data structures and \sphinxcode{\sphinxupquote{Chombo}} basics (see {\hyperref[\detokenize{Source/ChomboBasics:chap-basics}]{\sphinxcrossref{\DUrole{std,std-ref}{Chombo\sphinxhyphen{}3 basics}}}}).
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Key capabilities.}\label{\detokenize{Base/Overview:id1}}\label{\detokenize{Base/Overview:tab-keycapabilities}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{20}{70}|\X{50}{70}|}
\hline
\sphinxstyletheadfamily 
Capabilities
&\sphinxstyletheadfamily 
Supported?
\\
\hline
Grids
&
\sphinxstylestrong{Fundamentally Cartesian}.
\\
\hline
Parallelized?
&
\sphinxstylestrong{Yes}, using flat MPI.
\\
\hline
Load balancing?
&
\sphinxstylestrong{Yes}, with support for individual particle and fluid load balancing.
\\
\hline
Complex geometries?
&
\sphinxstylestrong{Yes}, using embedded boundaries (i.e., cut\sphinxhyphen{}cells).
\\
\hline
Adaptive mesh refinement?
&
\sphinxstylestrong{Yes}, using patch\sphinxhyphen{}based refinement.
\\
\hline
Subcycling in time?
&
\sphinxstylestrong{No}, only global time step methods.
\\
\hline
Computational particles?
&
\sphinxstylestrong{Yes.}
\\
\hline
Linear solvers?
&
\sphinxstylestrong{Yes}, using geometric multigrid in complex geometries.
\\
\hline
Time discretizations?
&
\sphinxstylestrong{Mostly explicit.}
\\
\hline
Parallel IO?
&
\sphinxstylestrong{Yes}, using HDF5.
\\
\hline
Checkpoint\sphinxhyphen{}restart?
&
\sphinxstylestrong{Yes}, for both fluid and particles.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

An early version of \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} used sub\sphinxhyphen{}cycling in time, but this has now been replaced with global time stepping methods.
That is, all the AMR levels are advanced using the same time step.
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} has also incorporated many changes to the EB functionality supplied by \sphinxcode{\sphinxupquote{Chombo}}.
This includes much faster grid generation, support for polygon surfaces, and many performance optimizations (in particular to the EB formulation).

\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} supports both fluid and particle methods, and can use multiply parallel distributed grids (see {\hyperref[\detokenize{Source/Realm:chap-realm}]{\sphinxcrossref{\DUrole{std,std-ref}{Realm}}}}) for individually load balancing particle and fluid kernels.
Although many abstractions are in place so that user can describe a new set of physics, or write entirely new solvers into \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} and still use the embedded boundary formalism, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} also provides several physics modules for describing various types of problems.
See e.g. {\hyperref[\detokenize{Applications/ImplementedModels:chap-implementedmodels}]{\sphinxcrossref{\DUrole{std,std-ref}{Implemented models}}}}.


\subsection{Design approach}
\label{\detokenize{Base/Overview:design-approach}}
A fundamental design principle in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is the division between the AMR core, geometry, solvers, physics coupling, and user applications.
As an example, the fundamental time integrator class \sphinxcode{\sphinxupquote{TimeStepper}} in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is a just an abstraction, i.e. it only presents an API which application codes must use.
Because of that, \sphinxcode{\sphinxupquote{TimeStepper}} can be used for solving completely unrelated problems.
We have, for example, implementations of \sphinxcode{\sphinxupquote{TimeStepper}} for solving radiative transfer equations, advection\sphinxhyphen{}diffusion problems, electrostatic problems, or for plasma problems.

The division between computational concepts (e.g., AMR functionality and solvers) exists so that users will be able to solve problems across a range of geometries, add new solvers functionality, or write entirely new applications, without requiring deep changes to \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
\hyperref[\detokenize{Base/Overview:fig-design}]{Fig.\@ \ref{\detokenize{Base/Overview:fig-design}}} shows the basic design sketch of the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} code.
To the right in this figure we have the AMR core functionality, which supplies the infrastructure for running the solvers.
In general, solvers may share common features (such as elliptic discretizations) or be completely disjoint.
For this reason numerical solvers are asked to \sphinxstyleemphasis{register} AMR requirements.
For example, elliptic solvers need functionality for interpolating ghost cells over the refinement boundary, but pure particle solvers have no need for such functionality.
A consequence of this is that the numerical solvers are literally asked (during their instantiation) to register what type of AMR infrastructure they require.
In return, the AMR core will allocate this infrastructure and make it available to solver, as illustrated in \hyperref[\detokenize{Base/Overview:fig-design}]{Fig.\@ \ref{\detokenize{Base/Overview:fig-design}}}.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{Design}.png}
\caption{Concept design sketch for \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.}\label{\detokenize{Base/Overview:id2}}\label{\detokenize{Base/Overview:fig-design}}\end{figure}

\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} also uses \sphinxstyleemphasis{loosely coupled} solvers as a foundation for the code design, where a \sphinxstyleemphasis{solver} indicates a piece of code for solving an equation.
For example, solving the Laplace equation \(\nabla^2\Phi = 0\) is encapsulated by one of the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} solvers.
Some solvers in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} have a null\sphinxhyphen{}implemented API, i.e. we have enforced a strict separation of the solver interface and the solver implementation.
This constraint exists because while new features may be added to a discretization, we do not want such changes to affect upstream application code.
An example of this is the \sphinxcode{\sphinxupquote{FieldSolver}}, which conceptualizes a numerical solver for solving for electrostatic field problems.
The \sphinxcode{\sphinxupquote{FieldSolver}} is an API with no fundamental discretization \textendash{} it only contains high\sphinxhyphen{}level routines for understanding the type of solver being dealt with.
Yet, it is the \sphinxcode{\sphinxupquote{FieldSolver}} API which is used by application code (and not the implementation class).

All numerical solvers interact with a common AMR core that encapsulates functionality for running the solvers.
All solvers are also compatible with mesh refinement and complex geometries, but they can only run through \sphinxstyleemphasis{application codes}, i.e. \sphinxstyleemphasis{physics modules}.
These modules encapsulate the time advancement of either individual or coupled solvers.
Solvers only interact with one another through these modules, and these modules usually advance the equations of motion using the method\sphinxhyphen{}of\sphinxhyphen{}lines.


\section{Installation}
\label{\detokenize{Base/Installation:installation}}\label{\detokenize{Base/Installation:chap-installation}}\label{\detokenize{Base/Installation::doc}}

\subsection{Obtaining \sphinxstyleliteralintitle{\sphinxupquote{chombo\sphinxhyphen{}discharge}}}
\label{\detokenize{Base/Installation:obtaining-chombo-discharge}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} can be freely obtained from \sphinxurl{https://github.com/chombo-discharge/chombo-discharge}.
The following packages are \sphinxstyleemphasis{required}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Chombo}}, which is supplied with \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.

\item {} 
The C++ JSON file parser \sphinxurl{https://github.com/nlohmann/json}.

\item {} 
The \sphinxcode{\sphinxupquote{EBGeometry}} package, see \sphinxurl{https://github.com/rmrsk/EBGeometry}.

\item {} 
LAPACK and BLAS

\end{itemize}

The \sphinxcode{\sphinxupquote{Chombo}}, \sphinxcode{\sphinxupquote{nlohmann/json}}, and \sphinxcode{\sphinxupquote{EBGeometry}} dependencies are automatically handled by \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} through git submodules.

\begin{sphinxadmonition}{warning}{Warning:}
Our version of \sphinxcode{\sphinxupquote{Chombo}} is hosted at \sphinxurl{https://github.com/chombo-discharge/Chombo-3.3.git}.
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} has made substantial changes to the embedded boundary generation in \sphinxcode{\sphinxupquote{Chombo}}.
It will not compile with other versions of \sphinxcode{\sphinxupquote{Chombo}} than the one above.
\end{sphinxadmonition}

Optional packages are
\begin{itemize}
\item {} 
A serial or parallel version of HDF5, which is used for writing plot and checkpoint files.

\item {} 
An MPI installation, which is used for parallelization.

\item {} 
\sphinxurl{https://visit-dav.github.io/visit-website/} visualization, which used for visualization.

\end{itemize}


\subsection{Organization}
\label{\detokenize{Base/Installation:organization}}
The \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} source files are organized as follows:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Code organization.}\label{\detokenize{Base/Installation:id1}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{10}{60}|\X{50}{60}|}
\hline
\sphinxstyletheadfamily 
Folder
&\sphinxstyletheadfamily 
Explanation
\\
\hline
\sphinxcode{\sphinxupquote{Source}}
&
Source files for the AMR core, solvers, and various utilities.
\\
\hline
\sphinxcode{\sphinxupquote{Physics}}
&
Various implementations that can run the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} source code.
\\
\hline
\sphinxcode{\sphinxupquote{Geometries}}
&
Various geometries.
\\
\hline
\sphinxcode{\sphinxupquote{Submodules}}
&
Git submodule dependencies.
\\
\hline
\sphinxcode{\sphinxupquote{Exec}}
&
Various executable applications.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Cloning \sphinxstyleliteralintitle{\sphinxupquote{chombo\sphinxhyphen{}discharge}}}
\label{\detokenize{Base/Installation:cloning-chombo-discharge}}
To obtain \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, the simplest approach is to clone it and recursively fetch the submodules:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
git clone \PYGZhy{}\PYGZhy{}recursive git@github.com:chombo\PYGZhy{}discharge/chombo\PYGZhy{}discharge.git
\end{sphinxVerbatim}


\subsection{Setting up the environment}
\label{\detokenize{Base/Installation:setting-up-the-environment}}
When compiling \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, makefiles must be able to find both \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} and \sphinxcode{\sphinxupquote{Chombo}}.
In our makefiles the paths to these are supplied through the environment variables
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DISCHARGE\_HOME}}, pointing to the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} root directory.

\item {} 
\sphinxcode{\sphinxupquote{CHOMBO\_HOME}}, pointing to your \sphinxcode{\sphinxupquote{Chombo}} library

\end{itemize}

Note that \sphinxcode{\sphinxupquote{DISCHARGE\_HOME}} must point to the root folder in the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} source code, while \sphinxcode{\sphinxupquote{CHOMBO\_HOME}} must point to the \sphinxcode{\sphinxupquote{lib/}} folder in your \sphinxcode{\sphinxupquote{Chombo}} root directory.
When cloning with submodules, both \sphinxcode{\sphinxupquote{Chombo}} and \sphinxcode{\sphinxupquote{nlohmann/json}} will be placed in the \sphinxcode{\sphinxupquote{Submodules}} folder in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME}}.

\begin{sphinxadmonition}{note}{Note:}
To clone \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} directly to \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME}}, set the environment variables and clone (using \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}} to fetch submodules):

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{export} \PYG{n+nv}{DISCHARGE\PYGZus{}HOME}\PYG{o}{=}/home/foo/chombo\PYGZhy{}discharge
\PYG{n+nb}{export} \PYG{n+nv}{CHOMBO\PYGZus{}HOME}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}DISCHARGE\PYGZus{}HOME}/Submodules/Chombo\PYGZhy{}3.3/lib

git clone \PYGZhy{}\PYGZhy{}recursive git@github.com:chombo\PYGZhy{}discharge/chombo\PYGZhy{}discharge.git \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{DISCHARGE\PYGZus{}HOME}\PYG{l+s+si}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is built using a configuration file supplied to \sphinxcode{\sphinxupquote{Chombo}}.
This file must reside in \sphinxcode{\sphinxupquote{\$CHOMBO\_HOME/mk}}.
Some standard configuration files are supplied with \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, and reside in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Lib/Local}}.
These files may or may not work right off the bat.


\subsection{Test build}
\label{\detokenize{Base/Installation:test-build}}
For a quick compilation test the user can use the GNU configuration file supplied with \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} by following the steps below.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Copy the GNU configuration file

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cp \PYGZdl{}DISCHARGE\PYGZus{}HOME/Lib/Local/Make.defs.GNU \PYGZdl{}CHOMBO\PYGZus{}HOME/mk/Make.defs.local
\end{sphinxVerbatim}

\item {} 
If you do not have the GNU compiler suite, install it by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{csh} \PYG{n}{gfortran} \PYG{n}{g}\PYG{o}{+}\PYG{o}{+} \PYG{n}{libblas}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{liblapack}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\end{sphinxVerbatim}

This will install
\begin{itemize}
\item {} 
LAPACK and BLAS

\item {} 
GNU compilers for Fortran and C++

\end{itemize}

\item {} 
Compile \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cd \PYGZdl{}DISCHARGE\PYGZus{}HOME
make \PYGZhy{}s \PYGZhy{}j4
\end{sphinxVerbatim}

\end{enumerate}

This will compile the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} source code in serial and without HDF5 (using four cores for the compilation).
If successful, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} libraries will appear in \sphinxcode{\sphinxupquote{\$DISCARGE\_HOME/Lib}}.


\subsection{Advanced configuration}
\label{\detokenize{Base/Installation:advanced-configuration}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is compiled using GNU Make, following the \sphinxcode{\sphinxupquote{Chombo}}.
Compilers, libraries, and configuration options are defined in a file \sphinxcode{\sphinxupquote{Make.defs.local}} which resides in \sphinxcode{\sphinxupquote{\$CHOMBO\_HOME/mk}}.
Users need to supply this file in order to compile \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
Typically, these steps include
\begin{itemize}
\item {} 
Specifying Fortran and C++ compilers

\item {} 
Specifying configurations. E.g., serial or parallel builds, and compiler flags.

\item {} 
Specifying library paths (in particular for HDF5).

\end{itemize}


\subsubsection{Main settings}
\label{\detokenize{Base/Installation:main-settings}}
The main variables that the user needs to set are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DIM = 2/3}} The dimensionality (must be 2 or 3).

\item {} 
\sphinxcode{\sphinxupquote{DEBUG = TRUE/FALSE}}
This enables or disables debugging flags and code checks/assertions.

\item {} 
\sphinxcode{\sphinxupquote{OPT = FALSE/TRUE/HIGH}}.
Setting \sphinxcode{\sphinxupquote{OPT=TRUE/HIGH}} enables optimization flags that will speed up \sphinxcode{\sphinxupquote{Chombo}} and \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.

\item {} 
\sphinxcode{\sphinxupquote{PRECISION = DOUBLE}}
Currently, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} has not been wetted with single precision.
Many algorithms (like conjugate gradient) depend on the use of double precision.

\item {} 
\sphinxcode{\sphinxupquote{CXX = \textless{}C++ compiler\textgreater{}}}

\item {} 
\sphinxcode{\sphinxupquote{FC = \textless{}Fortran compiler\textgreater{}}}

\item {} 
\sphinxcode{\sphinxupquote{MPI = TRUE/FALSE}}
This enables/disables MPI.

\item {} 
\sphinxcode{\sphinxupquote{MPICXX = \textless{}MPI compiler\textgreater{}}}

\item {} 
\sphinxcode{\sphinxupquote{CXXSTD=14}}
Sets the C++ standard \sphinxhyphen{} we are currently at C++14.

\item {} 
\sphinxcode{\sphinxupquote{USE\_EB=TRUE}}
Configures \sphinxcode{\sphinxupquote{Chombo}} with embedded boundary functionality.
This is a requirement.

\item {} 
\sphinxcode{\sphinxupquote{USE\_MF=TRUE}}
Configures \sphinxcode{\sphinxupquote{Chombo}} with multifluid functionality.
This is a requirement.

\item {} 
\sphinxcode{\sphinxupquote{USE\_HDF5 = TRUE/FALSE}}
This enables and disables HDF5 code.

\end{itemize}


\subsubsection{HDF5}
\label{\detokenize{Base/Installation:hdf5}}
If using HDF5, one must also set the following flags:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{HDFINCFLAGS      = \sphinxhyphen{}I\textless{}path to hdf5\sphinxhyphen{}serial\textgreater{}/include}} (for serial HDF5).

\item {} 
\sphinxcode{\sphinxupquote{HDFLIBFLAGS      = \sphinxhyphen{}L\textless{}path to hdf5\sphinxhyphen{}serial\textgreater{}/lib \sphinxhyphen{}lhdf5 \sphinxhyphen{}lz}} (for serial HDF5)

\item {} 
\sphinxcode{\sphinxupquote{HDFMPIINCFLAGS   = \sphinxhyphen{}I\textless{}path to hdf5\sphinxhyphen{}parallel\textgreater{}/include}} (for parallel HDF5)

\item {} 
\sphinxcode{\sphinxupquote{HDFMPILIBFLAGS   = \sphinxhyphen{}L\textless{}path to hdf5\sphinxhyphen{}parallel\textgreater{}/lib \sphinxhyphen{}lhdf5 \sphinxhyphen{}lz}} (for parallel HDF5).

\end{itemize}


\subsubsection{Compiler flags}
\label{\detokenize{Base/Installation:compiler-flags}}
Compiler flags are set through
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{cxxoptflags  = \textless{}C++ compiler flags}}

\item {} 
\sphinxcode{\sphinxupquote{foptflags    = \textless{}Fortran compiler flags}}

\item {} 
\sphinxcode{\sphinxupquote{syslibflags  = \textless{}system library flags\textgreater{}}}

\end{itemize}

Note that LAPACK and BLAS are requirements in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
Linking to these can often be done using
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{syslibflag = \sphinxhyphen{}llapack \sphinxhyphen{}lblas}} (for GNU compilers)

\item {} 
\sphinxcode{\sphinxupquote{syslibflag = \sphinxhyphen{}mkl=sequential}} (for Intel compilers)

\end{itemize}


\subsubsection{Pre\sphinxhyphen{}defined configuration files}
\label{\detokenize{Base/Installation:pre-defined-configuration-files}}
Some commonly used configuration files are found in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Lib/Local}}.
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} can be compiled in serial or with MPI, and with or without HDF5.
The user need to configure the \sphinxcode{\sphinxupquote{Chombo}} makefile to ensure that the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is properly configured.
Below, we include brief instructions for compilation on a Linux workstation and for a cluster.


\subsubsection{GNU configuration for workstations}
\label{\detokenize{Base/Installation:gnu-configuration-for-workstations}}
Here, we provide a more complete installation example using GNU compilers for a workstation.
These steps are intended for users that do not have MPI or HDF5 installed.
If you already have installed MPI and/or HDF5, the steps below might require modifications.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ensure that \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME}} and \sphinxcode{\sphinxupquote{\$CHOMBO\_HOME}} point to the correct locations:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}DISCHARGE\PYGZus{}HOME}
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}CHOMBO\PYGZus{}HOME}
\end{sphinxVerbatim}

\item {} 
Install GNU compiler dependencies by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{csh} \PYG{n}{gfortran} \PYG{n}{g}\PYG{o}{+}\PYG{o}{+} \PYG{n}{libblas}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{liblapack}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\end{sphinxVerbatim}

This will install
\begin{itemize}
\item {} 
LAPACK and BLAS

\item {} 
GNU compilers for Fortran and C++

\end{itemize}

\item {} 
To also install OpenMPI and HDF5:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{sudo} \PYG{n}{apt} \PYG{n}{install} \PYG{n}{libhdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{libhdf5}\PYG{o}{\PYGZhy{}}\PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{openmpi}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{bin}
\end{sphinxVerbatim}

This will install
\begin{itemize}
\item {} 
OpenMPI

\item {} 
HDF5, both serial and parallel.

\end{itemize}

Both serial and parallel HDF5 will be installed, and these are \sphinxstyleemphasis{usually} found in folders
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/usr/lib/x86\_64\sphinxhyphen{}linux\sphinxhyphen{}gnu/hdf5/serial/}} for serial HDF5

\item {} 
\sphinxcode{\sphinxupquote{/usr/lib/x86\_64\sphinxhyphen{}linux\sphinxhyphen{}gnu/hdf5/openmpi/}} for parallel HDF5 (using OpenMPI).

\end{itemize}

Before proceeding further, the user need to locate the HDF5 libraries (if building with HDF5).

\item {} 
After installing the dependencies, copy the desired configuration file to \sphinxcode{\sphinxupquote{\$CHOMBO\_HOME/mk}}:
\begin{itemize}
\item {} 
\sphinxstylestrong{Serial build without HDF5}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cp \PYGZdl{}DISCHARGE\PYGZus{}HOME/Lib/Local/Make.defs.GNU \PYGZdl{}CHOMBO\PYGZus{}HOME/mk/Make.defs.local
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{Serial build with HDF5}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cp \PYGZdl{}DISCHARGE\PYGZus{}HOME/Lib/Local/Make.defs.HDF5.GNU \PYGZdl{}CHOMBO\PYGZus{}HOME/mk/Make.defs.local
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{MPI build without HDF5}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cp \PYGZdl{}DISCHARGE\PYGZus{}HOME/Lib/Local/Make.defs.MPI.GNU \PYGZdl{}CHOMBO\PYGZus{}HOME/mk/Make.defs.local
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{MPI build with HDF5}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cp \PYGZdl{}DISCHARGE\PYGZus{}HOME/Lib/Local/Make.defs.MPI.HDF5.GNU \PYGZdl{}CHOMBO\PYGZus{}HOME/mk/Make.defs.local
\end{sphinxVerbatim}

\end{itemize}

\item {} 
Compile the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cd \PYGZdl{}DISCHARGE\PYGZus{}HOME
make \PYGZhy{}s \PYGZhy{}j4 discharge\PYGZhy{}lib
\end{sphinxVerbatim}

\end{enumerate}

This will compile the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} source code using the configuration settings set by the user.
To compile \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} in 3D, do \sphinxcode{\sphinxupquote{make \sphinxhyphen{}s \sphinxhyphen{}j4 DIM=3 discharge\sphinxhyphen{}lib}}.
If successful, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} libraries will appear in \sphinxcode{\sphinxupquote{\$DISCARGE\_HOME/Lib}}.


\subsubsection{Configuration on clusters}
\label{\detokenize{Base/Installation:configuration-on-clusters}}
To configure \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} for executation on a cluster, use one of the makefiles supplied in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Lib/Local}} if it exists for your computer.
Alternatively, copy \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Lib/Local/Make.defs.local.template}} to \sphinxcode{\sphinxupquote{\$CHOMBO\_HOME/mk/Make.defs.local}} and set the compilers, optimization flags, and paths to HDF5 library.

On clusters, MPI and HDF5 are usually already installed, but must usually be loaded (e.g. as modules) before compilation.


\subsection{Running an example application}
\label{\detokenize{Base/Installation:running-an-example-application}}
In \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, applications are set up so that they use the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} source code and one \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} physics module.
To run one of the applications that use a particular \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} physics module, we will run a simulation of a positive streamer (in air).

The application code is located in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Exec/Examples/CdrPlasma/DeterministicAir}} and it uses the convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction plasma module (located in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/CdrPlasma}}).

First, compile the application by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cd \PYGZdl{}DISCHARGE\PYGZus{}HOME/Exec/Examples/CdrPlasma/DeterministicAir
make \PYGZhy{}s \PYGZhy{}j4 DIM=2 program
\end{sphinxVerbatim}

This will provide an executable named \sphinxcode{\sphinxupquote{program2d.\textless{}bunch\_of\_options\textgreater{}.ex}}.
If one compiles for 3D, i.e. \sphinxcode{\sphinxupquote{DIM=3}}, the executable will be named \sphinxcode{\sphinxupquote{program3d.\textless{}bunch\_of\_options\textgreater{}.ex}}.

To run the application do:

\sphinxstylestrong{Serial build}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
./program2d.\PYGZlt{}bunch\PYGZus{}of\PYGZus{}options\PYGZgt{}.ex positive2d.inputs
\end{sphinxVerbatim}

\sphinxstylestrong{Parallel build}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
mpirun \PYGZhy{}np 8 program2d.\PYGZlt{}bunch\PYGZus{}of\PYGZus{}options\PYGZgt{}.ex positive2d.inputs
\end{sphinxVerbatim}

If the user also compiled with HDF5, plot files will appear in the subfolder \sphinxcode{\sphinxupquote{plt}}.


\subsection{Troubleshooting}
\label{\detokenize{Base/Installation:troubleshooting}}\label{\detokenize{Base/Installation:chap-troubleshooting}}
If the prerequisites are in place, compilation of \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is usually straightforward.
However, due to dependencies on \sphinxcode{\sphinxupquote{Chombo}} and HDF5, compilation can sometimes be an issue.
Our experience is that if \sphinxcode{\sphinxupquote{Chombo}} compiles, so does \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.

If experiencing issues, try cleaning \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{cd} \PYG{n+nv}{\PYGZdl{}DISCHARGE\PYGZus{}HOME}
make pristine
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Do not hesitate to contact us at \sphinxhref{https://github.com/chombo-discharge/chombo-discharge}{GitHub} regarding installation issues.
\end{sphinxadmonition}


\subsubsection{Recommended configurations}
\label{\detokenize{Base/Installation:recommended-configurations}}

\paragraph{Production runs}
\label{\detokenize{Base/Installation:production-runs}}
For production runs, we generally recommend that the user compiles with \sphinxcode{\sphinxupquote{DEBUG=FALSE}} and \sphinxcode{\sphinxupquote{OPT=HIGH}}.
These settings can be set directly in \sphinxcode{\sphinxupquote{Make.defs.local}}.
Alternatively, they can be included directly on the command line when compiling problems.


\paragraph{Debugging}
\label{\detokenize{Base/Installation:debugging}}
If you believe that there might be a bug in the code, one can compile with \sphinxcode{\sphinxupquote{DEBUG=TRUE}} and \sphinxcode{\sphinxupquote{OPT=TRUE}}.
This will turn on some assertions throughout \sphinxcode{\sphinxupquote{Chombo}} and \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.


\subsubsection{Common problems}
\label{\detokenize{Base/Installation:common-problems}}\begin{itemize}
\item {} 
Missing library paths:
\begin{quote}

On some installations the linker can not find the HDF5 library.
To troubleshoot, make sure that the the environment variable \sphinxcode{\sphinxupquote{LD\_LIBRARY\_PATH}} can find the HDF5 libraries:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}LD\PYGZus{}LIBRARY\PYGZus{}PATH}
\end{sphinxVerbatim}

If the path is not included, it can be defined by:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{export} \PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}LD\PYGZus{}LIBRARY\PYGZus{}PATH}:/\PYGZlt{}path\PYGZus{}to\PYGZus{}hdf5\PYGZus{}installation\PYGZgt{}/lib
\end{sphinxVerbatim}
\end{quote}

\end{itemize}


\section{Visualization}
\label{\detokenize{Base/Visualization:visualization}}\label{\detokenize{Base/Visualization:chap-visualization}}\label{\detokenize{Base/Visualization::doc}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} output files are always written to HDF5.
The plot files will reside in the \sphinxcode{\sphinxupquote{plt}} subfolder where the application was run.

Currently, we have only used \sphinxhref{https://visit-dav.github.io/visit-website/}{VisIt} for visualizing the plot files.
Learning how to use VisIt is not a part of this documentation; there are great tutorials on the \sphinxhref{https://visit-dav.github.io/visit-website/}{VisIt website}.


\section{Controlling \sphinxstyleliteralintitle{\sphinxupquote{chombo\sphinxhyphen{}discharge}}}
\label{\detokenize{Base/Control:controlling-chombo-discharge}}\label{\detokenize{Base/Control:chap-control}}\label{\detokenize{Base/Control::doc}}
In this chapter we give a brief overview of how to run a \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} simulation and control its behavior through input scripts or command line options.


\subsection{Compiling and running}
\label{\detokenize{Base/Control:compiling-and-running}}
To run simulations, the user must first compile his application.
Once the application has been setup, the user can compile by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
make \PYGZhy{}s \PYGZhy{}j \PYG{l+m}{32} \PYG{n+nv}{DIM}\PYG{o}{=}N \PYGZlt{}application\PYGZus{}name\PYGZgt{}
\end{sphinxVerbatim}

where \sphinxstyleemphasis{N} may be 2 or 3, and \textless{}application\_name\textgreater{} is the name of the file that holds the \sphinxcode{\sphinxupquote{main()}} function.
This will compile an executable whose name depends on your application name and compiler settings.
Please refer to the \sphinxcode{\sphinxupquote{Chombo}} manual for explanation of the executable name. You may, of course, rename your application.


\subsubsection{Compilation options}
\label{\detokenize{Base/Control:compilation-options}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} can compile with various code guards enabled, to spot bugs or potential errors in the code.
To compile with these guards turned on, compile with \sphinxcode{\sphinxupquote{DEBUG=TRUE}}, e.g. \sphinxcode{\sphinxupquote{make \sphinxhyphen{}s \sphinxhyphen{}j32 DIM=2 DEBUG=TRUE \textless{}application\_name\textgreater{}}}.

To compile for production runs, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} should generally speaking be compiled with \sphinxcode{\sphinxupquote{DEBUG=FALSE}} and \sphinxcode{\sphinxupquote{OPT=HIGH}}, for example

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
make \PYGZhy{}s \PYGZhy{}j32 \PYG{n+nv}{DIM}\PYG{o}{=}\PYG{l+m}{2} \PYG{n+nv}{OPT}\PYG{o}{=}HIGH \PYG{n+nv}{DEBUG}\PYG{o}{=}FALSE \PYGZlt{}application\PYGZus{}name\PYGZgt{}
\end{sphinxVerbatim}

Recall also that default settings for the dimension (\sphinxcode{\sphinxupquote{DIM}}), optimization level (\sphinxcode{\sphinxupquote{OPT}}), and debug mode (\sphinxcode{\sphinxupquote{DEBUG}}) can be set in \sphinxcode{\sphinxupquote{Make.defs.local}}, see \DUrole{xref,std,std-ref}{Chap:GettingStarted}.


\subsection{Running applications}
\label{\detokenize{Base/Control:running-applications}}

\subsubsection{Serial}
\label{\detokenize{Base/Control:serial}}
Next, if the application was compiled for serial execution one runs it with:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
./\PYGZlt{}application\PYGZus{}executable\PYGZgt{} \PYGZlt{}input\PYGZus{}file\PYGZgt{}
\end{sphinxVerbatim}

where \textless{}input\_file\textgreater{} is your input file.


\subsubsection{Parallel}
\label{\detokenize{Base/Control:parallel}}
If the executable was compiled with MPI, one executes with e.g. \sphinxcode{\sphinxupquote{mpirun}} (or one of its aliases):

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
mpirun \PYGZhy{}np \PYG{l+m}{32} \PYGZlt{}application\PYGZus{}executable\PYGZgt{} \PYGZlt{}input\PYGZus{}file\PYGZgt{}
\end{sphinxVerbatim}

On clusters, this is a little bit different and usually requires passing the above command through a batch system.


\subsection{Simulation inputs}
\label{\detokenize{Base/Control:simulation-inputs}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} simulations take their input from a single simulation input file (possibly appended with overriding options on the command line).
Simulations may consist of several hundred possible switches for altering the behavior of a simulation, and all physics models in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} are therefore equipped with Python setup tools that collect all such options into a single file when setting up a new application.
Generally, these input parameters are fetched from the options file of component that is used in a simulation.
Simulation options usually consist of a prefix, a suffix, and a configuration value.
For example, the configuration options that adjusts the number of time steps that will be run in a simulation is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
Driver.max\PYGZus{}steps \PYG{o}{=} \PYG{l+m}{100}
\end{sphinxVerbatim}

Likewise, for controlling how often plot are written:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
Driver.plot\PYGZus{}interval \PYG{o}{=} \PYG{l+m}{5}
\end{sphinxVerbatim}

You may also pass input parameters through the command line. For example, running

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
mpirun \PYGZhy{}np \PYG{l+m}{32} \PYGZlt{}application\PYGZus{}executable\PYGZgt{} \PYGZlt{}input\PYGZus{}file\PYGZgt{} Driver.max\PYGZus{}steps\PYG{o}{=}\PYG{l+m}{10}
\end{sphinxVerbatim}

will set the \sphinxcode{\sphinxupquote{Driver.max\_steps}} parameter to 10.
Command\sphinxhyphen{}line parameters override definitions in the input file.
Moreover, parameters parsed through the command line become static parameters, i.e. they are not run\sphinxhyphen{}time configurable (see {\hyperref[\detokenize{Base/Control:chap-runtimeconfig}]{\sphinxcrossref{\DUrole{std,std-ref}{Run\sphinxhyphen{}time configurations}}}}).
Also note that if you define a parameter multiple times in the input file, the last definition is canon.


\subsection{Simulation outputs}
\label{\detokenize{Base/Control:simulation-outputs}}
Mesh data from \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} simulations is by default written to HDF5 files, and if HDF5 is disabled \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} will not write any plot or checkpoint files.
In addition to plot files, MPI ranks can output information to separate files so that the simulation progress can be tracked.

\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} comes with controls for adjusting output.
Through the {\hyperref[\detokenize{Source/Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{Driver}}}} class the user may adjust the option \sphinxcode{\sphinxupquote{Driver.output\_directory}} to specify where output files will be placed.
This directory is relative to the location where the application is run.
If this directory does not exist, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} will create it.
It will also create the following subdirectories given in {\hyperref[\detokenize{Base/Control:tab-outputdirectories}]{\sphinxcrossref{\DUrole{std,std-ref}{Simulation output organization.}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Simulation output organization.}\label{\detokenize{Base/Control:id1}}\label{\detokenize{Base/Control:tab-outputdirectories}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{10}{80}|\X{70}{80}|}
\hline
\sphinxstyletheadfamily 
Folder
&\sphinxstyletheadfamily 
Explanation
\\
\hline
\sphinxcode{\sphinxupquote{chk}}
&
Checkpoint files (these are used for restarting simulations from a specified time step).
\\
\hline
\sphinxcode{\sphinxupquote{crash}}
&
Plot files written if a simulation crashes.
\\
\hline
\sphinxcode{\sphinxupquote{geo}}
&
Plot files for geometries (if you run with \sphinxcode{\sphinxupquote{Driver.geometry\_only = true}}).
\\
\hline
\sphinxcode{\sphinxupquote{mpi}}
&
Information about individual MPI ranks, such as computational loads or memory consumption per rank.
\\
\hline
\sphinxcode{\sphinxupquote{plt}}
&
All plot files.
\\
\hline
\sphinxcode{\sphinxupquote{regrid}}
&
Plot files written during regrids (if you run with \sphinxcode{\sphinxupquote{Driver.write\_regrid\_files}}).
\\
\hline
\sphinxcode{\sphinxupquote{restart}}
&
Plot files written during restarts (if you run with \sphinxcode{\sphinxupquote{Driver.write\_regrid\_files}}).
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

The reason for the output folder structure is that \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} can end up writing thousands of files per simulation and we feel that having a directory structure helps us navigate simulation data.

Fundamentally, there are only two types of HDF5 files written:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Plot files, containing plots of simulation data.

\item {} 
Checkpoint files, which are binary files used for restarting a simulation from a given time step.

\end{enumerate}

The {\hyperref[\detokenize{Source/Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{Driver}}}} class is responsible for writing output files at specified intervals, but the user is generally speaking responsible for specifying what goes into the plot files.
Since not all variables are always of interest, solver classes have options like \sphinxcode{\sphinxupquote{plt\_vars}} that specify which output variables in the solver will be written to the output file.
For example, one of our convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solver classes have the following output options:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
CdrGodunov.plt\PYGZus{}vars \PYG{o}{=} phi vel dco src ebflux \PYG{c+c1}{\PYGZsh{} Plot variables. Options are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}vel\PYGZsq{}, \PYGZsq{}dco\PYGZsq{}, \PYGZsq{}src\PYGZsq{}, \PYGZsq{}ebflux\PYGZsq{}}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{phi}} is the state density, \sphinxcode{\sphinxupquote{vel}} is the drift velocity, \sphinxcode{\sphinxupquote{dco}} is the diffusion coefficient, \sphinxcode{\sphinxupquote{src}} is the source term, and \sphinxcode{\sphinxupquote{ebflux}} is the flux at embedded boundaries.
If you only want to plot the density, then you should put \sphinxcode{\sphinxupquote{CdrGodunov.plt\_vars = phi}}.
An empty entry like \sphinxcode{\sphinxupquote{CdrGodunov.plt\_vars =}} may lead to run\sphinxhyphen{}time errors, so if you do not want a class to provide plot data you may put \sphinxcode{\sphinxupquote{CdrGodunov.plt\_vars = none}}.


\subsection{Controlling parallel processor verbosity}
\label{\detokenize{Base/Control:controlling-parallel-processor-verbosity}}
By default, \sphinxcode{\sphinxupquote{Chombo}} will write a process output file \sphinxstyleemphasis{per MPI process} and this file will be named \sphinxcode{\sphinxupquote{pout.n}} where \sphinxcode{\sphinxupquote{n}} is the MPI rank.
These files are written in the directory where you executed your application, and are \sphinxstyleemphasis{not} related to plot files or checkpoint files.
However, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} prints information to these files as simulations advance (for example by displaying information of the current time step, or convergence rates for multigrid solvers).
While it is possible to monitor the evolution of \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} for each MPI rank, most of these files contain redundant information.
To adjust the number of files that will be written, \sphinxcode{\sphinxupquote{Chombo}} can read an environment variable \sphinxcode{\sphinxupquote{CH\_OUTPUT\_INTERVAL}} that determines which MPI ranks write \sphinxcode{\sphinxupquote{pout.n}} files.
For example, if you only want the master MPI rank to write \sphinxcode{\sphinxupquote{pout.0}}, you would do

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{export} \PYG{n+nv}{CH\PYGZus{}OUTPUT\PYGZus{}INTERVAL}\PYG{o}{=}\PYG{l+m}{999999999}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{important}{Important:}
If you run simulations at high concurrencies, you \sphinxstyleemphasis{should} turn off the number of process output files since they impact the performance of the file system.
\end{sphinxadmonition}


\subsection{Restarting simulations}
\label{\detokenize{Base/Control:restarting-simulations}}\label{\detokenize{Base/Control:chap-restartingsimulations}}
Restarting simulations is done in exactly the same way as running simulations, although the user must set the \sphinxcode{\sphinxupquote{Driver.restart}} parameter.
For example,

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
mpirun \PYGZhy{}np \PYG{l+m}{32} \PYGZlt{}application\PYGZus{}executable\PYGZgt{} \PYGZlt{}input\PYGZus{}file\PYGZgt{} Driver.restart\PYG{o}{=}\PYG{l+m}{10}
\end{sphinxVerbatim}

will restart from step 10.

Specifying anything but an integer is an error.
When a simulation is restarted, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} will look for a checkpoint file with the \sphinxcode{\sphinxupquote{Driver.output\_names}} variable and the specified restart step.
It will look for this file in the subfolder \sphinxcode{\sphinxupquote{/chk}} relative to the execution directory.

If the restart file is not found, restarting will not work and \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} will abort.
You must therefore ensure that your executable can locate this file.
This also implies that you cannot change the \sphinxcode{\sphinxupquote{Driver.output\_names}} or \sphinxcode{\sphinxupquote{Driver.output\_directory}} variables during restarts, unless you also change the name of your checkpoint file and move it to a new directory.

\begin{sphinxadmonition}{note}{Note:}
If you set \sphinxcode{\sphinxupquote{Driver.restart=0}}, you will get a fresh simulation.
\end{sphinxadmonition}


\subsection{Run\sphinxhyphen{}time configurations}
\label{\detokenize{Base/Control:run-time-configurations}}\label{\detokenize{Base/Control:chap-runtimeconfig}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} reads input parameters before the simulation starts, but also during run\sphinxhyphen{}time.
This is useful when your simulation waited 5 days in the queue on a cluster before starting, but you forgot to tweak one parameter and don’t want to wait another 5 days.

\sphinxcode{\sphinxupquote{Driver}} re\sphinxhyphen{}reads the simulation input parameters after every time step.
The new options are parsed by the core classes \sphinxcode{\sphinxupquote{Driver}}, \sphinxcode{\sphinxupquote{TimeStepper}}, \sphinxcode{\sphinxupquote{AmrMesh}}, and \sphinxcode{\sphinxupquote{CellTagger}} through special routines \sphinxcode{\sphinxupquote{parseRuntimeOptions()}}.
Note that not all input configurations are suitable for run\sphinxhyphen{}time configuration.
For example, increasing the size of the simulation domain does not make sense but changing the blocking factor, refinement criteria, or plot intervals do.
To see which options are run\sphinxhyphen{}time configurable, see {\hyperref[\detokenize{Source/Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{Driver}}}}, {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}}, or the {\hyperref[\detokenize{Source/TimeStepper:chap-timestepper}]{\sphinxcrossref{\DUrole{std,std-ref}{TimeStepper}}}} and {\hyperref[\detokenize{Source/CellTagger:chap-celltagger}]{\sphinxcrossref{\DUrole{std,std-ref}{CellTagger}}}} that you use.


\chapter{Discretization}
\label{\detokenize{index:discretization}}

\section{Spatial discretization}
\label{\detokenize{Source/SpatialDiscretization:spatial-discretization}}\label{\detokenize{Source/SpatialDiscretization:chap-spatialdiscretization}}\label{\detokenize{Source/SpatialDiscretization::doc}}

\subsection{Cartesian AMR}
\label{\detokenize{Source/SpatialDiscretization:cartesian-amr}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} uses patch\sphinxhyphen{}based structured adaptive mesh refinement (AMR) provided by \sphinxcode{\sphinxupquote{Chombo}} {[}\hyperlink{cite.ZZReferences:id82}{4}{]}.
In patch\sphinxhyphen{}based AMR the domain is subdivided into a collection of hierarchically nested grid levels, see \hyperref[\detokenize{Source/SpatialDiscretization:fig-patchbasedamr}]{Fig.\@ \ref{\detokenize{Source/SpatialDiscretization:fig-patchbasedamr}}}.
With Cartesian AMR each patch is a Cartesian block of grid cells.
A \sphinxstyleemphasis{grid level} is composed of a union of grid patches sharing the same grid resolution, with the additional requirement that the patches on a grid level are \sphinxstyleemphasis{non\sphinxhyphen{}overlapping}.
With AMR, such levels can be hierarchically nested; finer grid levels exist on top of coarser ones.
In patch\sphinxhyphen{}based AMR there are only a few fundamental requirements on how such grids are constructed.
For example, a refined grid level must exist completely within the bounds of it’s parent level.
In other words, grid levels \(l-1\) and \(l+1\) are spatially separated by a non\sphinxhyphen{}zero number of grid cells on level \(l\).

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{PatchBasedAMR}.png}
\caption{Cartesian patch\sphinxhyphen{}based refinement showing two grid levels.
The fine\sphinxhyphen{}grid level lives on top of the coarse level, and consists of two patches (red and blue colors) with two layers of ghost cells (dashed lines and orange shaded region).}\label{\detokenize{Source/SpatialDiscretization:id6}}\label{\detokenize{Source/SpatialDiscretization:fig-patchbasedamr}}\end{figure}

The resolution on level \(l+1\) is typically finer than the resolution on level \(l\) by an integer (usually power of two).
However,

\begin{sphinxadmonition}{important}{Important:}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} only supports refinement factors of 2 and 4.
\end{sphinxadmonition}


\subsection{Embedded boundaries}
\label{\detokenize{Source/SpatialDiscretization:embedded-boundaries}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharges}} uses an embedded boundary (EB) formulation for describing complex geometries.
With EBs, the Cartesian grid is directly intersected by the geometry.
This is fundamentally different from unstructured grid where one generates a volume mesh that conforms to the surface mesh of the input geometry.
Since EBs are directly intersected by the geometry, there is no fundamental need for a surface mesh for describing the geometry.
Moreover, Cartesian EBs have a data layout which remains (almost) fully structured.
The connectivity of neighboring grid cells is still trivially found by fundamental strides along the data rows/columns, which allows extending the efficiency of patch\sphinxhyphen{}based AMR to complex geometries.
Figure \hyperref[\detokenize{Source/SpatialDiscretization:fig-complexpatches}]{Fig.\@ \ref{\detokenize{Source/SpatialDiscretization:fig-complexpatches}}} shows an example of patch\sphinxhyphen{}based grid refinement for a complex surface.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{ComplexPatches}.png}
\caption{Patch\sphinxhyphen{}based refinement (factor 4 between levels) of a complex surface. Each color shows a patch, which is a rectangular computational unit.}\label{\detokenize{Source/SpatialDiscretization:id7}}\label{\detokenize{Source/SpatialDiscretization:fig-complexpatches}}\end{figure}

Since EBs are directly intersected by the geometry, pathological cases can arise where a Cartesian grid cell consists of multiple volumes.
One can easily envision this case by intersecting a thin body with a Cartesian grid, as shown in \hyperref[\detokenize{Source/SpatialDiscretization:fig-multicells}]{Fig.\@ \ref{\detokenize{Source/SpatialDiscretization:fig-multicells}}}.
This figure shows a thin body which is intersected by a Cartesian grid, and this grid is then coarsened.
At the coarsened level, one of the grid cells has two cell fragments on opposite sides of the body.
Such multi\sphinxhyphen{}valued cells (a.k.a \sphinxstyleemphasis{multi\sphinxhyphen{}cells}) are fundamentally important for EB applications.
Note that there is no fundamental difference between single\sphinxhyphen{}cut and multi\sphinxhyphen{}cut grid cells.
This distinction exists primarily due to the fact that if all grid cells were single\sphinxhyphen{}cut cells the entire EB data structure would fit in a Cartesian grid block (say, of \(N_x \times N_y \times N_z\) grid cells).
Because of multi\sphinxhyphen{}cells, EB data structures are not purely Cartesian.
Data structures need to live on more complex graphs that describe support multi\sphinxhyphen{}cells and, furthermore, describe the cell connectivity.
Without multi\sphinxhyphen{}cells it would be impossible to describe most complex geometries.
It would also be extremely difficult to obtain performant geometric multigrid methods (which rely on this type of coarsening).

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{MultiCells}.png}
\caption{Example of how multi\sphinxhyphen{}valued cells occur during grid coarsening.
Left: Original grid.
Right: Coarsened grid.}\label{\detokenize{Source/SpatialDiscretization:id8}}\label{\detokenize{Source/SpatialDiscretization:fig-multicells}}\end{figure}


\subsection{Geometry representation}
\label{\detokenize{Source/SpatialDiscretization:geometry-representation}}\label{\detokenize{Source/SpatialDiscretization:chap-geometryrepresentation}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} uses (approximations to) signed distance functions (SDFs) for describing geometries.
Signed distance fields are functions \(f: \mathbb{R}^3\rightarrow \mathbb{R}\) that describe the distance from the object.
These functions are also \sphinxstyleemphasis{implicit functions}, i.e. \(f\left(\mathbf{x}\right)=0\) describes the surface of the object, \(f\left(\mathbf{x}\right) > 0\) decribes a point inside the object and \(f\left(\mathbf{x}\right) < 0\) describes a point outside the object.

Many EB applications only use the implicit function formulation, but \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} requires (an approximation to) the signed distance field.
There are two reasons for this:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The SDF can be used for robustly load balancing the geometry generation with orders of magnitude speedup over naive approaches.

\item {} 
The SDF is useful for resolving particle collisions with boundaries, using e.g. simple ray tracing of particle paths.

\end{enumerate}

To illustrate the difference between an SDF and an implicit function, consider the implicit functions for a sphere at the origin with radius \(R\):
\begin{align}
d_1\left(\mathbf{x}\right) &= R - \left|\mathbf{x}\right|, \\
d_2\left(\mathbf{x}\right) &= R^2 - \mathbf{x}\cdot\mathbf{x}.
\end{align}
Here, only \(d_1\left(\mathbf{x}\right)\) is a signed distance function.

In \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, SDFs can be generated through analytic expressions, constructive solid geometry, or by supplying polygon tesselation.
NURBS geometries are, unfortunately, not supported.
Fundamentally, all geometric objects are described using \sphinxcode{\sphinxupquote{BaseIF}} objects from \sphinxcode{\sphinxupquote{Chombo}}, see {\hyperref[\detokenize{Source/ChomboBasics:chap-baseif}]{\sphinxcrossref{\DUrole{std,std-ref}{BaseIF}}}}.


\subsubsection{Constructive solid geometry (CSG)}
\label{\detokenize{Source/SpatialDiscretization:constructive-solid-geometry-csg}}
Constructive solid geometry can be used to generate complex shapes from geometric primitives.
For example, to describe the union between two SDFs \(d_1\left(\mathbf{x}\right)\) and \(d_2\left(\mathbf{x}\right)\):
\begin{equation*}
\begin{split}d\left(\mathbf{x}\right) = \textrm{min}\left(d_1\left(\mathbf{x}\right), d_2\left(\mathbf{x}\right)\right)\end{split}
\end{equation*}
Note that the resulting is an implicit function but is \sphinxstyleemphasis{not} an SDF.
However, the union typically approximates the signed distance field quite well near the surface.
\sphinxcode{\sphinxupquote{Chombo}} natively supports many ways of performing CSG.


\subsubsection{EBGeometry}
\label{\detokenize{Source/SpatialDiscretization:ebgeometry}}
While functions like \(R - \left|\mathbf{x}\right|\) are quick to compute, a polygon surface may consist of hundreds of thousands of primitives (e.g., triangles).
Generating signed distance function from polygon tesselations is quite involved as it requires computing the signed distance to the closest feature, which can be a planar polygon (e.g., a triangle), edge, or a vertex.
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} supports such functions through the \sphinxhref{https://github.com/rmrsk/EBGeometry}{EBGeometry} package.

\begin{sphinxadmonition}{warning}{Warning:}
The signed distance function for a polygon surface is only well\sphinxhyphen{}defined if it is manifold\sphinxhyphen{}2, i.e. it is watertight and does not self\sphinxhyphen{}intersect.
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} should nonetheless compute the distance field as best as it can, but the final result may not make sense in an EB context.
\end{sphinxadmonition}

Searching through all features (faces, edge, vertices) is unacceptably slow, and \sphinxcode{\sphinxupquote{EBGeometry}} therefore uses a bounding volume hierarchy for accelerating these searches.
The bounding volume hierarchy is top\sphinxhyphen{}down constructed, using a root bounding volume (typically a cube) that encloses all triangles.
Using heuristics, the root bounding volume is then subdivided into two separate bounding volumes that contain roughly half of the primitives each.
The process is then recursed downwards until specified recursion criteria are met.
Additional details are provided in the \sphinxhref{https://rmrsk.github.io/EBGeometry/}{EBGeometry documentation}.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{Armadillo}.png}
\caption{Example of an SDF reconstruction and cut\sphinxhyphen{}cell grid from a surface tesselation in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.}\label{\detokenize{Source/SpatialDiscretization:id9}}\end{figure}


\subsection{Geometry generation}
\label{\detokenize{Source/SpatialDiscretization:geometry-generation}}\label{\detokenize{Source/SpatialDiscretization:chap-geometrygeneration}}

\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{Chombo}} approach}
\label{\detokenize{Source/SpatialDiscretization:chombo-approach}}
The default geometry generation method in \sphinxcode{\sphinxupquote{Chombo}} is to locate cut\sphinxhyphen{}cells on the finest AMR level first and then generate the coarser levels cells through grid coarsening.
This will look through all cells on the finest level, so for a domain which is effectively \(N\times N\times N\) cells there are \(\mathcal{O}\left(N^3\right)\) implicit function queries (in 2D, the complexity is \(\mathcal{O}\left(N^2\right)\)).
Note that as \(N\) becomes large, say \(N=10^5\), geometric queries of this type become a bottleneck.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{chombo\sphinxhyphen{}discharge}} pruning}
\label{\detokenize{Source/SpatialDiscretization:chombo-discharge-pruning}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} has made modifications to the geometry generation routines in \sphinxcode{\sphinxupquote{Chombo}}, resolving a few bugs and, most importantly, using the signed distance function for load balancing the geometry generation step.
This modification to \sphinxcode{\sphinxupquote{Chombo}} yields a reduction of the original \(\mathcal{O}\left(N^3\right)\) scaling in \sphinxcode{\sphinxupquote{Chombo}} grid generation to an \(\mathcal{O}\left(N^2\right)\) scaling in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
Typically, we find that this makes geometry generation computationally trivial (in the sense that it is very fast compared to the simulation).

To understand this process, note that the SDF satisfies the Eikonal equation
\begin{equation}
\left|\nabla f\right| = 1,
\end{equation}
and so it is well\sphinxhyphen{}behaved for all \(\mathbf{x}\).
The SDF can thus be used to prune large regions in space where cut\sphinxhyphen{}cells don’t exist.
For example, consider a Cartesian grid patch with cell size \(\Delta x\) and cell\sphinxhyphen{}centered grid points \(\mathbf{x}_{\mathbf{i}} = \left(\mathbf{i} + \mathbf{\frac{1}{2}}\right)\Delta x\) where \(\mathbf{i} \in \mathbb{Z}^3\) are grid cells in the patch, as shown in \hyperref[\detokenize{Source/SpatialDiscretization:fig-pruning}]{Fig.\@ \ref{\detokenize{Source/SpatialDiscretization:fig-pruning}}}.
We know that cut cells do not exist in the grid patch if \(\left|f\left(\mathbf{x}_{\mathbf{i}}\right)\right| > \frac{1}{2}\Delta x\) for all \(\mathbf{i}\) in the patch.
One can use this to perform a quick scan of the SDF on a \sphinxstyleemphasis{coarse} grid level first, for example on \(l=0\), and recurse deeper into the grid hierarchy to locate cut\sphinxhyphen{}cells on the other levels.
Typically, a level is decomposed into Cartesian subregions, and each subregion can be scanned independently of the other subregions (i.e. the problem is embarassingly parallel).
Subregions that can’t contain cut\sphinxhyphen{}cells are designated as \sphinxstyleemphasis{inside} or \sphinxstyleemphasis{outside}, depending on the sign of the SDF.
There is no point in recursively refining these to look for cut\sphinxhyphen{}cells at finer grid levels, owing to the nature of the SDF they can be safely pruned from subsequent scans at finer levels.
The subregions that did contain cut\sphinxhyphen{}cells are refined and decomposed into sub\sphinxhyphen{}subregions.
This procedure recurses until \(l=l_{\text{max}}\), at which point we have determined all sub\sphinxhyphen{}regions in space where cut\sphinxhyphen{}cells can exist (on each AMR level), and pruned the ones that don’t.
This process is shown in \hyperref[\detokenize{Source/SpatialDiscretization:fig-pruning}]{Fig.\@ \ref{\detokenize{Source/SpatialDiscretization:fig-pruning}}}.
Once all the grid patches that contain cut\sphinxhyphen{}cells have been found, these patches are distributed (i.e., load balanced) to the various MPI ranks for computing the discrete grid information.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{Pruning}.png}
\caption{Pruning cut\sphinxhyphen{}cells with the signed distance field.
Red\sphinxhyphen{}colored grid patches are grid patches entirely contained inside the EB.
Green\sphinxhyphen{}colored grid patches are entirely outside the EB, while blue\sphinxhyphen{}colored grid patches contain cut\sphinxhyphen{}cells.}\label{\detokenize{Source/SpatialDiscretization:id10}}\label{\detokenize{Source/SpatialDiscretization:fig-pruning}}\end{figure}

The above load balancing strategy is very simple, and it reduces the original \(O(N^3)\) complexity in 3D to \(O(N^2)\) complexity (in 2D the complexity is reduced from \(O(N^2)\) to \(O(N)\)).
The strategy works for all SDFs although, strictly speaking, an SDF is not fundamentally needed.
If a well\sphinxhyphen{}behaved Taylor series can be found for an implicit function, the bounds on the series can also be used to infer the location of the cut\sphinxhyphen{}cells, and the same algorithm can be used.
For example, generating compound objects with CSG are typically sufficiently well behaved (provided that the components are SDFs).
However, implicit functions like \(d\left(\mathbf{x}\right) = R^2 - \mathbf{x}\cdot\mathbf{x}\) must be used with caution.


\subsection{Mesh generation}
\label{\detokenize{Source/SpatialDiscretization:mesh-generation}}\label{\detokenize{Source/SpatialDiscretization:chap-meshgeneration}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} supports two algorithm for AMR grid generation:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The classical Berger\sphinxhyphen{}Rigoutsos algorithm {[}\hyperlink{cite.ZZReferences:id38}{1}{]}.

\item {} 
A \sphinxstyleemphasis{tiled} algorithm {[}\hyperlink{cite.ZZReferences:id164}{5}{]}.

\end{enumerate}

Both algorithms work by taking a set of flagged cells on each grid level and generating new boxes that cover the flags.
Only \sphinxstyleemphasis{properly nested} grids are generated, in which case two grid levels \(l-1\) and \(l+1\) are separated by a non\sphinxhyphen{}zero number of grid cells on level \(l\).
This requirement is specific for patch\sphinxhyphen{}based grids; itd dieoes not fundamentally exist for quad\sphinxhyphen{} and oct\sphinxhyphen{}tree grids.
For patch based AMR, the rationale for this requirement is that stencils on level \(l+1\) should should only reach into grid cells on levels \(l\) and \(l+1\).
For example, ghost cells on level \(l+1\) should be interpolated from data only on levels \(l\) and \(l+1\).


\subsubsection{Berger\sphinxhyphen{}Rigoutsos algorithm}
\label{\detokenize{Source/SpatialDiscretization:berger-rigoutsos-algorithm}}
The Berger\sphinxhyphen{}Rigoustous grid algorithm is implemented in \sphinxcode{\sphinxupquote{Chombo}} and is called by \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
The classical Berger\sphinxhyphen{}Rigoustous algorithm is inherently serial in the sense that is collects the flagged cells onto each MPI rank and then generates the boxes, see {[}\hyperlink{cite.ZZReferences:id38}{1}{]} for implementation details.
Typically, it is not used at large scale in 3D due to its memory consumption.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=240\sphinxpxdimen]{{BRMeshRefine}.png}
\caption{Classical cartoon of patch\sphinxhyphen{}based refinement. Bold lines indicate entire grid blocks.}\label{\detokenize{Source/SpatialDiscretization:id11}}\label{\detokenize{Source/SpatialDiscretization:brmeshrefine}}\end{figure}


\subsubsection{Tiled mesh refinement}
\label{\detokenize{Source/SpatialDiscretization:tiled-mesh-refinement}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} also supports a tiled algorithm where the grid boxes on each block are generated according to a predefined tiled pattern.
If a tile contains a single tag, the entire tile is flagged for refinement.
The tiled algorithm produces grids that are visually similar to octrees, but is slightly more general since it also supports refinement factors other than 2 and is not restricted to domain extensions that are an integer factor of 2 (e.g. \(2^{10}\) cells in each direction).
Moreover, the algorithm is extremely fast and has low memory consumption even at large scales.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=240\sphinxpxdimen]{{TiledMeshRefine}.png}
\caption{Classical cartoon of tiled patch\sphinxhyphen{}based refinement. Bold lines indicate entire grid blocks.}\label{\detokenize{Source/SpatialDiscretization:id12}}\label{\detokenize{Source/SpatialDiscretization:tiledmeshrefine}}\end{figure}


\subsection{Cell refinement philosophy}
\label{\detokenize{Source/SpatialDiscretization:cell-refinement-philosophy}}\label{\detokenize{Source/SpatialDiscretization:chap-refinementphilosophy}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} can flag cells for refinement using various methods:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Refine all embedded boundaries down to a specified refinement level.

\item {} 
Refine embedded boundaries based on estimations of the surface curvature in the cut\sphinxhyphen{}cells.

\item {} 
Manually add refinement flags (by specifying boxes where cells will be refined).

\item {} 
Physics\sphinxhyphen{}based or data\sphinxhyphen{}based refinement where the user fetches data from solver classes (e.g., discretization errors, the electric field) and uses that for refinement.

\end{enumerate}

The first two cases are covered by the \sphinxcode{\sphinxupquote{Driver}} class in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} (see {\hyperref[\detokenize{Source/Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{Driver}}}}).
In the first case the \sphinxcode{\sphinxupquote{Driver}} class will simply fetch arguments from an input script which specifies the refinement depth for the embedded boundaries.
In the second case, the \sphinxcode{\sphinxupquote{Driver}} class will visit every cut\sphinxhyphen{}cell and check if the normal vectors in neighboring cut\sphinxhyphen{}cell deviate by more than a specified threshold angle.
Given two normal vectors \(\mathbf{n}\) and \(\mathbf{n}^\prime\), the cell is refined if
\begin{equation*}
\begin{split}\mathbf{n}\cdot\mathbf{n}^\prime \geq \cos\theta_c,\end{split}
\end{equation*}
where \(\theta_c\) is a threshold angle for grid refinent.

The other two cases are more complicated, and are covered by the {\hyperref[\detokenize{Source/GeoCoarsener:chap-geocoarsener}]{\sphinxcrossref{\DUrole{std,std-ref}{GeoCoarsener}}}} and {\hyperref[\detokenize{Source/CellTagger:chap-celltagger}]{\sphinxcrossref{\DUrole{std,std-ref}{CellTagger}}}} classes.


\section{\sphinxstyleliteralintitle{\sphinxupquote{Chombo\sphinxhyphen{}3}} basics}
\label{\detokenize{Source/ChomboBasics:chombo-3-basics}}\label{\detokenize{Source/ChomboBasics:chap-basics}}\label{\detokenize{Source/ChomboBasics::doc}}
To fully understand this documentation the user should be familiar with \sphinxcode{\sphinxupquote{Chombo}}.
This documentation uses class names from \sphinxcode{\sphinxupquote{Chombo}} and the most relevant \sphinxcode{\sphinxupquote{Chombo}} data structures are summarized here.
What follows is a \sphinxstyleemphasis{very} brief introduction to these data structures, for in\sphinxhyphen{}depth explanations please see the \sphinxhref{https://github.com/applied-numerical-algorithms-group-lbnl/Chombo\_3.2/tree/master/doc}{Chombo manual}.


\subsection{Real}
\label{\detokenize{Source/ChomboBasics:real}}
\sphinxcode{\sphinxupquote{Real}} is a typedef’ed structure for holding a single floating point number.
Compiling with double precision will typedef \sphinxcode{\sphinxupquote{Real}} as \sphinxcode{\sphinxupquote{double}}, otherwise it is typedef’ed as \sphinxcode{\sphinxupquote{float}}.


\subsection{RealVect}
\label{\detokenize{Source/ChomboBasics:realvect}}
\sphinxcode{\sphinxupquote{RealVect}} is a spatial vector.
It holds two \sphinxcode{\sphinxupquote{Real}} components in 2D and three \sphinxcode{\sphinxupquote{Real}} components in 3D.
The \sphinxcode{\sphinxupquote{RealVect}} class has floating point arithmetic, e.g. addition, subtraction, multiplication etc.

Most of \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is written in dimension\sphinxhyphen{}independent code, and for cases where \sphinxcode{\sphinxupquote{RealVect}} is initialized with components the constructor uses \sphinxcode{\sphinxupquote{Chombo}} macros for expanding the correct number of arguments.
For example

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect} \PYG{n+nf}{v}\PYG{p}{(}\PYG{n}{D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{vx}\PYG{p}{,} \PYG{n}{vy}\PYG{p}{,} \PYG{n}{vz}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will expand to \sphinxcode{\sphinxupquote{RealVect v(vx,vy)}} in 2D and \sphinxcode{\sphinxupquote{RealVect v(vx, vy, vz)}} in 3D.


\subsection{IntVect}
\label{\detokenize{Source/ChomboBasics:intvect}}
\sphinxcode{\sphinxupquote{IntVect}} is an integer spatial vector, and is used for indexing data structures.
It works in much the same way as \sphinxcode{\sphinxupquote{RealVect}}, except that the components are integers.


\subsection{Box}
\label{\detokenize{Source/ChomboBasics:box}}
The \sphinxcode{\sphinxupquote{Box}} object describes a box in Cartesian space.
The boxes are indexed by the low and high corners, both of which are an \sphinxcode{\sphinxupquote{IntVect}}.
The \sphinxcode{\sphinxupquote{Box}} may be cell\sphinxhyphen{}centered or face\sphinxhyphen{}centered.
To turn a cell\sphinxhyphen{}centered \sphinxcode{\sphinxupquote{Box}} into a face\sphinxhyphen{}centered box one would do

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Box} \PYG{n+nf}{bx}\PYG{p}{(}\PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Zero}\PYG{p}{,} \PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Default constructor give cell centered boxes}
\PYG{n}{bx}\PYG{p}{.}\PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}                \PYG{c+c1}{// Now a cell\PYGZhy{}centered box}
\end{sphinxVerbatim}

This will increase the box dimensions by one in each coordinate direction.


\subsection{EBCellFAB and FArrayBox}
\label{\detokenize{Source/ChomboBasics:ebcellfab-and-farraybox}}
The \sphinxcode{\sphinxupquote{EBCellFAB}} object is an array for holding cell\sphinxhyphen{}centered data in an embedded boundary context.
The \sphinxcode{\sphinxupquote{EBCellFAB}} has two data structures: An \sphinxcode{\sphinxupquote{FArrayBox}} that holds the data on the cell centers, and a additional data structure that holds data in cells that are multiply cut.
Doing arithmetic with \sphinxcode{\sphinxupquote{EBCellFAB}} usually requires one to iterate over all the cell in the \sphinxcode{\sphinxupquote{FArrayBox}}, and then to iterate over the \sphinxstyleemphasis{irregular cells} (i.e. cut\sphinxhyphen{}cells) later.
A \sphinxcode{\sphinxupquote{VoFIterator}} is such as object; it can iterate over cut\sphinxhyphen{}cells.
Usually, code for doing anything with the \sphinxcode{\sphinxupquote{EBCellFAB}} looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Call Fortran code}
\PYG{n}{FORT\PYGZus{}DO\PYGZus{}SOMETHING}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}

\PYG{c+c1}{// Iterate over cut\PYGZhy{}cells}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{VoFIterator} \PYG{n}{vofit}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;} \PYG{n}{vofit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{vofit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{important}{Important:}
The \sphinxcode{\sphinxupquote{FArrayBox}} stores the data in column major order.
\end{sphinxadmonition}


\subsection{Vector}
\label{\detokenize{Source/ChomboBasics:vector}}
\sphinxcode{\sphinxupquote{Vector\textless{}T\textgreater{}}} is a one\sphinxhyphen{}dimensional array with constant\sphinxhyphen{}time random access and range checking.
It uses \sphinxcode{\sphinxupquote{std::vector}} under the hood and can access the most commonly used \sphinxcode{\sphinxupquote{std::vector}} functionality through the public member functions.
E.g. to obtain an element in the vector

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{my\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{T}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{element} \PYG{o}{=} \PYG{n}{my\PYGZus{}vector}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Likewise, \sphinxcode{\sphinxupquote{push\_back}}, \sphinxcode{\sphinxupquote{resize}} etc works in much the same way as for \sphinxcode{\sphinxupquote{std::vector}}.


\subsection{RefCountedPtr}
\label{\detokenize{Source/ChomboBasics:refcountedptr}}
\sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} is a pointer class in \sphinxcode{\sphinxupquote{Chombo}} with reference counting.
That is, when objects that hold a reference to some \sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} object goes out of scope the reference counter is decremented.
If the reference counter reaches zero, the object that \sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} points to it deallocated.
Using \sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} is much preferred over using a raw pointer \sphinxcode{\sphinxupquote{T*}} to 1) avoid memory leaks and 2) compress code since no explicit deallocations need to be called.

In modern C++\sphinxhyphen{}speak, \sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} can be thought of as a \sphinxstyleemphasis{very} simple version of \sphinxcode{\sphinxupquote{std::shared\_ptr\textless{}T\textgreater{}}}.


\subsection{DisjointBoxLayout}
\label{\detokenize{Source/ChomboBasics:disjointboxlayout}}
The \sphinxcode{\sphinxupquote{DisjointBoxLayout}} class describes a grid on an AMR level where all the boxes are \sphinxstyleemphasis{disjoint}, i.e. they don’t overlap.
\sphinxcode{\sphinxupquote{DisjointBoxLayout}} is built upon a union of non\sphinxhyphen{}overlapping boxes having the same grid resolution and with unique rank\sphinxhyphen{}to\sphinxhyphen{}box ownership.
The constructor is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Box}\PYG{o}{\PYGZgt{}} \PYG{n}{boxes}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Vector of disjoint boxes}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{ranks}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Ownership of each box}

\PYG{n}{DisjointBoxLayout} \PYG{n+nf}{dbl}\PYG{p}{(}\PYG{n}{boxes}\PYG{p}{,} \PYG{n}{ranks}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In simple terms,  \sphinxcode{\sphinxupquote{DisjointBoxLayout}} is the decomposed grid on each level in which MPI ranks have unique ownership of specific parts of the grid.

The \sphinxcode{\sphinxupquote{DisjointBoxLayout}} view is global, i.e. each MPI rank knows about all the boxes and the box ownership on the entire AMR level.
However, ranks will only allocate data on the part of the grid that they own.
Data iterators also exist, and the most common is to use iterators that only iterate over the part of the \sphinxcode{\sphinxupquote{DisjointBoxLayout}} that the specific MPI ranks own:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{DisjointBoxLayout} \PYG{n}{dbl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Do something}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Each MPI rank will then iterate \sphinxstyleemphasis{only} over the part of the grid where it has ownership.

Other data iterators exist that iterate over all boxes in the grid:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{LayoutIterator} \PYG{n}{lit} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{layoutIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Do something}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This is typically used if one wants to do some global operation, e.g. count the number of cells in the grid.
However, trying to use \sphinxcode{\sphinxupquote{LayoutIterator}} to retrieve data that was allocated locally on a different MPI rank is an error.


\subsection{LevelData}
\label{\detokenize{Source/ChomboBasics:leveldata}}
The \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} template structure holds data on all the grid patches of one AMR level.
The data is distributed with the domain decomposition specified by \sphinxcode{\sphinxupquote{DisjointBoxLayout}}, and each patch contains exactly one instance of \sphinxcode{\sphinxupquote{T}}.
\sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} uses a factory pattern for creating the \sphinxcode{\sphinxupquote{T}} objects, so if you have new data structures that should fit the in \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} structure you must also implement a factory method for \sphinxcode{\sphinxupquote{T}}.

The \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} object provides the domain decomposition method in \sphinxcode{\sphinxupquote{Chombo}} and \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
Often, \sphinxcode{\sphinxupquote{T}} is an \sphinxcode{\sphinxupquote{EBCellFAB}}, i.e. a Cartesian grid patch that also supports EB formulations.

To iterate over \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} one will use the data iterator above:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{myData}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{o}{=} \PYG{n}{myData}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} also includes the concept of ghost cells and exchange operations.


\subsection{EBISLayout and EBISBox}
\label{\detokenize{Source/ChomboBasics:ebislayout-and-ebisbox}}
The \sphinxcode{\sphinxupquote{EBISLayout}} holds the geometric information over one \sphinxcode{\sphinxupquote{DisjointBoxLayout}} level.
Typically, the \sphinxcode{\sphinxupquote{EBISLayout}} is used for fetching the geometric moments that are required for performing computations near cut\sphinxhyphen{}cells.
\sphinxcode{\sphinxupquote{EBISLayout}} can be thought of as an object which provides all EB\sphinxhyphen{}related information on a specific grid level.
The EB information consists of e.g. cell flags (i.e., is the cell a cut\sphinxhyphen{}cell?), volume fractions, etc.
This information is stored in a class \sphinxcode{\sphinxupquote{EBISBox}}, which holds all the EB information for one specific grid patch.
To obtain the EB\sphinxhyphen{}information for a specific grid patch, one will call:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{EBISLayout} \PYG{n}{ebisl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{EBISBox}\PYG{o}{\PYGZam{}} \PYG{n}{ebisbox} \PYG{o}{=} \PYG{n}{ebisl}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{EBISBox}} contains the geometric information over only one grid patch.
One can thus think of the \sphinxcode{\sphinxupquote{EBISLayout}} as a \sphinxcode{\sphinxupquote{LevelData\textless{}EBISBox\textgreater{}}} structure.

As an example, to iterate over all the cut\sphinxhyphen{}cells defined for a cell\sphinxhyphen{}centered data holder an AMR\sphinxhyphen{}level one would do:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{constexpr} \PYG{k+kt}{int} \PYG{n}{comp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Assume that these exist.}
\PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFAB}\PYG{o}{\PYGZgt{}} \PYG{n}{myData}\PYG{p}{;}
\PYG{n}{EBISLayout} \PYG{n}{ebisl}\PYG{p}{;}

\PYG{c+c1}{// Iterate over all the patches on a grid level.}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{Box}  \PYG{n}{cellBox}   \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{EBCellFAB}\PYG{o}{\PYGZam{}} \PYG{n}{patchData} \PYG{o}{=} \PYG{n}{myData}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{EBISBox}\PYG{o}{\PYGZam{}}   \PYG{n}{ebisbox}   \PYG{o}{=} \PYG{n}{ebisl} \PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

   \PYG{c+c1}{// Get all the cut\PYGZhy{}cells in the grid patch}
   \PYG{k}{const} \PYG{n}{IntVectSet}\PYG{o}{\PYGZam{}} \PYG{n}{ivs} \PYG{o}{=} \PYG{n}{ebisbox}\PYG{p}{.}\PYG{n}{getIrregIVS}\PYG{p}{(}\PYG{n}{cellBox}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{n}{EBGraph}\PYG{o}{\PYGZam{}}        \PYG{o}{=} \PYG{n}{ebisbox}\PYG{p}{.}\PYG{n}{getEBGraph}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Define a VoFIterator for the cut\PYGZhy{}cells and iterate over all the cut\PYGZhy{}cells.}
   \PYG{k}{for} \PYG{p}{(}\PYG{n}{VoFIterator} \PYG{n}{vofit}\PYG{p}{(}\PYG{n}{ivs}\PYG{p}{,} \PYG{n}{ebgraph}\PYG{p}{)}\PYG{p}{;} \PYG{n}{vofit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{vofit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{n}{VolIndex}\PYG{o}{\PYGZam{}} \PYG{n}{vof} \PYG{o}{=} \PYG{n}{vofit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

      \PYG{n}{patchData}\PYG{p}{(}\PYG{n}{vof}\PYG{p}{,} \PYG{n}{comp}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here, \sphinxcode{\sphinxupquote{EBGraph}} is the graph that describes the connectivity of the cut cells.


\subsection{BaseIF}
\label{\detokenize{Source/ChomboBasics:baseif}}\label{\detokenize{Source/ChomboBasics:chap-baseif}}
The \sphinxcode{\sphinxupquote{BaseIF}} is a \sphinxcode{\sphinxupquote{Chombo}} class which encapsulates an implicit function (recall that all SDFs are also implicit functions, see {\hyperref[\detokenize{Source/SpatialDiscretization:chap-geometryrepresentation}]{\sphinxcrossref{\DUrole{std,std-ref}{Geometry representation}}}}).
\sphinxcode{\sphinxupquote{BaseIF}} is therefore used for fundamentally constructing a geometric object.
Many examples of \sphinxcode{\sphinxupquote{BaseIF}} are found in \sphinxcode{\sphinxupquote{Chombo}} itself, and \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} includes additional ones.

To implement a new implicit function, the user must inherit from \sphinxcode{\sphinxupquote{BaseIF}} and implement the pure function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{n}{Real} \PYG{n}{BaseIF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{value}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}point}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The implemention should return a positive value if the point \sphinxcode{\sphinxupquote{a\_point}} is inside the object and a negative value otherwise.


\section{Mesh data}
\label{\detokenize{Source/MeshData:mesh-data}}\label{\detokenize{Source/MeshData:chap-meshdata}}\label{\detokenize{Source/MeshData::doc}}
Mesh data structures of the type discussed in {\hyperref[\detokenize{Source/SpatialDiscretization:chap-spatialdiscretization}]{\sphinxcrossref{\DUrole{std,std-ref}{Spatial discretization}}}} are derived from a class \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} which holds a \sphinxcode{\sphinxupquote{T}} in every grid patch across the AMR hiearchy.
Internally, the data is stored as a \sphinxcode{\sphinxupquote{Vector\textless{}RefCountedPtr\textless{}LevelData\textless{}T\textgreater{} \textgreater{} \textgreater{}}}.
Here, the \sphinxcode{\sphinxupquote{Vector}} holds data on each AMR level; the data is allocated with a smart pointer called \sphinxcode{\sphinxupquote{RefCountedPtr}} which points to a \sphinxcode{\sphinxupquote{LevelData}} template structure, see {\hyperref[\detokenize{Source/ChomboBasics:chap-basics}]{\sphinxcrossref{\DUrole{std,std-ref}{Chombo\sphinxhyphen{}3 basics}}}}.
The first entry in the Vector is base AMR level and finer levels follow later in the Vector, see e.g. \hyperref[\detokenize{Source/MeshData:fig-ebamrdata}]{Fig.\@ \ref{\detokenize{Source/MeshData:fig-ebamrdata}}}.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{PatchBasedAMR}.png}
\caption{Cartesian patch\sphinxhyphen{}based refinement showing two grid levels.
This is encapsulated by \sphinxcode{\sphinxupquote{EBAMRData}} where the levels are stored in a \sphinxcode{\sphinxupquote{Vector}} and the grid patches in the \sphinxcode{\sphinxupquote{LevelData}} object.}\label{\detokenize{Source/MeshData:id3}}\label{\detokenize{Source/MeshData:fig-ebamrdata}}\end{figure}

The reason for having class encapsulation of mesh data is due to {\hyperref[\detokenize{Source/Realm:chap-realm}]{\sphinxcrossref{\DUrole{std,std-ref}{Realm}}}}, so that we can only keep track on which \sphinxcode{\sphinxupquote{Realm}} the mesh data is defined.
Users will interact with \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} through application code, or interacting with the core AMR functionality in {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}} (such as computing gradients, interpolating ghost cells etc.).
\sphinxcode{\sphinxupquote{AmrMesh}} (see {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}}) has functionality for defining most \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} types on a \sphinxcode{\sphinxupquote{Realm}}, and \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} itself it typically not used anywhere elsewhere within \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.

A number of explicit template specifications exist and are frequently used.
These are outlined below:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{EBAMRCellData}\PYG{p}{;}  \PYG{c+c1}{// Cell\PYGZhy{}centered single\PYGZhy{}phase data}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFluxFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{EBAMRFluxData}\PYG{p}{;}  \PYG{c+c1}{// Face\PYGZhy{}centered data in all coordinate direction}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFaceFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{EBAMRFaceData}\PYG{p}{;}  \PYG{c+c1}{// Face\PYGZhy{}centered in a single coordinate direction}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIVFAB}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{EBAMRIVData}\PYG{p}{;}    \PYG{c+c1}{// Data on irregular data centroids}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{DomainFluxIFFAB}\PYG{o}{\PYGZgt{}}  \PYG{n}{EBAMRIFData}\PYG{p}{;}    \PYG{c+c1}{// Data on domain phases}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseFab}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}   \PYG{n}{EBAMRBool}\PYG{p}{;}      \PYG{c+c1}{// For holding bool at every cell}

\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{MFCellFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{MFAMRCellData}\PYG{p}{;}  \PYG{c+c1}{// Cell\PYGZhy{}centered multifluid data}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{MFFluxFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{MFAMRFluxData}\PYG{p}{;}  \PYG{c+c1}{// Face\PYGZhy{}centered multifluid data}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{MFBaseIVFAB}\PYG{o}{\PYGZgt{}}      \PYG{n}{MFAMRIVData}\PYG{p}{;}    \PYG{c+c1}{// Irregular face multifluid data}
\end{sphinxVerbatim}

For example, \sphinxcode{\sphinxupquote{EBAMRCellData}} is a \sphinxcode{\sphinxupquote{Vector\textless{}RefCountedPtr\textless{}LevelData\textless{}EBCellFAB\textgreater{} \textgreater{} \textgreater{}}}, describing cell\sphinxhyphen{}centered data across the entire AMR hierarchy.
There are many more data structures in place, but the above data structures are the most commonly used ones.
Here, \sphinxcode{\sphinxupquote{EBAMRFluxData}} is precisely like \sphinxcode{\sphinxupquote{EBAMRCellData}}, except that the data is stored on \sphinxstyleemphasis{cell faces} rather than cell centers.
Likewise, \sphinxcode{\sphinxupquote{EBAMRIVData}} is a typedef’ed data holder that holds data on each cut\sphinxhyphen{}cell center across the entire AMR hierachy.
In the same way, \sphinxcode{\sphinxupquote{EBAMRIFData}} holds data on each face of all cut cells.


\subsection{Allocating mesh data}
\label{\detokenize{Source/MeshData:allocating-mesh-data}}
To allocate data over a particular \sphinxcode{\sphinxupquote{Realm}}, the user will interact with {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{int} \PYG{n}{nComps} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{EBAMRCellData} \PYG{n}{myData}\PYG{p}{;}
\PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{allocate}\PYG{p}{(}\PYG{n}{myData}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myRealm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{gas}\PYG{p}{,} \PYG{n}{nComps}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here, \sphinxcode{\sphinxupquote{nComps}} determine the number of cell\sphinxhyphen{}centered data components.
Note that it \sphinxstyleemphasis{does} matter on which \sphinxcode{\sphinxupquote{Realm}} and on which \sphinxcode{\sphinxupquote{phase}} the data is defined.
See {\hyperref[\detokenize{Source/Realm:chap-realm}]{\sphinxcrossref{\DUrole{std,std-ref}{Realm}}}} for details.

The user \sphinxstyleemphasis{can} specify a number of ghost cells for his/hers application code directly in the \sphinxcode{\sphinxupquote{AmrMesh::allocate}} routine, like so:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{int} \PYG{n}{nComps} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{EBAMRCellData} \PYG{n}{myData}\PYG{p}{;}
\PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{allocate}\PYG{p}{(}\PYG{n}{myData}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myRealm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{gas}\PYG{p}{,} \PYG{n}{nComps}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If the user does not specify the number of ghost cells when calling \sphinxcode{\sphinxupquote{AmrMesh::allocate}}, \sphinxcode{\sphinxupquote{AmrMesh}} will use the default number of ghost cells specified in the input file.


\subsection{Iterating over patches}
\label{\detokenize{Source/MeshData:iterating-over-patches}}
To iterate over data in an AMR hierarchy, you will first iterate over levels and the patches in levels:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lvl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lvl} \PYG{o}{\PYGZlt{}} \PYG{n}{myData}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lvl}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFAB}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{levelData} \PYG{o}{=} \PYG{o}{*}\PYG{n}{myData}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}

   \PYG{k}{const} \PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZam{}} \PYG{n}{levelGrids} \PYG{o}{=} \PYG{n}{levelData}\PYG{p}{.}\PYG{n}{disjointBoxLayout}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{levelGrids}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{EBCellFAB}\PYG{o}{\PYGZam{}} \PYG{n}{patchData} \PYG{o}{=} \PYG{n}{levelData}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Iterating over cells}
\label{\detokenize{Source/MeshData:iterating-over-cells}}
For single\sphinxhyphen{}valued data, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} uses standard loops (in column\sphinxhyphen{}major order) for iterating over data.
For example, the standard loops for iterating over cell\sphinxhyphen{}centered data are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{namespace} \PYG{n}{BoxLoops} \PYG{p}{\PYGZob{}}

   \PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{Functor}\PYG{o}{\PYGZgt{}}
   \PYG{n}{ALWAYS\PYGZus{}INLINE} \PYG{k+kt}{void}
   \PYG{n}{loop}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}computeBox}\PYG{p}{,} \PYG{n}{Functor}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{kernel}\PYG{p}{,} \PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}stride} \PYG{o}{=} \PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{Functor}\PYG{o}{\PYGZgt{}}
   \PYG{n}{ALWAYS\PYGZus{}INLINE} \PYG{k+kt}{void}
   \PYG{n}{loop}\PYG{p}{(}\PYG{n}{VoFIterator}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}iter}\PYG{p}{,} \PYG{n}{Functor}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}kernel}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here, the \sphinxcode{\sphinxupquote{Functor}} argument is a C++ lambda or \sphinxcode{\sphinxupquote{std::function}} which takes a grid cell as a single argument.
For the first loop, we iterate over all grid cells in \sphinxcode{\sphinxupquote{a\_computeBox}}.
In the second function we use a \sphinxcode{\sphinxupquote{VoFIterator}}, which
Iterating over the cells in a patch data holder (like the \sphinxcode{\sphinxupquote{EBCellFAB}}) can be done with a \sphinxcode{\sphinxupquote{VoFIterator}}, which can iterate through cells on an \sphinxcode{\sphinxupquote{EBCellFAB}} that are not covered by the geometry
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{component} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lvl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lvl} \PYG{o}{\PYGZlt{}} \PYG{n}{myData}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lvl}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFAB}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{levelData} \PYG{o}{=} \PYG{o}{*}\PYG{n}{myData}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}

   \PYG{k}{const} \PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZam{}} \PYG{n}{levelGrids} \PYG{o}{=} \PYG{n}{levelData}\PYG{p}{.}\PYG{n}{disjointBoxLayout}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{levelGrids}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}


      \PYG{n}{EBCellFAB}\PYG{o}{\PYGZam{}} \PYG{n}{patchData}       \PYG{o}{=} \PYG{n}{levelData}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{BaseFab}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{regularData} \PYG{o}{=} \PYG{n}{patchData}\PYG{p}{.}\PYG{n}{getSingleValuedFab}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

      \PYG{k}{auto} \PYG{n}{regularKernel} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{iv}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{void} \PYG{p}{\PYGZob{}}
         \PYG{n}{regularData}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{,} \PYG{n}{component}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}\PYG{p}{;}

      \PYG{k}{auto} \PYG{n}{irregularKernel} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{VolIndex}\PYG{o}{\PYGZam{}} \PYG{n}{vof}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{void} \PYG{p}{\PYGZob{}}
         \PYG{n}{patchData}\PYG{p}{(}\PYG{n}{vof}\PYG{p}{,} \PYG{n}{component} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}\PYG{p}{;}

      \PYG{c+c1}{// Kernel regions (defined by user)}
      \PYG{n}{Box} \PYG{n}{computeBox}\PYG{p}{;}
      \PYG{n}{VoFIterator} \PYG{n}{vofit}\PYG{p}{;}

      \PYG{n}{BoxLoops}\PYG{o}{:}\PYG{o}{:}\PYG{n}{loop}\PYG{p}{(}\PYG{n}{computeBox}\PYG{p}{,} \PYG{n}{regularKernel}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{BoxLoops}\PYG{o}{:}\PYG{o}{:}\PYG{n}{loop}\PYG{p}{(}\PYG{n}{vofit}\PYG{p}{,} \PYG{n}{irregularKernel}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

There are loops available for other types of data (e.g., face\sphinxhyphen{}centered data), see the \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/CD\_\_BoxLoops\_8H.html}{BoxLoop documentation}.


\subsection{Coarsening data}
\label{\detokenize{Source/MeshData:coarsening-data}}\label{\detokenize{Source/MeshData:chap-coarsening}}
Conservative coarsening of data is done using the \sphinxcode{\sphinxupquote{averageDown(...)}} functions in {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}}.
When using these functions, coarse\sphinxhyphen{}grid data is replaced by a conservative average of fine grid data throughout the entire AMR hierarchy.
The signatures for various types of data are as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Conservatively coarsen multifluid cell\PYGZhy{}centered data}
\PYG{k+kt}{void} \PYG{n+nf}{averageDown}\PYG{p}{(}\PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// Conservatively coarsen multifluid face\PYGZhy{}centered data}
\PYG{k+kt}{void} \PYG{n+nf}{averageDown}\PYG{p}{(}\PYG{n}{MFAMRFluxData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// Conservatively coarsen cell\PYGZhy{}centered data}
\PYG{k+kt}{void} \PYG{n+nf}{averageDown}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{,} \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase} \PYG{n}{a\PYGZus{}phase}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// Conservatively coarsen face\PYGZhy{}centered data}
\PYG{k+kt}{void} \PYG{n+nf}{averageDown}\PYG{p}{(}\PYG{n}{EBAMRFluxData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{,} \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase} \PYG{n}{a\PYGZus{}phase}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// Conservatively coarsen EB\PYGZhy{}centered data}
\PYG{k+kt}{void} \PYG{n+nf}{averageDown}\PYG{p}{(}\PYG{n}{EBAMRIVData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{,} \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase} \PYG{n}{a\PYGZus{}phase}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

There are other types of coarsening available also.
For example, the \sphinxcode{\sphinxupquote{averageFaces(...)}} will use unweighted averaging, see the \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classAmrMesh.html}{AmrMesh API} for further details.


\subsection{Filling ghost cells}
\label{\detokenize{Source/MeshData:filling-ghost-cells}}\label{\detokenize{Source/MeshData:chap-ghostcells}}
Filling ghost cells is done using the \sphinxcode{\sphinxupquote{interpGhost(...)}} functions in {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{interpGhost}\PYG{p}{(}\PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{interpGhost}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{,} \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase} \PYG{n}{a\PYGZus{}phase}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

This will fill the specified number of ghost cells using data from the coarse level only, using piecewise linear interpolation.

As an alternative, one \sphinxstyleemphasis{can} interpolate a single layer of ghost cells using the multigrid interpolator (see {\hyperref[\detokenize{Source/LinearSolvers:chap-multigridinterpolation}]{\sphinxcrossref{\DUrole{std,std-ref}{Ghost cell interpolation}}}}).
In this case only a single layer of ghost cells are filled in regular regions, but additional ghost cells (up to some specified range) are filled near the EB.
This is often required when computing gradients (to avoid reaching into invalid cut\sphinxhyphen{}cells), see {\hyperref[\detokenize{Source/MeshData:chap-gradients}]{\sphinxcrossref{\DUrole{std,std-ref}{Computing gradients}}}} for details.
The functions for filling ghost cells in this way are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{interpGhostMG}\PYG{p}{(}\PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{interpGhostMG}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}data}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{,} \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase} \PYG{n}{a\PYGZus{}phase}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

See the \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classAmrMesh.html}{AmrMesh API} for further details.


\subsection{Computing gradients}
\label{\detokenize{Source/MeshData:computing-gradients}}\label{\detokenize{Source/MeshData:chap-gradients}}
In \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} gradients are computed using a standard second\sphinxhyphen{}order stencil based on finite differences.
This is true everywhere except near the refinement boundary and EB where the coarse\sphinxhyphen{}side stencil will avoid using the coarsened data beneath the fine level.
This is shown in \hyperref[\detokenize{Source/MeshData:fig-ebgradient}]{Fig.\@ \ref{\detokenize{Source/MeshData:fig-ebgradient}}} which shows the typical 5\sphinxhyphen{}point stencil in regular grid regions, and also a much larger and more complex stencil.

In \hyperref[\detokenize{Source/MeshData:fig-ebgradient}]{Fig.\@ \ref{\detokenize{Source/MeshData:fig-ebgradient}}} we have shown two regular 5\sphinxhyphen{}point stencils (red and green).
The coarse stencil (red) reaches underneath the fine level and uses the data defined by coarsening of the fine\sphinxhyphen{}level data.
The coarsened data in this case is just an average of the fine\sphinxhyphen{}level data.
Likewise, the green stencil reaches over the refinement boundary and into one of the ghost cells on the coarse level.

\hyperref[\detokenize{Source/MeshData:fig-ebgradient}]{Fig.\@ \ref{\detokenize{Source/MeshData:fig-ebgradient}}} also shows a much larger stencil (blue stencil).
The larger stencil is necessary because computing the \(y\) component of the gradient using a regular 5\sphinxhyphen{}point stencil would have the stencil reach underneath the fine level and into coarse data that is also irregular data.
Since there is no unique way (that we know of) for coarsening the cut\sphinxhyphen{}cell fine\sphinxhyphen{}level data onto the coarse cut\sphinxhyphen{}cell without introducing spurious artifacts into the gradient, we reconstruct the gradient using a least squares procedure.
In this case we fetch a sufficiently large neighborhood of cells for computing a least squares minimization of a local solution reconstruction in the neighborhood of the coarse cell.
In order to avoid fetching potentially badly coarsened data, this neighborhood of cells only uses \sphinxstyleemphasis{valid} grid cells, i.e. the stencil does not reach underneath the fine level at all.
Once this neighborhood of cells is obtained, we compute the gradient using the procedure in {\hyperref[\detokenize{Utilities/LeastSquares:chap-leastsquares}]{\sphinxcrossref{\DUrole{std,std-ref}{Least squares}}}}.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{EBGradient}.png}
\caption{Example of stencils for computing gradients near embedded boundaries.
The red stencil shows a regular 5\sphinxhyphen{}point stencil for computing the gradient on the coarse side of the refinement boundary; it reaches into the coarsened data beneath the fine level.
The green stencil shows a similar 5\sphinxhyphen{}point stencil on the fine side of the refinement boundary; the stencil reaches over the refinement boundary and into one ghost cell.
The blue stencils shows a much more complex stencil which is computed using a least squares reconstruction procedure.}\label{\detokenize{Source/MeshData:id4}}\label{\detokenize{Source/MeshData:fig-ebgradient}}\end{figure}

To compute gradients of a scalar, one can simply call \sphinxcode{\sphinxupquote{AmrMesh::computeGradient(...)}} functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{computeGradient}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}}           \PYG{n}{a\PYGZus{}gradient}\PYG{p}{,}
                     \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}phi}\PYG{p}{,}
                     \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}        \PYG{n}{a\PYGZus{}realm}\PYG{p}{,}
                     \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase} \PYG{n}{a\PYGZus{}phase}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{computeGradient}\PYG{p}{(}\PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}gradient}\PYG{p}{,} \PYG{k}{const} \PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}phi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}} or refer to the \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classAmrMesh.html}{AmrMesh API} for further details.


\subsection{Copying data}
\label{\detokenize{Source/MeshData:copying-data}}\label{\detokenize{Source/MeshData:chap-copyingdata}}
To copy data, one may use the \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}::copy(...)}} function \sphinxstyleemphasis{or} \sphinxcode{\sphinxupquote{DataOps::copy}} (see {\hyperref[\detokenize{Source/MeshData:chap-dataops}]{\sphinxcrossref{\DUrole{std,std-ref}{DataOps}}}}).
These differ in the following way:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}::copy}} works across realms, but will not copy ghost cells.

\item {} 
\sphinxcode{\sphinxupquote{DataOps::copy}} will always do a local copy, and thus the data that is copied \sphinxstyleemphasis{must} be defined on the same realm.

\end{itemize}

If you call \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}::copy(...)}}, the data holders will first check if they are both defined on the same realm.
If they are, a purely local copy is perform, which will include ghost cells.
Communication copies involving MPI are performed otherwise, in which case ghost cells are \sphinxstyleemphasis{not} copied into the new data holder.


\subsection{DataOps}
\label{\detokenize{Source/MeshData:dataops}}\label{\detokenize{Source/MeshData:chap-dataops}}
We have prototyped functions for many common data operations in a static class \sphinxcode{\sphinxupquote{DataOps}}.
For example, setting the value of various data holders can be done with

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{EBAMRFluxData} \PYG{n}{cellData}\PYG{p}{;}
\PYG{n}{EBAMRFluxData} \PYG{n}{fluxData}\PYG{p}{;}
\PYG{n}{EBAMRIVData}   \PYG{n}{irreData}\PYG{p}{;}

\PYG{n}{DataOps}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setValue}\PYG{p}{(}\PYG{n}{cellData}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{DataOps}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setValue}\PYG{p}{(}\PYG{n}{fluxData}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{DataOps}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setValue}\PYG{p}{(}\PYG{n}{irreData}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For the full API, see the \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classDataOps.html}{DataOps documentation}.


\section{Particles}
\label{\detokenize{Source/Particles:particles}}\label{\detokenize{Source/Particles:chap-particles}}\label{\detokenize{Source/Particles::doc}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} supports computational particles using native \sphinxcode{\sphinxupquote{Chombo}} particle data.
The source code for the particle functionality resides in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Source/Particle}}.


\subsection{ParticleContainer}
\label{\detokenize{Source/Particles:particlecontainer}}
The \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} is a template class that
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Stores computational particles of type \sphinxcode{\sphinxupquote{P}} over an AMR hierchy.

\item {} 
Provides infrastructure for mapping and remapping.

\end{enumerate}

\sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} uses the \sphinxcode{\sphinxupquote{Chombo}} structure \sphinxcode{\sphinxupquote{ParticleData\textless{}P\textgreater{}}} under the hood, and therefore has template constraints on \sphinxcode{\sphinxupquote{P}}.
The simplest way to use \sphinxcode{\sphinxupquote{ParticleContainer}} for a new type of particle is to let \sphinxcode{\sphinxupquote{P}} inherit from the \sphinxcode{\sphinxupquote{Chombo}} class \sphinxcode{\sphinxupquote{BinItem}}.
\sphinxcode{\sphinxupquote{BinItem}} only has a single member variable which is its position, but derived classes will contain more and must therefore also add new linearization functions if the new member variables should be communicated.
There are many examples of \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} particles, see e.g. \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classTracerParticle.html}{TracerParticle} or \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classPhoton.html}{Photon}.
Please refer to the \sphinxcode{\sphinxupquote{Chombo}} design document for complete specification on the template constraints of \sphinxcode{\sphinxupquote{P}}, or see some of the examples in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.


\subsection{Data structures}
\label{\detokenize{Source/Particles:data-structures}}

\subsubsection{List\textless{}P\textgreater{} and ListBox\textless{}P\textgreater{}}
\label{\detokenize{Source/Particles:list-p-and-listbox-p}}
At the lowest level the particles are always stored in a linked list \sphinxcode{\sphinxupquote{List\textless{}P\textgreater{}}}.
The class can be simply be through of as a regular list of \sphinxcode{\sphinxupquote{P}} with non\sphinxhyphen{}random access.

The \sphinxcode{\sphinxupquote{ListBox\textless{}P\textgreater{}}} consists of a \sphinxcode{\sphinxupquote{List\textless{}P\textgreater{}}} \sphinxstyleemphasis{and} a \sphinxcode{\sphinxupquote{Box}}.
The latter specifies the grid patch that the particles are assigned to.

To get the list of particles from a \sphinxcode{\sphinxupquote{ListBox\textless{}P\textgreater{}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ListBox}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myListBox}\PYG{p}{;}

\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{myList} \PYG{o}{=} \PYG{n}{myListBox}\PYG{o}{.}\PYG{n}{listItems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{ListIterator\textless{}P\textgreater{}}
\label{\detokenize{Source/Particles:listiterator-p}}
In order to iterate over particles, use an iterator \sphinxcode{\sphinxupquote{ListIterator\textless{}P\textgreater{}}} (which is not random access):

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticles}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{ListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{lit}\PYG{p}{(}\PYG{n}{myParticles}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{P}\PYG{o}{\PYGZam{}} \PYG{n}{p} \PYG{o}{=} \PYG{n}{lit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// ... do something with this particle}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{ParticleData\textless{}P\textgreater{}}
\label{\detokenize{Source/Particles:particledata-p}}
On each grid level, \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} stores the particles in a \sphinxcode{\sphinxupquote{Chombo}} class \sphinxcode{\sphinxupquote{ParticleData}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{o}{\PYGZgt{}}
\PYG{n}{ParticleData}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{P}} is the particle type.
\sphinxcode{\sphinxupquote{ParticleData\textless{}P\textgreater{}}} can be thought of as a \sphinxcode{\sphinxupquote{LevelData\textless{}ListBox\textless{}P\textgreater{} \textgreater{}}}, although it actually inherits from \sphinxcode{\sphinxupquote{LayoutData\textless{}ListBox\textless{}P\textgreater{} \textgreater{}}}.
Each grid patch contains a \sphinxcode{\sphinxupquote{ListBox\textless{}P\textgreater{}}} of particles.


\subsubsection{AMRParticles\textless{}P\textgreater{}}
\label{\detokenize{Source/Particles:amrparticles-p}}
\sphinxcode{\sphinxupquote{AMRParticles\textless{}P\textgreater{}}} is our AMR version of \sphinxcode{\sphinxupquote{ParticleData\textless{}P\textgreater{}}}.
It is a simply a typedef of a vector of pointers to \sphinxcode{\sphinxupquote{ParticleData\textless{}P\textgreater{}}} on each level:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{o}{\PYGZgt{}}
\PYG{k}{using} \PYG{n}{AMRParticles} \PYG{o}{=} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{ParticleData}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{p}{;}
\end{sphinxVerbatim}

Again, the \sphinxcode{\sphinxupquote{Vector}} indicates the AMR level and the \sphinxcode{\sphinxupquote{ParticleData\textless{}P\textgreater{}}} is a distributed data holder that holds the particles on each AMR level.


\subsection{Basic use}
\label{\detokenize{Source/Particles:basic-use}}
Here, we give some examples of basic use of \sphinxcode{\sphinxupquote{ParticleContainer}}.
For the full API, see the \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classParticleContainer.html}{ParticleContainer doxygen documentation}.


\subsubsection{Getting the particles}
\label{\detokenize{Source/Particles:getting-the-particles}}
To get the particles from a \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} one can call \sphinxcode{\sphinxupquote{AMRParticles\textless{}P\textgreater{}\& ParticleContainer\textless{}P\textgreater{}::getParticles()}} which will provide the particles:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticleContainer}\PYG{p}{;}

\PYG{n}{AMRParticles}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{myParticles} \PYG{o}{=} \PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{getParticles}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Alternatively, one can fetch directly from a specified grid level as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{int} \PYG{n}{lvl}\PYG{p}{;}
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticleContainer}\PYG{p}{;}

\PYG{n}{ParticleData}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{levelParticles} \PYG{o}{=} \PYG{n}{myParticleContainer}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Iterating over particles}
\label{\detokenize{Source/Particles:iterating-over-particles}}
To do something basic with the particle in a \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}}, one will typically iterate over the particles in all grid levels and patches.

The code bit below shows a typical example of how the particles can be moved, and then remapped onto the correct grid patches and ranks if they fall off their original one.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticleContainer}\PYG{p}{;}

\PYG{c+c1}{// Iterate over grid levels}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lvl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lvl} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getFinestLevel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lvl}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}

   \PYG{c+c1}{// Get the grid on this level.}
   \PYG{k}{const} \PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZam{}} \PYG{n}{dbl} \PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGrids}\PYG{p}{(}\PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{getRealm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}

   \PYG{c+c1}{// Get the distributed particles on this level}
   \PYG{n}{ParticleData}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{levelParticles} \PYG{o}{=} \PYG{n}{myParticleContainer}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}

   \PYG{c+c1}{// Iterate over grid patches on this level}
   \PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}

      \PYG{c+c1}{// Get the particles in the current patch.}
      \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{patchParticles} \PYG{o}{=} \PYG{n}{levelParticles}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{.}\PYG{n}{listItems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

      \PYG{c+c1}{// Iterate over the particles in the current patch.}
      \PYG{k}{for} \PYG{p}{(}\PYG{n}{ListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{lit}\PYG{p}{(}\PYG{n}{patchParticles}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{P}\PYG{o}{\PYGZam{}} \PYG{n}{p} \PYG{o}{=} \PYG{n}{lit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

         \PYG{c+c1}{// Move the particle}
         \PYG{n}{p}\PYG{p}{.}\PYG{n}{position}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Remap particles onto new patches and ranks (they may have moved off their original ones)}
\PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{remap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Sorting particles}
\label{\detokenize{Source/Particles:sorting-particles}}

\subsubsection{Sorting by cell}
\label{\detokenize{Source/Particles:sorting-by-cell}}
The particles can also be sorted by cell by calling \sphinxcode{\sphinxupquote{void ParticleContainer\textless{}P\textgreater{}::sortParticleByCell()}}, like so:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticleContainer}\PYG{p}{;}

\PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{sortParticlesByCell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Internally in \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}}, this will place the particles in another container which can be iterated over on a per\sphinxhyphen{}cell basis.
This is different from \sphinxcode{\sphinxupquote{List\textless{}P\textgreater{}}} and \sphinxcode{\sphinxupquote{ListBox\textless{}P\textgreater{}}} above, which contained particles stored on a per\sphinxhyphen{}patch basis with no internal ordering of the particles.

The per\sphinxhyphen{}cell particle container is a \sphinxcode{\sphinxupquote{Vector\textless{}RefCountedPtr\textless{}LayoutData\textless{}BinFab\textless{}P\textgreater{} \textgreater{} \textgreater{} \textgreater{}}} type where again the \sphinxcode{\sphinxupquote{Vector}} holds the particles on each AMR level and the \sphinxcode{\sphinxupquote{LayoutData\textless{}BinFab\textgreater{}}} holds one \sphinxcode{\sphinxupquote{BinFab}} on each grid patch.
The \sphinxcode{\sphinxupquote{BinFab}} is also a template, and it holds a \sphinxcode{\sphinxupquote{List\textless{}P\textgreater{}}} in each grid cell.
Thus, this data structure stores the particles per cell rather than per patch.
Due to the horrific template depth, this container is typedef’ed as \sphinxcode{\sphinxupquote{AMRCellParticles\textless{}P\textgreater{}}}.

To get cell\sphinxhyphen{}sorted particles one can call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{AMRCellParticles}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{cellSortedParticles} \PYG{o}{=} \PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{getCellParticles}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Iteration over cell\sphinxhyphen{}sorted particles is mostly the same as for patch\sphinxhyphen{}sorted particles, except that we also need to explicitly iterate over the grid cells in each grid patch:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{comp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Iterate over all AMR levels}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lvl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lvl} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getFinestLevel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lvl}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}

   \PYG{c+c1}{// Get the grids on this level}
   \PYG{k}{const} \PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZam{}} \PYG{n}{dbl} \PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGrids}\PYG{p}{(}\PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{getRealm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}

   \PYG{c+c1}{// Iterate over grid patches on this level}
   \PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}

      \PYG{c+c1}{// Get the Cartesian box for the current grid aptch}
      \PYG{k}{const} \PYG{n}{Box} \PYG{n}{cellBox} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

      \PYG{c+c1}{// Get the particles in the current grid patch.}
      \PYG{n}{BinFab}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{cellSortedBoxParticles} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{cellSortedParticles}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

      \PYG{c+c1}{// Iterate over all cells in the current box}
      \PYG{k}{for} \PYG{p}{(}\PYG{n}{BoxIterator} \PYG{n}{bit}\PYG{p}{(}\PYG{n}{cellBox}\PYG{p}{)}\PYG{p}{;} \PYG{n}{bit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{bit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k}{const} \PYG{n}{IntVect} \PYG{n}{iv} \PYG{o}{=} \PYG{n}{bit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

         \PYG{c+c1}{// Get the particles in the current grid cell.}
         \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{cellParticles} \PYG{o}{=} \PYG{n}{cellSortedBoxParticles}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{,} \PYG{n}{comp}\PYG{p}{)}\PYG{p}{;}

         \PYG{c+c1}{// Do something with cellParticles}
         \PYG{k}{for} \PYG{p}{(}\PYG{n}{ListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{lit}\PYG{p}{(}\PYG{n}{cellParticles}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{P}\PYG{o}{\PYGZam{}} \PYG{n}{p} \PYG{o}{=} \PYG{n}{lit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Sorting by patch}
\label{\detokenize{Source/Particles:sorting-by-patch}}
If the particles need to return to patch\sphinxhyphen{}sorted particles:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticleContainer}\PYG{p}{;}

\PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{sortParticlesByPatch}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{important}{Important:}
If particles are sorted by cell, calling \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} member functions that fetch particles by patch will issue an error.
This is done by design since the patch\sphinxhyphen{}sorted particles have been moved to a different container.
Note that remapping particles also requires that the particles are patch\sphinxhyphen{}sorted.
Calling \sphinxcode{\sphinxupquote{remap()}} with cell\sphinxhyphen{}sorted particles will issue a run\sphinxhyphen{}time error.
\end{sphinxadmonition}


\subsection{Allocating particles}
\label{\detokenize{Source/Particles:allocating-particles}}
\sphinxcode{\sphinxupquote{AmrMesh}} has a very simple function for allocating a \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{P}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{allocate}\PYG{p}{(}\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}container}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}pvrBuffer}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

which will allocate a \sphinxcode{\sphinxupquote{ParticleContainer}} on realm \sphinxcode{\sphinxupquote{a\_realm}} with a buffer zone of \sphinxcode{\sphinxupquote{a\_pvrBuffer}}.
This buffer zone adjusts if particles on the fine side of a refinement boundary map to the coarse grid or the fine grid (see {\hyperref[\detokenize{Source/Particles:chap-particlemapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Mapping and remapping}}}}).


\subsection{Mapping and remapping}
\label{\detokenize{Source/Particles:mapping-and-remapping}}\label{\detokenize{Source/Particles:chap-particlemapping}}

\subsubsection{Mapping particles with ParticleValidRegion}
\label{\detokenize{Source/Particles:mapping-particles-with-particlevalidregion}}
The \sphinxcode{\sphinxupquote{ParticleValidRegion}} (PVR) allows particles to be transferred to coarser grid levels if they are within a specified number of grid cells from the refinement boundary.
There are two reasons why such a functionality is useful:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Particles that live in the first strip of cells on the fine side of a refinement boundary have deposition clouds that hang over the boundary and into ghost cells.
This mass must be added to the coarse level, which adds algorithmic complexity (\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} can handle this complexity).

\item {} 
Deposition and interpolation kernels can be entirely contained within a grid level.
It might be useful to keep the kernel on a specific AMR level for a certain number of time step.

\end{enumerate}

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{ParticleValidRegion}.png}
\caption{The \sphinxcode{\sphinxupquote{ParticleValidRegion}} allows particles whose position fall into a fine grid patch to be moved to a coarser level if they are within a specified distance from the refinement boundary.
In this case, the green particles that overlap with the fine\sphinxhyphen{}level grid are remapped to the coarse level.}\label{\detokenize{Source/Particles:id1}}\end{figure}

The PVR is automatically allocated through the particle constructor by specifying the \sphinxcode{\sphinxupquote{a\_pvrBuffer}} flag.
If you do not want to use PVR functionality, simply set \sphinxcode{\sphinxupquote{a\_pvrBuffer = 0}} for your \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}}.
In this case the particles will live on the grid patch that contains them.


\subsubsection{Remapping particles}
\label{\detokenize{Source/Particles:remapping-particles}}
Particles that move off their original grid patch must be remapped in order to ensure that they are assigned to the correct grid.
The remapping function for \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} is \sphinxcode{\sphinxupquote{void ParticleContainer\textless{}P\textgreater{}::remap()}}, which is simply used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticles}\PYG{p}{;}

\PYG{n}{myParticles}\PYG{o}{.}\PYG{n}{remap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that if a PVR region is set, the particle container remapping will respect it.


\subsection{Regridding}
\label{\detokenize{Source/Particles:regridding}}
\sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} is comparatively simple to regrid, and this is done in two steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Each MPI rank collects \sphinxstyleemphasis{all} particles on a single \sphinxcode{\sphinxupquote{List\textless{}P\textgreater{}}} by calling

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{preRegrid}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a\PYGZus{}base}\PYG{p}{)}
\end{sphinxVerbatim}

This will pull the particles off their current grids and collect them in a single list (on a per\sphinxhyphen{}rank basis).

\item {} 
When \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} regrids, each rank adds his \sphinxcode{\sphinxupquote{List\textless{}P\textgreater{}}} back into the internal particle containers.

\end{enumerate}

The use case typically looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticleContainer}\PYG{p}{;}

\PYG{c+c1}{// Each rank caches his particles}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{baseLevel} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{preRegrid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Driver does a regrid.}
\PYG{p}{.}
\PYG{p}{.}
\PYG{p}{.}

\PYG{c+c1}{// After the regrid we fetch grids from AmrMesh:}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZgt{}} \PYG{n}{grids}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{ProblemDomain}\PYG{o}{\PYGZgt{}} \PYG{n}{domains}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{dx}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{refinement\PYGZus{}ratios}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{base}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{newFinestLevel}\PYG{p}{;}

\PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{regrid}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{,} \PYG{n}{domains}\PYG{p}{,} \PYG{n}{dx}\PYG{p}{,} \PYG{n}{refinement\PYGZus{}ratios}\PYG{p}{,} \PYG{n}{baseLevel}\PYG{p}{,} \PYG{n}{newFinestLevel}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here, \sphinxcode{\sphinxupquote{baseLevel}} is the finest level that didn’t change and \sphinxcode{\sphinxupquote{newFinestLevel}} is the finest AMR level after the regrid.


\subsection{Masked particles}
\label{\detokenize{Source/Particles:masked-particles}}\label{\detokenize{Source/Particles:chap-maskedparticles}}
\sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} also supports the concept of \sphinxstyleemphasis{masked particles}, where one can fetch a subset of particles that live only in specified regions in space.
Typically, this “specified region” is the refinement boundary, but the functionality is generic and might prove useful also in other cases.

When \sphinxstyleemphasis{masked particles} are used, the user can provide a boolean mask over the AMR hierarchy and obtain the subset of particles that live in regions where the mask evaluates to true.
This functionality is for example used for some of the particle deposition methods in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} where we deposit particles that live near the refinement boundary with special deposition functions.

To fill the masked particles, \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} has members functions for copying the particles into internal data containers which the user can later fetch.
The function signatures for these are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{using} \PYG{n}{AmrMask} \PYG{o}{=} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseFab}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{copyMaskParticles}\PYG{p}{(}\PYG{k}{const} \PYG{n}{AmrMask}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}mask}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{copyNonMaskParticles}\PYG{p}{(}\PYG{k}{const} \PYG{n}{AmrMask}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}mask}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

The argument \sphinxcode{\sphinxupquote{a\_mask}} holds a bool at each cell in the AMR hierarchy.
Particles that live in cells where \sphinxcode{\sphinxupquote{a\_mask}} is true will be copied to an internal data holder in \sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} which can be retried through a call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{AMRParticles}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{maskParticles} \PYG{o}{=} \PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{getMaskParticles}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that \sphinxcode{\sphinxupquote{copyNonMaskParticles}} is just like \sphinxcode{\sphinxupquote{copyMaskParticles}} except that the bools in \sphinxcode{\sphinxupquote{a\_mask}} have been flipped.

Note that the mask particles are \sphinxstyleemphasis{copied}, and the original particles are left untouched.
After the user is done with the particles, they should be deleted through the functions \sphinxcode{\sphinxupquote{void clearMaskParticles()}} and \sphinxcode{\sphinxupquote{void clearNonMaskParticles}}, like so:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{AmrMask} \PYG{n}{myMask}\PYG{p}{;}
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{myParticles}\PYG{p}{;}

\PYG{c+c1}{// Copy mask particles}
\PYG{n}{myParticles}\PYG{p}{.}\PYG{n}{copyMaskParticles}\PYG{p}{(}\PYG{n}{myMask}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Do something with the mask particles}
\PYG{n}{AMRParticles}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{maskParticles} \PYG{o}{=} \PYG{n}{myParticleContainer}\PYG{p}{.}\PYG{n}{getMaskParticles}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Release the mask particles}
\PYG{n}{myParticles}\PYG{p}{.}\PYG{n}{clearMaskParticles}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Creating particle halo masks}
\label{\detokenize{Source/Particles:creating-particle-halo-masks}}
\sphinxcode{\sphinxupquote{AmrMesh}} can register a \sphinxstyleemphasis{halo} mask with a specified width:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{registerMask}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}mask}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}buffer}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{a\_mask}} must be \sphinxcode{\sphinxupquote{"s\_particle\_halo"}}.
This will register a mask which is false everywhere except in coarse\sphinxhyphen{}grid cells that are within a distance a\_buffer from the refinement boundary, see \hyperref[\detokenize{Source/Particles:fig-halomask}]{Fig.\@ \ref{\detokenize{Source/Particles:fig-halomask}}}.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{HaloMask}.png}
\caption{Example of a particle halo mask (shaded green color) surrounding refined grid levels.}\label{\detokenize{Source/Particles:id2}}\label{\detokenize{Source/Particles:fig-halomask}}\end{figure}


\subsection{Embedded boundaries}
\label{\detokenize{Source/Particles:embedded-boundaries}}
\sphinxcode{\sphinxupquote{ParticleContainer\textless{}P\textgreater{}}} is EB\sphinxhyphen{}agnostic and has no information about the embedded boundary.
This means that particles remap just as if the EB was not there.
Interaction with the EB is done via the implicit function or discrete information, as well as modifications in the interpolation and deposition steps.


\subsubsection{Signed distance function}
\label{\detokenize{Source/Particles:signed-distance-function}}
When signed distance functions are used, one can always query how far a particle is from a boundary:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{particles}\PYG{p}{;}
\PYG{n}{BaseIF} \PYG{n}{distanceFunction}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{ListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}} \PYG{n}{lit}\PYG{p}{(}\PYG{n}{particles}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{P}\PYG{o}{\PYGZam{}} \PYG{n}{p}          \PYG{o}{=} \PYG{n}{lit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{pos} \PYG{o}{=} \PYG{n}{p}\PYG{p}{.}\PYG{n}{position}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{const} \PYG{n}{Real} \PYG{n}{distanceToBoundary} \PYG{o}{=} \PYG{n}{distanceFunction}\PYG{p}{.}\PYG{n}{value}\PYG{p}{(}\PYG{n}{pos}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If the particle is inside the EB then the signed distance function will be positive and the particle can be removed from the simulation.
The distance function can also be used to detect collisions between particles and the EB.


\subsection{Particle depositon}
\label{\detokenize{Source/Particles:particle-depositon}}
To deposit particles on the mesh, the user can call the templated function \sphinxcode{\sphinxupquote{AmrMesh::depositParticles}} which has a signature

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{P}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{particleScalarField}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{depositParticles}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}}              \PYG{n}{a\PYGZus{}meshData}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}}          \PYG{n}{a\PYGZus{}realm}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase}\PYG{o}{\PYGZam{}}   \PYG{n}{a\PYGZus{}phase}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}particles}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{DepositionType}        \PYG{n}{a\PYGZus{}depositionType}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{CoarseFineDeposition}  \PYG{n}{a\PYGZus{}coarseFineDeposition}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{bool}                  \PYG{n}{a\PYGZus{}forceIrregNGP}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{P}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{particleVectorField}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{depositParticles}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}}              \PYG{n}{a\PYGZus{}meshData}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}}          \PYG{n}{a\PYGZus{}realm}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase}\PYG{o}{\PYGZam{}}   \PYG{n}{a\PYGZus{}phase}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}particles}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{DepositionType}        \PYG{n}{a\PYGZus{}depositionType}\PYG{p}{,}
                      \PYG{k}{const} \PYG{n}{CoarseFineDeposition}  \PYG{n}{a\PYGZus{}coarseFineDeposition}\PYG{p}{,}
                      \PYG{k}{const} \PYG{k+kt}{bool}                  \PYG{n}{a\PYGZus{}forceIrregNGP}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here, the template parameter \sphinxcode{\sphinxupquote{P}} is the particle type and the template parameter \sphinxcode{\sphinxupquote{particleScalarField}} is a C++ pointer\sphinxhyphen{}to\sphinxhyphen{}member\sphinxhyphen{}function.
This function must have the indicated signature \sphinxcode{\sphinxupquote{const Real\& P::particleScalarField() const}} \sphinxstyleemphasis{or} the signature \sphinxcode{\sphinxupquote{Real P::particleScalarField() const}}.
The pointer\sphinxhyphen{}to\sphinxhyphen{}member \sphinxcode{\sphinxupquote{particleScalarField}} indicates the variable to be deposited on the mesh.
This function pointer does not need to return a member in the particle class.

Note that when depositing vector\sphinxhyphen{}quantities (such as electric currents), one must call the version which takes \sphinxcode{\sphinxupquote{RealVect P::particleVectorField() const}} as a template parameter.
The supplied function must return a \sphinxcode{\sphinxupquote{RealVect}} and \sphinxcode{\sphinxupquote{a\_meshData}} must have \sphinxcode{\sphinxupquote{SpaceDim}} components.

Next, the input arguments to \sphinxcode{\sphinxupquote{depositParticles}} are the output mesh data holder (must have exactly one or \sphinxcode{\sphinxupquote{SpaceDim}} components), the realm and phase where the particles live, and the particles themselves (\sphinxcode{\sphinxupquote{a\_particles}}).
The enum \sphinxcode{\sphinxupquote{DepositionType}} and input argument \sphinxcode{\sphinxupquote{a\_depositionType}} indicates the deposition method.
Valid arguments are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{DepositionType::NGP}} (Nearest grid\sphinxhyphen{}point).

\item {} 
\sphinxcode{\sphinxupquote{DepositionType::CIC}} (Cloud\sphinxhyphen{}In\sphinxhyphen{}Cell).

\item {} 
\sphinxcode{\sphinxupquote{DepositionType::TSC}} (Triangle\sphinxhyphen{}Shaped Cloud).

\item {} 
\sphinxcode{\sphinxupquote{DepositionType::W4}}  (Fourth order weighted).

\end{itemize}

The input argument \sphinxcode{\sphinxupquote{a\_coarseFineDeposition}} determines how coarse\sphinxhyphen{}fine deposition is handled.
Strictly speaking, this argument only affects how the particle mass is deposited from the coarse level to the fine level.
Valid input arguments are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CoarseFineDeposition::PVR}} This uses a standard PVR formulation.
When the particles near the refinement boundary deposit on the mesh, some of the mass from the coarse\sphinxhyphen{}side particles will end up underneath the fine grid.
This mass is interpolated to the fine grid using piecewise constant interpolation.
If the fine\sphinxhyphen{}level particles also have particle clouds that hang over the refinement boundary, the hanging mass will be added to the coarse level.

\item {} 
\sphinxcode{\sphinxupquote{CoarseFineDeposition::Halo}} This uses a what we call \sphinxstyleemphasis{halo} particles.
Instead of interpolating the mass from the invalid coarse region onto the fine level, the particles near the refinement boundary (i.e., the \sphinxstyleemphasis{halo} particles) deposit directly into the fine level but with 2x or 4x the particle width.
So, if a coarse\sphinxhyphen{}level particle lives right next to the fine grid and the refinement factor between the grids is \(r\), it will deposit both into the fine grid with \(r\) times the particle width compared to the coarse grid.
Again, if the fine\sphinxhyphen{}level particles also have particle clouds that hang over the refinement boundary, the hanging mass will be added to the coarse level.

\item {} 
\sphinxcode{\sphinxupquote{CoarseFineDeposition::HaloNGP}} This uses halo particles, but the particles along the refinement boundary are deposited with an NGP scheme.

\end{itemize}

Finally, the flag \sphinxcode{\sphinxupquote{a\_forceIrregNGP}} permits the user to enforce nearest grid\sphinxhyphen{}point deposition in cut\sphinxhyphen{}cells.
This option is motivated by the fact that some applications might require hard mass conservation, and the user can ensure that mass is never deposited into covered grid cells.

As an example, if the particle type \sphinxcode{\sphinxupquote{P}} needs to deposit a computational mass on the mesh, the particle class will at least contain the following member functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{class} \PYG{n+nc}{P} \PYG{o}{:} \PYG{k}{public} \PYG{n}{BinItem} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}

   \PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{mass}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{m\PYGZus{}mass}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{Real} \PYG{n}{mass2}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{m\PYGZus{}mass}\PYG{o}{*}\PYG{n}{m\PYGZus{}mass}\PYG{p}{.}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{RealVect} \PYG{n}{momentum}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{m\PYGZus{}mass}\PYG{o}{*}\PYG{n}{m\PYGZus{}velocity}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{k}{protected}\PYG{o}{:}

   \PYG{n}{Real} \PYG{n}{m\PYGZus{}mass}\PYG{p}{;}

   \PYG{n}{Real} \PYG{n}{m\PYGZus{}velocity}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Here, we have included an extra member function \sphinxcode{\sphinxupquote{mass()}} which returns the squared mass.
Note that the function does not return a member variable but an r\sphinxhyphen{}value.
When depositing the mass on the mesh the user will e.g. call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{AmrMesh}\PYG{o}{\PYGZgt{}} \PYG{n}{amr}\PYG{p}{;}

\PYG{n}{amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{depositParticles}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{P}\PYG{o}{:}\PYG{o}{:}\PYG{n}{mass} \PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{depositParticles}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{P}\PYG{o}{:}\PYG{o}{:}\PYG{n}{mass2}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

When depositing momentum, use

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{depositParticles}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{p}{,}  \PYG{o}{\PYGZam{}}\PYG{n}{P}\PYG{o}{:}\PYG{o}{:}\PYG{n}{momentum}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{.}
\end{sphinxVerbatim}


\subsection{Particle interpolation}
\label{\detokenize{Source/Particles:particle-interpolation}}
To interpolate a field onto a particle position, the user can call the \sphinxcode{\sphinxupquote{AmrMesh}} member functions

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{n}{Real}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{P}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{particleScalarField}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{interpolateParticles}\PYG{p}{(}\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}      \PYG{n}{a\PYGZus{}particles}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}realm}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase}\PYG{o}{\PYGZam{}}  \PYG{n}{a\PYGZus{}phase}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}}       \PYG{n}{a\PYGZus{}meshScalarField}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{DepositionType}       \PYG{n}{a\PYGZus{}interpType}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{bool}                 \PYG{n}{a\PYGZus{}forceIrregNGP}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{P}\PYG{p}{,} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{P}\PYG{o}{:}\PYG{o}{:}\PYG{o}{*}\PYG{n}{particleVectorField}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{interpolateParticles}\PYG{p}{(}\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{n}{P}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}      \PYG{n}{a\PYGZus{}particles}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}realm}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase}\PYG{o}{\PYGZam{}}  \PYG{n}{a\PYGZus{}phase}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}}       \PYG{n}{a\PYGZus{}meshVectorField}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{DepositionType}       \PYG{n}{a\PYGZus{}interpType}\PYG{p}{,}
                          \PYG{k}{const} \PYG{k+kt}{bool}                 \PYG{n}{a\PYGZus{}forceIrregNGP}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

The function signature for particle interpolation is pretty much the same as for particle deposition, with the exception of the interpolated field.
The template parameter \sphinxcode{\sphinxupquote{P}} still indicates the particle type, but the user can interpolate onto either a scalar particle variable or a vector variable.
For example, in order to interpolate the particle acceleration, the particle class (let’s call it \sphinxcode{\sphinxupquote{MyParticleClass}}) will typically have a member function \sphinxcode{\sphinxupquote{RealVect\& acceleration()}}, and in this case one can interpolate the acceleration by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{AmrMesh}\PYG{o}{\PYGZgt{}} \PYG{n}{amr}\PYG{p}{;}

\PYG{n}{amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{interpolateParticles}\PYG{o}{\PYGZlt{}}\PYG{n}{MyParticleClass}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{MyParticleClass}\PYG{o}{:}\PYG{o}{:}\PYG{n}{acceleration}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\end{sphinxVerbatim}

Note that if the user interpolates onto a scalar variable, the mesh variable must have exactly one component.
Likewise, if interpolating a vector variable, the mesh variable must have exact \sphinxcode{\sphinxupquote{SpaceDim}} components.


\section{Realm}
\label{\detokenize{Source/Realm:realm}}\label{\detokenize{Source/Realm:chap-realm}}\label{\detokenize{Source/Realm::doc}}
\sphinxcode{\sphinxupquote{Realm}} is a class for centralizing EBAMR\sphinxhyphen{}related grids and operators for a specific AMR grid.
For example, a \sphinxcode{\sphinxupquote{Realm}} consists of a set of grids (i.e. a \sphinxcode{\sphinxupquote{Vector\textless{}DisjointBoxLayout\textgreater{}}}) as well as \sphinxstyleemphasis{operators}, e.g. functionality for filling ghost cells or averaging down a solution from a fine level to a coarse level.
One may think of a \sphinxcode{\sphinxupquote{Realm}} as a fully\sphinxhyphen{}fledged AMR hierarchy with associated multilevel operators, i.e. how one would usually do AMR.


\subsection{Dual grid}
\label{\detokenize{Source/Realm:dual-grid}}
The reason why \sphinxcode{\sphinxupquote{Realm}} exists at all is due to individual load balancing of algorithmic components.
The terminology \sphinxstyleemphasis{dual grid} is used when more than one \sphinxcode{\sphinxupquote{Realm}} is used in a simulation, and in this case the user/developer has chosen to solve the equations of motion over a different set of \sphinxcode{\sphinxupquote{DisjointBoxLayout}} on each level.
This approach is very useful when using computational particles since users can quickly generate separate Eulerian sets of grids for fluids and particles, and the grids can then be load balanced separately.
Note that every \sphinxcode{\sphinxupquote{Realm}} consists of the same boxes, i.e. the physical domain and computational grids are the same for all realms.
The difference lies primarily in the assignment of MPI ranks to grids; i.e. the load\sphinxhyphen{}balancing and domain decomposition.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{DualMesh}.png}
\caption{Sketch of dual grid approach.
Each rectangle represents a grid patch and the numbers show MPI ranks. a) Load balancing with the number of grid cells. b) Load balancing with the number of particles.}\label{\detokenize{Source/Realm:id1}}\label{\detokenize{Source/Realm:fig-dualmesh}}\end{figure}

\hyperref[\detokenize{Source/Realm:fig-dualmesh}]{Fig.\@ \ref{\detokenize{Source/Realm:fig-dualmesh}}} shows an example of a dual\sphinxhyphen{}grid approach.
In  this figure we have a set of grid patches on a particular grid level.
In the top panel the grid patches are load\sphinxhyphen{}balanced using the grid patch volume as a proxy for the computational load.
The numbers in each grid patch indicates the MPI rank ownership of the patches.
In the bottom panel we have introduced computational particles in some of the patches.
For particles, the computational load is better defined by the number of computational particles assigned to the patch, and so using the number of particles as a proxy for the load yields different rank ownership over the grid patches.


\subsection{Realm registration}
\label{\detokenize{Source/Realm:realm-registration}}
To register a \sphinxcode{\sphinxupquote{Realm}}, users will have \sphinxcode{\sphinxupquote{TimeStepper}} allocate the desired number of realms in the pure routine \sphinxcode{\sphinxupquote{registerRealms()}}, as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{myTimeStepper}\PYG{o}{:}\PYG{o}{:}\PYG{n}{registerRealms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{registerRealm}\PYG{p}{(}\PYG{n}{Realm}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Primal}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{registerRealm}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{particleRealm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{registerRealm}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{otherParticleRealm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Since at least one realm is required, \sphinxcode{\sphinxupquote{Driver}} will \sphinxstyleemphasis{always} register the realm \sphinxcode{\sphinxupquote{"Primal"}}.
Fundamentally, there is no limitation to the number of realms that can be allocated.

During regrid, all realms are initially load balanced with the grid patch volume as the load proxy.
However, users can change load balancing individually for each realm through the load balancing routines in {\hyperref[\detokenize{Source/TimeStepper:chap-timestepper}]{\sphinxcrossref{\DUrole{std,std-ref}{TimeStepper}}}}.


\subsection{Operator registration}
\label{\detokenize{Source/Realm:operator-registration}}
Internally, an instantiation of \sphinxcode{\sphinxupquote{Realm}} contains the grids and the geometric information (e.g. \sphinxcode{\sphinxupquote{EBISLayout}}), as well as any operators that the user has seen fit to \sphinxstyleemphasis{register}.
Various operators are available for e.g. gradient stencils, conservative coarsening, ghost cell interpolation, filling a patch with interpolation data, redistribution, and so on.
Since operators always incur overhead and not all applications require \sphinxstyleemphasis{all} operators, they must be \sphinxstyleemphasis{registered}.
If a solver needs an operator for, say, piecewise linear ghost cell interpolation, the solver needs to \sphinxstyleemphasis{register} that operator through the \sphinxcode{\sphinxupquote{AmrMesh}} public interface:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{registerOperator}\PYG{p}{(}\PYG{n}{s\PYGZus{}eb\PYGZus{}pwl\PYGZus{}interp}\PYG{p}{,} \PYG{n}{m\PYGZus{}realm}\PYG{p}{,} \PYG{n}{m\PYGZus{}phase}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Once an operator has been registered, \sphinxcode{\sphinxupquote{Realm}} will define those operators during initialization e.g. regrids.
Run\sphinxhyphen{}time error messages are issued if an AMR operator is used, but has not been registered.

More commonly, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} solvers will contain a routine that registers the operators that the solver needs.
A valid \sphinxcode{\sphinxupquote{TimeStepper}} implementation \sphinxstyleemphasis{must} register all required operators in the function \sphinxcode{\sphinxupquote{registerOperators()}}.

Currently available operators are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Gradient \sphinxcode{\sphinxupquote{s\_eb\_gradient}}.

\item {} 
Irregular cell centroid interpolation, \sphinxcode{\sphinxupquote{s\_eb\_irreg\_interp}}.

\item {} 
Coarse grid conservative coarsening, \sphinxcode{\sphinxupquote{s\_eb\_coar\_ave}}.

\item {} 
Piecewise linear interpolation (with slope limiters), \sphinxcode{\sphinxupquote{s\_eb\_fill\_patch}}.

\item {} 
Linear ghost cell interpolation, \sphinxcode{\sphinxupquote{s\_eb\_fine\_interp}}.

\item {} 
Flux registers, \sphinxcode{\sphinxupquote{s\_eb\_flux\_reg}}.

\item {} 
Redistribution registers, \sphinxcode{\sphinxupquote{s\_eb\_redist}}.

\item {} 
Non\sphinxhyphen{}conservative divergence stencils, \sphinxcode{\sphinxupquote{s\_eb\_noncons\_div}}.

\item {} 
Multigrid interpolators, \sphinxcode{\sphinxupquote{s\_eb\_multigrid}} (used for multigrid).

\item {} 
Signed distance function defined on grid, \sphinxcode{\sphinxupquote{s\_levelset}}.

\item {} 
Particle\sphinxhyphen{}mesh support, \sphinxcode{\sphinxupquote{s\_eb\_particle\_mesh}}.

\end{enumerate}

Solvers will typically allocate a subset of these operators, but for multiphysics code that use both fluid and particles, most of these will probably be in use.


\subsection{Interacting with realms}
\label{\detokenize{Source/Realm:interacting-with-realms}}
Users will not interact with \sphinxcode{\sphinxupquote{Realm}} directly.
Every \sphinxcode{\sphinxupquote{Realm}} is owned by \sphinxcode{\sphinxupquote{AmrMesh}}, and the user will only interact with realms through the public \sphinxcode{\sphinxupquote{AmrMesh}} interface, for example by fetching operators for performing AMR operations.
In addition, data that is defined on one realm can be copied to another; \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} takes care of this.
You will simply call a copier:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{EBAMRCellData} \PYG{n}{realmOneData}\PYG{p}{;}
\PYG{n}{EBAMRCellData} \PYG{n}{realmTwoData}\PYG{p}{;}

\PYG{n}{realmOneData}\PYG{p}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{realmTwoData}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The rest of the functionality uses the public interface of {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}}.
For example for coarsening of multifluid data:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{multifluidRealm}\PYG{p}{;}
\PYG{n}{MFAMRCellData} \PYG{n}{multifluidData}\PYG{p}{;}
\PYG{n}{AmrMesh} \PYG{n}{amrMesh}\PYG{p}{;}

\PYG{n}{amrMesh}\PYG{p}{.}\PYG{n}{averageDown}\PYG{p}{(}\PYG{n}{multifluidData}\PYG{p}{,} \PYG{n}{multifluidRealm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Linear solvers}
\label{\detokenize{Source/LinearSolvers:linear-solvers}}\label{\detokenize{Source/LinearSolvers:chap-linearsolvers}}\label{\detokenize{Source/LinearSolvers::doc}}

\subsection{Helmholtz equation}
\label{\detokenize{Source/LinearSolvers:helmholtz-equation}}\label{\detokenize{Source/LinearSolvers:chap-helmholtz}}
The Helmholtz equation is represented by
\begin{equation*}
\begin{split}\alpha a\left(\mathbf{x}\right)\Phi + \beta\nabla\cdot\left[b\left(\mathbf{x}\right)\nabla\Phi\right] = \rho\end{split}
\end{equation*}
where \(\alpha\) and \(\beta\) are constants and \(a\left(\mathbf{x}\right)\) and \(b\left(\mathbf{x}\right)\) are spatially dependent and piecewise smooth.

To solve the Helmholtz equation, it is solved in the form
\begin{equation*}
\begin{split}\kappa L\Phi = \kappa\rho,\end{split}
\end{equation*}
where \(L\) is the Helmholtz operator above.
The preconditioning by the volume fraction \(\kappa\) is done in order to avoid the small\sphinxhyphen{}cell problem encountered in finite\sphinxhyphen{}volume discretizations on EB grids.


\subsubsection{Discretization and fluxes}
\label{\detokenize{Source/LinearSolvers:discretization-and-fluxes}}
The Helmholtz equation is solved by assuming that \(\Phi\) lies on the cell\sphinxhyphen{}center.
The \(b\left(\mathbf{x}\right)\)\sphinxhyphen{}coefficient lies on face centers and EB faces.
In the general case the cell center might lie inside the embedded boundary, and the cell\sphinxhyphen{}centered discretization relies on the concept of an extended state.
Thus, \(\Phi\) does not satisfy a discrete maximum principle.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{CutCell}.png}
\caption{Location of fluxes for finite volume discretization.}\label{\detokenize{Source/LinearSolvers:id1}}\label{\detokenize{Source/LinearSolvers:fig-helmholtzfluxes}}\end{figure}

The finite volume update require fluxes on the face centroids rather than the centers.
These are constructed by first computing the fluxes to second order on the face centers, and then interpolating them to the face centroids.
For example, the flux \(F_3\) in the figure above is
\begin{equation*}
\begin{split}F_3 = \beta b_{i,j+1/2}\frac{\Phi_{i,j+1} - \Phi_{i,j}}{\Delta x}.\end{split}
\end{equation*}

\subsubsection{Boundary conditions}
\label{\detokenize{Source/LinearSolvers:boundary-conditions}}
The finite volume discretization of the Helmholtz equation require fluxes through the EB and domain faces.
Below, we discuss how these are implemented.

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} supports spatially dependent boundary conditions
\end{sphinxadmonition}


\paragraph{Neumann}
\label{\detokenize{Source/LinearSolvers:neumann}}
Neumann boundary conditions are straightforward since the flux through the EB or domain faces are specified directly.

From the above figure, the fluxes \(F_{\textrm{EB}}\) and \(F_{\textrm{D}}\) are specified.


\paragraph{Dirichlet}
\label{\detokenize{Source/LinearSolvers:dirichlet}}\label{\detokenize{Source/LinearSolvers:chap-linearsolverdirichletbc}}
Dirichlet boundary conditions are more involved since only the value at the boundary is prescribed, but the finite volume discretization requires a flux.
On the domain boundaries the fluxes are face\sphinxhyphen{}centered and we therefore use finite differencing for obtaining a second order accurate approximation to the flux at the boundary.

On the embedded boundaries the flux is more complicated to compute, and requires us to compute an approximation to the normal gradient \(\partial_n\Phi\) at the boundary.
Our approach is to approximate this flux by expanding the solution as a polynomial around a specified number of grid cells.
By using more grid cells than there are unknown in the Taylor series, we formulate an over\sphinxhyphen{}determined system of equations up to some specified order.
As a first approximation we include only those cells in the quadrant or half\sphinxhyphen{}space defined by the normal vector, see \hyperref[\detokenize{Source/LinearSolvers:fig-gradientreconstruction}]{Fig.\@ \ref{\detokenize{Source/LinearSolvers:fig-gradientreconstruction}}}.
If we can not find enough equations, the strategy is to 1) drop order and 2) include all cells around the cut\sphinxhyphen{}cell.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{GradientReconstruction}.png}
\caption{Examples of neighborhoods (quadrant and half\sphinxhyphen{}space) used for gradient reconstruction on the EB.}\label{\detokenize{Source/LinearSolvers:id2}}\label{\detokenize{Source/LinearSolvers:fig-gradientreconstruction}}\end{figure}

Once the cells used for the gradient reconstruction have been obtained, we use weighted least squares to compute the approximation to the derivative to specified order (for details, see {\hyperref[\detokenize{Utilities/LeastSquares:chap-leastsquares}]{\sphinxcrossref{\DUrole{std,std-ref}{Least squares}}}}).
The result of the least squares computation is represented as a stencil:

\phantomsection\label{\detokenize{Source/LinearSolvers:eq-dirichletelliptic}}\begin{equation*}
\begin{split}\frac{\partial\Phi}{\partial n} = w_{\textrm{B}}\Phi_{\textrm{B}} + \sum_{\mathbf{i}} w_{\mathbf{i}}\Phi_{\mathbf{i}},\end{split}
\end{equation*}
where \(\Phi_{\textrm{B}}\) is the value on the boundary, the \(w\) are weights for grid points \(\mathbf{i}\), and the sum runs over cells in the domain.

Note that the gradient reconstruction can end up requiring more than one ghost cell layer near the embedded boundaries.
For example, \hyperref[\detokenize{Source/LinearSolvers:fig-stencilregion}]{Fig.\@ \ref{\detokenize{Source/LinearSolvers:fig-stencilregion}}} shows a typical stencil region which is built when using second order gradient reconstruction on the EB.
In this case the gradient reconstruction requires a stencil with a radius of 2, but as the cut\sphinxhyphen{}cell lies on the refinement boundary the stencil reaches into two layers of ghost cells.
For the same reason, gradient reconstruction near the cut\sphinxhyphen{}cells might require interpolation of corner ghost cells on refinement boundaries.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{StencilRegion}.png}
\caption{Example of the region of a second order stencil for the Laplacian operator with second order gradient reconstruction on the embedded boundary.}\label{\detokenize{Source/LinearSolvers:id3}}\label{\detokenize{Source/LinearSolvers:fig-stencilregion}}\end{figure}


\paragraph{Robin}
\label{\detokenize{Source/LinearSolvers:robin}}
Robin boundary conditions are in the form
\begin{equation*}
\begin{split}A\partial_n\Phi + B\Phi = C,\end{split}
\end{equation*}
where \(A\), \(B\), and \(C\) are constants.
This boundary conditions is enforced through the flux
\begin{equation*}
\begin{split}\partial_n\Phi = \frac{1}{A}\left(C - B\Phi\right),\end{split}
\end{equation*}
which requires an evaluation of \(\Phi\) on the domain boundaries and the EB.

For domain boundaries we extrapolate the cell\sphinxhyphen{}centered solution to the domain edge, using standard first order finite differencing.

On the embedded boundary, we approximate \(\Phi\left(\mathbf{x}_{\text{EB}}\right)\) by linearly interpolating the solution with a least squares fit, using cells which can be reached with a monotone path of radius one around the EB face (see {\hyperref[\detokenize{Utilities/LeastSquares:chap-leastsquares}]{\sphinxcrossref{\DUrole{std,std-ref}{Least squares}}}} for details).
The Robin boundary condition takes the form
\begin{equation*}
\begin{split}\partial_n\Phi = \frac{C}{A} - \frac{B}{A}\sum_{\mathbf{i}} w_{\mathbf{i}}\Phi_{\mathbf{i}}.\end{split}
\end{equation*}
Currently, we include the data in the cut\sphinxhyphen{}cell itself in the interpolation, and thus also use unweighted least squares.


\subsubsection{Ghost cell interpolation}
\label{\detokenize{Source/LinearSolvers:ghost-cell-interpolation}}\label{\detokenize{Source/LinearSolvers:chap-multigridinterpolation}}
With AMR, multigrid requires ghost cells on the refinement boundary.
The interior stencils for the Helmholtz operator are first order and thus only require a single level of ghost cells (and no corner ghost cells).
These ghost cells are filled using a finite\sphinxhyphen{}difference stencil, see \hyperref[\detokenize{Source/LinearSolvers:fig-multigridinterpolation}]{Fig.\@ \ref{\detokenize{Source/LinearSolvers:fig-multigridinterpolation}}}.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{MultigridInterpolation}.png}
\caption{Standard finite\sphinxhyphen{}difference stencil for ghost cell interpolation (open circle).
We first interpolate the coarse\sphinxhyphen{}grid cells to the centerline (diamond).
The coarse\sphinxhyphen{}grid interpolation is then used together with the fine\sphinxhyphen{}grid cells (filled circles) for interpolation to the ghost cell (open circle).}\label{\detokenize{Source/LinearSolvers:id4}}\label{\detokenize{Source/LinearSolvers:fig-multigridinterpolation}}\end{figure}

Embedded boundaries introduce many pathologies for multigrid:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Cut\sphinxhyphen{}cell stencils may have a large radius (see \hyperref[\detokenize{Source/LinearSolvers:fig-stencilregion}]{Fig.\@ \ref{\detokenize{Source/LinearSolvers:fig-stencilregion}}}) and thus require more ghost cell layers.

\item {} 
The EBs cut the grid in arbitrary ways, leading to multiple pathologies regarding cell availability.

\end{enumerate}

The pathologies mean that standard finite differencing fails near the EB, mandating a more general approach.
Our way of handling ghost cell interpolation near EBs is to reconstruct the solution (to specified order) in the ghost cells, using the available cells around the ghost cell (see {\hyperref[\detokenize{Utilities/LeastSquares:chap-leastsquares}]{\sphinxcrossref{\DUrole{std,std-ref}{Least squares}}}} for details).
As per conventional wisdom regarding multigrid interpolation, this reconstruction does \sphinxstyleemphasis{not} use coarse\sphinxhyphen{}level grid cells that are covered by the fine level.

Figure \hyperref[\detokenize{Source/LinearSolvers:fig-ebmultigridinterpolation}]{Fig.\@ \ref{\detokenize{Source/LinearSolvers:fig-ebmultigridinterpolation}}} shows a typical interpolation stencil for the stencil in \hyperref[\detokenize{Source/LinearSolvers:fig-stencilregion}]{Fig.\@ \ref{\detokenize{Source/LinearSolvers:fig-stencilregion}}}.
Here, the open circle indicates the ghost cell to be interpolated, and we interpolate the solution in this cell using neighboring grid cells (closed circles).
For this particular case there are 10 nearby grid cells available, which is sufficient for second order interpolation (which requirse at least 6 cells in 2D).

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{EBMultigridInterpolation}.png}
\caption{Multigrid interpolation for refinement boundaries away from and close to an embedded boundary.}\label{\detokenize{Source/LinearSolvers:id5}}\label{\detokenize{Source/LinearSolvers:fig-ebmultigridinterpolation}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} implements a fairly general ghost cell interpolation scheme near the EB. The ghost cell values can be reconstructed to specified order (and with specified least squares weights).
\end{sphinxadmonition}


\subsubsection{Relaxation methods}
\label{\detokenize{Source/LinearSolvers:relaxation-methods}}
The Helmholtz equation is solved using multigrid, with various smoothers available on each grid level.
The currently supported smoothers are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Standard point Jacobi relaxation.

\item {} 
Red\sphinxhyphen{}black Gauss\sphinxhyphen{}Seidel relaxation in which the relaxation pattern follows that of a checkerboard.

\item {} 
Multi\sphinxhyphen{}colored Gauss\sphinxhyphen{}Seidel relaxation in which the relaxation pattern follows quadrants in 2D and octants in 3D.

\end{enumerate}

Users can select between the various smoothers in solvers that use multigrid.

\begin{sphinxadmonition}{note}{Note:}
Multi\sphinxhyphen{}colored Gauss\sphinxhyphen{}Seidel usually provide the best convergence rates.
However, the multi\sphinxhyphen{}colored kernels are twice as expensive as red\sphinxhyphen{}black Gauss\sphinxhyphen{}Seidel relaxation in 2D, and four times as expensive in 3D.
\end{sphinxadmonition}


\subsection{Multiphase Helmholtz equation}
\label{\detokenize{Source/LinearSolvers:multiphase-helmholtz-equation}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} also supports a \sphinxstyleemphasis{multiphase version} where data exists on both sides of the embedded boundary.
The most common case is that involving discontinuous coefficients, e.g. for
\begin{equation*}
\begin{split}\nabla\cdot\left[b\left(\mathbf{x}\right)\nabla\Phi\left(\mathbf{x}\right)\right] = 0.\end{split}
\end{equation*}
where \(b\left(\mathbf{x}\right)\) is only piecewise constant.


\subsubsection{Jump conditions}
\label{\detokenize{Source/LinearSolvers:jump-conditions}}
For the case of discontinous coefficients there is a jump condition on the interface between two materials:
\begin{equation*}
\begin{split}b_1\partial_{n_1}\Phi + b_2\partial_{n_2}\Phi = \sigma,\end{split}
\end{equation*}
where \(b_1\) and \(b_2\) are the Helmholtz equation coefficients on each side of the interface, and \(n_1 = -n_2\) are the normal vectors pointing away from the interface in each phase.
\(\sigma\) is a jump factor.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{JumpCondition}.png}
\caption{Example of cells and stencils that are involved in discretizing the jump condition. Open and filled circles indicate cells in separate phases.}\label{\detokenize{Source/LinearSolvers:id6}}\label{\detokenize{Source/LinearSolvers:fig-jumpcondition}}\end{figure}


\subsubsection{Discretization}
\label{\detokenize{Source/LinearSolvers:discretization}}
To incorporate the jump condition in the Helmholtz discretization, we use a gradient reconstruction to obtain a solution to \(\Phi\) on the boundary, and use this value to impose a Dirichlet boundary condition during multigrid relaxation.
Recalling the gradient reconstruction \(\frac{\partial\Phi}{\partial n} = w_{\textrm{B}}\Phi_{\textrm{B}} + \sum_{\mathbf{i}} w_{\mathbf{i}}\Phi_{\mathbf{i}}\), the matching condition (see \hyperref[\detokenize{Source/LinearSolvers:fig-jumpcondition}]{Fig.\@ \ref{\detokenize{Source/LinearSolvers:fig-jumpcondition}}}) can be written as
\begin{equation*}
\begin{split}b_1\left[w_{\textrm{B},1}\Phi_{\textrm{B}} + \sum_{\mathbf{i}} w_{\mathbf{i},1}\Phi_{\mathbf{i},1}\right] + b_2\left[w_{\textrm{B},2}\Phi_{\textrm{B}} + \sum_{\mathbf{i}} w_{\mathbf{i},2}\Phi_{\mathbf{i},2}\right] = \sigma.\end{split}
\end{equation*}
This equation can be solved for the boundary value \(\Phi_{\textrm{B}}\), which can then be used to compute the finite\sphinxhyphen{}volume fluxes into the cut\sphinxhyphen{}cells.

\begin{sphinxadmonition}{note}{Note:}
For discontinuous coefficients the gradient reconstruction on one side of the EB does not reach into the other (since the solution is not differentiable across the EB).
\end{sphinxadmonition}


\subsection{AMRMultiGrid}
\label{\detokenize{Source/LinearSolvers:amrmultigrid}}
\sphinxcode{\sphinxupquote{AMRMultiGrid}} is the \sphinxcode{\sphinxupquote{Chombo}} implementation of the Martin\sphinxhyphen{}Cartwright multigrid algorithm.
It takes an “operator factory” as an argument, and the factory can generate objects (i.e., operators) that encapsulate the discretization on each AMR level.

\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} runs its own operator, and the user can use either of:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{EBHelmholtzOpFactory}} for single\sphinxhyphen{}phase problems.

\item {} 
\sphinxcode{\sphinxupquote{MFHelmholtzOpFactory}} for multi\sphinxhyphen{}phase problems.

\end{enumerate}

The source code for these are located in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Source/Elliptic}}.


\subsubsection{Bottom solvers}
\label{\detokenize{Source/LinearSolvers:bottom-solvers}}
Chombo provides (at least) three bottom solvers which can be used with \sphinxcode{\sphinxupquote{AMRMultiGrid}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A regular smoother (e.g., point Jacobi).

\item {} 
A biconjugate gradient stabilized method (BiCGStab)

\item {} 
A generalized minimal residual method (GMRES).

\end{enumerate}

The user can select between these for the various solvers that use multigrid.


\chapter{Design}
\label{\detokenize{index:design}}

\section{Driver}
\label{\detokenize{Source/Driver:driver}}\label{\detokenize{Source/Driver:chap-driver}}\label{\detokenize{Source/Driver::doc}}
The \sphinxcode{\sphinxupquote{Driver}} class is the class that runs \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} simulations and is defined in \sphinxcode{\sphinxupquote{/Source/Driver/CD\_Driver.cpp(H)}}.
The constructor for this class is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Driver}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{ComputationalGeometry}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}compgeom}\PYG{p}{,}
       \PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{TimeStepper}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}           \PYG{n}{a\PYGZus{}timestepper}\PYG{p}{,}
       \PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{AmrMesh}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}               \PYG{n}{a\PYGZus{}amr}\PYG{p}{,}
       \PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{CellTagger}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}            \PYG{n}{a\PYGZus{}celltagger} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{CellTagger}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{,}
       \PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{GeoCoarsener}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}          \PYG{n}{a\PYGZus{}geocoarsen} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{GeoCoarsener}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Observe that the \sphinxcode{\sphinxupquote{Driver}} class does not \sphinxstyleemphasis{require} an instance of {\hyperref[\detokenize{Source/CellTagger:chap-celltagger}]{\sphinxcrossref{\DUrole{std,std-ref}{CellTagger}}}}.
If users decide to omit a cell tagger, regridding functionality is completely turned off and only the initially generated grids will be used throughout the simulation.

The usage of the \sphinxcode{\sphinxupquote{Driver}} class is primarily object construction with dependency injection of the geometry, the physics (i.e. \sphinxcode{\sphinxupquote{TimeStepper}}), the \sphinxcode{\sphinxupquote{AmrMesh}} instance, and possibly a cell tagger.
The \sphinxcode{\sphinxupquote{Driver}} class will retrieve configurations from the input script during construction.


\subsection{Simulation setup}
\label{\detokenize{Source/Driver:simulation-setup}}
Usually, only a single routine is used:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{setupAndRun}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}input\PYGZus{}file}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This routine will set up and run a simulation.
Simulation setup depends on the way a simulation is run.


\subsubsection{New simulations}
\label{\detokenize{Source/Driver:new-simulations}}
If a simulation starts from the first time step, the \sphinxcode{\sphinxupquote{Driver}} class will perform the following major steps within \sphinxcode{\sphinxupquote{setupAndRun()}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ask \sphinxcode{\sphinxupquote{ComputationalGeometry}} to generate the cut\sphinxhyphen{}cell moments.

\item {} 
Collect all the cut\sphinxhyphen{}cells and ask \sphinxcode{\sphinxupquote{AmrMesh}} to set up an initial grid.
This initial grid is always generated by flagging cells for refinement along the boundary.
Various options are available for configuring this initial grid, see {\hyperref[\detokenize{Source/SpatialDiscretization:chap-refinementphilosophy}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell refinement philosophy}}}}.
Also note that it is possible to restrict the maximum level that can be generated from the geometric tags, or remove some of the cut\sphinxhyphen{}cell refinement flags through the auxiliary class \sphinxcode{\sphinxupquote{GeoCoarsener}}.

\item {} 
Ask the \sphinxcode{\sphinxupquote{TimeStepper}} to set up relevant solvers and fill them with initial data.

\item {} 
Perform the number of initial regrids that the user asks for.

\end{enumerate}

Step 3 and 4 will differ significantly depending on the physics that is solved for.

The full code is given in \sphinxcode{\sphinxupquote{Driver::setupFresh()}}.


\subsubsection{Restarting simulations}
\label{\detokenize{Source/Driver:restarting-simulations}}
If a simulation \sphinxstyleemphasis{does not start} from the first time step, the \sphinxcode{\sphinxupquote{Driver}} class will perform the following major steps within \sphinxcode{\sphinxupquote{setupAndRun(...)}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ask \sphinxcode{\sphinxupquote{ComputationalGeometry}} to generate the cut\sphinxhyphen{}cell moments.

\item {} 
Read a checkpoint file that contains the grids and all the data that have been checkpointed by the solvers.
\sphinxcode{\sphinxupquote{Driver}} will issue an error and abort if the checkpoint file does not exist.

\item {} 
Ask the \sphinxcode{\sphinxupquote{TimeStepper}} to perform a “post\sphinxhyphen{}checkpoint” step to initialize any remaining data so that a time step can be taken.
This functionality has been included because not all data in every solver needs to be checkpointed.
For example, an electric field solver only needs to write the electric potential to the checkpoint file because the electric field is simply obtained by taking the gradient.

\item {} 
Perform the number of initial regrids that the user asks for.

\end{enumerate}

Again, step 3 will differ significantly depending on the physics that is solved for.

The full code is given in \sphinxcode{\sphinxupquote{Driver::setupForRestart()}}.


\subsection{Simulation advancement}
\label{\detokenize{Source/Driver:simulation-advancement}}
The algorithm for running a simulation is conceptually simple; the \sphinxcode{\sphinxupquote{Driver}} class simply calls \sphinxcode{\sphinxupquote{TimeStepper}} for computing a reasonable time step for advancing the equations, and then it asks \sphinxcode{\sphinxupquote{TimeStepper}} to actually perform the advance.
Regrids, plot files, and checkpoint files are written at certain step intervals (or when the \sphinxcode{\sphinxupquote{TimeStepper}} demands them).
In essence, the algorithm looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Driver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{run}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}

   \PYG{k}{while}\PYG{p}{(}\PYG{n}{KeepRunningTheSimulation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{RegridEverything}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{Driver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}
      \PYG{p}{\PYGZcb{}}

      \PYG{n}{TimeStepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeTimeStep}\PYG{p}{(}\PYG{p}{)}
      \PYG{n}{TimeStepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{advanceAllEquationsOneStep}\PYG{p}{(}\PYG{p}{)}

      \PYG{k}{if}\PYG{p}{(}\PYG{n}{WriteAPlotFile} \PYG{o}{|}\PYG{o}{|} \PYG{n}{EndOfSimulation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{Driver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{writePlotFile}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{TimeToWriteACheckpointFile} \PYG{o}{|}\PYG{o}{|} \PYG{n}{EndOfSimulation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{Driver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{writeCheckpointFile}\PYG{p}{(}\PYG{p}{)}
      \PYG{p}{\PYGZcb{}}

      \PYG{n}{KeepRunningTheSimulation} \PYG{o}{=} \PYG{n+nb}{true} \PYG{n}{or} \PYG{n+nb}{false}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Regridding}
\label{\detokenize{Source/Driver:regridding}}
Regrids are called by the \sphinxcode{\sphinxupquote{Driver}} class and occur as follows in \sphinxcode{\sphinxupquote{Driver::regrid(...)}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ask \sphinxcode{\sphinxupquote{CellTagger}} to generate tags for grid refinement and coarsening.

\item {} 
The \sphinxcode{\sphinxupquote{TimeStepper}} class stores data that is subject to regrids.
How this happens depends on the solver that is run.
For grid\sphinxhyphen{}based solvers, e.g. CDR solvers, the scalar \(\phi\) is copied into a scratch space.
The reason for this backup is that during the regrid \(\phi\) will be allocated on the \sphinxstyleemphasis{new} AMR grids, but we must still have access to the previously defined data in order to interpolate to the new grids.

\item {} 
If necessary, \sphinxcode{\sphinxupquote{TimeStepper}} can deallocate unecessary storage.
Implementing a deallocation function for \sphinxcode{\sphinxupquote{TimeStepper}}\sphinxhyphen{}derived classes is not a requirement, but can in certain cases be useful, for example when using the Berger\sphinxhyphen{}Rigoutsous algorithm at large scale.

\item {} 
The \sphinxcode{\sphinxupquote{AmrMesh}} class generates the new grids and defines new AMR operators.

\item {} 
The \sphinxcode{\sphinxupquote{TimeStepper}} class regrids its solvers and internal data.

\item {} 
The \sphinxcode{\sphinxupquote{TimerStepper}} performs a \sphinxstyleemphasis{post\sphinxhyphen{}regrid} operation (e.g. filling solvers with auxiliary data).

\end{enumerate}

In C++ pseudo\sphinxhyphen{}code, this looks something like:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Driver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}

   \PYG{c+c1}{// Tag cells}
   \PYG{n}{CellTagger}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{tagCellsForRefinement}\PYG{p}{(}\PYG{p}{)}

   \PYG{c+c1}{// Store old data and free up some memory}
   \PYG{n}{TimeStepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{storeOldGridData}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{TimeStepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{deallocateUnneccesaryData}\PYG{p}{(}\PYG{p}{)}

   \PYG{c+c1}{// Generate the new grids}
   \PYG{n}{AmrMesh}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}

   \PYG{c+c1}{// Regrid physics and all solvers}
   \PYG{n}{TimeStepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}

   \PYG{c+c1}{// Do a post\PYGZhy{}regrid step}
   \PYG{n}{TimeStepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{postRegrid}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The full code is defined in \sphinxcode{\sphinxupquote{Driver::regrid()}} in file \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Source/Driver/CD\_Driver.cpp}}.


\subsection{Class options}
\label{\detokenize{Source/Driver:class-options}}
Various class options are available for adjusting the behavior of the \sphinxcode{\sphinxupquote{Driver}} class
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Driver.verbosity}} controls output will be given to \sphinxcode{\sphinxupquote{pout.n}}. We use 2 or 3 \sphinxhyphen{} higher values are for debugging.

\item {} 
\sphinxcode{\sphinxupquote{Driver.geometry\_generation}} controls the grid generation method (see {\hyperref[\detokenize{Source/SpatialDiscretization:chap-geometrygeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Geometry generation}}}}).
Valid options are \sphinxstyleemphasis{chombo\sphinxhyphen{}discharge} or \sphinxstyleemphasis{chombo}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.geometry\_scan\_level}}.
Which refinement level to initiate the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} geometry generation method.
This entry indicates the number of refinements of the coarsest AMR level used in the simulation.
E.g. if the \sphinxcode{\sphinxupquote{Driver.geometry\_scan\_level=1}} and the coarsest AMR level is \(128^3\) then the signed distance pruning (see {\hyperref[\detokenize{Source/SpatialDiscretization:chap-geometrygeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Geometry generation}}}}) begins at the AMR level \(256^3\).
Note that negative numbers are also permitted, in which case the pruning initiates at a coarsened level.

\item {} 
\sphinxcode{\sphinxupquote{Driver.ebis\_memory\_load\_balance}}. If using Chombo geo\sphinxhyphen{}gen, use memory as loads for EBIS generation. Valid options are \sphinxstyleemphasis{true} or \sphinxstyleemphasis{false}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.plot\_interval}}. Time steps between each plot file.

\item {} 
\sphinxcode{\sphinxupquote{Driver.checkpoint\_interval}}. Time steps between each checkpoint file.

\item {} 
\sphinxcode{\sphinxupquote{Driver.regrid\_interval}}. Time steps between each regrid.

\item {} 
\sphinxcode{\sphinxupquote{Driver.write\_regrid\_files}}. Write plot files during regrids. Valid options are \sphinxstyleemphasis{true} or \sphinxstyleemphasis{false}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.write\_restart\_files}}.Write plot files during restarts. Valid options are \sphinxstyleemphasis{true} or \sphinxstyleemphasis{false}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.initial\_regrids}}. Number of initial regrids to perform when starting (or restarting) a simulation.

\item {} 
\sphinxcode{\sphinxupquote{Driver.start\_time}}. Simulation start time.

\item {} 
\sphinxcode{\sphinxupquote{Driver.stop\_time}}.Simulation stop time.

\item {} 
\sphinxcode{\sphinxupquote{Driver.max\_steps}}. Maximum number of simulation time steps.

\item {} 
\sphinxcode{\sphinxupquote{Driver.geometry\_only}}. If \sphinxstyleemphasis{true}, do not run the simulation and only write the geometry to file.

\item {} 
\sphinxcode{\sphinxupquote{Driver.write\_memory}}. Write MPI memory report. Valid options are \sphinxstyleemphasis{true} or \sphinxstyleemphasis{false}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.write\_loads}}.  Write computational loads. Valid options are \sphinxstyleemphasis{true} or \sphinxstyleemphasis{false}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.output\_directory}}. Output directory.

\item {} 
\sphinxcode{\sphinxupquote{Driver.output\_names}}. Simulation file names.

\item {} 
\sphinxcode{\sphinxupquote{Driver.max\_plot\_depth}}. Maximum plot depth.
Values \(< 0\) means all levels.

\item {} 
\sphinxcode{\sphinxupquote{Driver.max\_chk\_depth}}.  Maximum checkpoint file depth.
Values \(< 0\) means all levels.

\item {} 
\sphinxcode{\sphinxupquote{Driver.num\_plot\_ghost}}. Number of ghost cells in plot files.

\item {} 
\sphinxcode{\sphinxupquote{Driver.plt\_vars}}. Plot variables for \sphinxcode{\sphinxupquote{Driver}}. Valid options are \sphinxstyleemphasis{tags}, \sphinxstyleemphasis{mpi\_rank}, \sphinxstyleemphasis{levelset}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.restart}}. Restart step (less or equal to 0 implies fresh simulation)

\item {} 
\sphinxcode{\sphinxupquote{Driver.allow\_coarsening}}. Allows removal of grid levels if cell tags dont run deep enough.

\item {} 
\sphinxcode{\sphinxupquote{Driver.grow\_geo\_tags}}. How much to grow boundary cell tags.

\item {} 
\sphinxcode{\sphinxupquote{Driver.refine\_angles}}. Refine cells if the angle between normal vector in neighboring cells exceed this threshold.

\item {} 
\sphinxcode{\sphinxupquote{Driver.refine\_electrodes}}. Refine electrode surfaces. Values \(< 0\) will refine all the way down.

\item {} 
\sphinxcode{\sphinxupquote{Driver.refine\_dielectrics}}. Refine dielectric surfaces. Values \(< 0\) will refine all the way down.

\end{itemize}


\subsection{Runtime options}
\label{\detokenize{Source/Driver:runtime-options}}
The following options can be adjusted during runtime:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Driver.verbosity}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.plot\_interval}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.checkpoint\_interval}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.regrid\_interval}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.write\_regrid\_files}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.write\_restart\_files}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.stop\_time}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.max\_steps}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.write\_memory}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.write\_loads}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.num\_plot\_ghost}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.plt\_vars}}.

\item {} 
\sphinxcode{\sphinxupquote{Driver.allow\_coarsening}}.

\end{itemize}


\section{ComputationalGeometry}
\label{\detokenize{Source/ComputationalGeometry:computationalgeometry}}\label{\detokenize{Source/ComputationalGeometry:chap-computationalgeometry}}\label{\detokenize{Source/ComputationalGeometry::doc}}
\sphinxcode{\sphinxupquote{ComputationalGeometry}} is the class that implements geometries in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
The source for for this class is located in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Source/Geometry/}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{ComputationalGeometry}} is \sphinxstyleemphasis{not} an abstract class.
The default implementation is an empty geometry \textendash{} i.e. a geometry without any objects.
\end{sphinxadmonition}

Making a non\sphinxhyphen{}empty \sphinxcode{\sphinxupquote{ComputationalGeometry}} class requires that you inherit from \sphinxcode{\sphinxupquote{ComputationalGeometry}} and set the following class members:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n}{m\PYGZus{}eps0}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Electrode}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}electrodes}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Dielectric}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}dielectrics}\PYG{p}{;}
\end{sphinxVerbatim}

Here, \sphinxcode{\sphinxupquote{m\_eps0}} is the relative gas permittivity, \sphinxcode{\sphinxupquote{m\_electrodes}} are the electrodes for the geometry and \sphinxcode{\sphinxupquote{m\_dielectrics}} are the dielectrics for the geometry.
These are described in detail further down.

When geometries are created, the \sphinxcode{\sphinxupquote{ComputationalGeometry}} class will first create the (approximations to the) signed distance functions that describe two possible material phases (gas and solid).
Here, the \sphinxstyleemphasis{solid} phase is the part of the computational domain inside the dielectrics, while the \sphinxstyleemphasis{gas phase} is the part of the computational domain that is outside the electrodes and dielectrics.


\subsection{Electrode}
\label{\detokenize{Source/ComputationalGeometry:electrode}}\label{\detokenize{Source/ComputationalGeometry:chap-electrode}}
The \sphinxcode{\sphinxupquote{Electrode}} class is responsible for describing an electrode and its boundary conditions. Internally, this class is lightweight and consists only of a tuple that holds a level\sphinxhyphen{}set function and an associated boolean value that tells whether or not the level\sphinxhyphen{}set function has a live potential or not. The constructor for the electrode class is:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Electrode}\PYG{p}{(}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}baseif}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}live}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{a\PYGZus{}fraction} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the first argument is the level\sphinxhyphen{}set function and the second argument is responsible for setting the potential. The third argument is an optional argument that allows the user to set the potential to a specified fraction of the applied potential.


\subsection{Dielectric}
\label{\detokenize{Source/ComputationalGeometry:dielectric}}\label{\detokenize{Source/ComputationalGeometry:chap-dielectric}}
The \sphinxcode{\sphinxupquote{Dielectric}} class describes a dielectric.
This class is lightweight and consists only of a tuple that holds a level\sphinxhyphen{}set function and the associated permittivity.
The constructors are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Dielectric}\PYG{p}{(}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}baseif}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{a\PYGZus{}permittivity}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dielectric}\PYG{p}{(}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}baseif}\PYG{p}{,} \PYG{n}{Real} \PYG{p}{(}\PYG{o}{*}\PYG{n}{a\PYGZus{}permittivity}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the first argument is the level\sphinxhyphen{}set function and the second argument sets a constant permittivity (first constructor) or a variable permittivity (second constructor).


\subsection{Retrieving distance functions}
\label{\detokenize{Source/ComputationalGeometry:retrieving-distance-functions}}
It is possible to retrieve the SDFs for each phase, as well as the the electrodes and dielectrics.
This functionality is provided by:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Dielectric}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{getDielectrics}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Electrode}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{getElectrodes}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{getGasImplicitFunction}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{getSolidImplicitFunction}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}


\section{TimeStepper}
\label{\detokenize{Source/TimeStepper:timestepper}}\label{\detokenize{Source/TimeStepper:chap-timestepper}}\label{\detokenize{Source/TimeStepper::doc}}
The \sphinxcode{\sphinxupquote{TimeStepper}} class is the physics class in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} \sphinxhyphen{} it has direct responsibility of setting up the solvers and performing time steps.

Since it is necessary to implement different solvers for different types of physics, \sphinxcode{\sphinxupquote{TimeStepper}} is an abstract class with the following pure functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Setup routines}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{setupSolvers}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{allocate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{initialData}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{postInitialize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{postCheckpointSetup}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{registerRealms}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{registerOperators}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{parseRuntimeOptions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// IO routines}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{writeCheckpointData}\PYG{p}{(}\PYG{n}{HDF5Handle}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}handle}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{readCheckpointData}\PYG{p}{(}\PYG{n}{HDF5Handle}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}handle}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{writePlotData}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}output}\PYG{p}{,} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}plotVariableNames}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}icomp}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{int}  \PYG{n+nf}{getNumberOfPlotVariables}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{getCheckpointLoads}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}level}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// Advance routines}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{computeDt}\PYG{p}{(}\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dt}\PYG{p}{,} \PYG{n}{TimeCode}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}timeCode}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{n}{Real} \PYG{n+nf}{advance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{synchronizeSolverTimes}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}step}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{printStepReport}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Regrid routines}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{preRegrid}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lmin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}oldFinestLevel}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{postRegrid}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{regrid}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lmin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}oldFinestLevel}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}newFinestLevel}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n+nf}{needToRegrid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n+nf}{loadBalanceThisRealm}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}realm}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{loadBalanceBoxes}\PYG{p}{(}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}            \PYG{n}{a\PYGZus{}procs}\PYG{p}{,}
                              \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Box}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}            \PYG{n}{a\PYGZus{}boxes}\PYG{p}{,}
                              \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}                \PYG{n}{a\PYGZus{}realm}\PYG{p}{,}
                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}grids}\PYG{p}{,}
                              \PYG{k}{const} \PYG{k+kt}{int}                        \PYG{n}{a\PYGZus{}lmin}\PYG{p}{,}
                              \PYG{k}{const} \PYG{k+kt}{int}                        \PYG{n}{a\PYGZus{}finestLevel}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

These functions are all used in the \sphinxcode{\sphinxupquote{Driver}} class at various stages.
The three functions in the category \sphinxstyleemphasis{setup routines} are, for example using during simulation setup or after reading a checkpoint file for simulation restarts.
The IO routines are there so that users can choose which solvers perform any output, and the advance routines are there such that the user can implement new algorithms for time integration.
Finally, the \sphinxstyleemphasis{regrid routines} are there so that the solvers can back up their data before the old grids are destroyed (\sphinxcode{\sphinxupquote{preRegrid()}}) and the data is interpolated data onto the new AMR grids \sphinxcode{\sphinxupquote{regrid(...)}}.

To see how these functions can be implemented, see {\hyperref[\detokenize{Tutorials/Tutorial:chap-tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{Introduction}}}}.


\section{AmrMesh}
\label{\detokenize{Source/AmrMesh:amrmesh}}\label{\detokenize{Source/AmrMesh:chap-amrmesh}}\label{\detokenize{Source/AmrMesh::doc}}
{\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}} handles (almost) all spatial operations in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
Internally, {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}} contains a bunch of operators that are useful across classes, such as ghost cell interpolation operators, coarsening operators, and stencils for interpolation and extrapolation near the embedded boundaries. {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}} also contains routines for generation and load\sphinxhyphen{}balancing of grids based and also contains simple routines for allocation and deallocation of memory.

\begin{sphinxadmonition}{note}{Note:}
{\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}} only handles spatial \sphinxstyleemphasis{operations}, it otherwise has limited knowledge of numerical discretizations.
\end{sphinxadmonition}

{\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}} is an integral part of \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, and users will never have the need to modify it unless they are implementing something entirely new. The behavior of {\hyperref[\detokenize{Source/AmrMesh:chap-amrmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrMesh}}}} is modified through it’s available input parameters, listed below:


\subsection{Main functionality}
\label{\detokenize{Source/AmrMesh:main-functionality}}
There are two main functionalities in \sphinxcode{\sphinxupquote{AmrMesh}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Building grid hierarchies, and providing geometric information

\item {} 
Providing AMR operators.

\end{enumerate}

The grids in \sphinxcode{\sphinxupquote{AmrMesh}} consist of a \sphinxcode{\sphinxupquote{DisjointBoxLayout}} (see {\hyperref[\detokenize{Source/ChomboBasics:chap-basics}]{\sphinxcrossref{\DUrole{std,std-ref}{Chombo\sphinxhyphen{}3 basics}}}}) on each level, supported also by the EB information (\sphinxcode{\sphinxupquote{EBISLayout}}).
Recall that each grid patch in a \sphinxcode{\sphinxupquote{DisjointBoxLayout}} is owned by a unique rank.
However, since \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} supports multiple decompositions, we support the use of multiple \sphinxcode{\sphinxupquote{DisjointBoxLayout}} describing the same grid level.
Although these \sphinxcode{\sphinxupquote{DisjointBoxLayout}} consist of the same boxes, the patch\sphinxhyphen{}to\sphinxhyphen{}rank mapping can be different (see {\hyperref[\detokenize{Source/Realm:chap-realm}]{\sphinxcrossref{\DUrole{std,std-ref}{Realm}}}}).
To fetch a grid on a particular level, one can call \sphinxcode{\sphinxupquote{AmrMesh::getGrids(const std::string a\_realm)}}.
E.g.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{myRealm}\PYG{p}{;}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{myLevel}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZam{}} \PYG{n}{dbl} \PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGrids}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myRealm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{[}\PYG{n}{myLevel}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Likewise, to fetch the geometric (EB) information for a specified realm, phase, and level:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{myRealm}\PYG{p}{;}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{myLevel}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase} \PYG{n}{myPhase}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{EBISLayout}\PYG{o}{\PYGZam{}} \PYG{n}{ebisl} \PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getEBISLayout}\PYG{p}{(}\PYG{n}{myRealm}\PYG{p}{,} \PYG{n}{myPhase}\PYG{p}{)}\PYG{p}{[}\PYG{n}{myLevel}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

In addition to the grids, the user can fetch AMR operators.
These are, for example, coarsening operators, interpolation operators, ghost cell interpolators etc.
To save some regrid time, we don’t always build every AMR operator that we might ever need, but have solvers \sphinxstyleemphasis{register} the ones that they specifically need.
See {\hyperref[\detokenize{Source/Realm:chap-realm}]{\sphinxcrossref{\DUrole{std,std-ref}{Realm}}}} for details.


\subsection{Class options}
\label{\detokenize{Source/AmrMesh:class-options}}
The class options below control \sphinxcode{\sphinxupquote{AmrMesh}}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.lo\_corner}}. Low corner of problem domain (e.g. 0 0 0)

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.hi\_corner}}. High corner of problem domain (e.g. 1 1 1).

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.verbosity}}. Class verbosity. Leave to \sphinxhyphen{}1 unless you are debugging.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.coarsest\_domain}}. Number of grid cells on coarsest domain

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.max\_amr\_depth}}. Maximum number of refinement levels.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.max\_sim\_depth}}. Maximum simulation depth.
Values \(< 0\) means that grids can be generated with depths up to \sphinxcode{\sphinxupquote{AmrMesh.max\_amr\_depth}}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.fill\_ratio}}. Fill ratio for BR grid generation

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.irreg\_growth}}. Buffer region around irregular tagged cells.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.buffer\_size}}. Buffer size for BR grid generation.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.grid\_algorithm}}. Grid generation algorithm. Valid options are \sphinxstyleemphasis{br} or \sphinxstyleemphasis{tiled}. See {\hyperref[\detokenize{Source/SpatialDiscretization:chap-meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh generation}}}} for details.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.box\_sorting}}. Box sorting algorithm. Valid options are \sphinxstyleemphasis{std}, \sphinxstyleemphasis{morton}, or \sphinxstyleemphasis{shuffle}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.blocking\_factor}}. Blocking factor.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.max\_box\_size}}. Maximum box size.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.max\_ebis\_box}}. Maximum box size during EB geometry generation.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.ref\_rat}}. Refinement ratios.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.num\_ghost}}. Number of ghost cells for mesh data.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.lsf\_ghost}}. Number of ghost cells when allocating level\sphinxhyphen{}set function on the grid.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.eb\_ghost}}. Number of ghost cells for EB moments.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.centroid\_sten}}. Which centroid interpolation stencils to use. Valid options are \sphinxstyleemphasis{pwl}, \sphinxstyleemphasis{linear}, \sphinxstyleemphasis{taylor}, \sphinxstyleemphasis{lsq}. Only \sphinxstyleemphasis{linear} is guaranteed monotone.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.eb\_sten}}. EB interpolation stencils.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.redist\_radius}}. Redistribution radius.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.ghost\_interp}}. Default ghost cell interpolation type. Valid options are \sphinxstyleemphasis{pwl} or \sphinxstyleemphasis{quad}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.ebcf}}. Can be set to false if refinement boundaries do not cross the EB. Valid options are \sphinxstyleemphasis{true} and \sphinxstyleemphasis{false}.

\end{itemize}


\subsection{Runtime options}
\label{\detokenize{Source/AmrMesh:runtime-options}}
The following options are runtime options for \sphinxcode{\sphinxupquote{AmrMesh}}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.verbosity}}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.fill\_ratio}}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.irreg\_growth}}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.buffer\_size}}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.grid\_algorithm}}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.box\_sorting}}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.blocking\_factor}}.

\item {} 
\sphinxcode{\sphinxupquote{AmrMesh.max\_box\_size}}.

\end{itemize}

These options only affect the grid generation method and parameters, and are thus only effective after the next regrid.

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} only supports uniform resolution (i.e., cubic grid cells).
I.e. the user must specify consist domain sizes and resolutions.
\end{sphinxadmonition}


\section{CellTagger}
\label{\detokenize{Source/CellTagger:celltagger}}\label{\detokenize{Source/CellTagger:chap-celltagger}}\label{\detokenize{Source/CellTagger::doc}}
The \sphinxcode{\sphinxupquote{CellTagger}} class is responsible for flagging grid cells for refinement or coarsening.
If the user wants to implement a new refinement routine, he will do so by writing a new derived class from \sphinxcode{\sphinxupquote{CellTagger}}.
The \sphinxcode{\sphinxupquote{CellTagger}} parent class is a stand\sphinxhyphen{}alone class \sphinxhyphen{} it does not have a view of \sphinxcode{\sphinxupquote{AmrMesh}}, \sphinxcode{\sphinxupquote{Driver}}, or \sphinxcode{\sphinxupquote{TimeStepper}}.
Since refinement is intended to be quite general, the user is responsible for providing \sphinxcode{\sphinxupquote{CellTagger}} with the appropriate depedencies.
For example, for streamer simulations we often use the electric field when tagging grid cells, in which case the user should supply either a reference to the electric field, the Poisson solver, or the time stepper.


\subsection{Design}
\label{\detokenize{Source/CellTagger:design}}
In \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, refinement flags live in a data holder called \sphinxcode{\sphinxupquote{EBAMRTags}} inside of \sphinxcode{\sphinxupquote{Driver}}.
This data is typedef’ed as

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{typedef} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{LayoutData}\PYG{o}{\PYGZlt{}}\PYG{n}{DenseIntVectSet}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{EBAMRTags}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{LayoutData\textless{}T\textgreater{}}} structure can be thought of as a \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} without possibilities for communication.
\sphinxcode{\sphinxupquote{CellTagger}} is an abstract class that the user \sphinxstyleemphasis{must} overwrite.

When the regrid routine enters, the \sphinxcode{\sphinxupquote{CellTagger}} will be asked to generate the refinement flags through a function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{bool} \PYG{n+nf}{tagCells}\PYG{p}{(}\PYG{n}{EBAMRTags}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}tags}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

Typically, code for refinement looks something like:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{bool} \PYG{n}{myCelltagger}\PYG{o}{:}\PYG{o}{:}\PYG{n}{tagCells}\PYG{p}{(}\PYG{n}{EBAMRTags}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}tags}\PYG{p}{)}\PYG{p}{\PYGZob{}}

   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{l} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{finestLevel}\PYG{p}{;} \PYG{n}{lvl}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZam{}} \PYG{n}{dbl} \PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}grids}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}

      \PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit}\PYG{p}{(}\PYG{n}{dbl}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
          \PYG{n}{DenseIntVectSet}\PYG{o}{\PYGZam{}} \PYG{n}{boxTags} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{a\PYGZus{}tags}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
          \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box}           \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

          \PYG{k}{for} \PYG{p}{(}\PYG{n}{BoxIterator} \PYG{n}{bit}\PYG{p}{(}\PYG{n}{box}\PYG{p}{)}\PYG{p}{;} \PYG{n}{bit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{bit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
             \PYG{k}{const} \PYG{n}{IntVect} \PYG{n}{iv} \PYG{o}{=} \PYG{n}{bit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

             \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{refineThisCell} \PYG{o}{=} \PYG{n}{myRefinementFunction}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}

             \PYG{k}{if}\PYG{p}{(}\PYG{n}{refineThisCell}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{boxTags}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{)} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
             \PYG{p}{\PYGZcb{}}
             \PYG{k}{else}\PYG{p}{\PYGZob{}}
                \PYG{n}{boxTags}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{)} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
             \PYG{p}{\PYGZcb{}}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}

   \PYG{k}{return} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{User interface}
\label{\detokenize{Source/CellTagger:user-interface}}
To implement a new \sphinxcode{\sphinxupquote{CellTagger}}, the following functions must be implemented:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{regrid}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{parseOptions}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{parseRuntimeOptions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{bool} \PYG{n+nf}{tagCells}\PYG{p}{(}\PYG{n}{EBAMRTags}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}tags}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

Users can also parse run\sphinxhyphen{}time options and have \sphinxcode{\sphinxupquote{CellTagger}} write to file, by implementing

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{k+kt}{int} \PYG{n+nf}{getNumberOfPlotVariables}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{writePlotData}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}output}\PYG{p}{,} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}plotvar\PYGZus{}names}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}icomp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This is primarily useful for debugging the tracer fields that are used for flagging cells for refinement.


\subsection{Restrict tagging}
\label{\detokenize{Source/CellTagger:restrict-tagging}}
It is possible to prevent cell tags in certain regions.
The default is simply to add a number of boxes where refinement and coarsening is allowed by specifying a number of boxes in the options file for the cell tagger:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
MyCellTagger.num\PYGZus{}boxes   \PYG{o}{=} \PYG{l+m}{0}            \PYG{c+c1}{\PYGZsh{} Number of allowed tag boxes (0 = tags allowe everywhere)}
MyCellTagger.box1\PYGZus{}lo     \PYG{o}{=} \PYG{l+m}{0}.0 \PYG{l+m}{0}.0 \PYG{l+m}{0}.0  \PYG{c+c1}{\PYGZsh{} Only allow tags that fall between}
MyCellTagger.box1\PYGZus{}hi     \PYG{o}{=} \PYG{l+m}{0}.0 \PYG{l+m}{0}.0 \PYG{l+m}{0}.0  \PYG{c+c1}{\PYGZsh{} these two corners}
\end{sphinxVerbatim}

Here, \sphinxstyleemphasis{MyCellTagger} is a placeholder for the name of the class that is used.
By adding restrictive boxes, tagging will only be allowed inside the specified box corners \sphinxcode{\sphinxupquote{box1\_lo}} and \sphinxcode{\sphinxupquote{box1\_hi}}.
More boxes can be specified by following the same convention, e.g. \sphinxcode{\sphinxupquote{box2\_lo}} and \sphinxcode{\sphinxupquote{box2\_hi}} etc.


\subsection{Adding a buffer}
\label{\detokenize{Source/CellTagger:adding-a-buffer}}
By default, each MPI rank can only tag grid cells where he owns data.
This has been done for performance and communication reasons.
Under the hood, the \sphinxcode{\sphinxupquote{DenseIntVectSet}} is an array of boolean values on a patch which is very fast and simple to communicate with MPI.
Adding a grid cell for refinement which lies outside the patch will lead to memory corruptions.
It is nonetheless still possible to do this by growing the final generated tags like so:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
MyCellTagger.buffer \PYG{o}{=} \PYG{l+m}{4} \PYG{c+c1}{\PYGZsh{} Add a buffer region around the tagged cells}
\end{sphinxVerbatim}

Just before passing the flags into \sphinxcode{\sphinxupquote{AmrMesh}} grid generation routines, the tagged cells are put in a different data holder (\sphinxcode{\sphinxupquote{IntVectSet}}) and this data holder \sphinxstyleemphasis{can} contain cells that are outside the patch boundaries.


\section{GeoCoarsener}
\label{\detokenize{Source/GeoCoarsener:geocoarsener}}\label{\detokenize{Source/GeoCoarsener:chap-geocoarsener}}\label{\detokenize{Source/GeoCoarsener::doc}}
The \sphinxcode{\sphinxupquote{GeoCoarsener}} class can remove refinement flags along a geometric surface.
To remove these so\sphinxhyphen{}called “geometric tags”, the user specifies boxes in space where geometric tags will be removed:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
GeoCoarsener.num\PYGZus{}boxes   \PYG{o}{=} \PYG{l+m}{1}            \PYG{c+c1}{\PYGZsh{} Number of coarsening boxes (0 = don\PYGZsq{}t coarsen)}
GeoCoarsener.box1\PYGZus{}lo     \PYG{o}{=} \PYGZhy{}1 \PYGZhy{}1 \PYGZhy{}1     \PYG{c+c1}{\PYGZsh{} Lower\PYGZhy{}left corner}
GeoCoarsener.box1\PYGZus{}hi     \PYG{o}{=}  \PYG{l+m}{1}  \PYG{l+m}{1}  \PYG{l+m}{1}     \PYG{c+c1}{\PYGZsh{} Upper\PYGZhy{}right corner}
GeoCoarsener.box1\PYGZus{}lvl    \PYG{o}{=} \PYG{l+m}{0}            \PYG{c+c1}{\PYGZsh{} Remove tags down to this level.}
GeoCoarsener.box1\PYGZus{}inv    \PYG{o}{=} \PYG{n+nb}{false}        \PYG{c+c1}{\PYGZsh{} Flip removal.}
\end{sphinxVerbatim}

If users want more boxes, they can specify it using the same syntax, e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
GeoCoarsener.num\PYGZus{}boxes   \PYG{o}{=} \PYG{l+m}{2}            \PYG{c+c1}{\PYGZsh{} Number of coarsening boxes (0 = don\PYGZsq{}t coarsen)}

GeoCoarsener.box1\PYGZus{}lo     \PYG{o}{=} \PYGZhy{}1 \PYGZhy{}1 \PYGZhy{}1     \PYG{c+c1}{\PYGZsh{} Lower\PYGZhy{}left corner}
GeoCoarsener.box1\PYGZus{}hi     \PYG{o}{=}  \PYG{l+m}{1}  \PYG{l+m}{1}  \PYG{l+m}{1}     \PYG{c+c1}{\PYGZsh{} Upper\PYGZhy{}right corner}
GeoCoarsener.box1\PYGZus{}lvl    \PYG{o}{=} \PYG{l+m}{0}            \PYG{c+c1}{\PYGZsh{} Remove tags down to this level.}
GeoCoarsener.box1\PYGZus{}inv    \PYG{o}{=} \PYG{n+nb}{false}        \PYG{c+c1}{\PYGZsh{} Flip removal.}

GeoCoarsener.box2\PYGZus{}lo     \PYG{o}{=}  \PYG{l+m}{2}  \PYG{l+m}{2}  \PYG{l+m}{2}     \PYG{c+c1}{\PYGZsh{} Lower\PYGZhy{}left corner}
GeoCoarsener.box2\PYGZus{}hi     \PYG{o}{=}  \PYG{l+m}{3}  \PYG{l+m}{3}  \PYG{l+m}{3}     \PYG{c+c1}{\PYGZsh{} Upper\PYGZhy{}right corner}
GeoCoarsener.box2\PYGZus{}lvl    \PYG{o}{=} \PYG{l+m}{0}            \PYG{c+c1}{\PYGZsh{} Remove tags down to this level.}
GeoCoarsener.box2\PYGZus{}inv    \PYG{o}{=} \PYG{n+nb}{false}        \PYG{c+c1}{\PYGZsh{} Flip removal.}
\end{sphinxVerbatim}


\chapter{Solvers}
\label{\detokenize{index:solvers}}

\section{Convection\sphinxhyphen{}Diffusion\sphinxhyphen{}Reaction}
\label{\detokenize{Solvers/CDR:convection-diffusion-reaction}}\label{\detokenize{Solvers/CDR:chap-cdr}}\label{\detokenize{Solvers/CDR::doc}}
Here, we discuss the discretization of the equation
\begin{equation*}
\begin{split}\frac{\partial \phi}{\partial t} + \nabla\cdot\left(\mathbf{v} \phi - D\nabla \phi\right) = S.\end{split}
\end{equation*}
We assume that \(\phi\) is discretized by cell\sphinxhyphen{}centered averages (note that cell centers may lie inside solid boundaries), and use finite volume methods to construct fluxes in a cut\sphinxhyphen{}cells and regular cells.
Here, \(\mathbf{v}\) indicates a drift velocity and \(D\) is the diffusion coefficient.

\begin{sphinxadmonition}{note}{Note:}
Using cell\sphinxhyphen{}centered versions \(\phi\) might be problematic for some models since the state is extended outside the valid region.
Models might have to recenter the state in order compute e.g. physically meaningful reaction terms in cut\sphinxhyphen{}cells.
\end{sphinxadmonition}

Source code for the convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers reside in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Source/ConvectionDiffusionReaction}} and the full API can be found at \sphinxurl{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classCdrSolver.html}.


\subsection{CdrSolver}
\label{\detokenize{Solvers/CDR:cdrsolver}}\label{\detokenize{Solvers/CDR:chap-cdrsolver}}
The \sphinxcode{\sphinxupquote{CdrSolver}} class contains the interface for solving advection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction problems.
\sphinxcode{\sphinxupquote{CdrSolver}} is an abstract class and does not contain any specific advective or diffusive discretization (these are added by implementation classes).

Currently, the implementation layers consist of the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
{\hyperref[\detokenize{Solvers/CDR:chap-cdrmultigrid}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrMultigrid}}}}, which inherits from \sphinxcode{\sphinxupquote{CdrSolver}} and adds a second order accurate discretization for the diffusion operator.

\item {} 
{\hyperref[\detokenize{Solvers/CDR:chap-cdrctu}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrCTU}}}} and {\hyperref[\detokenize{Solvers/CDR:chap-cdrgodunov}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrGodunov}}}} which inherit from \sphinxcode{\sphinxupquote{CdrMultigrid}} and add a second order accurate spatial discretization for the advection operator.

\end{enumerate}

Currently, we mostly use the \sphinxcode{\sphinxupquote{CTU}} class which contains a second order accurate discretization with slope limiters.
\sphinxcode{\sphinxupquote{CdrGodunov}} is a similar operator, but the advection code for this is distributed by the \sphinxcode{\sphinxupquote{Chombo}} team.
The C++ API for these classes can be obtained from \sphinxurl{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classCdrSolver.html}.

The advance methods for \sphinxcode{\sphinxupquote{CdrSolver}} are encapsulated by the following functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// For advancing the diffusion equation with an implicit Euler method.}
\PYG{k+kt}{void} \PYG{n+nf}{advanceEuler}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}newPhi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}oldPhi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}source}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// For advancing the diffusion equation with a Crank\PYGZhy{}Nicholson method.}
\PYG{k+kt}{void} \PYG{n+nf}{advanceCrankNicholson}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}newPhi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}oldPhi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}source}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// For computing div(v*phi \PYGZhy{} D*grad(phi)).}
\PYG{k+kt}{void} \PYG{n+nf}{computeDivJ}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divJ}\PYG{p}{,} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}phi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}conservativeOnly}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}ebFlux}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}domainFlux}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// For computing div(v*phi).}
\PYG{k+kt}{void} \PYG{n+nf}{computeDivF}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divJ}\PYG{p}{,} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}phi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}conservativeOnly}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}ebFlux}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}domainFlux}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// For computing div(D*grad(phi)).}
\PYG{k+kt}{void} \PYG{n+nf}{computeDivD}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divJ}\PYG{p}{,} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}phi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}conservativeOnly}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}ebFlux}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}domainFlux}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Discretization details}
\label{\detokenize{Solvers/CDR:discretization-details}}\label{\detokenize{Solvers/CDR:chap-cdrdetails}}

\subsubsection{Computing explicit divergences}
\label{\detokenize{Solvers/CDR:computing-explicit-divergences}}\label{\detokenize{Solvers/CDR:chap-explicitdivergence}}
Computing explicit divergences for equations like
\begin{equation*}
\begin{split}\frac{\partial \phi}{\partial t} + \nabla\cdot\mathbf{G} = 0\end{split}
\end{equation*}
is problematic because of the arbitarily small volume fractions of cut cells.
In general, we seek a method\sphinxhyphen{}of\sphinxhyphen{}lines update \(\phi^{k+1} = \phi^k - \Delta t \left[\nabla\cdot \mathbf{G}^k\right]\) where \(\left[\nabla\cdot\mathbf{G}\right]\) is a stable numerical approximation based on some finite volume approximation.

Pure finite volume methods use
\begin{equation}\label{equation:Solvers/CDR:conservativeUpdate}
\begin{split}\phi^{k+1} = \phi^k - \frac{\Delta t}{\kappa \Delta x^{\textrm{DIM}}}\int_V\nabla\cdot\mathbf{G}dV,\end{split}
\end{equation}
where \(\kappa\) is the volume fraction of a grid cell, \(\textrm{DIM}\) is the spatial dimension and the volume integral is written as discretized surface integral
\begin{equation*}
\begin{split}\int_V\nabla\cdot\mathbf{G}dV =\sum_{f\in f(V)}\left(\mathbf{G}_f\cdot \mathbf{n}_f\right)\alpha_f\Delta x^{\textrm{DIM} -1}.\end{split}
\end{equation*}
The sum runs over all cell edges (faces in 3D) of the cell where \(G_f\) is the flux on the edge centroid and \(\alpha_f\) is the edge (face) aperture.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{CutCell}.png}
\caption{Location of centroid fluxes for cut cells.}\label{\detokenize{Solvers/CDR:id2}}\end{figure}

However, taking \([\nabla\cdot\mathbf{G}^k]\) to be this sum leads to a time step constraint proportional to \(\kappa\), which can be arbitrarily small.
This leads to an unacceptable time step constraint for Eq. \ref{equation:Solvers/CDR:conservativeUpdate}.
We use the Chombo approach and expand the range of influence of the cut cells in order to stabilize the discretization and allow the use of a normal time step constraint.
First, we compute the conservative divergence
\begin{equation*}
\begin{split}\kappa_{\mathbf{i}} D_\mathbf{i}^c =  \sum_f G_f\alpha_f\Delta x^{\textrm{DIM} -1},\end{split}
\end{equation*}
where \(G_f = \mathbf{G}_f\cdot \mathbf{n}_f\). Next, we compute a non\sphinxhyphen{}conservative divergence \(D_{\mathbf{i}}^{nc}\)
\begin{equation*}
\begin{split}D_\mathbf{i}^{nc} =  \frac{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}D_\mathbf{i}^c}{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}}\end{split}
\end{equation*}
where \(N(\mathbf{i})\) indicates some neighborhood of cells around cell \(\mathbf{i}\). Next, we compute a hybridization of the divergences,
\begin{equation*}
\begin{split}D_{\mathbf{i}}^H = \kappa_{\mathbf{i}} D_{\mathbf{i}}^c + (1-\kappa_{\mathbf{i}})D_{\mathbf{i}}^{nc},\end{split}
\end{equation*}
and perform an intermediate update
\begin{equation*}
\begin{split}\phi_{\mathbf{i}}^{k+1} = \phi_{\mathbf{i}}^k - \Delta tD_{\mathbf{i}}^H.\end{split}
\end{equation*}
The hybrid divergence update fails to conserve mass by an amount \(\delta M_{\mathbf{i}} = \kappa_{\mathbf{i}}\left(1-\kappa_{\mathbf{i}}\right)\left(D_{\mathbf{i}}^c - D_{\mathbf{i}}^{nc}\right)\).
In order to main overall conservation, the excess mass is redistributed into neighboring grid cells.
Let \(\delta M_{\mathbf{i}, \mathbf{j}}\) be the redistributed mass from \(\mathbf{j}\) to \(\mathbf{i}\) where
\begin{equation*}
\begin{split}\delta M_{\mathbf{i}} = \sum_{\mathbf{j} \in N(\mathbf{i})}\delta M_{\mathbf{i}, \mathbf{i}}.\end{split}
\end{equation*}
This mass is used as a local correction in the vicinity of the cut cells, i.e.
\begin{equation*}
\begin{split}\phi_{\mathbf{i}}^{k+1} \rightarrow \phi_{\mathbf{i}}^{k+1} + \delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}},\end{split}
\end{equation*}
where \(\delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}}\) is the total mass redistributed to cell \(\mathbf{i}\) from the other cells.
After these steps, we define
\begin{equation*}
\begin{split}\left[\nabla\cdot\mathbf{G}^k\right]_{\mathbf{i}} \equiv \frac{1}{\Delta t}\left(\phi_{\mathbf{i}}^{k+1} - \phi_{\mathbf{i}}^k\right)\end{split}
\end{equation*}
Numerically, the above steps for computing a conservative divergence of a one\sphinxhyphen{}component flux \(\mathbf{G}\) are implemented in the convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers, which also respects boundary conditions (e.g. charge injection).
The user will need to call the function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{CdrSolver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{computeDivG}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divG}\PYG{p}{,} \PYG{n}{EBAMRFluxData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}G}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRIVData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}ebG}\PYG{p}{)}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{a\_G}} is the numerical representation of \(\mathbf{G}\) over the cut\sphinxhyphen{}cell AMR hierarchy and must be stored on cell\sphinxhyphen{}centered faces, and \sphinxcode{\sphinxupquote{a\_ebG}} is the flux on the embedded boundary.
The above steps are performed by interpolating \sphinxcode{\sphinxupquote{a\_G}} to face centroids in the cut cells for computing the conservative divergence, and the remaining steps are then performed successively.
The result is put in \sphinxcode{\sphinxupquote{a\_divG}}.

Note that when refinement boundaries intersect with embedded boundaries, the redistribution process is far more complicated since it needs to account for mass that moves over refinement boundaries.
These additional complicated are taken care of inside \sphinxcode{\sphinxupquote{a\_divG}}, but are not discussed in detail here.

\begin{sphinxadmonition}{caution}{Caution:}
Mass redistribution has the effect of not being monotone and thus not TVD, and the discretization order is formally \(\mathcal{O}(\Delta x)\).
\end{sphinxadmonition}


\subsubsection{Explicit advection}
\label{\detokenize{Solvers/CDR:explicit-advection}}\label{\detokenize{Solvers/CDR:chap-explicitadvection}}
Scalar advection updates follows the computation of the explicit divergence discussed in {\hyperref[\detokenize{Solvers/CDR:chap-explicitdivergence}]{\sphinxcrossref{\DUrole{std,std-ref}{Computing explicit divergences}}}}.
The face\sphinxhyphen{}centered fluxes \(\mathbf{G} = \phi\mathbf{v}\) are computed by instantiation classes for the convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers.
The function signature for explicit advection is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{computeDivF}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divF}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}state}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the face\sphinxhyphen{}centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in \sphinxcode{\sphinxupquote{a\_divF}} using the procedure outlined above.
The argument \sphinxcode{\sphinxupquote{a\_dt}} is the time step size.
It is not needed in a method\sphinxhyphen{}of\sphinxhyphen{}lines context, but it is used in e.g. \DUrole{xref,std,std-ref}{CdrCTU} for computing transverse derivatives in order to expand the stability region (i.e., use larger CFL numbers).

For example, in order to perform an advective advance over a time step \(\Delta t\), one would perform the following:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{CdrSolver}\PYG{o}{*} \PYG{n}{solver}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}

\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phi}  \PYG{o}{=} \PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getPhi}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// Cell\PYGZhy{}centered state}
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{divF} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getScratch}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Scratch storage in solver}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeDivF}\PYG{p}{(}\PYG{n}{divF}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// Computes divF}
\PYG{n+nl}{DataOps}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divF}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}               \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divF}
\end{sphinxVerbatim}


\subsubsection{Explicit diffusion}
\label{\detokenize{Solvers/CDR:explicit-diffusion}}\label{\detokenize{Solvers/CDR:chap-explicitdiffusion}}
Explicit diffusion is performed in much the same way as implicit advection, with the exception that the general flux \(\mathbf{G} = D\nabla\phi\) is computed by using centered differences on face centers.
The function signature for explicit diffusion is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{computeDivD}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divF}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}state}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and we increment in the same way as for explicit advection:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{CdrSolver}\PYG{o}{*} \PYG{n}{solver}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}

\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phi}  \PYG{o}{=} \PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getPhi}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// Cell\PYGZhy{}centered state}
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{divD} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getScratch}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Scratch storage in solver}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeDivF}\PYG{p}{(}\PYG{n}{divD}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// Computes divD}
\PYG{n+nl}{DataOps}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divD}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}                \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi + dt*divD}
\end{sphinxVerbatim}


\subsubsection{Explicit advection\sphinxhyphen{}diffusion}
\label{\detokenize{Solvers/CDR:explicit-advection-diffusion}}\label{\detokenize{Solvers/CDR:chap-explicitadvectiondiffusion}}
There is also functionality for aggregating explicit advection and diffusion advances.
The reason for this is that the cut\sphinxhyphen{}cell overhead is only applied once on the combined flux \(\phi\mathbf{v} - D\nabla\phi\) rather than on the individual fluxes.
For non\sphinxhyphen{}split methods this leads to some performance improvement since the interpolation of fluxes on cut\sphinxhyphen{}cell faces only needs to be performed once.
The signature for this is precisely the same as for explicit advection only:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{computeDivJ}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divJ}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}state}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}extrapDt}\PYG{p}{)}
\end{sphinxVerbatim}

where the face\sphinxhyphen{}centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in \sphinxcode{\sphinxupquote{a\_divF}}.
For example, in order to perform an advective advance over a time step \(\Delta t\), one would perform the following:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}

\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phi}  \PYG{o}{=} \PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getPhi}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// Cell\PYGZhy{}centered state}
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{divJ} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getScratch}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Scratch storage in solver}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeDivJ}\PYG{p}{(}\PYG{n}{divJ}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// Computes divD}
\PYG{n+nl}{DataOps}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divJ}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}               \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divJ}
\end{sphinxVerbatim}

Often, time integrators have the option of using implicit or explicit diffusion.
If the time\sphinxhyphen{}evolution is not split (i.e. not using a Strang or Godunov splitting), the integrators will often call \sphinxcode{\sphinxupquote{computeDivJ}} rather separately calling \sphinxcode{\sphinxupquote{computeDivF}} and \sphinxcode{\sphinxupquote{computeDivD}}.
If you had a split\sphinxhyphen{}step Godunov method, the above procedure for a forward Euler method for both parts would be:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{CdrSolver}\PYG{o}{*} \PYG{n}{solver}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}

\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeDivF}\PYG{p}{(}\PYG{n}{divF}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Computes divF = div(n*phi)}
\PYG{n+nl}{DataOps}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divF}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divF}

\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeDivD}\PYG{p}{(}\PYG{n}{divD}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// Computes divD = div(D*nabla(phi))}
\PYG{n+nl}{DataOps}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divD}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi + dt*divD}
\end{sphinxVerbatim}

However, the cut\sphinxhyphen{}cell redistribution dance (flux interpolation, hybrid divergence, and redistribution) would be performed twice.


\subsubsection{Implicit diffusion}
\label{\detokenize{Solvers/CDR:implicit-diffusion}}\label{\detokenize{Solvers/CDR:chap-implicitdiffusion}}
Implicit diffusion can occasionally be necesasry.
The convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers support two basic diffusion solves:
Backward Euler and the Crank\sphinxhyphen{}Nicholson methods.
The function signatures for these are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{advanceEuler}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}newPhi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}oldPhi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}source}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{advanceCrankNicholson}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}newPhi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}oldPhi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}source}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{a\_newPhi}} is the state at the new time \(t + \Delta t\), \sphinxcode{\sphinxupquote{a\_oldPhi}} is the state at time \(t\) and \sphinxcode{\sphinxupquote{a\_source}} is the source term which strictly speaking should be centered at time \(t + \Delta t\) for the Euler update and at time \(t + \Delta t/2\) for the Crank\sphinxhyphen{}Nicholson update.
This may or may not be possible for your particular problem.

For example, performing a split step Godunov method for advection\sphinxhyphen{}diffusion is as simple as:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// First. Compute phi = phi \PYGZhy{} dt*div(F)}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeDivF}\PYG{p}{(}\PYG{n}{divF}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nl}{DataOps}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divF}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Implicit diffusion advance over a time step dt}
\PYG{n}{DataOps}\PYG{o}{:}\PYG{o}{:}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{advanceEuler}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{CdrMultigrid}
\label{\detokenize{Solvers/CDR:cdrmultigrid}}\label{\detokenize{Solvers/CDR:chap-cdrmultigrid}}
\sphinxcode{\sphinxupquote{CdrMultigrid}} adds second\sphinxhyphen{}order accurate implicit diffusion code to \sphinxcode{\sphinxupquote{CdrSolver}}, but leaves the advection code unimplemented.
The class can use either implicit or explicit diffusion using second\sphinxhyphen{}order cell\sphinxhyphen{}centered stencils.
In addition, \sphinxcode{\sphinxupquote{CdrMultigrid}} adds two implicit time\sphinxhyphen{}integrators, an implicit Euler method and a Crank\sphinxhyphen{}Nicholson method.

The \sphinxcode{\sphinxupquote{CdrMultigrid}} layer uses the Helmholtz discretization discussed in {\hyperref[\detokenize{Source/LinearSolvers:chap-helmholtz}]{\sphinxcrossref{\DUrole{std,std-ref}{Helmholtz equation}}}}.
It implements the pure functions required by {\hyperref[\detokenize{Solvers/CDR:chap-cdrsolver}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrSolver}}}} but introduces a new pure function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{virtual} \PYG{n}{void} \PYG{n}{advectToFaces}\PYG{p}{(}\PYG{n}{EBAMRFluxData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}facePhi}\PYG{p}{,} \PYG{n}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}phi}\PYG{p}{,} \PYG{n}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The faces states defined by the above function are used when forming a finite\sphinxhyphen{}volume approximation to the divergence operators, see {\hyperref[\detokenize{Solvers/CDR:chap-cdrdetails}]{\sphinxcrossref{\DUrole{std,std-ref}{Discretization details}}}}.


\subsection{CdrCTU}
\label{\detokenize{Solvers/CDR:cdrctu}}\label{\detokenize{Solvers/CDR:chap-cdrctu}}
\sphinxcode{\sphinxupquote{CdrCTU}} is an implementation class that uses the corner transport upwind (CTU) discretization.
The CTU discretization uses information that propagates over corners of grid cells when calculating the face states.
It can combine this with use various limiters:
\begin{itemize}
\item {} 
No limiter (pure CTU)

\item {} 
Minmod

\item {} 
Superbee

\item {} 
Monotonized central differences

\end{itemize}

In addition, \sphinxcode{\sphinxupquote{CdrCTU}} can turn off the transverse terms in which case the discretization reduces to the donor cell method.
Our motivation for using the CTU discretization lies in the time step selection for the CTU and donor\sphinxhyphen{}cell methods, see {\hyperref[\detokenize{Solvers/CDR:chap-ctustep}]{\sphinxcrossref{\DUrole{std,std-ref}{Time step limitation}}}}.
Typically, we want to achieve a dimensionally independent time step that is the same in 1D, 2D, and 3D, but without directional splitting.


\subsubsection{Face extrapolation}
\label{\detokenize{Solvers/CDR:face-extrapolation}}
The finite volume discretization uses an upstream\sphinxhyphen{}centered Taylor expansion that extrapolates the cell\sphinxhyphen{}centered term to half\sphinxhyphen{}edges and half\sphinxhyphen{}steps:
\begin{equation*}
\begin{split}\phi_{i+1/2,j,}^{n+1/2} = \phi_{i,j,k}^n + \frac{\Delta x}{2}\frac{\partial \phi}{\partial x} + \frac{\Delta t}{2}\frac{\partial \phi}{\partial t}.\end{split}
\end{equation*}
For brevity, the resulting expression in 2D for a velocity field \(\mathbf{v} = (u,v)\) is
\begin{equation*}
\begin{split}\phi_{i\pm1/2,j}^{n+1/2,+} = \phi_{i,j}^n \pm \frac{1}{2}\min\left[1, 1 \mp \frac{\Delta t}{\Delta x}u_{i,j}^n\right]\left(\Delta^x\phi\right)_{i,j}^n - \frac{\Delta t}{2\Delta x}v_{i,j}^n\left(\Delta^y\phi\right)_{i,j}^n,\end{split}
\end{equation*}
Here, \(\Delta^x\) are the regular (normal) slopes whereas \(\Delta^y\) are the transverse slopes.
The transverse slopes are given by
\begin{equation*}
\begin{split}(\Delta^y\phi)_{i,j}^n = \begin{cases}
\phi_{i,j+1}^n - \phi_{i,j}^n, & v_{i,j}^n < 0 \\
\phi_{i,j}^n - \phi_{i,j-1}^n, & v_{i,j}^n > 0 \\
\end{cases}\end{split}
\end{equation*}

\subsubsection{Slopes}
\label{\detokenize{Solvers/CDR:slopes}}\label{\detokenize{Solvers/CDR:chap-ctuslopes}}
For the normal slopes, the user can choose between the minmod, superbee, and monotonized central difference (MC) slopes.
Let \(\Delta_l = \phi_{i,j}^n - \phi_{i-1,j}^n\) and \(\Delta_r = \phi_{i+1,j}^n - \phi_{i,j}^n\).
The slopes are given by:
\begin{equation*}
\begin{split}\text{minmod: }\left(\Delta^x\phi\right)_{i,j}^n &= \begin{cases}
\Delta_l & |\Delta_l| < |\Delta_r| \text { and } \Delta_l\Delta_r > 0 \\
\Delta_r & |\Delta_l| > |\Delta_r| \text { and } \Delta_l\Delta_r > 0 \\
0 & \text{otherwise}.
\end{cases} \\[1ex]
\text{MC: } \left(\Delta^x\phi\right)_{i,j}^n &= \text{sgn}\left(\Delta_l + \Delta_r\right)\min\left(\left|\frac{\Delta_l + \Delta_r}{2}\right|, 2\left|\Delta_l\right|, 2\left|\Delta_r\right|\right),\\[1ex]
\text{superbee: }\left(\Delta^x\phi\right)_{i,j}^n &= \begin{cases}
\Delta_1 & |\Delta_1| > |\Delta_2| \text { and } \Delta_1\Delta_2 > 0 \\
\Delta_2 & |\Delta_1| < |\Delta_2| \text { and } \Delta_1\Delta_2 > 0 \\
0 & \text{otherwise},
\end{cases} \\[1ex]\end{split}
\end{equation*}
where for the superbee slope we have \(\Delta_1 = \text{minmod}\left(\Delta_l, 2\Delta_r\right)\) and \(\Delta_2 = \text{minmod}\left(\Delta_r, 2\Delta_l\right)\).

\begin{sphinxadmonition}{note}{Note:}
When using slopes, monotonicity is not guaranteed for the CTU discretization.
If slopes are turned off, however, the scheme is guaranteed to be monotone.
\end{sphinxadmonition}


\subsubsection{Time step limitation}
\label{\detokenize{Solvers/CDR:time-step-limitation}}\label{\detokenize{Solvers/CDR:chap-ctustep}}
The stability region for the donor\sphinxhyphen{}cell and corner transport upwind methods are:
\begin{align*}\!\begin{aligned}
\text{Donor-cell}: \Delta t \leq \frac{\Delta x}{|v_x| + |v_y| + |v_z|}\\
\text{CTU}: \Delta t \leq \frac{\Delta x}{\max\left(|v_x|,|v_y|,|v_z|\right)}\\
\end{aligned}\end{align*}
Note that when the flow is diagonal to the grid, i.e. \(|v_x| = |v_y| = |v_z|\), the CTU can use a time step that is three times larger than for the donor\sphinxhyphen{}cell method.


\subsubsection{Class options}
\label{\detokenize{Solvers/CDR:class-options}}
When running the \sphinxcode{\sphinxupquote{CdrCTU}} solver the user can adjust the advective algorithm by turning on/off slope limiters and the transverse term through the class options:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{CdrCTU.slope\_limiter}}, which must be \sphinxstyleemphasis{none}, \sphinxstyleemphasis{minmod}, \sphinxstyleemphasis{mc}, or \sphinxstyleemphasis{superbee}.

\item {} 
\sphinxcode{\sphinxupquote{CdrCTU.use\_ctu}}, which must be \sphinxstyleemphasis{true} or \sphinxstyleemphasis{false}.

\end{itemize}

If the transverse terms are turned off, \sphinxcode{\sphinxupquote{CdrCTU}} will compute the donor\sphinxhyphen{}cell time step.


\subsection{CdrGodunov}
\label{\detokenize{Solvers/CDR:cdrgodunov}}\label{\detokenize{Solvers/CDR:chap-cdrgodunov}}
\sphinxcode{\sphinxupquote{CdrGodunov}} inherits from \sphinxcode{\sphinxupquote{CdrMultigrid}} and adds advection code for Godunov methods.
This class borrows from \sphinxcode{\sphinxupquote{Chombo}} internals (specifically, \sphinxcode{\sphinxupquote{EBLevelAdvectIntegrator}}) and can do second\sphinxhyphen{}order advection with time\sphinxhyphen{}extrapolation.
For example, when extrapolating cell\sphinxhyphen{}centered data to faces, the extrapolation can be done (with Van Leer limiters) in both space and time.


\subsubsection{Implementations}
\label{\detokenize{Solvers/CDR:implementations}}
To use a \sphinxcode{\sphinxupquote{CdrSolver}}, one must instantiate either \sphinxcode{\sphinxupquote{CdrGodunov}} or \sphinxcode{\sphinxupquote{CdrCTU}} (which differ only in their treatment of advection).
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{CdrSpecies}\PYG{o}{*} \PYG{n}{spec}  \PYG{o}{=} \PYG{p}{(}\PYG{n}{CdrSpecies}\PYG{o}{*}\PYG{p}{)} \PYG{n}{mySpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{CdrSolver}\PYG{o}{*} \PYG{n}{solver} \PYG{o}{=} \PYG{p}{(}\PYG{n}{CdrSolver}\PYG{o}{*}\PYG{p}{)}  \PYG{k}{new} \PYG{n}{CdrGodunov}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}species}\PYG{p}{(}\PYG{n}{spec}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Instantiating \sphinxcode{\sphinxupquote{CdrSolver}} or \sphinxcode{\sphinxupquote{CdrMultigrid}} directly will cause compile\sphinxhyphen{}time errors.

Note that if you want to add new advection code to \sphinxcode{\sphinxupquote{CdrSolver}}, you may inherit from \sphinxcode{\sphinxupquote{CdrMultigrid}} and implement new advection routines.


\subsection{Using CdrSolver}
\label{\detokenize{Solvers/CDR:using-cdrsolver}}
The \sphinxcode{\sphinxupquote{CdrSolver}} is intended to be used in a method\sphinxhyphen{}of\sphinxhyphen{}lines context where the user will
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Fill the solver with relevant data (e.g. velocities, diffusion coefficients, source terms etc.).

\item {} 
Call public member functions for explicit advection or diffusion, or for performing implicit diffusion advances.

\end{enumerate}

It is up to the developer to ensure that the solver is filled with appropriate data before calling the public member functions.
This would typically look something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{vel} \PYG{o}{=} \PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCellCenteredVelocity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lvl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lvl} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getFinestLevel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lvl}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZam{}} \PYG{n}{dbl} \PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getGrids}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{EBCellFAB}\PYG{o}{\PYGZam{}} \PYG{n}{patchVel} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{vel}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

      \PYG{c+c1}{// Set velocity of some patch}
      \PYG{n}{callSomeFunction}\PYG{p}{(}\PYG{n}{patchVel}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Compute div(v*phi)}
\PYG{n}{computeDivF}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\end{sphinxVerbatim}

There are no time integration algorithms built into the \sphinxcode{\sphinxupquote{CdrSolver}}, and the user will have to supply these through \sphinxcode{\sphinxupquote{TimeStepper}}.
More complete code is given in the physics module for advection\sphinxhyphen{}diffusion problems in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/AdvectionDiffusion/}}.
This code is also part of a regression test found in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Regression/AdvectionDiffusion}}.


\subsubsection{Setting up the solver}
\label{\detokenize{Solvers/CDR:setting-up-the-solver}}
To set up the \sphinxcode{\sphinxupquote{CdrSolver}}, the following commands are usually included in \sphinxcode{\sphinxupquote{time\_stepper::setup\_solvers()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume m\PYGZus{}solver and m\PYGZus{}species are pointers to a CdrSolver and CdrSpecies}
\PYG{n}{m\PYGZus{}solver}  \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{CdrSolver}\PYG{o}{\PYGZgt{}}  \PYG{p}{(}\PYG{k}{new} \PYG{n}{MyCdrSolver}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}species} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{CdrSpecies}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{new} \PYG{n}{MyCdrSpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solver setup}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setVerbosity}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setSpecies}\PYG{p}{(}\PYG{n}{m\PYGZus{}species}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{parseOptions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setPhase}\PYG{p}{(}\PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{gas}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAmr}\PYG{p}{(}\PYG{n}{m\PYGZus{}amr}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setComputational\PYGZus{}geometry}\PYG{p}{(}\PYG{n}{m\PYGZus{}compgeom}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sanityCheck}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{allocateInternals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

To see an example, the advection\sphinxhyphen{}diffusion code in \sphinxcode{\sphinxupquote{/physics/AdvectionDiffusion/AdvectionDiffusion\_stepper}} shows how to set up this particular solver.


\subsubsection{Filling the solver}
\label{\detokenize{Solvers/CDR:filling-the-solver}}
In order to obtain mesh data from the \sphinxcode{\sphinxupquote{CdrSolver}}, the user should use the following public member functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{getPhi}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                               \PYG{c+c1}{// Return  phi}
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{getSource}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                            \PYG{c+c1}{// Returns S}
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{getCellCenteredVelocity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}              \PYG{c+c1}{// Get cell\PYGZhy{}centered velocity}
\PYG{n}{EBAMRFluxData}\PYG{o}{\PYGZam{}} \PYG{n}{getFaceCenteredDiffusionCoefficient}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Returns D}
\PYG{n}{EBAMRIVData}\PYG{o}{\PYGZam{}} \PYG{n}{getEbFlux}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                              \PYG{c+c1}{// Returns flux at EB}
\PYG{n}{EBAMRIFData}\PYG{o}{\PYGZam{}} \PYG{n}{getDomainFlux}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                          \PYG{c+c1}{// Returns flux at domain boundaries}
\end{sphinxVerbatim}

To set the drift velocities, the user will fill the \sphinxstyleemphasis{cell\sphinxhyphen{}centered} velocities.
Interpolation to face\sphinxhyphen{}centered transport fluxes are done by \sphinxcode{\sphinxupquote{CdrSolver}} during the discretization step.

The general way of setting the velocity is to get a direct handle to the velocity data:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{CdrSolver} \PYG{n+nf}{solver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{veloCell} \PYG{o}{=} \PYG{n}{solver}\PYG{p}{.}\PYG{n}{getCellCenteredVelocity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Then, \sphinxcode{\sphinxupquote{veloCell}} can be filled with the cell\sphinxhyphen{}centered velocity.
The same procedure goes for the source terms, diffusion coefficients, boundary conditions and so on.

For example, an explicit Euler discretization for the problem \(\partial_t\phi = S\) is:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{CdrSolver}\PYG{o}{*} \PYG{n}{solver}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}

\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phi} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getPhi}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{src} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getSource}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{DataOps}\PYG{o}{:}\PYG{o}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{src}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Adjusting output}
\label{\detokenize{Solvers/CDR:adjusting-output}}
It is possible to adjust solver output when plotting data.
This is done through the input file for the class that you’re using (e.g. \sphinxcode{\sphinxupquote{/src/CdrSolver/CdrGodunov.options}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
CdrGodunov.plt\PYGZus{}vars \PYG{o}{=} phi vel src dco ebflux  \PYG{c+c1}{\PYGZsh{} Plot variables. Options are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}vel\PYGZsq{}, \PYGZsq{}dco\PYGZsq{}, \PYGZsq{}src\PYGZsq{}, \PYGZsq{}ebflux\PYGZsq{}}
\end{sphinxVerbatim}

Here, you adjust the plotted variables by adding or omitting them from your input script.
E.g. if you only want to plot the cell\sphinxhyphen{}centered states you would do:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
CdrGodunov.plt\PYGZus{}vars \PYG{o}{=} phi  \PYG{c+c1}{\PYGZsh{} Plot variables. Options are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}vel\PYGZsq{}, \PYGZsq{}dco\PYGZsq{}, \PYGZsq{}src\PYGZsq{}, \PYGZsq{}ebflux\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{CdrSpecies}
\label{\detokenize{Solvers/CDR:cdrspecies}}\label{\detokenize{Solvers/CDR:chap-cdrspecies}}
The \sphinxcode{\sphinxupquote{CdrSpecies}} class is a supporting class that passes information and initial conditions into \sphinxcode{\sphinxupquote{CdrSolver}} instances.
\sphinxcode{\sphinxupquote{CdrSpecies}} specifies whether or not the advect\sphinxhyphen{}diffusion solver will use only advection, diffusion, both advection and diffusion, or neither.
It also specifies initial data, and provides a string identifier to the class (e.g. for identifying output in plot files).
However, it does not contain any discretization.

\begin{sphinxadmonition}{note}{Note:}
Click \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classCdrSpecies.html}{here} for the \sphinxcode{\sphinxupquote{CdrSpecies}} C++ API.
\end{sphinxadmonition}

The below code block shows an example of how to instantiate a species.
Here, diffusion code is turned off and the initial data is one everywhere.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{class} \PYG{n+nc}{MySpecies} \PYG{o}{:} \PYG{k}{public} \PYG{n}{CdrSpecies}\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}

   \PYG{n}{MySpecies}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{m\PYGZus{}mobile}    \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}diffusive} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
      \PYG{n}{m\PYGZus{}name}      \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mySpecies}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{o}{\PYGZti{}}\PYG{n}{MySpecies}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{k}{default}\PYG{p}{;}

   \PYG{n}{Real} \PYG{n+nf}{initialData}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{k}{const} \PYG{k}{override} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{l+m+mf}{1.0}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
It is also possible to use computational particles as an initial condition in \sphinxcode{\sphinxupquote{CdrSpecies}}.
In this case you need to fill \sphinxcode{\sphinxupquote{m\_initialParticles}}, and these are then deposited with a nearest\sphinxhyphen{}grid\sphinxhyphen{}point scheme when instantiating the solver.
See {\hyperref[\detokenize{Source/Particles:chap-particles}]{\sphinxcrossref{\DUrole{std,std-ref}{Particles}}}} for further details.
\end{sphinxadmonition}


\subsubsection{Adding a stochastic flux}
\label{\detokenize{Solvers/CDR:adding-a-stochastic-flux}}
It is possible to add a stochastic flux through the public member functions of \sphinxcode{\sphinxupquote{CdrSolver}} in the odd case that one wants to use fluctuating hydrodynamics (FHD).
This is done by calling a function that computes the term \(\sqrt{2D\phi}\mathbf{Z}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{gwnDiffusionSource}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}noiseSource}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cellPhi}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

When FHD is used, there is no guarantee that the evolution leads to non\sphinxhyphen{}negative values.
We do our best to ensure that the stochastic flux is turned off when \(\phi \Delta V\) approaches 0 by computing the face\sphinxhyphen{}centered states for the stochastic term using an arithmetic mean that goes to zero as \(\phi\) approaches 0.

In the above function, \sphinxcode{\sphinxupquote{a\_ransource}} can be used directly in a MOL context, e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeDivF}\PYG{p}{(}\PYG{n}{divF}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Computes divF = div(n*phi)}
\PYG{n+nl}{DataOps}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divF}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divF}

\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{gwnDiffusionSource}\PYG{p}{(}\PYG{n}{ransource}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Compute stochastic flux}
\PYG{n}{DataOps}\PYG{o}{:}\PYG{o}{:}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}                  \PYG{c+c1}{// phiOld = phi \PYGZhy{} dt*divF}
\PYG{n}{DataOps}\PYG{o}{:}\PYG{o}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{ransource}\PYG{p}{,} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// phiOld = phi \PYGZhy{} dt*divF + dt*sqrt(2D*phi)Z}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{advanceEuler}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}       \PYG{c+c1}{// Backward Euler diffusion solve.}
\end{sphinxVerbatim}


\subsection{Example application}
\label{\detokenize{Solvers/CDR:example-application}}
An example application of usage of the \sphinxcode{\sphinxupquote{CdrSolver}} is found in {\hyperref[\detokenize{Applications/AdvectionDiffusionModel:chap-advectiondiffusionmodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Advection diffusion}}}}.


\section{Electrostatics}
\label{\detokenize{Solvers/Electrostatics:electrostatics}}\label{\detokenize{Solvers/Electrostatics:chap-electrostatics}}\label{\detokenize{Solvers/Electrostatics::doc}}
Here, we discuss the discretization of the equation
\begin{equation}\label{equation:Solvers/Electrostatics:Poisson}
\begin{split}\nabla\cdot\left(\epsilon_r\nabla\Phi\right) = -\frac{\rho}{\epsilon_0}\end{split}
\end{equation}
where \(\Phi\) is the electric potential, \(\rho\) is the space charge density and \(\epsilon_0\) is the vacuum permittivity.
The relative permittivity is \(\epsilon_r = \epsilon_r\left(\mathbf{x}\right)\) and can additionally be discontinuous at gas\sphinxhyphen{}dielectric interfaces.

\begin{sphinxadmonition}{note}{Note:}
All current electrostatic field solvers solve for the potential at the cell center (not the cell centroid).
The code for the electrostatics solver is given in \sphinxcode{\sphinxupquote{/Source/Electrostatics}} and \sphinxcode{\sphinxupquote{/Source/Elliptic}}.
\end{sphinxadmonition}


\subsection{FieldSolver}
\label{\detokenize{Solvers/Electrostatics:fieldsolver}}
\sphinxcode{\sphinxupquote{FieldSolver}} is an abstract class for electrostatic solves in an EB context and contains most routines required for setting up and solving electrostatic problems.
\sphinxcode{\sphinxupquote{FieldSolver}} can solve over three phases, gas, dielectric, and electrode, and thus it is uses \sphinxcode{\sphinxupquote{MFAMRCellData}} functionality where data is defined over multiple phases (see {\hyperref[\detokenize{Source/MeshData:chap-meshdata}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh data}}}}).

Note that in order to separate the electrostatic solver interface from the implementation, \sphinxcode{\sphinxupquote{FieldSolver}} is a pure class without knowledge of numerical discretizations.
Currently, our only supported implementation is \sphinxcode{\sphinxupquote{FieldSolverMultigrid}} (see {\hyperref[\detokenize{Solvers/Electrostatics:chap-fieldsolvermultigrid}]{\sphinxcrossref{\DUrole{std,std-ref}{FieldSolverMultigrid}}}}).

On gas\sphinxhyphen{}dielectric interfaces we enforce an extra equation
\begin{equation}\label{equation:Solvers/Electrostatics:GaussBC}
\begin{split}\epsilon_1\partial_{n_1}\Phi + \epsilon_2\partial_{n_2}\Phi = \sigma/\epsilon_0\end{split}
\end{equation}
where \(\mathbf{n}_1 = -\mathbf{n}_2\) are the normal vectors pointing out of each side of the interface, and \(\sigma\) is the surface charge density.

We point out that this equation can be enforced in various formats.
The most common case is that \(\partial_n\Phi\) are free parameters and \(\sigma\) is a fixed parameter.
However, we \sphinxstyleemphasis{can} also fix \(\partial_n\Phi\) on either side of the boundary and have \(\sigma\) as a free parameter.
When using \sphinxcode{\sphinxupquote{FieldSolverMultigrid}} (see {\hyperref[\detokenize{Solvers/Electrostatics:chap-fieldsolvermultigrid}]{\sphinxcrossref{\DUrole{std,std-ref}{FieldSolverMultigrid}}}}), users can choose between these two natural boundary conditions, see {\hyperref[\detokenize{Solvers/Electrostatics:chap-poissonebbc}]{\sphinxcrossref{\DUrole{std,std-ref}{EB boundary conditions}}}}.


\subsection{Using FieldSolver}
\label{\detokenize{Solvers/Electrostatics:using-fieldsolver}}
Using the \sphinxcode{\sphinxupquote{FieldSolver}} is usually straightforward by first constructing the solver and then parsing the class options.
Creating a solver is usually done by means of a pointer cast:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{FieldSolver}\PYG{o}{\PYGZgt{}} \PYG{n}{fieldSolver} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{FieldSolver}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{new} \PYG{n}{FieldSolverMultigrid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In addition, one must parse run\sphinxhyphen{}time options to the class, provide the \sphinxcode{\sphinxupquote{AmrMesh}} and \sphinxcode{\sphinxupquote{ComputationalGeometry}} instances, and set the initial conditions.
This is done as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{AmrMesh}\PYG{o}{\PYGZgt{}} \PYG{n}{amr}\PYG{p}{;}
\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{ComputationalGeometry}\PYG{o}{\PYGZgt{}} \PYG{n}{geo}\PYG{p}{;}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{p}{)}\PYG{o}{\PYGZgt{}} \PYG{n}{voltage}\PYG{p}{;}

\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{parseOptions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                \PYG{c+c1}{// Parse class options}
\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setAmr}\PYG{p}{(}\PYG{n}{amr}\PYG{p}{)}\PYG{p}{;}                   \PYG{c+c1}{// Set amr \PYGZhy{} we assume that `amr` is an object}
\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setComputationalGeometry}\PYG{p}{(}\PYG{n}{geo}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Set the computational geometry}
\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{allocateInternals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}           \PYG{c+c1}{// Allocate storage for potential etc.}
\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setVoltage}\PYG{p}{(}\PYG{n}{voltage}\PYG{p}{)}\PYG{p}{;}           \PYG{c+c1}{// Set the voltage}
\end{sphinxVerbatim}

The argument in the function \sphinxcode{\sphinxupquote{setVoltage(...)}} is a function pointer of the type:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n}{voltage}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)}
\end{sphinxVerbatim}

This allows setting a time\sphinxhyphen{}dependent voltage on electrodes and domain boundaries.
As shown above, one can also use \sphinxcode{\sphinxupquote{std::function\textless{}Real(const Real)\textgreater{}}} or lambdas to set the voltage.
E.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{FieldSolver}\PYG{o}{*} \PYG{n}{fieldSolver}\PYG{p}{;}

\PYG{n}{Real} \PYG{n}{myVoltage} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Real} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{l+m+mf}{1.0}\PYG{o}{*}\PYG{n}{a\PYGZus{}time}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setVoltage}\PYG{p}{(}\PYG{n}{myVoltage}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The electrostatic solver \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} has a lot of supporting functionality, but essentially relies on only one critical function:
Solving for the potential.
This is done by the member function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{bool} \PYG{n}{FieldSolver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{rho}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRIVData}\PYG{o}{\PYGZam{}} \PYG{n}{sigma}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{phi}} is the resulting potential that was computing with the space charge density \sphinxcode{\sphinxupquote{rho}} and surface charge density \sphinxcode{\sphinxupquote{sigma}}.
This function is implemented by {\hyperref[\detokenize{Solvers/Electrostatics:chap-fieldsolvermultigrid}]{\sphinxcrossref{\DUrole{std,std-ref}{FieldSolverMultigrid}}}}.


\subsection{Domain boundary conditions}
\label{\detokenize{Solvers/Electrostatics:domain-boundary-conditions}}\label{\detokenize{Solvers/Electrostatics:chap-poissondomainbc}}
Domain boundary conditions for the solver must be set by the user through an input script, whereas the boundary conditions on internal surfaces are Dirichlet by default.
Note that on multifluid\sphinxhyphen{}boundaries the boundary condition is enforced by the conventional matching boundary condition that follows from Gauss\textasciigrave{} law.


\subsubsection{General format}
\label{\detokenize{Solvers/Electrostatics:general-format}}
The most general form of setting domain boundary conditions for \sphinxcode{\sphinxupquote{FieldSolver}} is to specify a boundary condition \sphinxstyleemphasis{type} (e.g., Dirichlet) together with a function specifying the value.
Domain boundary condition \sphinxstyleemphasis{types} are parsed through a member function \sphinxcode{\sphinxupquote{FieldSolver::parseDomainBc}}.
This function will read string identifiers from the input script, and these identifiers are either in the format \sphinxcode{\sphinxupquote{\textless{}string\textgreater{} \textless{}float\textgreater{}}} (simplified format) or in the format \sphinxcode{\sphinxupquote{\textless{}string\textgreater{}}} (general format).
For setting general types of Neumann or Dirichlet BCs on the domain sides, one will specify

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
FieldSolverMultigrid.bc\PYGZus{}x\PYGZus{}low  \PYG{o}{=} dirichlet\PYGZus{}custom
FieldSolverMultigrid.bc\PYGZus{}x\PYGZus{}high \PYG{o}{=} dirichlet\PYGZus{}neumann
\end{sphinxVerbatim}

Unfortunately, due to the many degrees of freedom in setting domain boundary conditions, the procedure is a bit convoluted.
We first explain the general procedure.

\sphinxcode{\sphinxupquote{FieldSolver}} will always set individual space\sphinxhyphen{}time functions on each domain side, and these functions are always in the form

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)}\PYG{o}{\PYGZgt{}} \PYG{n}{bcFunction}\PYG{p}{;}
\end{sphinxVerbatim}

To set a domain boundary condition function on a side, one can use the following member function:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{FieldSolver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setDomainSideBcFunction}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}dir}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{Side}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LoHiSide} \PYG{n}{a\PYGZus{}side}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For a general way of setting the function value on the domain side, one will use the above function together with an identifier \sphinxcode{\sphinxupquote{dirichlet\_custom}} or \sphinxcode{\sphinxupquote{neumann\_custom}} in the input script.
This identifier simply tells \sphinxcode{\sphinxupquote{FieldSolver}} to use that function to either specifiy \(\Phi\) or \(\partial_n\Phi\) on the boundary.
These functions are then directly processed by the numerical discretizations.

\begin{sphinxadmonition}{note}{Note:}
On construction, \sphinxcode{\sphinxupquote{FieldSolver}} will set all the domain boundary condition functions to a constant of one (because the functions need to be populated).
\end{sphinxadmonition}


\subsubsection{Simplified format}
\label{\detokenize{Solvers/Electrostatics:simplified-format}}
\sphinxcode{\sphinxupquote{FieldSolver}} also supports a simplified method of setting the domain boundary conditions, in which case the user will specify Neumann or Dirichlet values (rather than functions) for each domain side.
These values are usually, but not necessarily, constant values.

In this case one will use an identifier \sphinxcode{\sphinxupquote{\textless{}string\textgreater{} \textless{}float\textgreater{}}} in the input script, like so:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
FieldSolverMultigrid.bc\PYGZus{}x\PYGZus{}low  \PYG{o}{=} neumann   \PYG{l+m}{0}.0
FieldSolverMultigrid.bc\PYGZus{}x\PYGZus{}high \PYG{o}{=} dirichlet \PYG{l+m}{1}.0
\end{sphinxVerbatim}

The floating point number has a slightly different interpretation for the two types of BCs.
Moreover, when using the simplified format the function specified through \sphinxcode{\sphinxupquote{setDomainSideBcFunction}} will be used as a multiplier rather than being parsed directly into the numerical discretization.
Although this may \sphinxstyleemphasis{seem} more involved, this procedure is usually easier to use when setting constant Neumann/Dirichlet values on the domain boundaries.
It also automatically provides a link between a specified voltage wave form and the boundary conditions (unlike the general format, where the user must supply that link themselves).


\paragraph{Dirichlet}
\label{\detokenize{Solvers/Electrostatics:dirichlet}}
When using simplified parsing of Dirichlet domain BCs, \sphinxcode{\sphinxupquote{FieldSolver}} will generate and parse a different function into the discretizations.
This function is \sphinxstyleemphasis{not} the same function as that which is parsed through \sphinxcode{\sphinxupquote{setDomainSideBcFunction}}.
In C++ pseudo\sphinxhyphen{}code, this function is in the format

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n}{dirichletFraction}\PYG{p}{;}

\PYG{k}{auto} \PYG{n}{func} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{n}{func}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Real} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{func}\PYG{p}{(}\PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{*} \PYG{n}{voltage}\PYG{p}{(}\PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{*} \PYG{n}{dirichletFraction}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{voltage}} is the voltage wave form specified through \sphinxcode{\sphinxupquote{FieldSolver::setVoltage}}, and \sphinxcode{\sphinxupquote{dirichletFraction}} is a placeholder for the floating point number specified in the input script, i.e. the floating point number in the input option.
The function \sphinxcode{\sphinxupquote{func(a\_pos, a\_time)}} \sphinxstyleemphasis{is} the space\sphinxhyphen{}time function set through \sphinxcode{\sphinxupquote{setDomainSideBcFunction}}.
Recall that, by default, this function is set to one so that the default voltage that is parsed into the numerical discretization is simply the specified voltage multiplied by the specified fraction in the input script.
For example, using

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
FieldSolverMultigrid.bc\PYGZus{}y\PYGZus{}low  \PYG{o}{=} dirichlet \PYG{l+m}{0}.0
FieldSolverMultigrid.bc\PYGZus{}y\PYGZus{}high \PYG{o}{=} dirichlet \PYG{l+m}{1}.0
\end{sphinxVerbatim}

will the set voltage on the lower y\sphinxhyphen{}plane to ground and the voltage on the upper y\sphinxhyphen{}plane to a live voltage.

In order to set the voltage on the domain side to also be spatially dependent, one can either use \sphinxcode{\sphinxupquote{dirichlet\_custom}} as an input option, or still \sphinxcode{\sphinxupquote{dirichlet \textless{}float\textgreater{}}} and set a different multiplier on the domain edge (face).
As an example. one can specify \sphinxcode{\sphinxupquote{bc\_y\_high = dirichlet 1.234}} in the input script AND set the multiplier on the wall as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{auto} \PYG{n}{wallFunc} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Real} \PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{Real} \PYG{n}{y} \PYG{o}{=} \PYG{n}{a\PYGZus{}pos}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{return} \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setDomainSideBcFunction}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Side}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Hi}\PYG{p}{,} \PYG{n}{wallFunc}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that this will essentially parse a voltage of
\begin{equation*}
\begin{split}V(\mathbf{x},t) = 1.234(1-y)V(t)\end{split}
\end{equation*}
on the upper y\sphinxhyphen{}plane.


\paragraph{Neumann}
\label{\detokenize{Solvers/Electrostatics:neumann}}
When using simplified parsing of Neumann boundary conditions, the procedure is precisely like that for Dirichlet boundary conditions \sphinxstyleemphasis{except} that multiplication by the voltage wave form is not made.
I.e. the boundary condition function that is passed into the numerical discretization is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n}{neumannFraction}\PYG{p}{;}

\PYG{k}{auto} \PYG{n}{func} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZam{}}\PYG{n}{func}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Real} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{func}\PYG{p}{(}\PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{*} \PYG{n}{neumannFraction}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Note that since \sphinxcode{\sphinxupquote{func}} is initialized to one, the floating point number in the input option directly specifies the value of \(\partial_n\Phi\).


\subsection{EB boundary conditions}
\label{\detokenize{Solvers/Electrostatics:eb-boundary-conditions}}\label{\detokenize{Solvers/Electrostatics:chap-poissonebbc}}

\subsubsection{Electrodes}
\label{\detokenize{Solvers/Electrostatics:electrodes}}
For the current \sphinxcode{\sphinxupquote{FieldSolver}} the natural BC at the EB is Dirichlet with a specified voltage, whereas on dielectrics we enforce Eq. \ref{equation:Solvers/Electrostatics:GaussBC}.
The voltage on the electrodes are automatically retrieved from the specified voltages on the electrodes in the geometry being used (see \sphinxcode{\sphinxupquote{ComputationalGeometry}}).
The exception to this is that while \sphinxcode{\sphinxupquote{ComputationalGeometry}} specifies that an electrode will be at some fraction of a specified voltage, \sphinxcode{\sphinxupquote{FieldSolverMultigrid}} uses this fraction \sphinxstyleemphasis{and} the specified voltage wave form in \sphinxcode{\sphinxupquote{setVoltage}}.

To understand how the voltage on the electrode is being set, we first remark that our implementation uses a completely general specification of the voltage on each electrode in both space and time.
This voltage has the form
\begin{equation*}
\begin{split}V_i = V_i\left(\mathbf{x}, t\right).\end{split}
\end{equation*}
where \(V_i\) is the voltage on electrode \(i\).
It is possible to interact with this function directly, doing through all electrodes and setting the electrode to be spatially and temporally varying.
The member function that does this is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{FieldSolver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setElectrodeDirichletFunction}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}electrode}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{ElectrostaticEbBc}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BcFunction}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}function}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here, the type \sphinxcode{\sphinxupquote{ElectrostaticEbBc::BcFunction}} is just an alias:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{using} \PYG{n}{ElectrodestaticEbBc}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BcFunction} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\end{sphinxVerbatim}

The voltage on an electrode \(i\) could thus be set as

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{int} \PYG{n}{electrode}\PYG{p}{;}

\PYG{k}{auto} \PYG{n}{myElectrodeVoltage} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Real}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setElectrodeDirichletFunction}\PYG{p}{(}\PYG{n}{electrode}\PYG{p}{,} \PYG{n}{myElectrodeVoltage}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the return value can be replaced by the user’ function.

In the majority of cases the voltage on electrodes is either a live voltage or ground.
Thus, although the above format is a general way of setting the voltage individually on each electrode (in both space and time) \sphinxcode{\sphinxupquote{FieldSolver}} supports a simpler way of generating these voltage waveforms.
When \sphinxcode{\sphinxupquote{FieldSolver}} is instantiated, it will interally generate these functions through simplified expression such that the user only needs to set a single wave form that applies to all electrodes.
The voltages that are set on the various electrodes are thus in the form:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{int} \PYG{n}{electrode}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{voltageFraction}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)}\PYG{o}{\PYGZgt{}} \PYG{n}{voltageWaveForm}\PYG{p}{;}

\PYG{k}{auto} \PYG{n}{defaultElectrodeVoltage} \PYG{o}{=} \PYG{p}{[}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Real}\PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{voltageFraction} \PYG{o}{*} \PYG{n}{voltageWaveForm}\PYG{p}{(}\PYG{n}{a\PYGZus{}time}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{fieldSolver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setElectrodeDirichletFunction}\PYG{p}{(}\PYG{n}{electrode}\PYG{p}{,} \PYG{n}{defaultElectrodeVoltage}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Thus, the default voltage which is set on an electrode is the voltage \sphinxstyleemphasis{fraction} specified on the electrodes (in \sphinxcode{\sphinxupquote{ComputationalGeometry}}) multiplied by a voltage wave form (specified by \sphinxcode{\sphinxupquote{FieldSolver::setVoltage}}).


\subsubsection{Dielectrics}
\label{\detokenize{Solvers/Electrostatics:dielectrics}}\label{\detokenize{Solvers/Electrostatics:chap-poissondielectricbc}}
As mentioned above, on dielectric interfaces the user can choose to specify which “form” of Eq. \ref{equation:Solvers/Electrostatics:GaussBC} to solve.
If the user wants the natural form in which the surface charge is the free parameter, he can specify

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
FieldSolverMultigrid.which\PYGZus{}jump \PYG{o}{=} natural
\end{sphinxVerbatim}

To use the other format (in which one of the fluxes is specified), use

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
FieldSolverMultigrid.which\PYGZus{}jump \PYG{o}{=} saturation\PYGZus{}charge
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{saturation\_charge}} option will set the derivative of \(\partial_n\Phi\) to zero on the gas side.
Support for setting \(\partial_n\Phi\) to a specified (e.g., non\sphinxhyphen{}zero) value on either side is missing, but is straightforward to implement.
\end{sphinxadmonition}


\subsection{FieldSolverMultigrid}
\label{\detokenize{Solvers/Electrostatics:fieldsolvermultigrid}}\label{\detokenize{Solvers/Electrostatics:chap-fieldsolvermultigrid}}\label{\detokenize{Solvers/Electrostatics:chap-electrostaticdispersion}}
\sphinxcode{\sphinxupquote{FieldSolverMultigrid}} implements a multigrid routine for solving Eq. \ref{equation:Solvers/Electrostatics:Poisson}, and is currently the only implementation of \sphinxcode{\sphinxupquote{FieldSolver}}.

The discretization used by \sphinxcode{\sphinxupquote{FieldSolverMultigrid}} is described in {\hyperref[\detokenize{Source/LinearSolvers:chap-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solvers}}}}.
The underlying solver type is a Helmholtz solver, but \sphinxcode{\sphinxupquote{FieldSolverMultigrid}} considers only the Laplacian term.


\subsubsection{Solver configuration}
\label{\detokenize{Solvers/Electrostatics:solver-configuration}}
\sphinxcode{\sphinxupquote{FieldSolverMultigrid}} has a number of switches for determining how it operates.
Some of these switches are intended for parsing boundary conditions, whereas others are settings for operating multigrid or for I/O.
The current list of configuration options are indicated below

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{c+c1}{\PYGZsh{} FieldSolverMultigrid class options}
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
FieldSolverMultigrid.verbosity         \PYG{o}{=} \PYGZhy{}1                \PYG{c+c1}{\PYGZsh{} Class verbosity}
FieldSolverMultigrid.jump\PYGZus{}bc           \PYG{o}{=} natural           \PYG{c+c1}{\PYGZsh{} Jump BC type (\PYGZsq{}natural\PYGZsq{} or \PYGZsq{}saturation\PYGZus{}charge\PYGZsq{})}
FieldSolverMultigrid.bc.x.lo           \PYG{o}{=} dirichlet \PYG{l+m}{0}.0     \PYG{c+c1}{\PYGZsh{} Bc type (see docs)}
FieldSolverMultigrid.bc.x.hi           \PYG{o}{=} dirichlet \PYG{l+m}{0}.0     \PYG{c+c1}{\PYGZsh{} Bc type (see docs)}
FieldSolverMultigrid.bc.y.lo           \PYG{o}{=} dirichlet \PYG{l+m}{0}.0     \PYG{c+c1}{\PYGZsh{} Bc type (see docs)}
FieldSolverMultigrid.bc.y.hi           \PYG{o}{=} dirichlet \PYG{l+m}{0}.0     \PYG{c+c1}{\PYGZsh{} Bc type (see docs)}
FieldSolverMultigrid.bc.z.lo           \PYG{o}{=} dirichlet \PYG{l+m}{0}.0     \PYG{c+c1}{\PYGZsh{} Bc type (see docs)}
FieldSolverMultigrid.bc.z.hi           \PYG{o}{=} dirichlet \PYG{l+m}{0}.0     \PYG{c+c1}{\PYGZsh{} Bc type (see docs)}
FieldSolverMultigrid.plt\PYGZus{}vars          \PYG{o}{=} phi rho E         \PYG{c+c1}{\PYGZsh{} Plot variables. Possible vars are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}rho\PYGZsq{}, \PYGZsq{}E\PYGZsq{}, \PYGZsq{}res\PYGZsq{}, \PYGZsq{}sigma\PYGZsq{}}
FieldSolverMultigrid.kappa\PYGZus{}source      \PYG{o}{=} \PYG{n+nb}{true}              \PYG{c+c1}{\PYGZsh{} Volume weighted space charge density or not (depends on algorithm)}

FieldSolverMultigrid.gmg\PYGZus{}verbosity     \PYG{o}{=} \PYGZhy{}1                \PYG{c+c1}{\PYGZsh{} GMG verbosity}
FieldSolverMultigrid.gmg\PYGZus{}pre\PYGZus{}smooth    \PYG{o}{=} \PYG{l+m}{12}                \PYG{c+c1}{\PYGZsh{} Number of relaxations in downsweep}
FieldSolverMultigrid.gmg\PYGZus{}post\PYGZus{}smooth   \PYG{o}{=} \PYG{l+m}{12}                \PYG{c+c1}{\PYGZsh{} Number of relaxations in upsweep}
FieldSolverMultigrid.gmg\PYGZus{}bott\PYGZus{}smooth   \PYG{o}{=} \PYG{l+m}{12}                \PYG{c+c1}{\PYGZsh{} Number of at bottom level (before dropping to bottom solver)}
FieldSolverMultigrid.gmg\PYGZus{}min\PYGZus{}iter      \PYG{o}{=} \PYG{l+m}{5}                 \PYG{c+c1}{\PYGZsh{} Minimum number of iterations}
FieldSolverMultigrid.gmg\PYGZus{}max\PYGZus{}iter      \PYG{o}{=} \PYG{l+m}{32}                \PYG{c+c1}{\PYGZsh{} Maximum number of iterations}
FieldSolverMultigrid.gmg\PYGZus{}exit\PYGZus{}tol      \PYG{o}{=} \PYG{l+m}{1}.E\PYGZhy{}10            \PYG{c+c1}{\PYGZsh{} Residue tolerance}
FieldSolverMultigrid.gmg\PYGZus{}exit\PYGZus{}hang     \PYG{o}{=} \PYG{l+m}{0}.2               \PYG{c+c1}{\PYGZsh{} Solver hang}
FieldSolverMultigrid.gmg\PYGZus{}min\PYGZus{}cells     \PYG{o}{=} \PYG{l+m}{16}                \PYG{c+c1}{\PYGZsh{} Bottom drop}
FieldSolverMultigrid.gmg\PYGZus{}bc\PYGZus{}order      \PYG{o}{=} \PYG{l+m}{2}                 \PYG{c+c1}{\PYGZsh{} Boundary condition order for multigrid}
FieldSolverMultigrid.gmg\PYGZus{}bc\PYGZus{}weight     \PYG{o}{=} \PYG{l+m}{2}                 \PYG{c+c1}{\PYGZsh{} Boundary condition weights (for least squares)}
FieldSolverMultigrid.gmg\PYGZus{}jump\PYGZus{}order    \PYG{o}{=} \PYG{l+m}{2}                 \PYG{c+c1}{\PYGZsh{} Boundary condition order for jump conditions}
FieldSolverMultigrid.gmg\PYGZus{}jump\PYGZus{}weight   \PYG{o}{=} \PYG{l+m}{2}                 \PYG{c+c1}{\PYGZsh{} Boundary condition weight for jump conditions (for least squares)}
FieldSolverMultigrid.gmg\PYGZus{}bottom\PYGZus{}solver \PYG{o}{=} bicgstab          \PYG{c+c1}{\PYGZsh{} Bottom solver type. \PYGZsq{}simple\PYGZsq{}, \PYGZsq{}bicgstab\PYGZsq{}, or \PYGZsq{}gmres\PYGZsq{}}
FieldSolverMultigrid.gmg\PYGZus{}cycle         \PYG{o}{=} vcycle            \PYG{c+c1}{\PYGZsh{} Cycle type. Only \PYGZsq{}vcycle\PYGZsq{} supported for now.}
FieldSolverMultigrid.gmg\PYGZus{}smoother      \PYG{o}{=} red\PYGZus{}black         \PYG{c+c1}{\PYGZsh{} Relaxation type. \PYGZsq{}jacobi\PYGZsq{}, \PYGZsq{}multi\PYGZus{}color\PYGZsq{}, or \PYGZsq{}red\PYGZus{}black\PYGZsq{}}
\end{sphinxVerbatim}

Note that \sphinxstyleemphasis{all} options pertaining to IO or multigrid are run\sphinxhyphen{}time configurable (see {\hyperref[\detokenize{Base/Control:chap-runtimeconfig}]{\sphinxcrossref{\DUrole{std,std-ref}{Run\sphinxhyphen{}time configurations}}}}).


\subsubsection{Setting boundary conditions}
\label{\detokenize{Solvers/Electrostatics:setting-boundary-conditions}}
The flags that are in the format \sphinxcode{\sphinxupquote{bc.coord.side}} (e.g., \sphinxcode{\sphinxupquote{bc.x.low}}) parse the domain boundary condition type to the solver.
See {\hyperref[\detokenize{Solvers/Electrostatics:chap-poissondomainbc}]{\sphinxcrossref{\DUrole{std,std-ref}{Domain boundary conditions}}}} for details.

The flag \sphinxcode{\sphinxupquote{jump\_bc}} indicates how the dielectric jump condition is enforced.
See {\hyperref[\detokenize{Solvers/Electrostatics:chap-poissondielectricbc}]{\sphinxcrossref{\DUrole{std,std-ref}{Dielectrics}}}} for additional details.

\begin{sphinxadmonition}{note}{Note:}
Currently, we only solve the dielectric jump condition on gas\sphinxhyphen{}dielectric interfaces and dielectric\sphinxhyphen{}dielectric interfaces are not supported.
If you want to use numerical mock\sphinxhyphen{}ups of dielectric\sphinxhyphen{}dielectric interfaces, you can change \(\epsilon_r\) inside a dielectric, but note that the dielectric boundary condition \(\partial_{n_1}\Phi + \partial_{n_2}\Phi = \sigma/\epsilon_0\) is \sphinxstyleemphasis{not} solved in this case.
\end{sphinxadmonition}


\subsubsection{Algorithmic adjustments}
\label{\detokenize{Solvers/Electrostatics:algorithmic-adjustments}}
By default, the Helmholtz operator uses a diagonally weighting of the operator using the volume fraction as weight.
This means that the quantity that is passed into \sphinxcode{\sphinxupquote{AMRMultiGrid}} should be weighted by the volume fraction to avoid the small\sphinxhyphen{}cell problem of EB grids.
The flag \sphinxcode{\sphinxupquote{kappa\_source}} indicates whether or not we should multiply the right\sphinxhyphen{}hand side by the volume fraction before passing it into the solver routine.
If this flag is set to \sphinxcode{\sphinxupquote{false}}, it is an indication that the user has taken responsibility to perform this weighting prior to calling \sphinxcode{\sphinxupquote{FieldSolver::solve(...)}}.
If this flag is set to \sphinxcode{\sphinxupquote{true}}, \sphinxcode{\sphinxupquote{FieldSolverMultigrid}} will perform the multiplication before the multigrid solve.


\subsubsection{Tuning multigrid performance}
\label{\detokenize{Solvers/Electrostatics:tuning-multigrid-performance}}
Multigrid operates by coarsening the solution (and the geometry with it) on a hierarchy of grid levels, and smoothing the solution on each level.
There are a number of factors that influence the multigrid performance.
Often the most critical factors are the radius of the cut\sphinxhyphen{}cell stencils and how far multigrid is allowed to coarsen.
In addition, the multigrid convergence is improved by increasing the number of smoothings per grid level (up to a certain point), as well as the type of smoother and bottom solver being used.
We explain these options below:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_verbosity}}.
Controls the multigrid verbosity.
Setting it to a number \(> 0\) will print multigrid convergence information.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_pre\_smooth}}.
Controls the number of relaxations on each level during multigrid downsweeps.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_post\_smooth}}.
Controls the number of relaxations on each level during multigrid upsweeps.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_bott\_smooth}}.
Controls the number of relaxations before entering the bottom solve.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_min\_iter}}.
Sets the minimum number of iterations that multigrid will perform.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_max\_iter}}.
Sets the maximum number of iterations that multigrid will perform.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_exit\_tol}}.
Sets the exit tolerance for multigrid.
Multigrid will exit the iterations if \(r < \lambda r_0\) where \(\lambda\) is the specified tolerance, \(r = |L\Phi -\rho|\) is the residual and \(r_0\) is the residual for \(\Phi = 0\).

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_exit\_hang}}.
Sets the minimum permitted reduction in the convergence rate before exiting multigrid.
Letting \(r^k\) be the residual after \(k\) multigrid cycles, multigrid will abort if the residual between levels is not reduce by at least a factor of \(r^{k+1} < (1-h)r^k\), where \(h\) is the “hang” factor.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_min\_cells}}.
Sets the minimum amount of cells along any coordinate direction for coarsened levels.
Note that this will control how far multigrid will coarsen. Setting a number \sphinxcode{\sphinxupquote{gmg\_min\_cells = 16}} will terminate multigrid coarsening when the domain has 16 cells in any of the coordinate direction.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_bc\_order}}.
Sets the stencil order for Dirichlet boundary conditions (on electrodes).
Note that this is also the stencil radius.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_bc\_weight}}. Sets the least squares stencil weighting factor for least squares gradient reconstruction on EBs.
See {\hyperref[\detokenize{Utilities/LeastSquares:chap-leastsquares}]{\sphinxcrossref{\DUrole{std,std-ref}{Least squares}}}} for details.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_jump\_order}}. Sets the stencil order when performing least squares gradient reconstruction on dielectric interfaces.
Note that this is also the stencil radius.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_jump\_weight}}.
Sets the least squares stencil weighting factor for least squares gradient reconstruction on dielectric interfaces.
See {\hyperref[\detokenize{Utilities/LeastSquares:chap-leastsquares}]{\sphinxcrossref{\DUrole{std,std-ref}{Least squares}}}} for details.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_bottom\_solver}}.
Sets the bottom solver type.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_cycle}}.
Sets the multigrid method.
Currently, only V\sphinxhyphen{}cycles are supported.

\item {} 
\sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_smoother}}.
Sets the multigrid smoother.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
When setting the bottom solver (which by default is a biconjugate gradient stabilized method) to a regular smoother, one must also specify the number of smoothings to perform.
E.g., \sphinxcode{\sphinxupquote{FieldSolverMultigrid.gmg\_bottom\_solver = simple 64}}.
Setting the bottom solver to \sphinxcode{\sphinxupquote{simple}} without specifying the number of smoothings that will be performed will issue a run\sphinxhyphen{}time error.
\end{sphinxadmonition}


\subsubsection{Adjusting output}
\label{\detokenize{Solvers/Electrostatics:adjusting-output}}
The user may plot the potential, the space charge, the electric, and the GMG residue as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
FieldSolverMultigrid.plt\PYGZus{}vars  \PYG{o}{=} phi rho E res     \PYG{c+c1}{\PYGZsh{} Plot variables. Possible vars are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}rho\PYGZsq{}, \PYGZsq{}E\PYGZsq{}, \PYGZsq{}res\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{Frequency dependent permittivity}
\label{\detokenize{Solvers/Electrostatics:frequency-dependent-permittivity}}
Frequency\sphinxhyphen{}dependent permittivities are fundamentally supported by the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} elliptic discretization but none of the solvers implement it.
Recall that the polarization (in frequency space) is
\begin{equation*}
\begin{split}\mathbf{P}(\omega) = \epsilon_0\chi(\omega)\mathbf{E}(\omega),\end{split}
\end{equation*}
where \(\chi(\omega)\) is the dielectric susceptibility.

There are two forms that \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} can support frequency dependent permittivities; through convolution or through auxiliary differential equations (ADEs).


\subsubsection{Convolution approach}
\label{\detokenize{Solvers/Electrostatics:convolution-approach}}
In the time domain, the displacement field is.
\begin{equation*}
\begin{split}\mathbf{D}(t_k) = \epsilon_0\mathbf{E}(t_k) + \epsilon_0\int_0^{t_k} \chi(t)\mathbf{E}(t_k-t)\text{d}t.\end{split}
\end{equation*}
There are various forms of discretizing the integral.
E.g. with the trapezoidal rule then
\begin{equation*}
\begin{split}\begin{split}
\int_0^{t_k}\chi(t)\mathbf{E}(t-t)\text{d}t &= \sum_{n=0}^{k-1} \int_{t_n}^{t_{n+1}}\chi(t)\mathbf{E}(t_k-t)\text{d}t \\
&\approx \frac{1}{2}\sum_{n=0}^{k-1}\Delta t_n\left[\chi(t_n)\mathbf{E}(t_k-t_n) + \chi(t_{n+1})\mathbf{E}(t_k-t_{n+1})\right] \\
&= \frac{\Delta t_0}{2}\chi_0\mathbf{E}(t_k) + \frac{1}{2}\sum_{n=1}^{k-1}\Delta t_n\chi_n\mathbf{E}(t_k-t_n) + \frac{1}{2}\sum_{n=0}^{k-1}\Delta t_n\chi_{n+1}\mathbf{E}(t_k-t_{n+1})
\end{split}\end{split}
\end{equation*}
The Gauss law becomes
\begin{equation*}
\begin{split}\begin{split}
\nabla\cdot\left[\left(1+\frac{\chi_0\Delta t_0}{2}\right)\mathbf{E}(t_k)\right] &= \frac{\rho(t_k)}{\epsilon_0}\\
&- \nabla\cdot\left[\frac{1}{2}\sum_{n=1}^{k-1}\Delta t_n\chi_n\mathbf{E}(t_k-t_n) + \frac{1}{2}\sum_{n=0}^{k-1}\Delta t_n\chi_{n+1}\mathbf{E}(t_k-t_{n+1})\right].
\end{split}\end{split}
\end{equation*}
Note that the dispersion enters as an extra term on the right\sphinxhyphen{}hand side, emulating a space charge.
Unfortunately, inclusion of dispersion means that we must store \(\mathbf{E}(t_n)\) for all previous time steps.


\subsubsection{Auxiliary differential equation}
\label{\detokenize{Solvers/Electrostatics:auxiliary-differential-equation}}
With the ADE approach we seek a solution to \(\mathbf{P}(\omega) = \epsilon_0\chi(\omega)\mathbf{E}(\omega)\) in the form
\begin{equation*}
\begin{split}\sum_k a_k(i\omega)^k\mathbf{P}(\omega) = \epsilon_0\mathbf{E}(\omega),\end{split}
\end{equation*}
where \(\sum a_k(i\omega)^k\) is the Taylor series for \(1/\chi(\omega)\).
This can be written as a partial differential equation
\begin{equation*}
\begin{split}\sum_{k}a_k\partial_t^k\mathbf{P}(t) = \epsilon_0\mathbf{E}(t).\end{split}
\end{equation*}
This equation can be discretized using finite differences, and centering the solution on \(t_k\) with backward differences yields an expression
\begin{equation*}
\begin{split}\mathbf{P}^k = \epsilon_0C_0^k\mathbf{E}^k - \sum_{m>0} C_m^k\mathbf{P}^{k-m}.\end{split}
\end{equation*}
where \(C_k\) are stencil coefficients to be worked out for each case.
The displacement field \(\mathbf{D}^k = \epsilon_0 \mathbf{E}^k + \mathbf{P}^k\) is then
\begin{equation*}
\begin{split}\mathbf{D} = \epsilon_0(1 + C_0^k)\mathbf{E} - \sum_{m>0} C_m^k\mathbf{P}^{k-m}.\end{split}
\end{equation*}
The Gauss law yields
\begin{equation*}
\begin{split}\nabla\cdot\left[\left(1 + C_0^k\right)\mathbf{E}^k\right] = \frac{\rho}{\epsilon_0} - \frac{1}{\epsilon_0}\nabla\cdot\sum_{m>0} C_m^k\mathbf{P}^{k-m}.\end{split}
\end{equation*}
Unlike the convolution approach, this only requires storing terms required for the ADE description.
This depends both on the order of the ADE, as well as it’s discretization.
Normally, the ADE is a low\sphinxhyphen{}order PDE and a few terms are sufficient.


\subsection{Limitations}
\label{\detokenize{Solvers/Electrostatics:limitations}}
\begin{sphinxadmonition}{warning}{Warning:}
There is currently a bug where having a dielectric interface align \sphinxstyleemphasis{completely} with a grid face will cause the cell to be identified as an electrode EB.
This bug is due to the way \sphinxcode{\sphinxupquote{Chombo}} handles cut\sphinxhyphen{}cells that align completely with a grid face.
In this case the cell with volume fraction \(\kappa = 1\) will be identified as an irregular cell.
For the opposite phase (i.e., viewing the grids from inside the boundary) the situation is opposite and thus the two “matching cells” can appear in different grid patches.
A fix for this is underway.
In the meantime, a sufficient workaround is simply to displace the dielectric slightly away from the interface (any non\sphinxhyphen{}zero displacement will do).
\end{sphinxadmonition}


\subsection{Example application}
\label{\detokenize{Solvers/Electrostatics:example-application}}
An example application of usage of the \sphinxcode{\sphinxupquote{FieldSolver}} is found in {\hyperref[\detokenize{Applications/ElectrostaticsModel:chap-electrostaticsmodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Electrostatics}}}}.


\section{Mesh ODE solver}
\label{\detokenize{Solvers/MeshODESolver:mesh-ode-solver}}\label{\detokenize{Solvers/MeshODESolver:chap-meshodesolver}}\label{\detokenize{Solvers/MeshODESolver::doc}}

\section{Radiative transfer}
\label{\detokenize{Solvers/RTE:radiative-transfer}}\label{\detokenize{Solvers/RTE:chap-radiativetransfer}}\label{\detokenize{Solvers/RTE::doc}}
Radiative transfer is supported in the diffusion (i.e. Eddington or Helmholtz) approximation and with Monte Carlo sampling of discrete photons.
The solvers share a common interface (a parent class), but note that the radiative transfer equation is inherently deterministic while Monte Carlo photon transport is inherently stochastic.
The diffusion approximation relies on solving an elliptic equation in the stationary case and a parabolic equation in the time\sphinxhyphen{}dependent case, while the Monte\sphinxhyphen{}Carlo approach solves solves for fully transient or ‘’stationary’’ transport.


\subsection{RtSpecies}
\label{\detokenize{Solvers/RTE:rtspecies}}\label{\detokenize{Solvers/RTE:chap-rtspecies}}
The class \sphinxcode{\sphinxupquote{RtSpecies}} is an abstract base class for parsing necessary information into radiative transfer solvers.
When creating a radiative transfer solver one will need to pass in a pointer to \sphinxcode{\sphinxupquote{RtSpecies}} such that the solvers can look up the required infromation.
Currently, \sphinxcode{\sphinxupquote{RtSpecies}} is a lightweight class where the user needs to implement the function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{n}{Real} \PYG{n}{RtSpecies}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getAbsorptionCoefficient}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The absorption coefficient is used in the diffusion (see {\hyperref[\detokenize{Solvers/RTE:chap-diffusionrte}]{\sphinxcrossref{\DUrole{std,std-ref}{Diffusion approximation}}}}) and Monte Carlo (see {\hyperref[\detokenize{Solvers/RTE:chap-montecarlorte}]{\sphinxcrossref{\DUrole{std,std-ref}{Monte Carlo methods}}}}) solvers.

One can also assign a name to the species through the member variable \sphinxcode{\sphinxupquote{RtSpecies::m\_name}}.


\subsection{RtSolver}
\label{\detokenize{Solvers/RTE:rtsolver}}\label{\detokenize{Solvers/RTE:chap-rtsolver}}
\sphinxcode{\sphinxupquote{RtSolver}} is the base class for encapsulating a radiative transfer solver.
The source code for the solver is located in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Source/RadiativeTransfer}} and it is a fairly lightweight abstract class.
As with other solvers, \sphinxcode{\sphinxupquote{RtSolver}} can use a specified {\hyperref[\detokenize{Source/Realm:chap-realm}]{\sphinxcrossref{\DUrole{std,std-ref}{Realm}}}}.

To use the \sphinxcode{\sphinxupquote{RtSolver}} interface the user must cast from one of the inherited classes (see {\hyperref[\detokenize{Solvers/RTE:chap-diffusionrte}]{\sphinxcrossref{\DUrole{std,std-ref}{Diffusion approximation}}}} or {\hyperref[\detokenize{Solvers/RTE:chap-montecarlorte}]{\sphinxcrossref{\DUrole{std,std-ref}{Monte Carlo methods}}}}).
Since most of the \sphinxcode{\sphinxupquote{RtSolver}} is an interface which is implemented by other radiative transfer solvers, documentation of boundary conditions, kernels and so on are found in the implementation classes.


\subsection{Diffusion approximation}
\label{\detokenize{Solvers/RTE:diffusion-approximation}}\label{\detokenize{Solvers/RTE:chap-diffusionrte}}

\subsubsection{EddingtonSP1}
\label{\detokenize{Solvers/RTE:eddingtonsp1}}
The first\sphinxhyphen{}order diffusion approximation to the radiative transfer equation is encapsulated by the \sphinxcode{\sphinxupquote{EddingtonSP1}} class which implements a first order Eddington approximation of the radiative transfer equation.
\sphinxcode{\sphinxupquote{EddingtonSP1}} implements \sphinxcode{\sphinxupquote{RtSolver}} using both stationary and transient advance methods (e.g. for stationary or time\sphinxhyphen{}dependent radiative transport).
The source code is located in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/RadiativeTransfer}}.


\subsubsection{Equation of motion}
\label{\detokenize{Solvers/RTE:equation-of-motion}}
In the diffusion approximation, the radiative transport equation is
\begin{equation}\label{equation:Solvers/RTE:TransientDiffusionRTE}
\begin{split}\partial_t\Psi + \kappa\Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi\right) = \frac{\eta}{c},\end{split}
\end{equation}
where \(\kappa\) is the absorption coefficient (i.e., inverse absorption length).
Note that in the context below, \(\kappa\) is \sphinxstyleemphasis{not} the volume fraction of a grid cell.
This is called the Eddington approximation, and the radiative flux is \(F = -\frac{c}{3\kappa}\nabla \Psi\).

In the stationary case this yields a Helmholtz equation
\begin{equation}\label{equation:Solvers/RTE:StationaryDiffusionRTE}
\begin{split}\kappa\Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi\right) = \frac{\eta}{c},\end{split}
\end{equation}

\subsubsection{Implementation}
\label{\detokenize{Solvers/RTE:implementation}}
\sphinxcode{\sphinxupquote{EddingtonSP1}} uses multigrid methods for solving Eq. \ref{equation:Solvers/RTE:TransientDiffusionRTE} and Eq. \ref{equation:Solvers/RTE:StationaryDiffusionRTE}, see {\hyperref[\detokenize{Source/LinearSolvers:chap-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solvers}}}}.
The class implements \sphinxcode{\sphinxupquote{RtSolver::advance()}}, which can switch between Eq. \ref{equation:Solvers/RTE:TransientDiffusionRTE} and Eq. \ref{equation:Solvers/RTE:StationaryDiffusionRTE}.
Note that for both the stationary and time\sphinxhyphen{}dependent cases the absorption coefficient \(\kappa\) in Eq. \ref{equation:Solvers/RTE:TransientDiffusionRTE} and Eq. \ref{equation:Solvers/RTE:StationaryDiffusionRTE} are filled using the \sphinxcode{\sphinxupquote{RtSpecies}} implementation provided to the solver.
Also note that the absorption coefficient does not need to be constant in space.


\paragraph{Stationary kernel}
\label{\detokenize{Solvers/RTE:stationary-kernel}}
For the stationary kernel we solve Eq. \ref{equation:Solvers/RTE:StationaryDiffusionRTE} directly, using a single multigrid solve.
See {\hyperref[\detokenize{Source/LinearSolvers:chap-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solvers}}}} for discretization details.


\paragraph{Transient kernel}
\label{\detokenize{Solvers/RTE:transient-kernel}}
For solving Eq. \ref{equation:Solvers/RTE:TransientDiffusionRTE}, \sphinxcode{\sphinxupquote{EddingtonSP1}} implements both the backward Euler method and the Twizell\sphinxhyphen{}Gumel\sphinxhyphen{}Arigu (TGA) scheme.
Explicit discretizations are not available.
The Euler discretization is
\begin{equation*}
\begin{split}\left(1+ \kappa \Delta t\right)\Psi^{k+1} - \Delta t \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi^{k+1}\right) = \Psi^{k} + \frac{\Delta t\eta^{k+1}}{c},\end{split}
\end{equation*}
Again, this is a Helmholtz equation for \sphinxtitleref{Psi\textasciicircum{}\{k+1\}} which is solved using geometric multigrid.
Expressions for the TGA scheme are found in {[}\hyperlink{cite.ZZReferences:id34}{9}{]}, but note that the TGA scheme requires a solution to two elliptic equations (thus it has approximately twice the cost).


\subsubsection{Boundary conditions}
\label{\detokenize{Solvers/RTE:boundary-conditions}}\label{\detokenize{Solvers/RTE:chap-eddingtonsp1bc}}

\paragraph{Simplified domain boundary conditions}
\label{\detokenize{Solvers/RTE:simplified-domain-boundary-conditions}}
The \sphinxcode{\sphinxupquote{EddingtonSP1}} solver supports the following boundary conditions on domain faces and EBs.
The domain boundary condition \sphinxstyleemphasis{type}, which is either Dirichlet, Neumann, or Larsen (a special type of Robin boundary condition) is always passed in through the input file.
If the user passes in a value, say \sphinxcode{\sphinxupquote{neumann 0.0}}, for a particular domain side/face, then the class will use a homogeneous Neumann boundary for the entire domain edge/face.


\paragraph{Custom domain boundary conditions}
\label{\detokenize{Solvers/RTE:custom-domain-boundary-conditions}}
It is possible to use more complex boundary conditions by passing in \sphinxcode{\sphinxupquote{dirichlet\_custom}}, \sphinxcode{\sphinxupquote{neumann\_custom}}, or \sphinxcode{\sphinxupquote{larsen\_custom}} options.
In this case the \sphinxcode{\sphinxupquote{EddingtonSP1}} solver will use a specified function at the domain edge/face.
To specify that function, \sphinxcode{\sphinxupquote{EddingtonSP1}} has a member function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{setDomainSideBcFunction}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}dir}\PYG{p}{,}
                             \PYG{k}{const} \PYG{n}{Side}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LoHiSide} \PYG{n}{a\PYGZus{}side}\PYG{p}{,}
                             \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}function}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

which species a boundary condition value for one of the edges (faces in 3D).
Note that the boundary condition \sphinxstyleemphasis{type} is still Dirichlet, Neumann, or Larsen (depending on whether or not \sphinxcode{\sphinxupquote{dirichlet\_custom}}, \sphinxcode{\sphinxupquote{neumann\_custom}}, or \sphinxcode{\sphinxupquote{larsen\_custom}} was passed in).
For example, to set the boundary condition on the left \(x\) face in the domain, one can create a \sphinxcode{\sphinxupquote{EddingtonSP1DomainBc::BcFunction}} object as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume this has been instantiated.}
\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{EddingtonSP1}\PYG{o}{\PYGZgt{}} \PYG{n}{eddingtonSolver}\PYG{p}{;}

\PYG{c+c1}{// Make a lambda which we can bind to std::function.}
\PYG{k}{auto} \PYG{n}{myValue} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Real} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{a\PYGZus{}pos}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{a\PYGZus{}time}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Set the domain bc function in the solver.}
\PYG{n}{eddingtonSolver}\PYG{p}{.}\PYG{n}{setDomainSideBcFunction}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Side}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Lo}\PYG{p}{,} \PYG{n}{myValue}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If the user specifies one of the custom boundary conditions but does not set the function, it will issue a run\sphinxhyphen{}time error.
\end{sphinxadmonition}


\paragraph{Embedded boundaries}
\label{\detokenize{Solvers/RTE:embedded-boundaries}}
On the EB, we currently only support constant\sphinxhyphen{}value boundary conditions.
In the input script, the user can specify
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{dirichlet \textless{}value\textgreater{}}} For setting a constant Dirichlet boundary condition everywhere.

\item {} 
\sphinxcode{\sphinxupquote{neumann \textless{}value\textgreater{}}} For setting a constant Neumann boundary condition everywhere.

\item {} 
\sphinxcode{\sphinxupquote{larsen \textless{}value\textgreater{}}} For setting a constant Larsen boundary condition everywhere.

\end{itemize}


\paragraph{Boundary condition types}
\label{\detokenize{Solvers/RTE:boundary-condition-types}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstylestrong{Dirichlet}.
For Dirichlet boundary conditions we specify the value of \(\Psi\) on the boundary.
Note that this involves reconstructing the gradient \(\partial_n\Psi\) on domain faces and edges, see \DUrole{xref,std,std-ref}{Chap:LinearSolversDirichletBC}.

\item {} 
\sphinxstylestrong{Neumann}.
For Neumann boundary conditions we specify the value of \(\partial_n\Psi\) on the boundary.
Note that the linear solver interface also supports setting \(B\partial_n\Psi\) on the boundary (where \(B\) is the Helmholtz equation \(B\) coefficient).
However, the \sphinxcode{\sphinxupquote{EddingtonSP1}} solver does not use this functionality.

\item {} 
\sphinxstylestrong{Larsen}.
The Larsen boundary condition is an absorbing boundary condition, taking the form of a Robin boundary as follows:
\begin{equation*}
\begin{split}\kappa\partial_n\Psi + \frac{3\kappa^2}{2}\frac{1-3r_2}{1-2r_1}\Psi = g,\end{split}
\end{equation*}
where \(r_1\) and \(r_2\) are reflection coefficients and \(g\) is a surface source, see {[}\hyperlink{cite.ZZReferences:id51}{6}{]} for details.
Note that when the user specifies the boundary condition value (e.g. by setting the BC function), he is setting the surface sourge \(g\).
In the majority of cases, however, we will have \(r_1 = r_2 = g = 0\) and the BC becomes
\begin{equation*}
\begin{split}\partial_n\Psi + \frac{3\kappa}{2}\Psi = 0.\end{split}
\end{equation*}
\end{enumerate}


\subsubsection{Solver configuration}
\label{\detokenize{Solvers/RTE:solver-configuration}}
The \sphinxcode{\sphinxupquote{EddingtonSP1}} implementation has a number of configurable options for running the solver, and these are given below:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{c+c1}{\PYGZsh{} EddingtonSP1 class options}
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
EddingtonSP1.stationary          \PYG{o}{=} \PYG{n+nb}{true}         \PYG{c+c1}{\PYGZsh{} Stationary solver}
EddingtonSP1.reflectivity        \PYG{o}{=} \PYG{l+m}{0}.           \PYG{c+c1}{\PYGZsh{} Reflectivity}
EddingtonSP1.use\PYGZus{}tga             \PYG{o}{=} \PYG{n+nb}{false}        \PYG{c+c1}{\PYGZsh{} Use TGA for integration}
EddingtonSP1.kappa\PYGZus{}scale         \PYG{o}{=} \PYG{n+nb}{true}         \PYG{c+c1}{\PYGZsh{} Kappa scale source or not (depends on algorithm)}
EddingtonSP1.plt\PYGZus{}vars            \PYG{o}{=} phi src      \PYG{c+c1}{\PYGZsh{} Plot variables. Available are \PYGZsq{}phi\PYGZsq{} and \PYGZsq{}src\PYGZsq{}}

EddingtonSP1.ebbc                \PYG{o}{=} larsen \PYG{l+m}{0}.0   \PYG{c+c1}{\PYGZsh{} Bc on embedded boundaries}
EddingtonSP1.bc.x.lo             \PYG{o}{=} larsen \PYG{l+m}{0}.0   \PYG{c+c1}{\PYGZsh{} Bc on domain side. \PYGZsq{}dirichlet\PYGZsq{}, \PYGZsq{}neuman\PYGZsq{}, or \PYGZsq{}larsen\PYGZsq{}}
EddingtonSP1.bc.x.hi             \PYG{o}{=} larsen \PYG{l+m}{0}.0   \PYG{c+c1}{\PYGZsh{} Bc on domain side. \PYGZsq{}dirichlet\PYGZsq{}, \PYGZsq{}neuman\PYGZsq{}, or \PYGZsq{}larsen\PYGZsq{}}
EddingtonSP1.bc.y.lo             \PYG{o}{=} larsen \PYG{l+m}{0}.0   \PYG{c+c1}{\PYGZsh{} Bc on domain side. \PYGZsq{}dirichlet\PYGZsq{}, \PYGZsq{}neuman\PYGZsq{}, or \PYGZsq{}larsen\PYGZsq{}}
EddingtonSP1.bc.y.hi             \PYG{o}{=} larsen \PYG{l+m}{0}.0   \PYG{c+c1}{\PYGZsh{} Bc on domain side. \PYGZsq{}dirichlet\PYGZsq{}, \PYGZsq{}neuman\PYGZsq{}, or \PYGZsq{}larsen\PYGZsq{}}
EddingtonSP1.bc.z.lo             \PYG{o}{=} larsen \PYG{l+m}{0}.0   \PYG{c+c1}{\PYGZsh{} Bc on domain side. \PYGZsq{}dirichlet\PYGZsq{}, \PYGZsq{}neuman\PYGZsq{}, or \PYGZsq{}larsen\PYGZsq{}}
EddingtonSP1.bc.z.hi             \PYG{o}{=} larsen \PYG{l+m}{0}.0   \PYG{c+c1}{\PYGZsh{} Bc on domain side. \PYGZsq{}dirichlet\PYGZsq{}, \PYGZsq{}neuman\PYGZsq{}, or \PYGZsq{}larsen\PYGZsq{}}
EddingtonSP1.bc.z.hi             \PYG{o}{=} larsen \PYG{l+m}{0}.0   \PYG{c+c1}{\PYGZsh{} Boundary on domain. \PYGZsq{}neumann\PYGZsq{} or \PYGZsq{}larsen\PYGZsq{}}

EddingtonSP1.gmg\PYGZus{}verbosity       \PYG{o}{=} \PYGZhy{}1           \PYG{c+c1}{\PYGZsh{} GMG verbosity}
EddingtonSP1.gmg\PYGZus{}pre\PYGZus{}smooth      \PYG{o}{=} \PYG{l+m}{8}            \PYG{c+c1}{\PYGZsh{} Number of relaxations in downsweep}
EddingtonSP1.gmg\PYGZus{}post\PYGZus{}smooth     \PYG{o}{=} \PYG{l+m}{8}            \PYG{c+c1}{\PYGZsh{} Number of relaxations in upsweep}
EddingtonSP1.gmg\PYGZus{}bott\PYGZus{}smooth     \PYG{o}{=} \PYG{l+m}{8}            \PYG{c+c1}{\PYGZsh{} NUmber of relaxations before dropping to bottom solver}
EddingtonSP1.gmg\PYGZus{}min\PYGZus{}iter        \PYG{o}{=} \PYG{l+m}{5}            \PYG{c+c1}{\PYGZsh{} Minimum number of iterations}
EddingtonSP1.gmg\PYGZus{}max\PYGZus{}iter        \PYG{o}{=} \PYG{l+m}{32}           \PYG{c+c1}{\PYGZsh{} Maximum number of iterations}
EddingtonSP1.gmg\PYGZus{}exit\PYGZus{}tol        \PYG{o}{=} \PYG{l+m}{1}.E\PYGZhy{}6        \PYG{c+c1}{\PYGZsh{} Residue tolerance}
EddingtonSP1.gmg\PYGZus{}exit\PYGZus{}hang       \PYG{o}{=} \PYG{l+m}{0}.2          \PYG{c+c1}{\PYGZsh{} Solver hang}
EddingtonSP1.gmg\PYGZus{}min\PYGZus{}cells       \PYG{o}{=} \PYG{l+m}{16}           \PYG{c+c1}{\PYGZsh{} Bottom drop}
EddingtonSP1.gmg\PYGZus{}bottom\PYGZus{}solver   \PYG{o}{=} bicgstab     \PYG{c+c1}{\PYGZsh{} Bottom solver type. Valid options are \PYGZsq{}simple \PYGZlt{}number\PYGZgt{}\PYGZsq{} and \PYGZsq{}bicgstab\PYGZsq{}}
EddingtonSP1.gmg\PYGZus{}cycle           \PYG{o}{=} vcycle       \PYG{c+c1}{\PYGZsh{} Cycle type. Only \PYGZsq{}vcycle\PYGZsq{} supported for now}
EddingtonSP1.gmg\PYGZus{}ebbc\PYGZus{}weight     \PYG{o}{=} \PYG{l+m}{2}            \PYG{c+c1}{\PYGZsh{} EBBC weight (only for Dirichlet)}
EddingtonSP1.gmg\PYGZus{}ebbc\PYGZus{}order      \PYG{o}{=} \PYG{l+m}{2}            \PYG{c+c1}{\PYGZsh{} EBBC order (only for Dirichlet)}
EddingtonSP1.gmg\PYGZus{}smoother        \PYG{o}{=} red\PYGZus{}black    \PYG{c+c1}{\PYGZsh{} Relaxation type. \PYGZsq{}jacobi\PYGZsq{}, \PYGZsq{}red\PYGZus{}black\PYGZsq{}, or \PYGZsq{}multi\PYGZus{}color\PYGZsq{}}
\end{sphinxVerbatim}


\paragraph{Basic options}
\label{\detokenize{Solvers/RTE:basic-options}}
Basic input options to \sphinxcode{\sphinxupquote{EddingtonSP1}} are as follows:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.stationary}} for setting whether or not the solver is stationary.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.reflectivity}} for controlling the reflectivity in the Larsen boundary conditions.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.use\_tga}} for switching between backward Euler and TGA time discretizations.
Only relevant if \sphinxcode{\sphinxupquote{EddingtonSP1.stationary = false}}.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.kappa\_scale}} Switch for multiplying the source with with the volume fraction or not.
Note that the multigrid Helmholtz solvers require a diagonal weighting of the operator.
If \sphinxcode{\sphinxupquote{EddingtonSP1.kappa\_scale = false}} then the solver will assume that this weighting of the source term has already been made.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.plt\_vars}} For setting which solver plot variables are included in plot files.

\end{itemize}


\paragraph{Setting boundary conditions}
\label{\detokenize{Solvers/RTE:setting-boundary-conditions}}
Boundary conditions are parsed through the flags
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.ebbc}} Which sets the boundary conditions on the EBs.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.bc.dim.side}} Which sets the boundary conditions on the domain sides, see {\hyperref[\detokenize{Solvers/RTE:chap-eddingtonsp1bc}]{\sphinxcrossref{\DUrole{std,std-ref}{Boundary conditions}}}} for details.

\end{itemize}


\paragraph{Tuning multigrid performance}
\label{\detokenize{Solvers/RTE:tuning-multigrid-performance}}
All parameters that begin with the form \sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_}} indicate a tuning parameter for geometric multigrid.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_verbosity}}.
Controls the multigrid verbosity.
Setting it to a number \(> 0\) will print multigrid convergence information.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_pre\_smooth}}.
Controls the number of relaxations on each level during multigrid downsweeps.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_post\_smooth}}.
Controls the number of relaxations on each level during multigrid upsweeps.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_bott\_smooth}}.
Controls the number of relaxations before entering the bottom solve.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_min\_iter}}.
Sets the minimum number of iterations that multigrid will perform.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_max\_iter}}.
Sets the maximum number of iterations that multigrid will perform.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_exit\_tol}}.
Sets the exit tolerance for multigrid.
Multigrid will exit the iterations if \(r < \lambda r_0\) where \(\lambda\) is the specified tolerance, \(r = |L\Phi -\rho|\) is the residual and \(r_0\) is the residual for \(\Phi = 0\).

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_exit\_hang}}.
Sets the minimum permitted reduction in the convergence rate before exiting multigrid.
Letting \(r^k\) be the residual after \(k\) multigrid cycles, multigrid will abort if the residual between levels is not reduce by at least a factor of \(r^{k+1} < (1-h)r^k\), where \(h\) is the “hang” factor.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_min\_cells}}.
Sets the minimum amount of cells along any coordinate direction for coarsened levels.
Note that this will control how far multigrid will coarsen. Setting a number \sphinxcode{\sphinxupquote{gmg\_min\_cells = 16}} will terminate multigrid coarsening when the domain has 16 cells in any of the coordinate direction.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_bottom\_solver}}.
Sets the bottom solver type.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_cycle}}.
Sets the multigrid method.
Currently, only V\sphinxhyphen{}cycles are supported.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_ebbc\_order}}.
Sets the stencil order on EBs when using Dirichlet boundary conditions.
Note that this is also the stencil radius.
See {\hyperref[\detokenize{Source/LinearSolvers:chap-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solvers}}}} for details.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_ebbc\_weight}}.
Sets the least squares stencil weighting factor for least squares gradient reconstruction on EBs when using Dirichlet boundary conditions.
See {\hyperref[\detokenize{Utilities/LeastSquares:chap-leastsquares}]{\sphinxcrossref{\DUrole{std,std-ref}{Least squares}}}} for details.

\item {} 
\sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_smoother}}.
Sets the multigrid smoother.

\end{itemize}


\paragraph{Runtime parameters}
\label{\detokenize{Solvers/RTE:runtime-parameters}}
The following parameters for \sphinxcode{\sphinxupquote{EddingtonSP1}} are run\sphinxhyphen{}time configurable:
\begin{itemize}
\item {} 
All multigrid tuning parameters, i.e. parameters starting with \sphinxcode{\sphinxupquote{EddingtonSP1.gmg\_}}.

\item {} 
Plot variables, i.e. \sphinxcode{\sphinxupquote{EddingtonSP1.plt\_vars}}.

\item {} 
Kappa scaling (for algorithmic adjustments), i.e. \sphinxcode{\sphinxupquote{EddingtonSP1.kappa\_scale}}.

\end{itemize}


\subsection{Monte Carlo methods}
\label{\detokenize{Solvers/RTE:monte-carlo-methods}}\label{\detokenize{Solvers/RTE:chap-montecarlorte}}
All types of moment\sphinxhyphen{}closed radiative transfer equations contain nonphysical artifacts (which may or may not be acceptable).
For example, in the diffusion approximation the radiative flux is \(F = -\frac{c}{3\kappa}\nabla \Psi\), implying that photons can leak around boundaries.
I.e. the diffusion approximation does not correctly describe shadows.
It is possible to go beyond the diffusion approximation by also solving for higher\sphinxhyphen{}order moments like the radiative flux.
While such methods can describe shadows, they do, contain other nonphysical features.

Both ‘’stationary’’ and transient Monte Carlo methods are offered as an alternative to the diffusion approximation.


\subsubsection{photon particle}
\label{\detokenize{Solvers/RTE:photon-particle}}
The Îto particle is a computational particle class in \sphinxtitleref{chombo\sphinxhyphen{}discharge} which can be used together with the particle tools in \sphinxtitleref{Chombo}.
The following data fields are implemented in the particle:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect} \PYG{n}{m\PYGZus{}position}\PYG{p}{;}
\PYG{n}{RealVect} \PYG{n}{m\PYGZus{}velocity}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{m\PYGZus{}mass}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{m\PYGZus{}kappa}\PYG{p}{;}
\end{sphinxVerbatim}

To obtain the fields, the user will call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{velocity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{mass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{diffusion}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

All functions also have \sphinxcode{\sphinxupquote{const}} versions.
Note that the field \sphinxcode{\sphinxupquote{m\_mass}} is the same as the \sphinxstyleemphasis{weight} of the computational particle.
The following functions are used to set the various properties:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{setPosition}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setVelocity}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}vel}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setMass}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}mass}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setDiffusion}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}diffusion}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Interaction with boundaries}
\label{\detokenize{Solvers/RTE:interaction-with-boundaries}}

\subsubsection{Stationary Monte Carlo}
\label{\detokenize{Solvers/RTE:stationary-monte-carlo}}
The stationary Monte Carlo method proceeds as follows.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
For each cell in the mesh, draw a discrete number of photons \(\mathcal{P}\left(\eta \Delta V\Delta t\right)\) where \(\mathcal{P}\) is a Poisson distribution. The user may also choose to use pseudophotons rather than physical photons by modifying photon weights. Each photon is generated in the cell centroid \(\mathbf{x}_0\) and given a random propagation direction \(\mathbf{n}\).

\item {} 
Draw a propagation distance \(r\) by drawing random numbers from an exponential distribution \(p(r) = \kappa \exp\left(-\kappa r\right)\). The absorbed position of the photon is \(\mathbf{x} = \mathbf{x}_0 + r\mathbf{n}\).

\item {} 
Check if the path from \(\mathbf{x}_0\) to \(\mathbf{x}\) intersects an internal or domain boundary. If it does, absorb the photon on the boundary. If not, move the photon to \(\mathbf{x}\) or reflect it off symmetry boundaries.

\item {} 
Rebin the absorbed photons onto the AMR grid. This involves parallel communication.

\item {} 
Compute the resulting photoionization profile. The user may choose between several different deposition schemes (like e.g. cloud\sphinxhyphen{}in\sphinxhyphen{}cell).

\end{enumerate}

The Monte Carlo methods use computational particles for advancing the photons in exactly the same way a Particle\sphinxhyphen{}In\sphinxhyphen{}Cell method would use them for advancing electrons. Although a computational photon would normally live on the finest grid level that overlaps its position, this is not practical for all particle deposition kernels. For example, for cloud\sphinxhyphen{}in\sphinxhyphen{}cell deposition schemes it is useful to have the restrict the interpolation kernels to the grid level where the particle lives. In Chombo\sphinxhyphen{}speak, we therefore use a buffer region that extends some cells from a refinement boundary where the photons are not allowed to live. Instead, photons in that buffer region are transferred to a coarser level, and their deposition clouds are first interpolated to the fine level before deposition on the fine level happens. Selecting a deposition scheme and adjusting the buffer region is done through an input script associated with the solver.


\subsubsection{Transient Monte Carlo}
\label{\detokenize{Solvers/RTE:transient-monte-carlo}}
The transient Monte Carlo method is almost identical to the stationary method, except that it does not deposit all generated photons on the mesh but tracks them through time. The transient method is implemented as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
For each cell in the mesh, draw a discrete number of photons \(\mathcal{P}\left(\eta \Delta V\Delta t\right)\) as above, and append these to the already existing photons. Each photon is given a uniformly distributed random creation time within \(\Delta t\).

\item {} 
Each photon is advanced over the time step \(\Delta t\) by a sequence of \(N\) substeps (\(N\) may be different for each photon).
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
We compute \(N\) such that we sample \(N\Delta \tau = \Delta t\) with \(c\kappa\Delta\tau < 1\).

\item {} 
A photon at position \(\mathbf{x}_0\) is moved a distance \(\Delta \mathbf{x} = c\mathbf{n}\Delta\tau\). For each step we compute the absorption probability \(p = \kappa\left|\Delta\mathbf{x}\right|\) where \(p\in[0,1]\) is a uniform random number. If the photon is absorbed on this interval, draw a new uniform random number \(r \in [0,1]\) and absorb the photon at the position \(\mathbf{x}_0 + r\Delta\mathbf{x}\). If the photon is not absorbed, it is moved to position \(\mathbf{x}_0 + r\Delta\mathbf{x}\).

\end{enumerate}

\item {} 
Check if the path from \(\mathbf{x}_0\) to \(\mathbf{x}\) intersects an internal or domain boundary. If it does, absorb the photon on the boundary. If not, move the photon to \(\mathbf{x}\).

\item {} 
Rebin the absorbed photons onto the AMR grid. This involves parallel communication.

\item {} 
Compute the resulting photoionization profile. The user may choose between several different deposition schemes (like e.g. cloud\sphinxhyphen{}in\sphinxhyphen{}cell).

\end{enumerate}


\subsection{Limitations}
\label{\detokenize{Solvers/RTE:limitations}}

\subsection{Example application}
\label{\detokenize{Solvers/RTE:example-application}}
An example application of usage of the \sphinxcode{\sphinxupquote{RtSolver}} is found in {\hyperref[\detokenize{Applications/RadiativeTransferModel:chap-radiativetransfermodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Radiative transfer}}}}.


\section{Surface charge solver}
\label{\detokenize{Solvers/Sigma:surface-charge-solver}}\label{\detokenize{Solvers/Sigma:chap-sigmasolver}}\label{\detokenize{Solvers/Sigma::doc}}
In order to conserve charge on solid insulators, \sphinxtitleref{chombo\sphinxhyphen{}discharge} has a solver that is defined on the gas\sphinxhyphen{}dielectric interface where the surface charge is updated with the incoming flux
\begin{equation*}
\begin{split}F_\sigma(\phi) = \sum_{\phi}q_\phi F_{\textrm{EB}}(\phi),\end{split}
\end{equation*}
where \(q_\phi\) is the charge of a species \(\phi\). This ensures strong conservation on insulating surfaces.


\section{Tracer particles}
\label{\detokenize{Solvers/TracerParticles:tracer-particles}}\label{\detokenize{Solvers/TracerParticles:chap-tracerparticlesolver}}\label{\detokenize{Solvers/TracerParticles::doc}}

\section{Îto diffusion}
\label{\detokenize{Solvers/Ito:ito-diffusion}}\label{\detokenize{Solvers/Ito:chap-itodiffusion}}\label{\detokenize{Solvers/Ito::doc}}
The Îto diffusion model advances computational particles as Brownian walkers with drift:
\begin{equation*}
\begin{split}d\mathbf{X}_i = \mathbf{v}_idt + \sqrt{2D_i}\mathbf{W}_i dt,\end{split}
\end{equation*}
where \(\mathbf{X}_i\) is the spatial position of a particle \(i\), \(\mathbf{v}_i\) is the drift coefficient and \(D_i\) is the diffusion coefficient \sphinxstyleemphasis{in the continuum limit}.
That is, both \(\mathbf{v}_i\) and \(D_i\) are the quantities that appear in {\hyperref[\detokenize{Solvers/CDR:chap-cdr}]{\sphinxcrossref{\DUrole{std,std-ref}{Convection\sphinxhyphen{}Diffusion\sphinxhyphen{}Reaction}}}}.
The vector term \(\mathbf{W}_i\) is a Gaussian random field with a mean value of 0 and standard deviation of 1.

The code for Îto diffusion is given in \sphinxcode{\sphinxupquote{/src/ito\_solver}} and only a brief explanation is given here.
The source code is used by a physics module in \sphinxcode{\sphinxupquote{/physics/brownian\_walker}} and in the regression test \sphinxcode{\sphinxupquote{/regression/brownian\_walker}}.


\subsection{The Îto particle}
\label{\detokenize{Solvers/Ito:the-ito-particle}}\label{\detokenize{Solvers/Ito:chap-ito-particle}}
The Îto particle is a computational particle class in \sphinxtitleref{chombo\sphinxhyphen{}discharge} which can be used together with the particle tools in \sphinxtitleref{Chombo}.
The following data fields are implemented in the particle:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect} \PYG{n}{m\PYGZus{}position}\PYG{p}{;}
\PYG{n}{RealVect} \PYG{n}{m\PYGZus{}velocity}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{m\PYGZus{}mass}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{m\PYGZus{}diffusion}\PYG{p}{;}
\end{sphinxVerbatim}

To obtain the fields, the user will call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{velocity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{mass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{diffusion}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

All functions also have \sphinxcode{\sphinxupquote{const}} versions.
Note that the field \sphinxcode{\sphinxupquote{m\_mass}} is the same as the \sphinxstyleemphasis{weight} of the computational particle.
The following functions are used to set the various properties:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{setPosition}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setVelocity}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}vel}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setMass}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}mass}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setDiffusion}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}diffusion}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{ito\_species}
\label{\detokenize{Solvers/Ito:ito-species}}\label{\detokenize{Solvers/Ito:chap-ito-species}}
\sphinxcode{\sphinxupquote{ito\_species}} is a class for parsing information into the solver class.
The constructor for the \sphinxcode{\sphinxupquote{ito\_species}} class is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ito\PYGZus{}species}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}name}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}charge}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}mobile}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}diffusive}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and this will set the name of the class, the charge, and whether or not the transport kernels account for drift and diffusion.


\subsubsection{Setting initial conditions}
\label{\detokenize{Solvers/Ito:setting-initial-conditions}}
In order to set the initial conditions the user must fill the list \sphinxcode{\sphinxupquote{List\textless{}ito\_particle\textgreater{} m\_initial\_particles}} in \sphinxcode{\sphinxupquote{ito\_species}}.
When \sphinxcode{\sphinxupquote{initial\_data()}} is called from \sphinxcode{\sphinxupquote{ito\_solver}}, the initial particles are transferred from the instance of \sphinxcode{\sphinxupquote{ito\_species}} and into the instance of \sphinxcode{\sphinxupquote{ito\_solver}}.

We remark that it is a bad idea to replicate the initial particle list over all MPI ranks in a simulation.
If one has a list of initial particles, or wants to draw a specified number of particles from a distribution, the initial particles \sphinxstyleemphasis{must} be distributed over the available MPI ranks.
For example, the code in \sphinxcode{\sphinxupquote{/physics/brownian\_walker/brownian\_walker\_species.cpp}} draws a specified number of particles distributed over all MPI ranks as (the code is called in \sphinxcode{\sphinxupquote{brownian\_walker\_species::draw\_initial\_particles}})

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// To avoid that MPI ranks draw the same particle positions, increment the seed for each rank}
\PYG{n}{m\PYGZus{}seed} \PYG{o}{+}\PYG{o}{=} \PYG{n}{procID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set up the RNG}
\PYG{n}{m\PYGZus{}rng} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{mt19937\PYGZus{}64}\PYG{p}{(}\PYG{n}{m\PYGZus{}seed}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}gauss} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{normal\PYGZus{}distribution}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{m\PYGZus{}blob\PYGZus{}radius}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}udist11} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{uniform\PYGZus{}real\PYGZus{}distribution}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Each MPI process draws the desired number of particles from a distribution}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{quotient}  \PYG{o}{=} \PYG{n}{m\PYGZus{}num\PYGZus{}particles}\PYG{o}{/}\PYG{n}{numProc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{remainder} \PYG{o}{=} \PYG{n}{m\PYGZus{}num\PYGZus{}particles} \PYG{o}{\PYGZpc{}} \PYG{n}{numProc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{particlesPerRank}\PYG{p}{(}\PYG{n}{numProc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{quotient}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{remainder}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{n}{particlesPerRank}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Now make the particles}
\PYG{n}{m\PYGZus{}initial\PYGZus{}particles}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{particlesPerRank}\PYG{p}{[}\PYG{n}{procID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{k}{const} \PYG{n}{Real} \PYG{n}{weight}  \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
  \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{pos} \PYG{o}{=} \PYG{n}{m\PYGZus{}blob\PYGZus{}center} \PYG{o}{+} \PYG{n}{random\PYGZus{}gaussian}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{m\PYGZus{}initial\PYGZus{}particles}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{ito\PYGZus{}particle}\PYG{p}{(}\PYG{n}{weight}\PYG{p}{,} \PYG{n}{pos}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Computing time steps}
\label{\detokenize{Solvers/Ito:computing-time-steps}}
The signatures for computing a time step for the \sphinxcode{\sphinxupquote{ito\_solver}} are given separately for the drift part and the diffusion part.


\subsubsection{Drift}
\label{\detokenize{Solvers/Ito:drift}}
The drift time step routines are implemented such that one restricts the time step such that the fastest particle does not move more than a specified number of grid cells.

For the drift, the signatures are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}min\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// Compute dt on all AMR levels, return vector of time step}
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{,} \PYG{k}{const} \PYG{n}{DataIndex}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dit}\PYG{p}{,} \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}dx}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

These last three functions all compute \(\Delta t = \Delta x/Max(v_x, v_y, v_z)\) on the the various AMR levels and patches.
The routine

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

simply scales \(\Delta t\) by \sphinxcode{\sphinxupquote{a\_maxCellsToMove}} on every level.
Finally, the function \sphinxcode{\sphinxupquote{compute\_min\_drift\_dt(...)}} computes the smallest time step across every AMR level.


\subsubsection{Diffusion}
\label{\detokenize{Solvers/Ito:diffusion}}
The signatures for the diffusion time step are similar to the ones for drift:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}min\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{,} \PYG{k}{const} \PYG{n}{DataIndex}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dit}\PYG{p}{,} \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}dx}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

In these routines, the time step is computed as \(\Delta t = \frac{\Delta x}{\sqrt{2D}}\).
Note that there is still a chance that a particle jumps further than specified by \sphinxcode{\sphinxupquote{a\_maxCellsToMove}} since the diffusion hop is
\begin{equation*}
\begin{split}\mathbf{d} = \sqrt{2D}\mathbf{Z}\Delta t,\end{split}
\end{equation*}
where \(\mathbf{Z}\) is a random Gaussian.
The probability that a diffusion hop leads to a jump larger than \(N\) cells can be evaluated and is \(P = \textrm{erf}\left(\sqrt{2}N\right)\). It is useful to keep this probability in mind when deciding on the PVR.


\subsection{Remapping particles}
\label{\detokenize{Solvers/Ito:remapping-particles}}
Particle remapping has been implemented for the whole AMR hierarchy as a two step process.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Perform two\sphinxhyphen{}level remapping where particles are transferred up or down one grid level if they move out the level PVR.

\item {} 
Gather all particles that are remnant in the outcast list on the coarsest level, and then distribute them back to their appropriate levels. For example, particles that hopped over more than one refinement boundary cannot be transferred with a (clean) two\sphinxhyphen{}level transfer.

\end{enumerate}


\subsection{Limitations}
\label{\detokenize{Solvers/Ito:limitations}}

\subsection{Example application}
\label{\detokenize{Solvers/Ito:example-application}}
An example application of usage of the \sphinxcode{\sphinxupquote{ItoSolver}} is found in {\hyperref[\detokenize{Applications/BrownianWalkerModel:chap-brownianwalkermodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Brownian walker}}}}.


\chapter{Physics models}
\label{\detokenize{index:physics-models}}

\section{Implemented models}
\label{\detokenize{Applications/ImplementedModels:implemented-models}}\label{\detokenize{Applications/ImplementedModels:chap-implementedmodels}}\label{\detokenize{Applications/ImplementedModels::doc}}
Various models that use the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} solvers and functionality have been implemented and are shipped with \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
These models implement \sphinxcode{\sphinxupquote{TimeStepper}} for advancing various types of equations, and have been set up both for unit testing and as building blocks for more complex applications.
The models reside \sphinxcode{\sphinxupquote{\$DICHARGE\_HOME/Physics}} and are supplemented with Python tools for quickly setting up new applications that use the same code.
In general, users are encouraged to modify or copy these models and tailor them for their own applications.

The following models are currently supported:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
{\hyperref[\detokenize{Applications/AdvectionDiffusionModel:chap-advectiondiffusionmodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Advection diffusion}}}} Used for solving pure advection\sphinxhyphen{}diffusion problems in 2D/3D with complex geometries.

\item {} 
{\hyperref[\detokenize{Applications/BrownianWalkerModel:chap-brownianwalkermodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Brownian walker}}}} Used for solving advection\sphinxhyphen{}diffusion problems using computational particles.
This is, essentially, a Particle\sphinxhyphen{}In\sphinxhyphen{}Cell code that uses classical particles (rather than kinetic ones).

\item {} 
{\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmamodel}]{\sphinxcrossref{\DUrole{std,std-ref}{CDR plasma}}}} Implements \sphinxcode{\sphinxupquote{TimeStepper}} for solving low\sphinxhyphen{}temperature discharge plasma problems using fluids.
Used e.g. for streamer simulations.

\item {} 
{\hyperref[\detokenize{Applications/ElectrostaticsModel:chap-electrostaticsmodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Electrostatics}}}} Implements \sphinxcode{\sphinxupquote{TimeStepper}} for setting up a static calculation that solves the Poisson equation in 2D/3D.

\item {} 
{\hyperref[\detokenize{Applications/GeometryModel:chap-geometrymodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Geometry}}}} Implement \sphinxcode{\sphinxupquote{TimeStepper}} with empty functionality. Often used when setting up new geometries/cases.

\item {} 
{\hyperref[\detokenize{Applications/RadiativeTransferModel:chap-radiativetransfermodel}]{\sphinxcrossref{\DUrole{std,std-ref}{Radiative transfer}}}} Implements \sphinxcode{\sphinxupquote{TimeStepper}} for solving radiative transfer problems. Used e.g. for regression testing.

\end{enumerate}


\section{Advection diffusion}
\label{\detokenize{Applications/AdvectionDiffusionModel:advection-diffusion}}\label{\detokenize{Applications/AdvectionDiffusionModel:chap-advectiondiffusionmodel}}\label{\detokenize{Applications/AdvectionDiffusionModel::doc}}

\section{Brownian walker}
\label{\detokenize{Applications/BrownianWalkerModel:brownian-walker}}\label{\detokenize{Applications/BrownianWalkerModel:chap-brownianwalkermodel}}\label{\detokenize{Applications/BrownianWalkerModel::doc}}

\section{CDR plasma}
\label{\detokenize{Applications/CdrPlasmaModel:cdr-plasma}}\label{\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmamodel}}\label{\detokenize{Applications/CdrPlasmaModel::doc}}
The CDR plasma model resides in \sphinxcode{\sphinxupquote{/Physics/CdrPlasma}} and describes plasmas in the drift\sphinxhyphen{}diffusion approximation.
This physics model also includes the following subfolders:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/Physics/CdrPlasma/PlasmaModel}} which contains various implementation of some plasma models that we have used.

\item {} 
\sphinxcode{\sphinxupquote{/Physics/CdrPlasma/TimeSteppers}} contains various algorithms for advancing the equations of motion.

\item {} 
\sphinxcode{\sphinxupquote{/Physics/CdrPlasma/CellTaggers}} contains various algorithms for flagging cells for refinement and coarsening.

\item {} 
\sphinxcode{\sphinxupquote{/Physics/CdrPlasma/python}} contains Python source files for quickly setting up new applications.

\end{itemize}


\subsection{Equations of motion}
\label{\detokenize{Applications/CdrPlasmaModel:equations-of-motion}}
In the CDR plasma model we are solving
\begin{equation*}
\begin{split}&\nabla\cdot\left(\epsilon_r\nabla\Phi\right) = -\frac{\rho}{\epsilon_0},\\
&\frac{\partial\sigma}{\partial t} = F_\sigma,\\
&\frac{\partial n}{\partial t} + \nabla\cdot\left(\mathbf{v} n - D\nabla n\right) = S,\end{split}
\end{equation*}
The above equations must be supported by additional boundary conditions on electrodes and insulating surfaces.

Radiative transport can be done either in the diffusive approximation or by means of Monte Carlo methods.
Diffusive RTE methods involve solving
\begin{equation*}
\begin{split}\partial_t\Psi + \kappa\Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi\right) = \frac{\eta}{c},\end{split}
\end{equation*}
where \(\Psi\) is the isotropic photon density, \(\kappa\) is an absorption length and \(\eta\) is an isotropic source term.
I.e., \(\eta\) is the number of photons produced per unit time and volume.
The time dependent term can be turned off and the equation can be solved stationary.

The module also supports discrete photons where photon transport and absorption is done by sampling discrete photons.
In general, discrete photon methods incorporate better physics (like shadows)
They can easily be adapted to e.g. scattering media.
They are, on the other hand, inherently stochastic which implies that some extra caution must be exercised when integrating the equations of motion.

The coupling that is (currently) available in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is
\begin{equation}\label{equation:Applications/CdrPlasmaModel:CdrPlasmaCoupling}
\begin{split}\epsilon_r =& \epsilon_r(\mathbf{x}), (\textrm{can additionally be discontinuous}), \\
\mathbf{v} =& \mathbf{v}\left(t, \mathbf{x}, \mathbf{E}, n\right),\\
D =& \mathbf{v}\left(t, \mathbf{x}, \mathbf{E}, n\right),\\
S =& S\left(t, \mathbf{x}, \mathbf{E}, \nabla\mathbf{E}, n, \nabla n, \Psi\right),\\
\eta =& \eta\left(t, \mathbf{x}, \mathbf{E}, n\right),\\
F =& F(t, \mathbf{x}, \mathbf{E}, n),\end{split}
\end{equation}
where \(F\) is the boundary flux on insulators or electrodes (which must be separately implemented).

\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} works by embedding the equations above into an abstract C++ framework (see {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmaphysics}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrPlasmaPhysics}}}}) that the user must implement or reuse existing pieces of, and then compile into an executable.


\subsection{CdrPlasmaPhysics}
\label{\detokenize{Applications/CdrPlasmaModel:cdrplasmaphysics}}\label{\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmaphysics}}
{\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmaphysics}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrPlasmaPhysics}}}} is an abstract class which represents the plasma physics for the CDR plasma module, i.e. it provides the coupling functions in Eq. \ref{equation:Applications/CdrPlasmaModel:CdrPlasmaCoupling}.
The source code for the class resides in \sphinxcode{\sphinxupquote{/Physics/CdrPlasma/CD\_CdrPlasmaPhysics.H}}.
Note that the entire class is an interface, whose implementations are used by the time integrators that advance the equations.

There are no default input parameters for {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmaphysics}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrPlasmaPhysics}}}}, as users must generally implement their own kinetics.
The class exists solely for providing the integrators with the necessary fundamentals for filling solvers with the correct quantities at the same time, for example filling source terms and drift velocities.

A successful implementation of {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmaphysics}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrPlasmaPhysics}}}} has the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Instantiated a list of {\hyperref[\detokenize{Solvers/CDR:chap-cdrspecies}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrSpecies}}}}.
These become {\hyperref[\detokenize{Solvers/CDR:chap-cdr}]{\sphinxcrossref{\DUrole{std,std-ref}{Convection\sphinxhyphen{}Diffusion\sphinxhyphen{}Reaction}}}} solvers and contain initial conditions and basic transport settings for the convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers.

\item {} 
Instantiated a list {\hyperref[\detokenize{Solvers/RTE:chap-rtspecies}]{\sphinxcrossref{\DUrole{std,std-ref}{RtSpecies}}}}.
These become {\hyperref[\detokenize{Solvers/RTE:chap-radiativetransfer}]{\sphinxcrossref{\DUrole{std,std-ref}{Radiative transfer}}}} solvers and contain metadata for the radiative transport solvers.

\item {} 
Implemented the core functionality that couple the solvers together.

\end{enumerate}

\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} automatically allocates the specified number of convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction and radiative transport solvers from the list of species the is intantiated.
For information on how to interface into the CDR solvers, see {\hyperref[\detokenize{Solvers/CDR:chap-cdrspecies}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrSpecies}}}}.
Likewise, see {\hyperref[\detokenize{Solvers/RTE:chap-rtspecies}]{\sphinxcrossref{\DUrole{std,std-ref}{RtSpecies}}}} for how to interface into the RTE solvers.

Implementation of the core functionality is comparatively straightforward, but can lead to boilerplate code.
For this reason we also provide an implementation layer {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmajson}]{\sphinxcrossref{\DUrole{std,std-ref}{JSON interface}}}} that provides a plug\sphinxhyphen{}and\sphinxhyphen{}play interface for specifying the plasma physics.


\subsubsection{API}
\label{\detokenize{Applications/CdrPlasmaModel:api}}
The API for \sphinxcode{\sphinxupquote{CdrPlasmaPhysics}} is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{n}{Real} \PYG{n+nf}{computeAlpha}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}E}\PYG{p}{)} \PYG{k}{const}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{advanceReactionNetwork}\PYG{p}{(}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}          \PYG{n}{a\PYGZus{}cdrSources}\PYG{p}{,}
                                    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}          \PYG{n}{a\PYGZus{}rteSources}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}     \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrGradients}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}     \PYG{n}{a\PYGZus{}rteDensities}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{RealVect}         \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{RealVect}         \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Real}             \PYG{n}{a\PYGZus{}dx}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Real}             \PYG{n}{a\PYGZus{}dt}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Real}             \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Real}             \PYG{n}{a\PYGZus{}kappa}\PYG{p}{)} \PYG{k}{const}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrDriftVelocities}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{)} \PYG{k}{const}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrDiffusionCoefficients}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                                     \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                                     \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                                     \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{)} \PYG{k}{const}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrElectrodeFluxes}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}normal}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrVelocities}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrGradients}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}rteFluxes}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}extrapCdrFluxes}\PYG{p}{)} \PYG{k}{const}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrDielectricFluxes}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}normal}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrVelocities}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrGradients}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}rteFluxes}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}extrapCdrFluxes}\PYG{p}{)} \PYG{k}{const}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrDomainFluxes}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}           \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{RealVect}       \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{k+kt}{int}            \PYG{n}{a\PYGZus{}dir}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{Side}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LoHiSide} \PYG{n}{a\PYGZus{}side}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{RealVect}       \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}cdrVelocities}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}cdrGradients}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}rteFluxes}\PYG{p}{,}
                                            \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}extrapCdrFluxes}\PYG{p}{)} \PYG{k}{const}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Real} \PYG{n+nf}{initialSigma}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{,} \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)} \PYG{k}{const}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The above code blocks do the following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{computeAlpha}} computes the Townsend ionization coefficient.
This is used by the cell tagger.

\item {} 
\sphinxcode{\sphinxupquote{advanceReactionNetwork}} provides the coupling \(S = S(t, \mathbf{x}, \mathbf{E}, \nabla\mathbf{E}, n, \nabla n, \Psi)\).

\item {} 
\sphinxcode{\sphinxupquote{computeCdrDriftVelocities}} provides the coupling \(\mathbf{v} = \mathbf{v}\left(t, \mathbf{x}, \mathbf{E}, n\right)\).

\item {} 
\sphinxcode{\sphinxupquote{computeCdrDiffusionCoefficients}} provides the coupling \(D = \mathbf{v}\left(t, \mathbf{x}, \mathbf{E}, n\right)\).

\item {} 
\sphinxcode{\sphinxupquote{computeCdrElectrodeFluxes}} provides the coupling \(F = F(t, \mathbf{x}, \mathbf{E}, n)\) on electrode EBs.

\item {} 
\sphinxcode{\sphinxupquote{computeCdrDielectricFluxes}} provides the coupling \(F = F(t, \mathbf{x}, \mathbf{E}, n)\) on dielectric EBs.

\item {} 
\sphinxcode{\sphinxupquote{computeCdrDomainFluxes}} provides the coupling \(F = F(t, \mathbf{x}, \mathbf{E}, n)\) on domain sides.

\end{itemize}

For a fully documented API, see the \sphinxhref{doxygen/html/classPhysics\_1\_1CdrPlasma\_1\_1CdrPlasmaPhysics.html}{doxygen API}.

Below, we include a brief overview of how \sphinxcode{\sphinxupquote{CdrPlasmaPhysics}} can be directly implemented.
Note that direct implements like these tend to become boilerplate, we also include an interface which implements these functions with pre\sphinxhyphen{}defined rules, see {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmajson}]{\sphinxcrossref{\DUrole{std,std-ref}{JSON interface}}}}.


\subsubsection{Initializing species}
\label{\detokenize{Applications/CdrPlasmaModel:initializing-species}}
In the constructor, the user should define the advected/diffused species and the radiative transfer species.
These are stored in vectors \sphinxcode{\sphinxupquote{Vector\textless{}RefCountedPtr\textless{}CdrSpecies\textgreater{} \textgreater{} m\_CdrSpecies}} and \sphinxcode{\sphinxupquote{Vector\textless{}RefCountedPtr\textless{}RtSpecies\textgreater{} \textgreater{} m\_RtSpecies}}.
Each species in these vectors become a convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solver or a radiative transfer solver.
See {\hyperref[\detokenize{Solvers/CDR:chap-cdrspecies}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrSpecies}}}} and {\hyperref[\detokenize{Solvers/RTE:chap-rtspecies}]{\sphinxcrossref{\DUrole{std,std-ref}{RtSpecies}}}} for details on how to implement these.


\subsubsection{Defining drift velocities}
\label{\detokenize{Applications/CdrPlasmaModel:defining-drift-velocities}}
To set the drift velocities, implement \sphinxcode{\sphinxupquote{computeCdrDriftVelocities}} \textendash{} this will set the drift velocity \(\mathbf{v}\) in the CDR equations:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrDriftVelocities}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                           \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                           \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                           \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{)} \PYG{k}{const}  \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m\PYGZus{}numCdrSpecies}\PYG{p}{,} \PYG{n}{a\PYGZus{}E}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This implementation is set the advection velocity equal to \(\mathbf{E}\).
For a full plasma simulation, there will also be mobilities involved, which the user is reponsible for obtaining.


\subsubsection{Defining diffusion coefficients}
\label{\detokenize{Applications/CdrPlasmaModel:defining-diffusion-coefficients}}
To set the diffusion coefficients, implement \sphinxcode{\sphinxupquote{computeCdrDiffusionCoefficients}} \textendash{} this will set the diffusion coefficient \(D\) in the CDR equations:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrDiffusionCoefficients}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                             \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                             \PYG{k}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                             \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m\PYGZus{}numCdrSpecies}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This sets \(D = 1\) for all species involved.


\subsubsection{Defining chemistry terms}
\label{\detokenize{Applications/CdrPlasmaModel:defining-chemistry-terms}}
To set the source terms \(S\), implement \sphinxcode{\sphinxupquote{advanceReactionNetwork}}.
This routine should set the reaction terms for both the CDR equations \sphinxstyleemphasis{and} the radiative transfer equations.

\begin{sphinxadmonition}{note}{Note:}
For the radiative transfer equations we set the isotropic source term \(\eta\) which is the number of ionizing photons produced per unit volume and time.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{advanceReactionNetwork}\PYG{p}{(}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}          \PYG{n}{a\PYGZus{}cdrSources}\PYG{p}{,}
                                    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}          \PYG{n}{a\PYGZus{}rteSources}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}     \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrGradients}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}     \PYG{n}{a\PYGZus{}rteDensities}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{RealVect}         \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{RealVect}         \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Real}             \PYG{n}{a\PYGZus{}dx}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Real}             \PYG{n}{a\PYGZus{}dt}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Real}             \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Real}             \PYG{n}{a\PYGZus{}kappa}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{n}{a\PYGZus{}cdrSources} \PYG{o}{=} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m\PYGZus{}numCdrSpecies}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{a\PYGZus{}rteSources} \PYG{o}{=} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m\PYGZus{}numRteSpecies}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The above code will set \(S = \eta = 1\) for all species.

We point out that in the plasma module the source terms are \sphinxstyleemphasis{always} used in the form
\begin{equation*}
\begin{split}n^{k+1} = n^k + \Delta t S,\end{split}
\end{equation*}
where \(S\) is the source term obtained from \sphinxcode{\sphinxupquote{advanceReactionNetwork}}.
This implies that it \sphinxstyleemphasis{is} possible to define fully implicit integrators directly in \sphinxcode{\sphinxupquote{advanceReactionNetwork}}.
For example, if the reactive problem consisted only of \(\partial_t n = -\frac{n}{\tau}\), one could form a reactive integrator with the implicit Euler rule by first computing \(n^{k+1} = \frac{n^k}{1 + \Delta t/\tau}\) and then linearizing \(S = \frac{n^{k+1} - n^k}{\Delta t}\).


\subsubsection{Fluxes at electrode boundaries}
\label{\detokenize{Applications/CdrPlasmaModel:fluxes-at-electrode-boundaries}}
To set the fluxes \(F\) on electrode EBs, implement \sphinxcode{\sphinxupquote{computeCdrElectrodeFluxes}}.
Note that the fluxes \(F\) are those occuring in a finite\sphinxhyphen{}volume context; i.e. the total injected or extracted mass.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrElectrodeFluxes}\PYG{p}{(}\PYG{n}{const} \PYG{n}{Real}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                       \PYG{n}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                       \PYG{n}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}normal}\PYG{p}{,}
                                       \PYG{n}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                       \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{,}
                                       \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrVelocities}\PYG{p}{,}
                                       \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrGradients}\PYG{p}{,}
                                       \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}rteFluxes}\PYG{p}{,}
                                       \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}extrapCdrFluxes}\PYG{p}{)} \PYG{n}{const} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m\PYGZus{}numCdrSpecies}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The input variable \sphinxcode{\sphinxupquote{a\_extrapCdrFluxes}} are cell\sphinxhyphen{}centered fluxes extrapolated to the EBs.


\subsubsection{Fluxes at dielectric boundaries}
\label{\detokenize{Applications/CdrPlasmaModel:fluxes-at-dielectric-boundaries}}
To set the fluxes \(F\) on dielectric EBs, implement \sphinxcode{\sphinxupquote{computeCdrDielectricFluxes}}.
Note that the fluxes \(F\) are those occuring in a finite\sphinxhyphen{}volume context; i.e. the total injected or extracted mass.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrDielectricFluxes}\PYG{p}{(}\PYG{n}{const} \PYG{n}{Real}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                        \PYG{n}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                        \PYG{n}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}normal}\PYG{p}{,}
                                        \PYG{n}{const} \PYG{n}{RealVect}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                        \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{,}
                                        \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrVelocities}\PYG{p}{,}
                                        \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}cdrGradients}\PYG{p}{,}
                                        \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}rteFluxes}\PYG{p}{,}
                                        \PYG{n}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}extrapCdrFluxes}\PYG{p}{)} \PYG{n}{const} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m\PYGZus{}numCdrSpecies}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The input variable \sphinxcode{\sphinxupquote{a\_extrapCdrFluxes}} are cell\sphinxhyphen{}centered fluxes extrapolated to the EBs.


\subsubsection{Fluxes at domain boundaries}
\label{\detokenize{Applications/CdrPlasmaModel:fluxes-at-domain-boundaries}}
To set the fluxes \(F\) on dielectric EBs, implement \sphinxcode{\sphinxupquote{computeCdrDielectricFluxes}}.
Note that the fluxes \(F\) are those occuring in a finite\sphinxhyphen{}volume context; i.e. the total injected or extracted mass.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{computeCdrDomainFluxes}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}           \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{RealVect}       \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{k+kt}{int}            \PYG{n}{a\PYGZus{}dir}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Side}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LoHiSide} \PYG{n}{a\PYGZus{}side}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{RealVect}       \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}cdrDensities}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}cdrVelocities}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}cdrGradients}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}rteFluxes}\PYG{p}{,}
                                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}   \PYG{n}{a\PYGZus{}extrapCdrFluxes}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{m\PYGZus{}numCdrSpecies}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The input variable \sphinxcode{\sphinxupquote{a\_extrapCdrFluxes}} are cell\sphinxhyphen{}centered fluxes extrapolated to the domain sides.


\subsubsection{Setting initial surface charge}
\label{\detokenize{Applications/CdrPlasmaModel:setting-initial-surface-charge}}
To set the initial surface charge on dielectric boundaries, implement

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n+nf}{initialSigma}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{,} \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)} \PYG{k}{const}\PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Time discretizations}
\label{\detokenize{Applications/CdrPlasmaModel:time-discretizations}}
Here, we discuss two discretizations of \sphinxcode{\sphinxupquote{CdrPlasmaEquations}}.
Firstly, note that there are two layers to the time integrators:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A pure class \sphinxcode{\sphinxupquote{CdrPlasmaStepper}} which inherits from \sphinxcode{\sphinxupquote{TimeSteppers}} but does not implement an \sphinxcode{\sphinxupquote{advance}} method.
This class simply provides the base functionality for more easily developing time integrators.
\sphinxcode{\sphinxupquote{CdrPlasmaStepper}} contains methods that are necessary for coupling the solvers, e.g. calling the \DUrole{xref,std,std-ref}{CdrPlasmaPhysics} methods at the correct time.

\item {} 
Implementations of \sphinxcode{\sphinxupquote{CdrPlasmaPhysics}}, which implement the \sphinxcode{\sphinxupquote{advance}} method and can thus be used for advancing models.

\end{enumerate}

The supported time integrators are located in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/CdrPlasma/TimeSteppers}}.
There are two integrators that are commonly used.
\begin{itemize}
\item {} 
A Godunov operator splitting with either explicit or implicit diffusion.
This integrator also supports semi\sphinxhyphen{}implicit formulations.

\item {} 
A spectral deferred correction (SDC) integrator with implicit diffusion.
This integrator is an implicit\sphinxhyphen{}explicit.

\end{itemize}

Briefly put, the Godunov operator is our most stable integrator, while the SDC integrator is our most accurate integrator.


\subsubsection{Godunov operator splitting}
\label{\detokenize{Applications/CdrPlasmaModel:godunov-operator-splitting}}\label{\detokenize{Applications/CdrPlasmaModel:chap-godunov}}
The \sphinxcode{\sphinxupquote{CdrPlasmaGodunovStepper}} implements \sphinxcode{\sphinxupquote{CdrPlasmaStepper}} and defines an operator splitting method between charge transport and plasma chemistry.
It has a formal order of convergence of one.
The source code is located in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/CdrPlasma/TimeSteppers/CdrPlasmaGodunovStepper}}.

\begin{sphinxadmonition}{warning}{Warning:}
Splitting the terms yields \sphinxstyleemphasis{splitting errors} which can dominate for large time steps.
Typically, the operator splitting discretization is not suitable for large time steps.
\end{sphinxadmonition}

The basic advancement routine for \sphinxcode{\sphinxupquote{CdrPlasmaGodunovStepper}} is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Advance the charge transport \(\phi^k \rightarrow \phi^{k+1}\) with the source terms set to zero.

\item {} 
Compute the electric field.

\item {} 
Advance the plasma chemistry over the same time step using the field computed above
I.e., advance \(\partial_t\phi = S\) over a time step \(\Delta t\).

\item {} 
Advance the radiative transport part.
This can also involve discrete photons.

\end{enumerate}

The transport/field steps can be done in various ways:
The following transport algorithms are available:
\begin{itemize}
\item {} 
\sphinxstylestrong{Euler}, where everything is advanced with the Euler rule.

\item {} 
\sphinxstylestrong{Semi\sphinxhyphen{}implicit}, where the Euler field/transport step is performed with an implicit coupling to the electric field.

\end{itemize}

In addition, diffusion can be treated
\begin{itemize}
\item {} 
\sphinxstylestrong{Explicitly}, where all diffusion advances are performed with an \sphinxstyleemphasis{explicit} rule.

\item {} 
\sphinxstylestrong{Implicitly}, where all diffusion advances are performed with an \sphinxstyleemphasis{implicit} rule.

\item {} 
\sphinxstylestrong{Automatically}, where diffusion advances are performed with an implicit rule only if time steps dictate it, and explicitly otherwise.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
When setting up a new problem with the Godunov time integrator, the default setting is to use automatic diffusion and a semi\sphinxhyphen{}implicit coupling.
These settings tend to work for most problems.
\end{sphinxadmonition}


\paragraph{Specifying transport algorithm}
\label{\detokenize{Applications/CdrPlasmaModel:specifying-transport-algorithm}}
To specify the transport algorithm, modify the flag \sphinxcode{\sphinxupquote{CdrPlasmaGodunovStepper.transport}}, and set it to \sphinxcode{\sphinxupquote{semi\_implicit}} or \sphinxcode{\sphinxupquote{euler}}.
Everything else is an error.

Note that for the Godunov integrator, it is possible to center the advective discretization at the half time step.
That is, the advancement algorithm is
\begin{equation*}
\begin{split}n^{k+1} = n^{k} - \nabla\cdot\left(n^{k+1/2}\mathbf{v}\right) + \nabla\cdot\left(D\nabla\phi^k\right),\end{split}
\end{equation*}
where \(n^{k+1/2}\) is obtained by also including transverse slopes (i.e., extrapolation in time).
See Trebotich and Graves {[}\hyperlink{cite.ZZReferences:id157}{8}{]} for details.
Note that the formal order of accuracy is still one, but the accuracy of the advective discretization is increased substantially.


\paragraph{Specifying diffusion}
\label{\detokenize{Applications/CdrPlasmaModel:specifying-diffusion}}
To specify how diffusion is treated, modify the flag \sphinxcode{\sphinxupquote{CdrPlasmaGodunovStepper.diffusion}}, and set it to \sphinxcode{\sphinxupquote{auto}}, \sphinxcode{\sphinxupquote{explicit}}, or \sphinxcode{\sphinxupquote{implicit}}.
In addition, the flag \sphinxcode{\sphinxupquote{CdrPlasmaGodunovStepper.diffusion\_thresh}} must be set to a number.

When diffusion is set to \sphinxcode{\sphinxupquote{auto}}, the integrator switches to implicit diffusion when
\begin{equation*}
\begin{split}\frac{\Delta t_{\textrm{A}}}{\Delta t_{\textrm{AD}}} > \epsilon,\end{split}
\end{equation*}
where \(\Delta t_{\textrm{A}}\) is the advection\sphinxhyphen{}only limited time step and \(\Delta t_{\textrm{AD}}\) is the advection\sphinxhyphen{}diffusion limited time step.

\begin{sphinxadmonition}{note}{Note:}
When there are multiple species being advected and diffused, the integrator will perform extra checks in order to maximize the time steps for the other species.
\end{sphinxadmonition}


\paragraph{Time step limitations}
\label{\detokenize{Applications/CdrPlasmaModel:time-step-limitations}}
The basic time step limitations for the Godunov integrator are:
\begin{itemize}
\item {} 
Manually set maximum and minimum time steps

\item {} 
Courant\sphinxhyphen{}Friedrichs\sphinxhyphen{}Lewy conditions, either on advection, diffusion, or both.

\item {} 
The dielectric relaxation time.

\end{itemize}

The user is responsible for setting these when running the simulation.
Note when the the semi\sphinxhyphen{}implicit scheme is used, it is not necessary to restrict the time step by the dielectric relaxation time.


\subsubsection{Spectral deferred corrections}
\label{\detokenize{Applications/CdrPlasmaModel:spectral-deferred-corrections}}\label{\detokenize{Applications/CdrPlasmaModel:chap-sisdc}}
The \sphinxcode{\sphinxupquote{CdrPlasmaImExSdcStepper}} uses implicit\sphinxhyphen{}explicit (ImEx) spectral deferred corrections (SDCs) to advance the equations.
This integrator implements the \sphinxcode{\sphinxupquote{advance}} method for \sphinxcode{\sphinxupquote{CdrPlasmStepper}}, and is a high\sphinxhyphen{}order method with implicit diffusion.


\paragraph{SDC basics}
\label{\detokenize{Applications/CdrPlasmaModel:sdc-basics}}
First, we provide a quick introduction to the SDC procedure.
Given an ordinary differential equation (ODE) as
\begin{equation*}
\begin{split}\frac{\partial u}{\partial t} = F(u,t), \quad u(t_0) = u_0,\end{split}
\end{equation*}
the exact solution is
\begin{equation*}
\begin{split}u(t) = u_0 + \int_{t_0}^tF\left(u,\tau\right)d\tau.\end{split}
\end{equation*}
Denote an approximation to this solution by \(\widetilde{u}(t)\) and the correction by \(\delta(t) = u(t) - \widetilde{u}(t)\). The measure of error in \(\widetilde{u}(t)\) is then
\begin{equation*}
\begin{split}R(\widetilde{u}, t) = u_0 + \int_{t_0}^tF(\widetilde{u}, \tau)d\tau - \widetilde{u}(t).\end{split}
\end{equation*}
Equivalently, since \(u = \widetilde{u} + \delta\), we can write
\begin{equation*}
\begin{split}\widetilde{u} + \delta = u_0 + \int_{t_0}^t F\left(\widetilde{u}+\delta, \tau\right)d\tau.\end{split}
\end{equation*}
This yields
\begin{equation*}
\begin{split}\delta = \int_{t_0}^t\left[F\left(\widetilde{u}+\delta, \tau\right) - F\left(\widetilde{u}, \tau\right)\right]d\tau + R\left(\widetilde{u},t\right).\end{split}
\end{equation*}
This is called the correction equation. The goal of SDC is to iteratively solve this equation in order to provide a high\sphinxhyphen{}order discretization.

The ImEx SDC method in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} uses implicit diffusion in the SDC scheme.
Coupling to the electric field is always explicit.
The user is responsible for specifying the quadrature nodes, as well as setting the number of sub\sphinxhyphen{}intervals in the SDC integration and the number of corrections.
In general, each correction raises the discretization order by one.


\paragraph{Time step limitations}
\label{\detokenize{Applications/CdrPlasmaModel:id2}}
The ImEx SDC integrator is limited by
\begin{itemize}
\item {} 
The dielectric relaxation time.

\item {} 
An advective CFL conditions.

\end{itemize}

In addition to this, the user can specify maximum/minimum allowed time steps.


\subsection{JSON interface}
\label{\detokenize{Applications/CdrPlasmaModel:json-interface}}\label{\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmajson}}
Since implementations of {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmaphysics}]{\sphinxcrossref{\DUrole{std,std-ref}{CdrPlasmaPhysics}}}} are usually boilerplate, we provide a class \sphinxcode{\sphinxupquote{CdrPlasmaJSON}} which can initialize and parse various types of initial conditions and reactions from a JSON input file.
This class is defined in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/PlasmaModels/CdrPlasmaJSON}}.

\sphinxcode{\sphinxupquote{CdrPlasmaJSON}} is a full implementation of \sphinxcode{\sphinxupquote{CdrPlasmaPhysics}} which supports the definition of various species (neutral, plasma species, and photons) and methods of coupling them.
We expect that \sphinxcode{\sphinxupquote{CdrPlasmaJSON}} provides the simplest method of setting up a new plasma model.
It is also comparatively straightforward to extend the class with further required functionality.

In the JSON interface, the radiative transfer solvers always solve for the number of photons that lead to photoionization events.
This means that the interpretation of \(\Psi\) is the number of photoionization events during the previous time step.
This is true for both continuum and discrete radiative transfer models.


\subsubsection{Usage}
\label{\detokenize{Applications/CdrPlasmaModel:usage}}
To use this plasma model, use \sphinxcode{\sphinxupquote{\sphinxhyphen{}physics CdrPlasmaJSON}} when setting up a new plasma problem (see {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmanewproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Simulation quick start}}}}).
When \sphinxcode{\sphinxupquote{CdrPlasmaJSON}} is instantiated, the constructor will parse species, reactions, initial conditions, and boundary conditions from a JSON file that the user provides.
In addition, users can parse transport data or reaction rates from tabulated ASCII files that they provide.

To specify the input plasma kinetics file, include


\subsubsection{Specifying input file}
\label{\detokenize{Applications/CdrPlasmaModel:specifying-input-file}}
\sphinxcode{\sphinxupquote{CdrPlasmaJSON}} will read a JSON file specified by the input variable \sphinxcode{\sphinxupquote{CdrPlasmaJSON.chemistry\_file}}.


\subsubsection{Discrete photons}
\label{\detokenize{Applications/CdrPlasmaModel:discrete-photons}}
There are two approaches when using discrete photons, and both rely on the user setting up the application with the Monte Carlo photon solver (rather than continuum solvers).
For an introduction to the particle radiative transfer solver, see {\hyperref[\detokenize{Solvers/RTE:chap-montecarlorte}]{\sphinxcrossref{\DUrole{std,std-ref}{Monte Carlo methods}}}}.

The user must use one of the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Set the following class options:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
CdrPlasmaJSON.discrete\PYGZus{}photons \PYG{o}{=} \PYG{n+nb}{true}

McPhoto.photon\PYGZus{}generation \PYG{o}{=} deterministic
McPhoto.source\PYGZus{}type       \PYG{o}{=} number
\end{sphinxVerbatim}

When specifying \sphinxcode{\sphinxupquote{CdrPlasmaJSON.discrete\_photons=true}}, \sphinxcode{\sphinxupquote{CdrPlasmaJSON}} will do a Poisson sampling of the number of photons that are generated in each cell and put this in the radiative transfer solvers’ source terms.
This means that the radiative transfer solver source terms \sphinxstyleemphasis{contain the physical number of photons generated in one time step}.
To turn off sampling inside the radiative transfer solver, we specify \sphinxcode{\sphinxupquote{McPhoto.photon\_generation = stochastic}} and set \sphinxcode{\sphinxupquote{McPhoto.source\_type = number}} to let the solver know that the source contains the number of physical photons.

\item {} 
Set the following class options:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
CdrPlasmaJSON.discrete\PYGZus{}photons \PYG{o}{=} \PYG{n+nb}{false}

McPhoto.photon\PYGZus{}generation \PYG{o}{=} stochastic
McPhoto.source\PYGZus{}type       \PYG{o}{=} volume\PYGZus{}rate
\end{sphinxVerbatim}

In this case the \sphinxcode{\sphinxupquote{CdrPlasmaJSON}} class will fill the solver source terms with the volumetric rate, i.e. the number of photons produced per unit volume and time.
When \sphinxcode{\sphinxupquote{McPhoto}} generates the photons it will compute the number of photons generated in a cell through Poisson sampling \(n = P\left(S_\gamma\Delta V\Delta t\right)\) where \(P\) indicates a Poisson sampling operator.

\end{enumerate}

Fundamentally, the two approaches differ only in where the the Poisson sampling is performed.
With the first approach, plotting the radiative transfer solver source terms will show the number of physical photons generated.
In the second approach, the source terms will show the volume photo\sphinxhyphen{}generation rate.


\subsubsection{Gas law and neutral background}
\label{\detokenize{Applications/CdrPlasmaModel:gas-law-and-neutral-background}}

\paragraph{General functionality}
\label{\detokenize{Applications/CdrPlasmaModel:general-functionality}}
To include the gas law and neutral species, include a JSON object \sphinxcode{\sphinxupquote{gas}} with the the field \sphinxcode{\sphinxupquote{law}} specified.
Currently, \sphinxcode{\sphinxupquote{law}} can be either \sphinxcode{\sphinxupquote{ideal}}, \sphinxcode{\sphinxupquote{troposphere}}, or \sphinxcode{\sphinxupquote{table}}.

The purpose of the gas law is to set the temperature, pressure, and neutral density of the background gas.
In addition, we specify the neutral species that are used through the simulation.
These species are \sphinxstyleemphasis{not} stored on the mesh; we only store function pointers to their temperature, density, and pressure.

It is also possible to include a field \sphinxcode{\sphinxupquote{plot}} which will then include the temperature, pressure, and density in plot files.


\paragraph{Ideal gas}
\label{\detokenize{Applications/CdrPlasmaModel:ideal-gas}}
To specify an ideal gas law, specify ideal gas law as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}gas\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}law\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ideal\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}temperature\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{300}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}pressure\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}
  \PYG{p}{\PYGZcb{}}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In this case the gas pressure and temperatures will be as indicated, and the gas number density will be computed as
\begin{equation*}
\begin{split}\rho = \frac{p_0^\prime N_{\textrm{A}}}{RT_0},\end{split}
\end{equation*}
where \(p^\prime\) is the pressure converted to Pascals.

Note that the input temperature should be specified in Kelvin, and the input pressure in atmospheres.


\paragraph{Troposphere}
\label{\detokenize{Applications/CdrPlasmaModel:troposphere}}
It is also possible to specify the pressure, temperature, and density to be functions of tropospheric altitude.
In this case one must specify the extra fields
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{molar mass}} For specifying the molar mass (in \(\textrm{g}\cdot\textrm{mol}^{-1}\)) of the gas.

\item {} 
\sphinxcode{\sphinxupquote{gravity}} Gravitational acceleration \(g\).

\item {} 
\sphinxcode{\sphinxupquote{lapse rate}} Temperature lapse rate \(L\) in units of \(\textrm{K}/\textrm{m}\).

\end{itemize}

In this case the gas temperature pressure, and number density are computed as
\begin{equation*}
\begin{split}T(h) = T_0 - Lh\end{split}
\end{equation*}\begin{equation*}
\begin{split}p(h) = p_0\left((1 - \frac{Lh}{T_0}\right)^{\frac{g M}{RL}}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\rho(h) = \frac{p^\prime(h) N_{\textrm{A}}}{RT(h)}\end{split}
\end{equation*}
For example, specification of tropospheric conditions can be included by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}gas\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}law\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}troposphere\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}temperature\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{300}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}pressure\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}molar\PYGZus{}mass\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{28.97}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}gravity\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{9.81}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}lapse\PYGZus{}rate\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.0065}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}plot\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Tabulated}
\label{\detokenize{Applications/CdrPlasmaModel:tabulated}}
To specify temperature, density, and pressure as function of altitude, set \sphinxcode{\sphinxupquote{law}} to \sphinxcode{\sphinxupquote{table}} and incldue the following fields:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{file}} For specifying which file we read the data from.

\item {} 
\sphinxcode{\sphinxupquote{height}} For specifying the column where the height is stored (in meters).

\item {} 
\sphinxcode{\sphinxupquote{temperature}} For specifying the column where the temperature (in Kelvin) is stored.

\item {} 
\sphinxcode{\sphinxupquote{pressure}} For specifying the column where the pressure (in Pascals) is stored.

\item {} 
\sphinxcode{\sphinxupquote{density}} For specifying the column where the density (in \(\textrm{kg}\cdot\textrm{m}^{-3}\)) is stored.

\item {} 
\sphinxcode{\sphinxupquote{molar mass}} For specifying the molar mass (in \(\textrm{g}\cdot\textrm{mol}^{-1}\)) of the gas.

\item {} 
\sphinxcode{\sphinxupquote{min height}} For setting the minimum altitude in the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} internal table.

\item {} 
\sphinxcode{\sphinxupquote{max height}} For setting the minimum altitude in the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} internal table.

\item {} 
\sphinxcode{\sphinxupquote{res height}} For setting the height resolution in the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} internal table.

\end{itemize}

For example, assume that our file \sphinxcode{\sphinxupquote{MyAtmosphere.dat}} contains the following data:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYGZsh{} z [m]              rho [kg/m\PYGZca{}3]    T [K]           p [Pa]
0.0000000E+00        1.2900000E+00   2.7210000E+02   1.0074046E+05
1.0000000E+03        1.1500000E+00   2.6890000E+02   8.8751220E+04
2.0000000E+03        1.0320000E+00   2.6360000E+02   7.8074784E+04
3.0000000E+03        9.2860000E\PYGZhy{}01   2.5690000E+02   6.8466555E+04
4.0000000E+03        8.3540000E\PYGZhy{}01   2.4960000E+02   5.9844569E+04
\end{sphinxVerbatim}

If we want to truncate this data to altitude \(z \ in[1000\,\textrm{m}, 3000\,\textrm{m}]\) we specify:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}gas\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{\PYGZdq{}law\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}table\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ENMSIS\PYGZus{}Atmosphere.dat\PYGZdq{}}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}molar mass\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{28.97}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}temperature\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}pressure\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}density\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}min height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}max height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3000}\PYG{p}{,}
    \PYG{n+nt}{\PYGZdq{}res height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Neutral species background}
\label{\detokenize{Applications/CdrPlasmaModel:neutral-species-background}}
Neutral species are included by an array \sphinxcode{\sphinxupquote{neutral species}} in the \sphinxcode{\sphinxupquote{gas}} object.
Each neutral species must have the fields
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}} Species name

\item {} 
\sphinxcode{\sphinxupquote{molar fraction}} Molar fraction of the species.

\end{itemize}

If the molar fractions do not add up to one, they will be normalized.

\begin{sphinxadmonition}{warning}{Warning:}
Neutral species are \sphinxstyleemphasis{not} tracked on the mesh.
They are simply stored as functions that allow us to obtain the (spatially varying) density, temperature, and pressure for each neutral species.
If a neutral species needs to be tracked on the mesh (through e.g. a convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solver) it must be defined as a plasma species.
See {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-plasmaspeciesjson}]{\sphinxcrossref{\DUrole{std,std-ref}{Plasma species}}}}.
\end{sphinxadmonition}

For example, a standard nitrogen\sphinxhyphen{}oxygen atmosphere will look like:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
  \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}gas\PYGZdq{}}\PYG{p}{:}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}law\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ideal\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}temperature\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{300}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}pressure\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}plot\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}neutral species\PYGZdq{}}\PYG{p}{:}
      \PYG{p}{[}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}molar\PYGZus{}fraction\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.2}
        \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}
          \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}N2\PYGZdq{}}\PYG{p}{,}
          \PYG{n+nt}{\PYGZdq{}molar\PYGZus{}fraction\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.8}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Plasma species}
\label{\detokenize{Applications/CdrPlasmaModel:plasma-species}}\label{\detokenize{Applications/CdrPlasmaModel:chap-plasmaspeciesjson}}
The list of plasma species is included by an array \sphinxcode{\sphinxupquote{plasma species}}.
Each entry \sphinxstyleemphasis{must} have the entries
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}} (string) For identifying the species name.

\item {} 
\sphinxcode{\sphinxupquote{Z}} (integer) Species charge number.

\item {} 
\sphinxcode{\sphinxupquote{mobile}} (true/false) Mobile species or not.

\item {} 
\sphinxcode{\sphinxupquote{diffusive}} (true/false) Diffusive species or not.

\end{itemize}

Optionally, the field \sphinxcode{\sphinxupquote{initial data}}, can be included for providing initial data to the species
Details are discussed further below.

For example, a minimum version would look like

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma species\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}N2+\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}diffusive\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2+\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}diffusive\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZhy{}\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}diffusive\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Initial data}
\label{\detokenize{Applications/CdrPlasmaModel:initial-data}}
To provide initial data one include \sphinxcode{\sphinxupquote{initial data}} for each species.
Currently, the following fields are supported:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{uniform}} For specifying a uniform background density.
Simply the field \sphinxcode{\sphinxupquote{uniform}} and a density (in units of \(m^{-3}\))

\item {} 
\sphinxcode{\sphinxupquote{gauss2}} for specifying Gaussian seeds \(n = n_0\exp\left(-\frac{\left(\mathbf{x}-\mathbf{x_0}\right)^2}{2R^2}\right)\).
\sphinxcode{\sphinxupquote{gauss2}} is an array where each array entry must contain
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{radius}}, for specifying the radius \(R\):

\item {} 
\sphinxcode{\sphinxupquote{amplitude}}, for specifying the amplitude \(n_0\).

\item {} 
\sphinxcode{\sphinxupquote{position}}, for specifying the seed position \(\mathbf{x}\).

\end{itemize}

The position must be a 2D/3D array.

\item {} 
\sphinxcode{\sphinxupquote{gauss2}} for specifying Gaussian seeds \(n = n_0\exp\left(-\frac{\left(\mathbf{x}-\mathbf{x_0}\right)^4}{2R^4}\right)\).
\sphinxcode{\sphinxupquote{gauss4}} is an array where each array entry must contain
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{radius}}, for specifying the radius \(R\):

\item {} 
\sphinxcode{\sphinxupquote{amplitude}}, for specifying the amplitude \(n_0\).

\item {} 
\sphinxcode{\sphinxupquote{position}}, for specifying the seed position \(\mathbf{x}\).

\end{itemize}

The position must be a 2D/3D array.

\item {} 
\sphinxcode{\sphinxupquote{height profile}} For specifying a height profile along \(y\) in 2D, and \(z\) in 3D.
To include it, prepare an ASCII files with at least two columns.
The height (in meters) must be specified in one column and the density (in units of \(m^{-3}\)) in another.
Internally, this data is stored in a lookup table (see {\hyperref[\detokenize{Utilities/LookupTable:chap-lookuptable}]{\sphinxcrossref{\DUrole{std,std-ref}{Lookup tables}}}}).
Required fields are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{file}} , for specifying the file.

\item {} 
\sphinxcode{\sphinxupquote{height}}, for specifying the column that stores the height.

\item {} 
\sphinxcode{\sphinxupquote{density}}, for specifying the column that stores the density.

\item {} 
\sphinxcode{\sphinxupquote{min height}}, for trimming data to a minimum height.

\item {} 
\sphinxcode{\sphinxupquote{max height}}, for trimming data to a maximum height.

\item {} 
\sphinxcode{\sphinxupquote{res height}}, for specifying the resolution height in the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} lookup tables.

\end{itemize}

In addition, height and density columns can be scaled in the internal tables by including
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{scale height}} for scaling the height data.

\item {} 
\sphinxcode{\sphinxupquote{scale density}} for scaling the density data.

\end{itemize}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
When multiple initial data fields are specified, \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} takes the superposition of all of them.
\end{sphinxadmonition}

For example, a species with complex initial data can look like:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma species\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}N2+\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}diffusive\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}initial data\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}uniform\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E10}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}gauss2\PYGZdq{}} \PYG{p}{:}
          \PYG{p}{[}
            \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}radius\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{100E\PYGZhy{}6}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}amplitude\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E18}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}position\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
            \PYG{p}{\PYGZcb{}}\PYG{p}{,}
            \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}radius\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{200E\PYGZhy{}6}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}amplitude\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{2E18}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}position\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
            \PYG{p}{\PYGZcb{}}
          \PYG{p}{]}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}gauss4\PYGZdq{}}\PYG{p}{:}
           \PYG{p}{[}
             \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}radius\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{300E\PYGZhy{}6}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}amplitude\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{3E18}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}position\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
             \PYG{p}{\PYGZcb{}}\PYG{p}{,}
             \PYG{p}{\PYGZob{}}
               \PYG{n+nt}{\PYGZdq{}radius\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{400E\PYGZhy{}6}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}amplitude\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{4E18}\PYG{p}{,}
               \PYG{n+nt}{\PYGZdq{}position\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
             \PYG{p}{\PYGZcb{}}
           \PYG{p}{]}\PYG{p}{,}
         \PYG{n+nt}{\PYGZdq{}height profile\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
           \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}MyHeightProfile.dat\PYGZdq{}}\PYG{p}{,}
           \PYG{n+nt}{\PYGZdq{}height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
           \PYG{n+nt}{\PYGZdq{}density\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
           \PYG{n+nt}{\PYGZdq{}min height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
           \PYG{n+nt}{\PYGZdq{}max height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{100000}\PYG{p}{,}
           \PYG{n+nt}{\PYGZdq{}res height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
           \PYG{n+nt}{\PYGZdq{}scale height\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{100}\PYG{p}{,}
           \PYG{n+nt}{\PYGZdq{}scale density\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E6}
         \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Mobilities}
\label{\detokenize{Applications/CdrPlasmaModel:mobilities}}\label{\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmajsonmobility}}
If a species is specified as mobile, the mobility is set from a field \sphinxcode{\sphinxupquote{mobility}}, and the field \sphinxcode{\sphinxupquote{lookup}} is used to specify the method for computing it.
Currently supported are:
\begin{itemize}
\item {} 
Constant mobility.

\item {} 
Function\sphinxhyphen{}based mobility, i.e. \(\mu = \mu(E,N)\).

\item {} 
Tabulated mobility, i.e. \(\mu = \mu(E,N)\).

\end{itemize}

The cases are discussed below.

\sphinxstylestrong{Constant mobility}

Setting \sphinxcode{\sphinxupquote{lookup}} to \sphinxcode{\sphinxupquote{constant}} lets the user set a constant mobility.
If setting a constant mobility, the field \sphinxcode{\sphinxupquote{value}} is also required.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma species\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}diffusive\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
     \PYG{n+nt}{\PYGZdq{}mobility\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
       \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}} \PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}value\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.05}\PYG{p}{,}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Function\sphinxhyphen{}based mobility}

Setting \sphinxcode{\sphinxupquote{lookup}} to \sphinxcode{\sphinxupquote{function E/N}}  lets the user set the mobility as a function of the reduced electric field.
When setting a function\sphinxhyphen{}based mobility, the field \sphinxcode{\sphinxupquote{function}} is also required.

Supported functions are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ABC}}, in which case the mobility is computed as
\begin{quote}
\begin{equation*}
\begin{split}\mu(E) = A \frac{E^B}{N^C}.\end{split}
\end{equation*}
The fields \sphinxcode{\sphinxupquote{A}}, \sphinxcode{\sphinxupquote{B}}, and \sphinxcode{\sphinxupquote{C}} must also be specified.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma species\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}diffusive\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
     \PYG{n+nt}{\PYGZdq{}mobility\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
       \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}} \PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}function E/N\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}function\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}ABC\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}A\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}B\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}C\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}

\sphinxstylestrong{Tabulated mobility}

Specifying \sphinxcode{\sphinxupquote{lookup}} to \sphinxcode{\sphinxupquote{table E/N}} lets the user set the mobility from a tabulated value of the reduced electric field.
BOLSIG\sphinxhyphen{}like files can be parsed by specifying the header which contains the tabulated data, and the columns that identify the reduced electric field and mobilities.
This data is then stored in a lookup table, see {\hyperref[\detokenize{Utilities/LookupTable:chap-lookuptable}]{\sphinxcrossref{\DUrole{std,std-ref}{Lookup tables}}}}.

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma species\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}diffusive\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
     \PYG{n+nt}{\PYGZdq{}mobility\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
       \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}} \PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}table E/N\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}transport\PYGZus{}file.txt\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}header\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{} Electron mobility (E/N, mu*N)\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}E/N \PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}mu*N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}min E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}max E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}points\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{100}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}spacing\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}exponential\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}dump\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}MyMobilityTable.dat\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In the above, the fields have the following meaning:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{file}} The file where the data is found.
The data must be stored in rows and columns.

\item {} 
\sphinxcode{\sphinxupquote{header}}, the contents of the line preceding the table data.

\item {} 
\sphinxcode{\sphinxupquote{E/N}}, the column that contains \(E/N\).

\item {} 
\sphinxcode{\sphinxupquote{mu*N}}, the column that contains \(\mu\cdot E\).

\item {} 
\sphinxcode{\sphinxupquote{min E/N}}, for trimming the data range.

\item {} 
\sphinxcode{\sphinxupquote{max E/N}}, for trimming the data range.

\item {} 
\sphinxcode{\sphinxupquote{points}}, for specifying the number of points in the lookup table.

\item {} 
\sphinxcode{\sphinxupquote{spacing}}, for specifying how to regularize the table.

\item {} 
\sphinxcode{\sphinxupquote{dump}}, an optional argument (useful for debugging) which will write the table to file.

\end{itemize}

Note that the input file does \sphinxstyleemphasis{not} need regularly spaced or sorted data.
For performance reasons, the tables are always resampled, see {\hyperref[\detokenize{Utilities/LookupTable:chap-lookuptable}]{\sphinxcrossref{\DUrole{std,std-ref}{Lookup tables}}}}.


\paragraph{Diffusion coefficients}
\label{\detokenize{Applications/CdrPlasmaModel:diffusion-coefficients}}
Setting the diffusion coefficient is done \sphinxstyleemphasis{exactly} in the same was as the mobility.
If a species is diffusive, one must include the field \sphinxcode{\sphinxupquote{diffusion}} as well as \sphinxcode{\sphinxupquote{lookup}}.
For example, the JSON input for specifying a tabulated diffusion coefficient is done by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma species\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e\PYGZdq{}}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,} \PYG{n+nt}{\PYGZdq{}true\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
     \PYG{n+nt}{\PYGZdq{}diffusion\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
       \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}} \PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}table E/N\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}transport\PYGZus{}file.txt\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}header\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{} Electron diffusion coefficient (E/N, D*N)\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}E/N \PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}D*N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}min E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}max E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}points\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}spacing\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}exponential\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Temperatures}
\label{\detokenize{Applications/CdrPlasmaModel:temperatures}}
Plasma species temperatures can set by including a field \sphinxcode{\sphinxupquote{temperature}} for the plasma species.

\begin{sphinxadmonition}{warning}{Warning:}
If the \sphinxcode{\sphinxupquote{temperature}} field is omitted, the species temperature will be set to the gas temperature.
\end{sphinxadmonition}

\sphinxstylestrong{Constant temperature}

To set a constant temperature, include the field \sphinxcode{\sphinxupquote{temperature}} and set \sphinxcode{\sphinxupquote{lookup}} to constant and specify the temperature through the field \sphinxcode{\sphinxupquote{value}} as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma species\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}true\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{false}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}temperature\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}value\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{300}
      \PYG{p}{\PYGZcb{}}
     \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Tabulated temperature}

To include a tabulated temperature \(T = T(E,N)\), set \sphinxcode{\sphinxupquote{lookup}} to \sphinxcode{\sphinxupquote{table E/N}}.
The temperature is then computed as
\begin{equation*}
\begin{split}T = \frac{2 \epsilon}{3k_{\textrm{B}}},\end{split}
\end{equation*}
where \(\epsilon\) is the energy and \(k_{\textrm{B}}\) is the Boltzmann constant.

The following fields are required:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{file}} for specifying which file the temperature is stored.

\item {} 
\sphinxcode{\sphinxupquote{header}} for specifying where in the file the temperature is stored.

\item {} 
\sphinxcode{\sphinxupquote{E/N}} for specifying in which column we find \(E/N\).

\item {} 
\sphinxcode{\sphinxupquote{eV}} for specifying in which column we find the species energy (in units of electron volts).

\item {} 
\sphinxcode{\sphinxupquote{min E/N}} for trimming the data range.

\item {} 
\sphinxcode{\sphinxupquote{max E/N}} for trimming the data range.

\item {} 
\sphinxcode{\sphinxupquote{points}} for setting the number of points in the lookup table.

\item {} 
\sphinxcode{\sphinxupquote{spacing}} for setting the grid point spacing type.

\item {} 
\sphinxcode{\sphinxupquote{dump}} for writing the final table to file.

\end{itemize}

For a further explanation to these fields, see {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmajsonmobility}]{\sphinxcrossref{\DUrole{std,std-ref}{Mobilities}}}}.

A complete example is:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma species\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}Z\PYGZdq{}}\PYG{p}{:}  \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}mobile\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}true\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}temperature\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}table E/N\PYGZdq{}}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}transport\PYGZus{}data.txt\PYGZdq{}}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}header\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{} Electron mean energy (E/N, eV)\PYGZdq{}}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}eV\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}min E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}max E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}points\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}spacing\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}exponential\PYGZdq{}}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}dump\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}MyTemperatureTable.dat\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}
     \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Photon species}
\label{\detokenize{Applications/CdrPlasmaModel:photon-species}}
As for the plasma species, photon species (for including radiative transfer) are included by an array \sphinxcode{\sphinxupquote{photon species}}.
For each species, the required fields are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{name}} For setting the species name.

\item {} 
\sphinxcode{\sphinxupquote{kappa}} For specifying the absorption coefficient.

\end{itemize}

Currently, \sphinxcode{\sphinxupquote{kappa}} can be either
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{constant}} Which lets the user set a constant absorption coefficient.

\item {} 
\sphinxcode{\sphinxupquote{helmholtz}} Computes the absorption coefficient as
\begin{equation*}
\begin{split}\kappa = \frac{p_X\lambda}{\sqrt{3}}\end{split}
\end{equation*}
where \(\lambda\) is a specified input parameter and \(p_X\) is the partial pressure of some species \(X\).

\item {} 
\sphinxcode{\sphinxupquote{stochastic A}} which samples a random absorption coefficient as
\begin{equation*}
\begin{split}\kappa = K_1 \left(\frac{K_2}{K_1}\right)^{\frac{f-f1}{f2-f1}}.\end{split}
\end{equation*}
Here, \(f_1\) and \(f_2\) are frequency ranges, \(K_1\) and \(K_2\) are absorption coefficients, and \(f\) is a stochastically sampled frequency.
Note that this method is only sensible when using discrete photons.

\end{itemize}

\sphinxstylestrong{Constant absorption coefficients}

When specifying a constant absorption coefficient, one must include a field \sphinxcode{\sphinxupquote{value}} as well.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}photon species\PYGZdq{}}\PYG{p}{:}
   \PYG{p}{[}
     \PYG{p}{\PYGZob{}}
       \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}UVPhoton\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}kappa\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}value\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E4}
     \PYG{p}{\PYGZcb{}}
   \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Helmholtz absorption coefficients}

The interface for the Helmholtz\sphinxhyphen{}based absorption coefficients are inspired by Bourdon \sphinxstyleemphasis{et al.} {[}\hyperlink{cite.ZZReferences:id12}{2}{]} approach for computing photoionization.
This method only makes sense if doing a Helmholtz\sphinxhyphen{}based reconstruction of the photoionization profile as a relation:
\begin{equation*}
\begin{split}\left[\nabla^2 - \left(p_{\textrm{O}_2} \lambda\right)^2\right]S_\gamma = -\left(A p_{\textrm{O}_2}^2\frac{p_q}{p + p_q}\xi\nu\right)S_i,\end{split}
\end{equation*}
where
\begin{itemize}
\item {} 
\(S_\gamma\) is the number of photoionization events per unit volume and time.

\item {} 
\(A\) is a model coefficient.

\item {} 
\(\frac{p_q}{p + p_q}\) is a quenching factor.

\item {} 
\(\xi\) is a photoionization efficiency.

\item {} 
\(\nu\) is a relative excitation efficiency.

\item {} 
\(S_i\) is the electron impact ionization source term.

\end{itemize}

Since the radiative transfer solver is based on the Eddington approximation, the Helmholtz reconstruction can be written as
\begin{equation*}
\begin{split}\kappa \Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla \Psi\right) = \frac{\eta}{c}\end{split}
\end{equation*}
where the absorption coefficient is set as
\begin{equation*}
\begin{split}\kappa(\mathbf{x}) = \frac{p_{\textrm{O}_2}\lambda}{\sqrt{3}}.\end{split}
\end{equation*}
The photogeneration source term is still
\begin{equation*}
\begin{split}\eta = \frac{p_q}{p + p_q}\xi\nu S_i,\end{split}
\end{equation*}
but the photoionization term is
\begin{equation*}
\begin{split}S_\gamma = \frac{c A p_{\textrm{O}_2}}{\sqrt{3}\lambda}\Psi.\end{split}
\end{equation*}
Note that the photoionization term is, in principle, \sphinxstyleemphasis{not} an Eddington approximation.
Rather, the Eddington\sphinxhyphen{}like equations occur here through an approximation of the exact integral solution to the radiative transfer problem.
In the pure Eddington approximation, on the other hand, \(\Psi\) represents the total number of ionizing photons per unit volume, and we would have \(S_\gamma = \frac{\Psi}{\Delta t}\) where \(\Delta t\) is the time step.

When specifying the \sphinxcode{\sphinxupquote{kappa}} field as \sphinxcode{\sphinxupquote{helmholtz}}, the absorption coefficient is computed as
\begin{equation*}
\begin{split}\kappa(\mathbf{x}) = \frac{p_X\left(\mathbf{x}\right)\lambda}{\sqrt{3}}\end{split}
\end{equation*}
where \(p_X\) is the partial pressure of a species \(X\) and \(\lambda\) is the same input parameter as in the Helmholtz reconstruction.
These are specified through fields \sphinxcode{\sphinxupquote{neutral}} and \sphinxcode{\sphinxupquote{lambda}} as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}photon species\PYGZdq{}}\PYG{p}{:}
   \PYG{p}{[}
     \PYG{p}{\PYGZob{}}
       \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}UVPhoton\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}kappa\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}helmholtz\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}lambda\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.0415}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}neutral\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZdq{}}
     \PYG{p}{\PYGZcb{}}
   \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This input will set \(\kappa\left(\mathbf{x}\right) = \frac{p_{\textrm{O}_2}\left(\mathbf{x}\right)\lambda}{\sqrt{3}}\).

\begin{sphinxadmonition}{note}{Note:}
The source term \(\eta\) is specified when specifying the plasma reactions, see {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmareactionsjson}]{\sphinxcrossref{\DUrole{std,std-ref}{Plasma reactions}}}}.
\end{sphinxadmonition}

\sphinxstylestrong{Stochastic sampling}

Setting the \sphinxcode{\sphinxupquote{kappa}} field to \sphinxcode{\sphinxupquote{stochastic A}} will stochastically sample the absorption length from
\begin{equation*}
\begin{split}\kappa = K_1 \left(\frac{K_2}{K_1}\right)^{\frac{f-f1}{f2-f1}}.\end{split}
\end{equation*}
where \(K_1 = p_X\chi_{\textrm{min}}\), \(K_1 = p_X\chi_{\textrm{max}}\), and \(f_1\) and \(f_2\) are frequency ranges.
Like above, \(p_X\) is the partial pressure of some species \(X\).
Note that all input parameters are given in SI units.

Stochastic sampling of the absorption length only makes sense when using discrete photons \textendash{} this particular method is inspired by the method in Chanrion and Neubert {[}\hyperlink{cite.ZZReferences:id163}{3}{]}.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}photon species\PYGZdq{}}\PYG{p}{:}
   \PYG{p}{[}
     \PYG{p}{\PYGZob{}}
       \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}UVPhoton\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}kappa\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}stochastic A\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}neutral\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZdq{}}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}f1\PYGZdq{}}\PYG{p}{:}   \PYG{l+m+mf}{2.925E15}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}f2\PYGZdq{}}\PYG{p}{:}   \PYG{l+m+mf}{3.059E15}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}chi min\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{2.625E\PYGZhy{}2}\PYG{p}{,}
       \PYG{n+nt}{\PYGZdq{}chi max\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1.5}
     \PYG{p}{\PYGZcb{}}
   \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Plasma reactions}
\label{\detokenize{Applications/CdrPlasmaModel:plasma-reactions}}\label{\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmareactionsjson}}
Plasma reactions are reactions between charged and neutral species and are written in the form
\begin{equation*}
\begin{split}A + B + \ldots \rightarrow C + D + \ldots.\end{split}
\end{equation*}
Importantly, the left hand side of the reaction can only consist of charged or neutral species.
It is not permitted to put a photon species on the left hand side of these reactions; photo\sphinxhyphen{}ionization is handled separately by another set of reaction types (see {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-photoreactionsjson}]{\sphinxcrossref{\DUrole{std,std-ref}{Photo\sphinxhyphen{}reactions}}}}).
However, photon species \sphinxstyleemphasis{can} appear on the left hand side of the equation.

When specifying reactions in this form, the reaction rate is computed as
\begin{equation*}
\begin{split}R = k n_A n_B\ldots\end{split}
\end{equation*}
When computing the source term for some species \(X\), we subtract \(R\) for each time \(X\) appears on the left hand side of the reaction and add \(R\) for each time \(X\) appears on the right\sphinxhyphen{}hand side of the reaction.


\paragraph{Specifying reactions}
\label{\detokenize{Applications/CdrPlasmaModel:specifying-reactions}}
Reactions of the above type are handled by a JSON array \sphinxcode{\sphinxupquote{plasma reactions}}, with required fields:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{reaction}} (string) containing the reaction process.

\item {} 
\sphinxcode{\sphinxupquote{lookup}} (string) for determining how to compute the reaction rate.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + O2 \PYGZhy{}\PYGZgt{} e + e + O2+\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}30}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This adds a reaction \(\textrm{e} + \textrm{O}_2 \rightarrow \textrm{e} + \textrm{e} + \textrm{O}_2^+\) to the reaction set.
We compute
\begin{equation*}
\begin{split}R = kn_{\textrm{e}}n_{\textrm{O}_2^+}\end{split}
\end{equation*}
and set
\begin{equation*}
\begin{split}S_{\textrm{e}} = S_{\textrm{O}_2^+} = R.\end{split}
\end{equation*}
Some caveats when setting the reaction string are:
\begin{itemize}
\item {} 
Whitespace are separators.
For example, \sphinxcode{\sphinxupquote{O2+e}} will be interpreted as a species with string identifier \sphinxcode{\sphinxupquote{O2+e}}, but \sphinxcode{\sphinxupquote{O2 + e}} will interpreted as a reaction between \sphinxcode{\sphinxupquote{O2}} and \sphinxcode{\sphinxupquote{e}}.

\item {} 
The reaction string \sphinxstyleemphasis{must} contain a left and right hand side separated by \sphinxcode{\sphinxupquote{\sphinxhyphen{}\textgreater{}}}.
An error will be thrown if this symbol can not be found.

\item {} 
The left\sphinxhyphen{}hand must consist \sphinxstyleemphasis{only} of neutral or plasma species.
If the left\sphinxhyphen{}hand side consists of species that are not neutral or plasma species, an error will be thrown.

\item {} 
The right\sphinxhyphen{}hand side can consist of either neutral, plasma species, or photon species.
Otherwise, an error will be thrown.

\item {} 
The reaction string will be checked for charge conservation.

\end{itemize}

Note that if a reaction involves a right\sphinxhyphen{}hand side that is not otherwise tracked, the user should omit the species from the right\sphinxhyphen{}hand side altogether.
For example, if we have a model which tracks the species \(e\) and \(\textrm{O}_2^+\) but we want to include the dissociative recombination reaction \(e + \textrm{O}_2^+ \rightarrow O + O\), this reaction should be added to the reaction with an empty right\sphinxhyphen{}hand side:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + O2 \PYGZhy{}\PYGZgt{} e + e + O2+\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}30}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + O2+ \PYGZhy{}\PYGZgt{} \PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}30}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Wildcards}
\label{\detokenize{Applications/CdrPlasmaModel:wildcards}}\label{\detokenize{Applications/CdrPlasmaModel:cdrplasma-wildcards}}
Reaction specifiers may include the wildcard \sphinxcode{\sphinxupquote{@}} which is a placeholder for another species.
The wildcards must be specified by including a JSON array \sphinxcode{\sphinxupquote{@}} of the species that the wildcard is replaced by.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}N2+ + N2 + @ \PYGZhy{}\PYGZgt{} N4+ + @\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}@\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}N2\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}30}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The above code will add two reactions to the reaction set: \(N_2 + N_2 + N_2 \rightarrow N_4^+ + N_2\) and \(N_2 + N_2 + \textrm{O}_2 \rightarrow N_4^+ + \textrm{O}_2\).
It is not possible to set different reaction rates for the two reactions.


\paragraph{Plotting reactions}
\label{\detokenize{Applications/CdrPlasmaModel:plotting-reactions}}
It is possible to have \sphinxcode{\sphinxupquote{CdrPlasmaJSON}} include the reaction rates in the HDF5 output files by including a field \sphinxcode{\sphinxupquote{plot}} as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + O2 \PYGZhy{}\PYGZgt{} e + e + O2+\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}plot\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}30}\PYG{p}{,}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Plotting the reaction rate can be useful for debugging or analysis.
Note that it is, by extension, also possible to add useful data to the I/O files from reactions that otherwise do not contribute to the discharge evolution.
For example, if we know the rate \(k\) for excitation of nitrogen to a specific excited state, but do not otherwise care about tracking the excited state, we can add the reaction as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + N2 \PYGZhy{}\PYGZgt{} e + N2\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}plot\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}30}\PYG{p}{,}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This reaction is a dud in terms of the discharge evolution (the left and right hand sides are the same), but it can be useful for plotting the excitation rate.

\begin{sphinxadmonition}{note}{Note:}
This functionality should be used with care because each reaction increases the I/O load.
\end{sphinxadmonition}


\paragraph{Constant reaction rates}
\label{\detokenize{Applications/CdrPlasmaModel:constant-reaction-rates}}
To set a constant reaction rate for a reaction, set the field \sphinxcode{\sphinxupquote{lookup}} to \sphinxcode{\sphinxupquote{"constant"}} and specify the rate.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + O2 \PYGZhy{}\PYGZgt{} e + e + O2+\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}30}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Function based rates}
\label{\detokenize{Applications/CdrPlasmaModel:function-based-rates}}\begin{itemize}
\item {} 
To set a rate dependent on two species temperature in the form \(k(T_1, T_2) = c_1\left(T_1/T_2\right)^{c_2}\), set \sphinxcode{\sphinxupquote{lookup}} to \sphinxcode{\sphinxupquote{functionT1T2 A}}.
The user must specify which temperatures are involved by specifying the fields \sphinxcode{\sphinxupquote{T1}}, \sphinxcode{\sphinxupquote{T2}}, as well as the constants through fields \sphinxcode{\sphinxupquote{c1}} and \sphinxcode{\sphinxupquote{c2}}.
For example, to include the reaction \(e + \textrm{O}_2 + \textrm{O}_2 \rightarrow \textrm{O}_2^- + O2\) in the set, with this reaction having a rate
\begin{equation*}
\begin{split}k = 2.4\times 10^{-41}\left(\frac{T_{\textrm{O}_2}}{T_e}\right),\end{split}
\end{equation*}
we add the following:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + O2 + O2 \PYGZhy{}\PYGZgt{} O2\PYGZhy{} + O2\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}functionT1T2 A\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}T1\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}T2\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}c1\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{2.41E\PYGZhy{}41}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}c2\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}


\paragraph{Tabulated rates}
\label{\detokenize{Applications/CdrPlasmaModel:tabulated-rates}}
To set a tabulated rate with \(k = k(E,N)\), set the field \sphinxcode{\sphinxupquote{lookup}} to \sphinxcode{\sphinxupquote{table E/N}} and specify the file, header, and data format to be used.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + O2 \PYGZhy{}\PYGZgt{} e + e + O2+\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}table E/N\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}transport\PYGZus{}file.txt\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}header\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{} O2 ionization (E/N, rate/N)\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}E/N \PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}min E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}max E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}spacing\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}exponential\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}points\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}plot\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}dump\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZus{}ionization.dat\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{file}} field specifies which field to read the reaction rate from, while \sphinxcode{\sphinxupquote{header}} indicates where in the file the reaction rate is found.
The file parser will read the files below the header line until it reaches an empty line.
The fields \sphinxcode{\sphinxupquote{E/N}} and \sphinxcode{\sphinxupquote{rate/N}} indicate the columns where the reduced electric field and reaction rates are stored.

The final fields \sphinxcode{\sphinxupquote{min E/N}}, \sphinxcode{\sphinxupquote{max E/N}}, and \sphinxcode{\sphinxupquote{points}} are formatting fields that trim the range of the data input and organizes the data along a table with \sphinxcode{\sphinxupquote{points}} entries.
As with the mobilities (see \DUrole{xref,std,std-ref}{Chap:CdrPlasmaJSONMobilities}), the \sphinxcode{\sphinxupquote{spacing}} argument determines whether or not the internal interpolation table uses uniform or exponential grid point spacing.
Finally, the \sphinxcode{\sphinxupquote{dump}} argument will tell \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} to dump the table to file, which is useful for debugging or quality assurance of the tabulated data.


\paragraph{Collisional quenching}
\label{\detokenize{Applications/CdrPlasmaModel:collisional-quenching}}
To quench a reaction, include a field \sphinxcode{\sphinxupquote{qenching\_pressure}} and specify the \sphinxstyleemphasis{quenching pressure} (in atmospheres).
When computing reaction rates, the rate for the reaction will be modified as
\begin{equation*}
\begin{split}k \rightarrow k\frac{p_q}{p_q + p}\end{split}
\end{equation*}
where \(p^q\) is the quenching pressure and \(p = p(\mathbf{x})\) is the gas pressure.

\begin{sphinxadmonition}{important}{Important:}
The quenching pressure should be specified in Pascal.
\end{sphinxadmonition}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + N2 \PYGZhy{}\PYGZgt{} e + N2 + Y\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}table E/N\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}transport\PYGZus{}file.txt\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}header\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{} N2 ionization (E/N, rate/N)\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}E/N \PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}min E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}max E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}points\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}spacing\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}exponential\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}quenching pressure\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4000}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Reaction efficiencies}
\label{\detokenize{Applications/CdrPlasmaModel:reaction-efficiencies}}
To modify a reaction efficiency, include a field \sphinxcode{\sphinxupquote{efficiency}} and specify it.
This will modify the reaction rate as
\begin{equation*}
\begin{split}k \rightarrow \nu k\end{split}
\end{equation*}
where \(\nu\) is the reaction efficiency.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + N2 \PYGZhy{}\PYGZgt{} e + N2 + Y\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}table E/N\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}transport\PYGZus{}file.txt\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}header\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{} N2 ionization (E/N, rate/N)\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}E/N \PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}min E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}max E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}points\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}spacing\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}exponential\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}efficiency\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.6}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Scaling reactions}
\label{\detokenize{Applications/CdrPlasmaModel:scaling-reactions}}
Reactions can be scaled by including a \sphinxcode{\sphinxupquote{scale}} argument to the reaction.
This works exactly like the \sphinxcode{\sphinxupquote{efficiency}} field outlined above.


\paragraph{Energy correction}
\label{\detokenize{Applications/CdrPlasmaModel:energy-correction}}
Occasionally, it can be necessary to incorporate an energy correction to models, accounting e.g. for electron energy loss near strong gradients.
The JSON interface supports the correction in Soloviev and Krivtsov {[}\hyperlink{cite.ZZReferences:id101}{7}{]}.
To use it, include an (optional) field \sphinxcode{\sphinxupquote{soloviev}} and specify \sphinxcode{\sphinxupquote{correction}} and \sphinxcode{\sphinxupquote{species}}.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}plasma reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e + N2 \PYGZhy{}\PYGZgt{} e + N2 + Y\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}table E/N\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}file\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}transport\PYGZus{}file.txt\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}header\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}\PYGZsh{} N2 ionization (E/N, rate/N)\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}E/N \PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}rate/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}min E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}max E/N\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}points\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}spacing\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}exponential\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}efficiency\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.6}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}soloviev\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}correction\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}species\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}e\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

When this energy correction is enabled, the rate coefficient is modified as
\begin{equation*}
\begin{split}k \rightarrow k\left(1 + \frac{\mathbf{E}\cdot D_s\nabla n_s}{\mu_s n_s E^2}\right),\end{split}
\end{equation*}
where \(s\) is the species specified in the \sphinxcode{\sphinxupquote{soloviev}} field, \(n_s\) is the density and \(D_s\) and \(\mu_s\) are diffusion and mobility coefficients.
We point out that the correction factor is restricted such that the reaction rate is always non\sphinxhyphen{}negative.
Note that this correction makes sense when rates are dependent only on the electric field, see Soloviev and Krivtsov {[}\hyperlink{cite.ZZReferences:id101}{7}{]}.

\begin{sphinxadmonition}{note}{Note:}
When using the energy correction, the specifies species must be both mobile and diffusive.
\end{sphinxadmonition}


\subsubsection{Photo\sphinxhyphen{}reactions}
\label{\detokenize{Applications/CdrPlasmaModel:photo-reactions}}\label{\detokenize{Applications/CdrPlasmaModel:chap-photoreactionsjson}}
Photo\sphinxhyphen{}reactions are reactions between charged/neutral and photons in the form
\begin{equation*}
\begin{split}A + B + \gamma + \ldots \rightarrow C + D + \ldots.\end{split}
\end{equation*}
where species \(A, B, \ldots\) are charged and neutral species and \(\gamma\) is a photon.
The left hand side can contain only \sphinxstyleemphasis{one} photon species, and the right\sphinxhyphen{}hand side can not contain a photon species.
In other words, two\sphinxhyphen{}photon absorption is not supported, and photons that are absorbed on the mesh cannot become new photons.
This is not a fundamental limitation, but a restriction imposed by the JSON interface.


\paragraph{Specifying reactions}
\label{\detokenize{Applications/CdrPlasmaModel:id7}}
Reactions of the above type are handled by a JSON array \sphinxcode{\sphinxupquote{photo reactions}}, with required fields:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{reaction}} (string) containing the reaction process.

\item {} 
\sphinxcode{\sphinxupquote{lookup}} (string) for determining how to compute the reaction rate.

\end{itemize}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}photo reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}Y + O2 \PYGZhy{}\PYGZgt{} e + O2+\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The rules for specifying reaction strings are the same as for the plasma reactions, see \DUrole{xref,std,std-ref}{CdrPlasmaReactionsJSON}.
Wildcards also apply, see {\hyperref[\detokenize{Applications/CdrPlasmaModel:cdrplasma-wildcards}]{\sphinxcrossref{\DUrole{std,std-ref}{Wildcards}}}}.


\paragraph{Default behavior}
\label{\detokenize{Applications/CdrPlasmaModel:default-behavior}}
Since the radiative transfer solvers solve for the number of ionizing photons, the CDR solver source terms are incremented by
\begin{equation*}
\begin{split}S \rightarrow S + \frac{\Psi}{\Delta t}.\end{split}
\end{equation*}
where \(\Psi\) is the number of ionizing photons per unit volume (i.e., the solution \(\Psi\)).


\paragraph{Helmholtz reconstruction}
\label{\detokenize{Applications/CdrPlasmaModel:helmholtz-reconstruction}}
When performing a Helmholtz reconstruction the photoionization source term is
\begin{equation*}
\begin{split}S = \frac{c A p_{\textrm{O}_2}}{\sqrt{3}\lambda}\Psi.\end{split}
\end{equation*}
To modify the source term for consistency with Helmholtz reconstruction specify the field \sphinxcode{\sphinxupquote{helmholtz}} with variables
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{A}}. the \(A\) coefficient.

\item {} 
\sphinxcode{\sphinxupquote{lambda}}. the \(\lambda\) coefficient.
This value will also be specified in the photon species, but it is not retrieved automatically.

\item {} 
\sphinxcode{\sphinxupquote{neutral}}. The neutral species for which we obtain the partial pressure.

\end{itemize}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}photo reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}Y + O2 \PYGZhy{}\PYGZgt{} e + O2+\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}helmholtz\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}A\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1.1E\PYGZhy{}4}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}lambda\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.0415}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}neutral\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Scaling reactions}
\label{\detokenize{Applications/CdrPlasmaModel:id8}}
Photo\sphinxhyphen{}reactions can be scaled by including a \sphinxcode{\sphinxupquote{scale}} argument.
For example, to completely turn off the photoreaction above:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}photo reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}Y + O2 \PYGZhy{}\PYGZgt{} e + O2+\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}helmholtz\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{n+nt}{\PYGZdq{}A\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1.1E\PYGZhy{}4}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}lambda\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.0415}\PYG{p}{,}
        \PYG{n+nt}{\PYGZdq{}neutral\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}O2\PYGZdq{}}
      \PYG{p}{\PYGZcb{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}scale\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.0}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{EB boundary conditions}
\label{\detokenize{Applications/CdrPlasmaModel:eb-boundary-conditions}}
Boundary conditions on the embedded boundary are included by the fields
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{electrode reactions}}, for specifying secondary emission on electrodes.

\item {} 
\sphinxcode{\sphinxupquote{dielectric reactions}}, for specifying secondary emission on dielectrics.

\end{itemize}

To include secondary emission, the user must specify a reaction string in the form \(A \rightarrow B\), and also include an emission rate.
Currently, we only support constant emission rates (i.e., secondary emission coefficients).
This is likely to change in the future.

The following points furthermore apply:
\begin{itemize}
\item {} 
By default, standard outflow boundary conditions.
When \sphinxcode{\sphinxupquote{electrode reactions}} or \sphinxcode{\sphinxupquote{dielectric reactions}} are specified, the user only controls the \sphinxstyleemphasis{inflow} back into the domain.

\item {} 
Wildcards can appear on the left hand side of the reaction.

\item {} 
If one specifies \(A + B \rightarrow C\) for a surface reaction, this is the same as specifying two reactions \(A \rightarrow C\) and \(B\rightarrow C\).
The same emission coefficient will be used for both reactions.

\item {} 
Both photon species and plasma species can appear on the left hand side of the reaction.

\item {} 
Photon species can not appear on the right\sphinxhyphen{}hand side of the reaction; we do not include surface sources for photoionization.

\item {} 
To scale reactions, include a modifier \sphinxcode{\sphinxupquote{scale}}.

\end{itemize}

For example, the following specification will set secondary emission efficiencies to \(10^{-3}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{\PYGZob{}}\PYG{n+nt}{\PYGZdq{}electrode reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}@ \PYGZhy{}\PYGZgt{} e\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}@\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}N2+\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}O2+\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}N4+\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}O4+\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}O2+N2\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}value\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}4}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}\PYG{p}{,}
 \PYG{n+nt}{\PYGZdq{}dielectric reactions\PYGZdq{}}\PYG{p}{:}
  \PYG{p}{[}
    \PYG{p}{\PYGZob{}} \PYG{n+nt}{\PYGZdq{}reaction\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}@ \PYGZhy{}\PYGZgt{} e\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}@\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}N2+\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}O2+\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}N4+\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}O4+\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}O2+N2\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}lookup\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}constant\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}value\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1E\PYGZhy{}3}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\end{sphinxVerbatim}


\subsubsection{Domain boundary conditions}
\label{\detokenize{Applications/CdrPlasmaModel:domain-boundary-conditions}}
TODO.


\subsection{Simulation quick start}
\label{\detokenize{Applications/CdrPlasmaModel:simulation-quick-start}}\label{\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmanewproblem}}
New problems that use the \sphinxcode{\sphinxupquote{CdrPlasma}} physics model are best set up by using the Python tools provided with the module.
Navigate to \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/CdrPlasma\textasciigrave{}}} and set up the problem with.
To see the list of available options type

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{cd} \PYG{n+nv}{\PYGZdl{}DISCHARGE\PYGZus{}HOME}/Physics/CdrPlasma
./setup.py \PYGZhy{}\PYGZhy{}help
\end{sphinxVerbatim}

The following options are helpful for setting up the problem:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{base\_dir}} The base directory where the application will be placed.
Defaults to \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/MyApplications}}.

\item {} 
\sphinxcode{\sphinxupquote{app\_name}} The application name.
The application will be put in \sphinxcode{\sphinxupquote{base\_dir/app\_name}}.

\item {} 
\sphinxcode{\sphinxupquote{geometry}} The geometry to be used.
The geometry must be one of the ones provided in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Geometries}} (users can also provide their own models).

\item {} 
\sphinxcode{\sphinxupquote{physics}} The plasma physics model.
This must be one of the folders/class in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/CdrPlasma/PlasmaModel}} (users can also provide their own models).
Defaults to \sphinxcode{\sphinxupquote{CdrPlasmaJSON}} (see {\hyperref[\detokenize{Applications/CdrPlasmaModel:chap-cdrplasmajson}]{\sphinxcrossref{\DUrole{std,std-ref}{JSON interface}}}}).

\item {} 
\sphinxcode{\sphinxupquote{time\_stepper}} Time integrator.
This must derive from \sphinxcode{\sphinxupquote{CdrPlasmaStepper}} and must be one of the time steppers in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/CdrPlasma/TimeSteppers}}.
The default integrator is \sphinxcode{\sphinxupquote{CdrPlasmaGodunovStepper}}.

\item {} 
\sphinxcode{\sphinxupquote{cell\_tagger}} Cell tagger
This must derive from \sphinxcode{\sphinxupquote{CdrPlasmaTagger}} and must be one of the cell taggers in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/CdrPlasma/CellTaggers}}.

\end{itemize}

For example, to set up a geometry\sphinxhyphen{}less that does not use AMR, do

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{cd} \PYG{n+nv}{\PYGZdl{}DISCHARGE\PYGZus{}HOME}
./setup.py \PYGZhy{}app\PYGZus{}name\PYG{o}{=}MyApplication
\end{sphinxVerbatim}


\section{Electrostatics}
\label{\detokenize{Applications/ElectrostaticsModel:electrostatics}}\label{\detokenize{Applications/ElectrostaticsModel:chap-electrostaticsmodel}}\label{\detokenize{Applications/ElectrostaticsModel::doc}}

\section{Geometry}
\label{\detokenize{Applications/GeometryModel:geometry}}\label{\detokenize{Applications/GeometryModel:chap-geometrymodel}}\label{\detokenize{Applications/GeometryModel::doc}}

\section{Radiative transfer}
\label{\detokenize{Applications/RadiativeTransferModel:radiative-transfer}}\label{\detokenize{Applications/RadiativeTransferModel:chap-radiativetransfermodel}}\label{\detokenize{Applications/RadiativeTransferModel::doc}}

\chapter{Tutorial}
\label{\detokenize{index:tutorial}}

\section{Introduction}
\label{\detokenize{Tutorials/Tutorial:introduction}}\label{\detokenize{Tutorials/Tutorial:chap-tutorial}}\label{\detokenize{Tutorials/Tutorial::doc}}
In this tutorial we will set up and examine the code for simulating advection\sphinxhyphen{}diffusion problems with AMR and regridding functionality.
If you want to examine the final code, it is given in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Physics/AdvectionDiffusion}}.


\section{Creating a geometry}
\label{\detokenize{Tutorials/Tutorial:creating-a-geometry}}

\section{Setting up a \sphinxstyleliteralintitle{\sphinxupquote{TimeStepper}}}
\label{\detokenize{Tutorials/Tutorial:setting-up-a-timestepper}}

\chapter{Utilities}
\label{\detokenize{index:utilities}}

\section{Lookup tables}
\label{\detokenize{Utilities/LookupTable:lookup-tables}}\label{\detokenize{Utilities/LookupTable:chap-lookuptable}}\label{\detokenize{Utilities/LookupTable::doc}}
\sphinxcode{\sphinxupquote{LookupTable}} is a class for looking up and interpolation data stored in a row\sphinxhyphen{}column format.
It is used in order to easily retrieve input data that can be stored in table formats.

\begin{sphinxadmonition}{important}{Important:}
LookupTable is used for data lookup \sphinxstyleemphasis{in one independent variable}.
It does not support higher\sphinxhyphen{}dimensional data interpolation.
\end{sphinxadmonition}

The class is templated as

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{template} \PYG{o}{\PYGZlt{}}\PYG{n+nb}{int} \PYG{n}{N}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{LookupTable}
\end{sphinxVerbatim}

where the template parameter \sphinxcode{\sphinxupquote{N}} indicates the number of columns in the data holders.
Internally, the data is stored as an \sphinxcode{\sphinxupquote{std::vector\textless{}std::array\textless{}Real, N\textgreater{} \textgreater{}}} where the vector entries are rows and the \sphinxcode{\sphinxupquote{std::array\textless{}Real, N\textgreater{}}} are data in each row.
Thus, a table \sphinxcode{\sphinxupquote{LookupTable\textless{}2\textgreater{}}} always has two columns.

The \sphinxcode{\sphinxupquote{LookupTable}} is used on regularly spaced data (for performance reasons).
Although the user can fill irregularly spaced data into \sphinxcode{\sphinxupquote{LookupTable}}, the class has routines for making that data regularly spaced and sorted along of its columns.
Usage of \sphinxcode{\sphinxupquote{LookupTable}} will therefore consist of the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Add data rows into the table.

\item {} 
Swap columns if necessary.

\item {} 
Restrict data ranges if necessary.

\item {} 
Sort the table along of it’s columns, smallest to largest.

\item {} 
Regularize the table with a specified number of grid points.

\item {} 
\sphinxstyleemphasis{Retrieve data}.

\end{enumerate}

The steps for these processes are explained in detail below.


\subsection{Inserting data}
\label{\detokenize{Utilities/LookupTable:inserting-data}}
To add data to the table, one will use the member function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{Ts}\PYG{o}{\PYGZgt{}}
\PYG{k+kr}{inline}
\PYG{k+kt}{void} \PYG{n}{addEntry}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Ts}\PYG{o}{\PYGZam{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the parameter pack must have \sphinxcode{\sphinxupquote{N}} entries.
For example, to add two rows of data to a table:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{LookupTable}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}} \PYG{n}{myTable}\PYG{p}{;}

\PYG{n}{myTable}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{l+m+mf}{6.0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{myTable}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This will insert two new rows at the end up the table.

\begin{sphinxadmonition}{important}{Important:}
Input data points do not need to be uniformly spaced, or even sorted.
Users will insert rows one by one; \sphinxcode{\sphinxupquote{LookupTable}} has functions for sorting and regularizing the table.
\end{sphinxadmonition}


\subsection{Restricting ranges}
\label{\detokenize{Utilities/LookupTable:restricting-ranges}}
To restrict the data range, call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{setRange}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}min}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}max}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}independentVariable}\PYG{p}{)}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{a\_min}} and \sphinxcode{\sphinxupquote{a\_max}} are the permissible ranges for data in the input column (\sphinxcode{\sphinxupquote{a\_independentVariable}}).
Data outside these ranges are discarded from the table.


\subsection{Independent variable}
\label{\detokenize{Utilities/LookupTable:independent-variable}}
To select an independent variable, the user will select one of the columns and sort the data along that column.
The C++ code for this is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k+kt}{int} \PYG{n}{N}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{LookupTable}\PYG{o}{\PYGZlt{}}\PYG{n}{N}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sort}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}independentVariable}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the input integer indicates the column (i.e., independent variable) used for sorting.
Note that the sorting \sphinxstyleemphasis{is always from smallest to largest value}.
Thus, if one has two rows

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
1.0  5.0  6.0
2.0  2.0  3.0
\end{sphinxVerbatim}

and one calls \sphinxcode{\sphinxupquote{LookupTable\textless{}N\textgreater{}::sort(1)}} the final table becomes

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
2.0  2.0  3.0
1.0  5.0  6.0
\end{sphinxVerbatim}

Note that the second column now becomes the independent variable.


\subsection{Swapping columns}
\label{\detokenize{Utilities/LookupTable:swapping-columns}}
Columns can be swapped by calling \sphinxcode{\sphinxupquote{LookupTable\textless{}N\textgreater{}::swap(int, int)}}, which will swap two of the columns.
For example if the original data is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
2.0  2.0  3.0
1.0  5.0  6.0
\end{sphinxVerbatim}

and one calls \sphinxcode{\sphinxupquote{swap(1,2)}} the final table becomes

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
2.0  3.0  2.0
1.0  6.0  5.0
\end{sphinxVerbatim}

Note that swapping two columns destroys the sorting and one will need to set the independent variable again afterwards.


\subsection{Regularize table}
\label{\detokenize{Utilities/LookupTable:regularize-table}}
To regularize the table the user must first determine if the grid points should be uniformly spaced or exponentially spaced in the independent variable.


\subsubsection{Setting grid point spacing}
\label{\detokenize{Utilities/LookupTable:setting-grid-point-spacing}}
The user can set the spacing by calling

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{setTableSpacing}\PYG{p}{(}\PYG{k}{const} \PYG{n}{TableSpacing} \PYG{n}{a\PYGZus{}spacing}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{TableSpacing::Uniform}} and \sphinxcode{\sphinxupquote{TableSpacing::Exponential}} are supported.
For example, to use uniformly or exponentially spaced grid points:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{LookupTable}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{n}{myTable}\PYG{p}{;}

\PYG{n}{myTable}\PYG{p}{.}\PYG{n}{setTableSpacing}\PYG{p}{(}\PYG{n}{TableSpacing}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Uniform}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// For uniformly spaced points}
\PYG{n}{myTable}\PYG{p}{.}\PYG{n}{setTableSpacing}\PYG{p}{(}\PYG{n}{TableSpacing}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Exponential}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// For exponentially spaced points}
\end{sphinxVerbatim}

\sphinxstylestrong{Uniform spacing}

With uniform spacing, grid points in the table are spaced as
\begin{equation*}
\begin{split}x_i = x_{\textrm{min}} + \frac{i}{N-1}\left(x_{\textrm{max}} - x_{\textrm{min}}\right),\quad i\in[0,N-1]\end{split}
\end{equation*}
where \(x_{\textrm{min}}\) and \(x_{\textrm{max}}\) is the minimum and maximum data range for the independent variable (i.e., column).

\sphinxstylestrong{Exponential spacing}

If grid points are exponentially spaced then
\begin{equation*}
\begin{split}x_i = x_{\textrm{min}}\left(\frac{x_{\textrm{max}}}{x_{\textrm{min}}}\right)^{\frac{i-1}{N}}, \quad i\in[0,N-1].\end{split}
\end{equation*}

\subsubsection{Regularizing table}
\label{\detokenize{Utilities/LookupTable:regularizing-table}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{regularize}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}numRows}\PYG{p}{)}
\end{sphinxVerbatim}

which will make the table into a regularly spaced table with \sphinxcode{\sphinxupquote{a\_numRows}} rows.
\sphinxcode{\sphinxupquote{LookupTable}} will always use piecewise linear interpolation when regularizing the table.
Specifying a number of rows that is smaller/larger than the original number of rows will downsample/upsample the table.

\begin{sphinxadmonition}{important}{Important:}
When regularizing a table through \sphinxcode{\sphinxupquote{regularize}}, the original data table is destroyed.
\end{sphinxadmonition}


\subsection{Retrieving data}
\label{\detokenize{Utilities/LookupTable:retrieving-data}}
To retrieve data from one of the columns, one can fetch either a specific value in a row, or the entire row.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// For fetching column K}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int} \PYG{n}{K}\PYG{o}{\PYGZgt{}}
\PYG{n}{Real} \PYG{n}{getEntry}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}x}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// For fetching the entire row}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{array}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{,} \PYG{n}{N}\PYG{o}{\PYGZgt{}} \PYG{n}{getData}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In the above, the template parameter \sphinxcode{\sphinxupquote{K}} is the column to retrieve and \sphinxcode{\sphinxupquote{a\_x}} is the value of the independent variable.

\begin{sphinxadmonition}{important}{Important:}
\sphinxcode{\sphinxupquote{LookupTable}} will \sphinxstyleemphasis{always} use piecewise linear interpolation between two grid points.
\end{sphinxadmonition}

For example, consider table regularized and sorted along the middle column:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
2.0  1.0  3.0
1.0  3.0  6.0
1.0  5.0  4.0
\end{sphinxVerbatim}

To retrieve an interpolated value for \sphinxcode{\sphinxupquote{x=2.0}} in the third column we call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{LookupTable}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}} \PYG{n}{myTable}\PYG{p}{,}

\PYG{k}{const} \PYG{n}{Real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{myTable}\PYG{p}{.}\PYG{n}{getEntry}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

which will return a value of 4.5 (linearly interpolated).


\subsection{Viewing tables}
\label{\detokenize{Utilities/LookupTable:viewing-tables}}
For debugging purposes, \sphinxcode{\sphinxupquote{LookupTable}} can write the internal data to an output stream or a file through the two member functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{dumpTable}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}outputStream} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{dumpTable}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}fileName}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{LookupTable}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{o}{\PYGZgt{}} \PYG{n}{myTable}\PYG{p}{;}

\PYG{c+c1}{// Dump table to terminal window}
\PYG{n}{myTable}\PYG{p}{.}\PYG{n}{dumpTable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Dump table to file.}
\PYG{n}{myTable}\PYG{p}{.}\PYG{n}{dumpTable}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myTable.dat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Random numbers}
\label{\detokenize{Utilities/RandomNumbers:random-numbers}}\label{\detokenize{Utilities/RandomNumbers:chap-random}}\label{\detokenize{Utilities/RandomNumbers::doc}}
\sphinxcode{\sphinxupquote{Random}} is a static class for generating pseudo\sphinxhyphen{}random numbers, and exist so that all random number operations can be aggregated into a single class.
Internally, \sphinxcode{\sphinxupquote{Random}} use a Mersenne\sphinxhyphen{}Twister random number generation.

To use the \sphinxcode{\sphinxupquote{Random}} class, simply include \sphinxcode{\sphinxupquote{\textless{}CD\_Random.H\textgreater{}}}, e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}CD\PYGZus{}Random.H\PYGZgt{}}
\end{sphinxVerbatim}

See the \sphinxhref{https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classRandom.html}{Random API} for further details.


\subsection{Drawing random numbers}
\label{\detokenize{Utilities/RandomNumbers:drawing-random-numbers}}
The general routine for drawing a random number is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{Real} \PYG{n}{get}\PYG{p}{(}\PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}distribution}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

which is for example used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{uniform\PYGZus{}real\PYGZus{}distribution}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{dist}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{100.0}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{Real} \PYG{n}{randomNumber} \PYG{o}{=} \PYG{n}{Random}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get}\PYG{p}{(}\PYG{n}{dist}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Pre\sphinxhyphen{}defined distributions exist for performing the following operations:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
For drawing a real number from a uniform distribution between 0 and 1, use \sphinxcode{\sphinxupquote{Real Random::getUniformReal01()}}.

\item {} 
For drawing a real number from a uniform distribution between \sphinxhyphen{}1 and 1, use \sphinxcode{\sphinxupquote{Real Random::getUniformReal11()}}.

\item {} 
For drawing a real number from a normal distribution centered at 0 and with a variance of 1, use \sphinxcode{\sphinxupquote{Real Random::getNormal01()}}.

\item {} 
For drawing an integer from a Poisson distribution with a specified mean, use \sphinxcode{\sphinxupquote{T Random::getPoisson\textless{}T\textgreater{}(const Real a\_mean)}} where \sphinxcode{\sphinxupquote{T}} is an integer type.

\item {} 
For drawing a random direction in space, use \sphinxcode{\sphinxupquote{RealVect Random::getDirection()}}.
The implementation uses the Marsaglia algorithm for drawing coordinates uniformly distributed over the unit sphere.

\end{enumerate}


\subsection{Setting the seed}
\label{\detokenize{Utilities/RandomNumbers:setting-the-seed}}
By default, the random number generator is seeded with the MPI rank, which we do to avoid having the MPI ranks producing the same number sequences.
\sphinxcode{\sphinxupquote{Driver}} (see {\hyperref[\detokenize{Source/Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{Driver}}}}) will seed the random number generator, and user can override the seed by setting \sphinxcode{\sphinxupquote{Random.seed = \textless{}number\textgreater{}}} in the input script.
If the user sets \sphinxcode{\sphinxupquote{\textless{}number\textgreater{} \textless{} 0}} then a random seed will be produced based on the elapsed CPU clock time.
If running with MPI, this seed is obtained by only one of the MPI ranks, and this seed is then broadcast to all the other ranks.
The other ranks will then increment the seed by their own MPI rank number so that each MPI rank gets a unique seed.


\section{Least squares}
\label{\detokenize{Utilities/LeastSquares:least-squares}}\label{\detokenize{Utilities/LeastSquares:chap-leastsquares}}\label{\detokenize{Utilities/LeastSquares::doc}}
Least squares routines are useful for reconstructing a local polynomial in the vicinity of the embedded boundary.
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} supports the expansion of such solutions in a fairly general way.
The need for such routines are motivated e.g. by the fact that the embedded boundary introduces grid pathologies which are difficult to meet with pure finite differencing.
An example of this is filling ghost cells near the embedded boundary.


\subsection{Polynomial expansion}
\label{\detokenize{Utilities/LeastSquares:polynomial-expansion}}
Given some position \(\mathbf{x}\), we expand the solution around a grid point \(\mathbf{x}_{\mathbf{i}}\) to some order \(Q\):
\begin{equation*}
\begin{split}f\left(\mathbf{x}_{\mathbf{i}}\right) = f\left(\mathbf{x}_{\mathbf{i}}\right) + \nabla f\left(\mathbf{x}\right) \cdot \left(\mathbf{x}_{\mathbf{i}} - \mathbf{x}\right) + \ldots + \mathcal{O}\left(\Delta x^{Q+1}\right).\end{split}
\end{equation*}
Using multi\sphinxhyphen{}index notation this is written as
\begin{equation*}
\begin{split}f\left(\mathbf{x}_{\mathbf{i}}\right) = \sum_{|\alpha| \leq Q}\frac{\left(\mathbf{x}_{\mathbf{i}}-\mathbf{x}\right)^\alpha}{\alpha!} \left(\partial^\alpha f\right)\left(\mathbf{x}\right) + \mathcal{O}\left(\Delta x^{Q+1}\right),\end{split}
\end{equation*}
where \(\alpha\) is a multi\sphinxhyphen{}index.
For a specified order \(Q\) there is also a specified number of unknowns.
E.g. in two dimensions with \(Q = 1\) the unknowns are \(f\left(\mathbf{x}\right)\), \(\partial_x f\left(\mathbf{x}\right)\), and \(\partial_y f\left(\mathbf{x}\right)\).

By expanding the solution around more grid points, we can formulate an over\sphinxhyphen{}determined system of equations \(\mathbf{i} = 1, 2, 3, \ldots, N\) that allows us to compute the coefficients (i.e., unknowns) in the Taylor expansion.
By using lexicographical ordering of the multi\sphinxhyphen{}indices, it is straightforward to write the system out explicitly.
E.g., for \(Q = 1\) in two dimensions:
\begin{equation*}
\begin{split}\begin{pmatrix}
1 & (x_1 - x) & (y - y_1) \\
1 & (x_2 - x) & (y - y_2) \\
\vdots & \ddots & \vdots \\
1 & (x_N - x) & (y - y_N) \\
\end{pmatrix}
\begin{pmatrix}
f            \\
\partial_x f \\
\partial_y f \\
\end{pmatrix}(\mathbf{x})
=
\begin{pmatrix}
f(\mathbf{x}_1) \\
f(\mathbf{x}_2) \\
\vdots \\
f(\mathbf{x}_N)
\end{pmatrix}\end{split}
\end{equation*}
In general, we represent this system as
\begin{equation*}
\begin{split}\mathbf{A}\mathbf{u} = \mathbf{b},\end{split}
\end{equation*}
where unknowns in \(\mathbf{u}\) are the coefficients in the Taylor series, ordered lexicographically (encoded with a Chombo \sphinxcode{\sphinxupquote{IntVect}}).
\(\mathbf{b}\) is a column vector of grid point values representing the local expansion around each grid point, and \(\mathbf{A}\) is the expansion matrix.

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is not restricted to second order \textendash{} it implements the above expansion to any order.
\end{sphinxadmonition}


\subsection{Neighborhood algorithm}
\label{\detokenize{Utilities/LeastSquares:neighborhood-algorithm}}
To avoid reaching over or around embedded boundaries, the neighborhood algorithms only includes grid cells which can be reached by a \sphinxstyleemphasis{monotone} path.
This path is defined by walking through neighboring grid cells without changing direction, see e.g. \hyperref[\detokenize{Utilities/LeastSquares:monotonepath}]{Fig.\@ \ref{\detokenize{Utilities/LeastSquares:monotonepath}}}.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{MonotonePath}.png}
\caption{Neighborhood algorithm, only reaching into grid cells that can be reached by a monotone path. The grid cell at the end of the dashed line is excluded (even though it is a neighbor to the starting grid cell) since the path circulates the embedded boundary.}\label{\detokenize{Utilities/LeastSquares:id1}}\label{\detokenize{Utilities/LeastSquares:monotonepath}}\end{figure}


\subsection{Weighted equations}
\label{\detokenize{Utilities/LeastSquares:weighted-equations}}
Weights can also be added to each equation, e.g. to ensure that close grid points are more important than remote ones:
\begin{equation*}
\begin{split}\begin{pmatrix}
w_1 & w_1(x_1 - x) & w_N(y - y_1) \\
w_2 & w_2(x_2 - x) & w_N(y - y_2) \\
\vdots & \ddots & \vdots \\
w_N & w_N(x_N - x) & w_N(y - y_N) \\
\end{pmatrix}
\begin{pmatrix}
f            \\
\partial_x f \\
\partial_y f \\
\end{pmatrix}(\mathbf{x})
=
\begin{pmatrix}
w_1f(\mathbf{x}_1) \\
w_2f(\mathbf{x}_2) \\
\vdots \\
w_Nf(\mathbf{x}_N)
\end{pmatrix}\end{split}
\end{equation*}
For weighted least squares the system is represented as
\begin{equation*}
\begin{split}\mathbf{W}\mathbf{A}\mathbf{u} = \mathbf{W}\mathbf{b},\end{split}
\end{equation*}
where \(\mathbf{W}\) are the weights.
Typically, the weights are some power of the Euclidean distance
\begin{equation*}
\begin{split}w_{\mathbf{i}} = \frac{1}{\left|\mathbf{x}_{\mathbf{i}} - \mathbf{x}\right|^p}.\end{split}
\end{equation*}

\subsection{Pseudo\sphinxhyphen{}inverse}
\label{\detokenize{Utilities/LeastSquares:pseudo-inverse}}
An over\sphinxhyphen{}determined system does not have a unique solution, and so to obtain the solution to \(\mathbf{u}\) for the system \(\mathbf{W}\mathbf{A}\mathbf{u} = \mathbf{W}\mathbf{b}\) we use ordinary least squres.
The solution is then
\begin{equation*}
\begin{split}\mathbf{u} = \left[\left(\mathbf{W}\mathbf{A}\right)^+ \mathbf{W}\right]\mathbf{b},\end{split}
\end{equation*}
where \(\left(\mathbf{W}\mathbf{A}\right)^+\) is the Moore\sphinxhyphen{}Penrose inverse of \(\mathbf{W}\mathbf{A}\).
The pseudo\sphinxhyphen{}inverse is computed using the singular value decomposition (SVD) routines in LAPACK.

Note that the column vector \(\mathbf{b}\) consist of known values (grid points), and the result \(\left[\left(\mathbf{W}\mathbf{A}\right)^+ \mathbf{W}\right]\) can therefore be represented as a stencil.
For example, in two dimensions with \(Q = 1\) we find
\begin{equation*}
\begin{split}\begin{pmatrix}
f            \\
\partial_x f \\
\partial_y f
\end{pmatrix}(\mathbf{x})
=
\begin{pmatrix}
C_{11} & C_{12} & \ldots & C_{1N} \\
C_{21} & C_{22} & \ddots & C_{2N} \\
C_{31} & C_{32} & \ldots & C_{3N} \\
\end{pmatrix}
\begin{pmatrix}
f(\mathbf{x}_1) \\
f(\mathbf{x}_2) \\
\vdots \\
f(\mathbf{x}_N)
\end{pmatrix}\end{split}
\end{equation*}

\subsection{Pruning equations}
\label{\detokenize{Utilities/LeastSquares:pruning-equations}}
If some terms in the Taylor series are specified, one can prune equations from the systems.
E.g. if \(f\left(\mathbf{x}\right)\) happens to be known, the system of equations can be rewritten as
\begin{equation*}
\begin{split}\begin{pmatrix}
w_1(x_1 - x) & w_N(y - y_1) \\
w_2(x_2 - x) & w_N(y - y_2) \\
\vdots & \vdots \\
w_N(x_N - x) & w_N(y - y_N) \\
\end{pmatrix}
\begin{pmatrix}
\partial_x f \\
\partial_y f \\
\end{pmatrix}(\mathbf{x})
=
\begin{pmatrix}
w_1f(\mathbf{x}_1) - w_1f(\mathbf{x})  \\
w_2f(\mathbf{x}_1) - w_2f(\mathbf{x})  \\
\vdots \\
w_Nf(\mathbf{x}_1) - w_Nf(\mathbf{x})  \\
\end{pmatrix}\end{split}
\end{equation*}
Again, following the benefits of lexicographical ordering it is straightforward to write an arbitrary order system of equations in the form \(\mathbf{W}\mathbf{A}\mathbf{u} = \mathbf{W}\mathbf{b}\), even with an arbitrary number of terms pruned from the Taylor series.
However, note that the result of the least squares solve is now in the format
\begin{equation*}
\begin{split}\begin{pmatrix}
\partial_x f \\
\partial_y f
\end{pmatrix}(\mathbf{x})
=
\begin{pmatrix}
C_{11} & C_{12} & \ldots & C_{1N} \\
C_{21} & C_{22} & \ldots & C_{2N} \\
\end{pmatrix}
\begin{pmatrix}
f(\mathbf{x}_1) - f(\mathbf{x}) \\
f(\mathbf{x}_2) - f(\mathbf{x}) \\
\vdots \\
f(\mathbf{x}_N) - f(\mathbf{x}) \\
\end{pmatrix}.\end{split}
\end{equation*}
Thus, when evaluating the terms in the polynomial expansion the user must account for the modified right\sphinxhyphen{}hand side due to equation pruning.
The modification to the right\sphinxhyphen{}hand side also depends on which terms are pruned from the expansion.


\subsection{Source code}
\label{\detokenize{Utilities/LeastSquares:source-code}}
The source code for the least squares routines is found in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Source/Utilities/CD\_LeastSquares.*}}, and the neighborhood algorithms are found in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Source/Utilities/CD\_VofUtils.*}}.


\chapter{Contributing}
\label{\detokenize{index:contributing}}

\section{Contributions}
\label{\detokenize{Contrib/Contributions:contributions}}\label{\detokenize{Contrib/Contributions:chap-contributions}}\label{\detokenize{Contrib/Contributions::doc}}
We welcome feedback, bug reports, and contributions to \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
If you have feedback, questions, or general types of queries, use the issue tracker or discussion tab at \sphinxhref{https://github.com/chombo-discharge/chombo-discharge}{https://github.com/chombo\sphinxhyphen{}discharge}.

If you want to submit code to \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, use the pull request system at \sphinxhref{https://github.com/chombo-discharge/chombo-discharge}{https://github.com/chombo\sphinxhyphen{}discharge}.


\section{Convergence testing}
\label{\detokenize{Contrib/Convergence:convergence-testing}}\label{\detokenize{Contrib/Convergence:chap-convergence}}\label{\detokenize{Contrib/Convergence::doc}}

\section{Continuous integration}
\label{\detokenize{Contrib/CI:continuous-integration}}\label{\detokenize{Contrib/CI:chap-ci}}\label{\detokenize{Contrib/CI::doc}}
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} uses continuous integration at GitHub.
These tests consist of cloning, installing, and running various \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} tests.


\subsection{GitHub actions}
\label{\detokenize{Contrib/CI:github-actions}}
The tests defined in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Exec/Tests}} are automatically run when opening a pull request.
In general, all tests must pass before a pull request can be merged.
The tests status can be observed either in the pull request, or at \sphinxurl{https://github.com/chombo-discharge/chombo-discharge/actions}.
GitHub actions usually take 1\sphinxhyphen{}2 hours to complete.


\subsection{Running tests locally}
\label{\detokenize{Contrib/CI:running-tests-locally}}
The tests are defined in \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Exec/Tests}} and can be run using various configurations.
Generally, it is a good idea to run the tests locally before running them at GitHub (which can be slower).


\subsubsection{Running all tests}
\label{\detokenize{Contrib/CI:running-all-tests}}
To do a clean compile and run of all tests, navigate to \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME/Exec/Tests}} and execute the following:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
python3 tests.py \PYGZhy{}\PYGZhy{}compile \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{}silent \PYGZhy{}\PYGZhy{}no\PYGZus{}compare \PYGZhy{}\PYGZhy{}parallel \PYGZhy{}cores X
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{X}} is the number of cores to use when compiling and running.
If the tests should be run in serial, omit the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}parallel \sphinxhyphen{}cores X}} flag.


\subsubsection{Test suite options}
\label{\detokenize{Contrib/CI:test-suite-options}}
The following options are available for running the various tests:


\subsubsection{Using benchmark files}
\label{\detokenize{Contrib/CI:using-benchmark-files}}
The test suite can generate benchmark files which can later be compared against new test suite output files.
This can be a good idea if one wants to ensure that changes the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} code does not affect output files.
In this case one can run the test suite and generate benchmark files \sphinxstyleemphasis{before} adding changes to \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}.
Once the code development is completed, the benchmark files can later be bit\sphinxhyphen{}wise compared against the results of a later test suite.

This consists of the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstyleemphasis{Before} making changes to \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, generate benchmark files with

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
python3 tests.py \PYGZhy{}\PYGZhy{}compile \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{}silent \PYGZhy{}\PYGZhy{}parallel \PYGZhy{}cores X \PYGZhy{}\PYGZhy{}benchmark
\end{sphinxVerbatim}

\item {} 
Make the required changes to the \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} code.

\item {} 
Run the test suite again, and compare benchmark and output files as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
python3 tests.py \PYGZhy{}\PYGZhy{}compile \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{}silent \PYGZhy{}\PYGZhy{}parallel \PYGZhy{}cores X
\end{sphinxVerbatim}

\end{enumerate}


\section{Code standard}
\label{\detokenize{Contrib/CodeStandard:code-standard}}\label{\detokenize{Contrib/CodeStandard:chap-codestandard}}\label{\detokenize{Contrib/CodeStandard::doc}}
When submitting new code to \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}, the following guidelines below show be followed.


\subsection{C++ standard}
\label{\detokenize{Contrib/CodeStandard:c-standard}}
We are currently at \sphinxcode{\sphinxupquote{c++14}}.


\subsection{Namespace}
\label{\detokenize{Contrib/CodeStandard:namespace}}
All code in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}} is embedded in a namespace \sphinxcode{\sphinxupquote{ChomboDischarge}}.
Embedding into a namespace is done by including header file \sphinxcode{\sphinxupquote{CD\_NamespaceHeader.H}} that contain the necessary definitions.
This is done by including after any other file includes.
In addition, files must include \sphinxcode{\sphinxupquote{CD\_NamespaceFooter.H}} at the end.


\subsection{File names}
\label{\detokenize{Contrib/CodeStandard:file-names}}
Each file should contain only one class definition, and the file name must be name of the class prepended by \sphinxcode{\sphinxupquote{CD\_}}.
For example, if you are contributing a class \sphinxcode{\sphinxupquote{MyClass}} the header files for this class must be named \sphinxcode{\sphinxupquote{CD\_MyClass.H}} and the implementation file must be named \sphinxcode{\sphinxupquote{CD\_MyClass.cpp}}.
If your code contains templates or inlined functions, these should be defined in files appended by \sphinxcode{\sphinxupquote{Implem}}, e.g. \sphinxcode{\sphinxupquote{CD\_MyClassImplem.H}}.


\subsection{File headers}
\label{\detokenize{Contrib/CodeStandard:file-headers}}
Each file shall begin with the following note:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+cm}{/* chombo\PYGZhy{}discharge}
\PYG{c+cm}{* Copyright © \PYGZlt{}Copyright holder 1\PYGZgt{}}
\PYG{c+cm}{* Copyright © \PYGZlt{}Copyright holder 2\PYGZgt{}}
\PYG{c+cm}{* Please refer to Copyright.txt and LICENSE in the chombo\PYGZhy{}discharge root directory.}
\PYG{c+cm}{*/}
\end{sphinxVerbatim}

where \sphinxstyleemphasis{\textless{}Copyright holder 1\textgreater{}}, \sphinxstyleemphasis{\textless{}Copyright holder 2\textgreater{}}, etc. are replaced by the copyright holder.

This file header shall be followed by a brief Doxygen documentation, containing at least \sphinxcode{\sphinxupquote{@file}}, \sphinxcode{\sphinxupquote{@brief}}, and \sphinxcode{\sphinxupquote{@author}}.

File inclusions should use the follow standards for C++, \sphinxcode{\sphinxupquote{Chombo}}, and \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstyleemphasis{C++}. Use brackets, e.g. \sphinxcode{\sphinxupquote{\#include \textless{}memory\textgreater{}}}.

\item {} 
\sphinxcode{\sphinxupquote{Chombo}}. Use brackets, e.g. \sphinxcode{\sphinxupquote{\#include \textless{}LevelData.H\textgreater{}}}.

\item {} 
\sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}. Use brackets and the file name, e.g. \sphinxcode{\sphinxupquote{\#include \textless{}CD\_FieldSolver.H\textgreater{}}}.

\end{enumerate}

Here is a complete example of a header file in \sphinxcode{\sphinxupquote{chombo\sphinxhyphen{}discharge}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+cm}{/* chombo\PYGZhy{}discharge}
\PYG{c+cm}{* Copyright © \PYGZlt{}Copyright holder 1\PYGZgt{}}
\PYG{c+cm}{* Copyright © \PYGZlt{}Copyright holder 2\PYGZgt{}}
\PYG{c+cm}{* Please refer to Copyright.txt and LICENSE in the chombo\PYGZhy{}discharge root directory.}
\PYG{c+cm}{*/}

\PYG{c+cm}{/*!}
\PYG{c+cm}{  @file   CD\PYGZus{}MyClass.H}
\PYG{c+cm}{  @brief  This file contains ...}
\PYG{c+cm}{  @author Author name}
\PYG{c+cm}{*/}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef CD\PYGZus{}MyClass\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define CD\PYGZus{}MyClass\PYGZus{}H}

\PYG{c+c1}{// Std includes (e.g.)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}memory\PYGZgt{}}

\PYG{c+c1}{// Chombo includes (e.g.)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}LevelData.H\PYGZgt{}}

\PYG{c+c1}{// Our includes (e.g.)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}CD\PYGZus{}EBAMRData.H\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}CD\PYGZus{}NamespaceHeader.H\PYGZgt{}}

\PYG{c+cm}{/*!}
\PYG{c+cm}{  @brief This class does the following: ....}
\PYG{c+cm}{*/}
\PYG{k}{class} \PYG{n+nc}{MyClass}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}

\PYG{c+c1}{//...}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}CD\PYGZus{}NamespaceFooter.H\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}CD\PYGZus{}MyClassImplem.H\PYGZgt{} // Inline and template code included at the end.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsection{Code syntax}
\label{\detokenize{Contrib/CodeStandard:code-syntax}}

\subsubsection{Class names, functions, and variables}
\label{\detokenize{Contrib/CodeStandard:class-names-functions-and-variables}}
We use the following syntax:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Class names, structs, and namespaces should be in Pascal case where the first letter of every word is capitalized.
E.g. a class is called \sphinxcode{\sphinxupquote{MyClass}}.

\item {} 
Class functions should be in Camel case where the first letter of every word but the first is capitalized.
E.g. functions should be named \sphinxcode{\sphinxupquote{MyClass::myFunction}}

\item {} 
Variables should use Pascal\sphinxhyphen{}case, with the following requirements:
\begin{itemize}
\item {} 
Arguments to functions should be prepended by \sphinxcode{\sphinxupquote{a\_}}. For example \sphinxcode{\sphinxupquote{MyClass::myFunction(int a\_inputVariable)}}.

\item {} 
Class members should always be prepended by \sphinxcode{\sphinxupquote{m\_}}, indicating it is a member of a class. For example \sphinxcode{\sphinxupquote{MyClass::m\_functionMember}}.

\item {} 
Static variables are prepended by \sphinxcode{\sphinxupquote{s\_}}. For example \sphinxcode{\sphinxupquote{MyClass::s\_staticFunctionMember}}.

\item {} 
Global variables are prepended by \sphinxcode{\sphinxupquote{//}}.

\end{itemize}

\end{enumerate}


\subsubsection{Code formatting}
\label{\detokenize{Contrib/CodeStandard:code-formatting}}
We use \sphinxcode{\sphinxupquote{clang\sphinxhyphen{}format}} for formatting the source code.
Before opening a pull request for review, navigate to \sphinxcode{\sphinxupquote{\$DISCHARGE\_HOME}} and format the code using

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
find Source Physics Geometries Exec \PYG{l+s+se}{\PYGZbs{}(} \PYGZhy{}name \PYG{l+s+s2}{\PYGZdq{}*.H\PYGZdq{}} \PYGZhy{}o \PYGZhy{}name \PYG{l+s+s2}{\PYGZdq{}*.cpp\PYGZdq{}} \PYG{l+s+se}{\PYGZbs{})} \PYGZhy{}exec clang\PYGZhy{}format \PYGZhy{}i \PYG{o}{\PYGZob{}}\PYG{o}{\PYGZcb{}} +
\end{sphinxVerbatim}


\subsection{Options files}
\label{\detokenize{Contrib/CodeStandard:options-files}}
Options files are named using the same convention as class files, e.g. \sphinxcode{\sphinxupquote{CD\_MyClass.options}}.
It is the responsibility of \sphinxcode{\sphinxupquote{MyClass}} to parse these variables correctly.

Everything in the options file should be lower\sphinxhyphen{}case, with the exception of the class name which should follow the class name syntax.
If you need a separator for the variable, use an underscore \sphinxcode{\sphinxupquote{\_}}.
For variables that should be grouped under a common block, use a dot \sphinxcode{\sphinxupquote{.}} for grouping them.
For a class \sphinxcode{\sphinxupquote{MyClass}} and options file might look something like

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
MyClass.input\PYGZus{}variable \PYG{o}{=} \PYG{l+m}{1}.0
MyClass.bc.x.lo        \PYG{o}{=} dirichlet \PYG{l+m}{1}.0
\end{sphinxVerbatim}


\section{References}
\label{\detokenize{ZZReferences:references}}\label{\detokenize{ZZReferences::doc}}


\begin{sphinxthebibliography}{1}
\bibitem[1]{ZZReferences:id38}
Marsha Berger and Isidore Rigoutsos. An Algorithm for Point Clustering and Grid Generation. \sphinxstyleemphasis{IEEE Transactions on Systems, Man and Cybernetics}, 1991. \sphinxhref{https://doi.org/10.1109/21.120081}{doi:10.1109/21.120081}.
\bibitem[2]{ZZReferences:id12}
A Bourdon, V P Pasko, N Y Liu, S Célestin, P Ségur, and E Marode. Efficient models for photoionization produced by non\sphinxhyphen{}thermal gas discharges in air based on radiative transfer and the Helmholtz equations. \sphinxstyleemphasis{Plasma Sources Science and Technology}, 16(3):656\textendash{}678, aug 2007. URL: \sphinxurl{http://stacks.iop.org/0963-0252/16/i=3/a=026?key=crossref.26470bbe9c1f765777a162c80aa57bb7}, \sphinxhref{https://doi.org/10.1088/0963-0252/16/3/026}{doi:10.1088/0963\sphinxhyphen{}0252/16/3/026}.
\bibitem[3]{ZZReferences:id163}
O. Chanrion and T. Neubert. A PIC\sphinxhyphen{}MCC code for simulation of streamer propagation in air. \sphinxstyleemphasis{Journal of Computational Physics}, 2008. \sphinxhref{https://doi.org/10.1016/j.jcp.2008.04.016}{doi:10.1016/j.jcp.2008.04.016}.
\bibitem[4]{ZZReferences:id82}
P Colella, D T Graves, T J Ligocki, G Miller, D Modiano, P O Schwartz, B Van Straalen, J Pilliod, D Trebotich, M Barad, B Keen, A Nonaka, and C Shen. EBChombo software package for cartesian grid, embedded boundary applications. Technical Report, Lawrence Berkeley National Laboratory, 2004.
\bibitem[5]{ZZReferences:id164}
Brian T.N. Gunney and Robert W. Anderson. Advances in patch\sphinxhyphen{}based adaptive mesh refinement scalability. \sphinxstyleemphasis{Journal of Parallel and Distributed Computing}, 2016. \sphinxhref{https://doi.org/10.1016/j.jpdc.2015.11.005}{doi:10.1016/j.jpdc.2015.11.005}.
\bibitem[6]{ZZReferences:id51}
Edward W. Larsen, Guido Thömmes, Axel Klar, Seaid Mohammed, and Thomas Götz. Simplified PN Approximations to the Equations of Radiative Heat Transfer and Applications. \sphinxstyleemphasis{Journal of Computational Physics}, 183(2):652\textendash{}675, dec 2002. URL: \sphinxurl{https://www.sciencedirect.com/science/article/pii/S0021999102972104}, \sphinxhref{https://doi.org/10.1006/JCPH.2002.7210}{doi:10.1006/JCPH.2002.7210}.
\bibitem[7]{ZZReferences:id101}
V R Soloviev and V M Krivtsov. Surface barrier discharge modelling for aerodynamic applications. \sphinxstyleemphasis{Journal of Physics D: Applied Physics}, 42(12):125208, jun 2009. URL: \sphinxurl{http://stacks.iop.org/0022-3727/42/i=12/a=125208?key=crossref.6a72c0ae60b829dd552a56b7f9dfa90c}, \sphinxhref{https://doi.org/10.1088/0022-3727/42/12/125208}{doi:10.1088/0022\sphinxhyphen{}3727/42/12/125208}.
\bibitem[8]{ZZReferences:id157}
David Trebotich and Daniel Graves. An adaptive finite volume method for the incompressible Navier\textendash{}Stokes equations in complex geometries. \sphinxstyleemphasis{Commun. Appl. Math. Comput. Sci.}, 10(1):43\textendash{}82, 2015. URL: \sphinxurl{https://doi.org/10.2140/camcos.2015.10.43}, \sphinxhref{https://doi.org/10.2140/camcos.2015.10.43}{doi:10.2140/camcos.2015.10.43}.
\bibitem[9]{ZZReferences:id34}
E. H. Twizell, A. B. Gumel, and M. A. Arigu. Second\sphinxhyphen{}order,L 0\sphinxhyphen{}stable methods for the heat equation with time\sphinxhyphen{}dependent boundary conditions. \sphinxstyleemphasis{Advances in Computational Mathematics}, 6(1):333\textendash{}352, 1996. URL: \sphinxurl{http://link.springer.com/10.1007/BF02127712}, \sphinxhref{https://doi.org/10.1007/BF02127712}{doi:10.1007/BF02127712}.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}