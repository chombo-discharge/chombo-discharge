/*!
  @file   euler_maruyama_storage.H
  @brief  Declaration of scratch storage for euler_maruyama
  @author Robert Marskar
  @date   Feb. 2018
*/

#ifndef _EULER_MARUYAMA_STORAGE_
#define _EULER_MARUYAMA_STORAGE_

#include "euler_maruyama.H"
#include "CD_AmrMesh.H"

#include <RefCountedPtr.H>

class euler_maruyama::CdrStorage {
public:

  CdrStorage();
  CdrStorage(const RefCountedPtr<AmrMesh>& a_amr, const phase::which_phase a_phase, const int m_ncomp);
  ~CdrStorage();

  void allocate_storage();
  void deallocate_storage();

  EBAMRCellData& getScratch()  { return m_scratch;    }
  EBAMRCellData& getScratch2() { return m_scratch2;   }
  EBAMRCellData& getGradient() { return m_gradient;   }

  EBAMRIVData& getEbScratch1(){ return m_scratchIVs; }
  EBAMRIVData& getEbScratchD(){ return m_scratchIVD; }
  EBAMRIVData& getEbState(){    return m_scratchIV1; }
  EBAMRIVData& getEbVelo(){     return m_scratchIV2; }
  EBAMRIVData& getEbFlux(){     return m_scratchIV3; }
  EBAMRIVData& getEbGrad(){     return m_scratchIV4; }

  EBAMRIFData& getDomainState(){  return m_scratchIF1; }
  EBAMRIFData& getDomainVelo(){   return m_scratchIF2; }
  EBAMRIFData& getDomainFlux(){   return m_scratchIF3; }
  EBAMRIFData& getDomainGrad(){   return m_scratchIF4; }
  
protected:

  RefCountedPtr<AmrMesh> m_amr; // Needed for allocation. Will allocate
  phase::which_phase m_phase;    // on this phase
  int m_ncomp;                   // with this many components

  EBAMRCellData m_scratch;  // Scratch data
  EBAMRCellData m_scratch2; // Scratch data
  EBAMRCellData m_gradient; // Storage for holding gradient

  EBAMRIVData m_scratchIVs; // Scratch data
  EBAMRIVData m_scratchIVD; // Scratch data
  EBAMRIVData m_scratchIV1; // Scratch data
  EBAMRIVData m_scratchIV2; // Scratch data
  EBAMRIVData m_scratchIV3; // Scratch data
  EBAMRIVData m_scratchIV4; // Scratch data

  EBAMRIFData m_scratchIF1; // Scratch data
  EBAMRIFData m_scratchIF2; // Scratch data
  EBAMRIFData m_scratchIF3; // Scratch data
  EBAMRIFData m_scratchIF4; // Scratch data
};

class euler_maruyama::FieldStorage {
public:

  FieldStorage();
  FieldStorage(const RefCountedPtr<AmrMesh>& a_amr, const phase::which_phase a_phase, const int m_ncomp);
  ~FieldStorage();

  void allocate_storage();
  void deallocate_storage();

  EBAMRCellData& getElectricFieldCell()      {return m_E_cell;   }
  EBAMRIVData& getElectricFieldEb()          {return m_E_eb;     }
  EBAMRIFData& getElectricFieldDomain()      {return m_E_dom;    }

protected:

  RefCountedPtr<AmrMesh> m_amr; // Needed for allocation. Will allocate
  phase::which_phase m_phase;    // on this phase
  int m_ncomp;                   // with this many components

  EBAMRCellData m_E_cell;        // Cell-centered E
  EBAMRIVData m_E_eb;            // EB-centered E
  EBAMRIFData m_E_dom;           // E-field on domain faces
};

class euler_maruyama::RtStorage {
public:

  RtStorage();
  RtStorage(const RefCountedPtr<AmrMesh>& a_amr, const phase::which_phase a_phase, const int m_ncomp);
  ~RtStorage();

  void allocate_storage();
  void deallocate_storage();

  EBAMRIVData& getEbFlux(){     return m_scratchIV; }
  EBAMRIFData& getDomainFlux(){ return m_scratchIF; }

protected:

  RefCountedPtr<AmrMesh> m_amr; // Needed for allocation. Will allocate
  phase::which_phase m_phase;    // on this phase
  int m_ncomp;                   // with this many components

  EBAMRIVData m_scratchIV;
  EBAMRIFData m_scratchIF;
};

class euler_maruyama::SigmaStorage {
public:

  SigmaStorage();
  SigmaStorage(const RefCountedPtr<AmrMesh>& a_amr, const phase::which_phase a_phase, const int m_ncomp);
  ~SigmaStorage();
  
  void allocate_storage();
  void deallocate_storage();
  
protected:

  RefCountedPtr<AmrMesh> m_amr; // Needed for allocation. Will allocate
  phase::which_phase m_phase;    // on this phase
  int m_ncomp;                   // with this many components
#include "CD_NamespaceFooter.H"

#endif
