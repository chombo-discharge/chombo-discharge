/* chombo-discharge
 * Copyright Â© 2021 SINTEF Energy Research.
 * Please refer to Copyright.txt and LICENSE in the chombo-discharge root directory.
 */

/*!
  @file   CD_CdrPlasmaStepper.H
  @brief  Declaration of a CdrPlasmaStepper, an abstract class for evolving cdr plasma equations in time.
  @author Robert Marskar
*/

#ifndef CD_CdrPlasmaStepper_H
#define CD_CdrPlasmaStepper_H

// Std includes
#include <functional>

// Our includes
#include <CD_ComputationalGeometry.H>
#include <CD_CdrPlasmaPhysics.H>
#include <CD_AmrMesh.H>
#include <CD_MultiFluidIndexSpace.H>
#include <CD_CdrLayout.H>
#include <CD_RtLayout.H>
#include <CD_FieldSolver.H>
#include <CD_SigmaSolver.H>
#include <CD_TimeStepper.H>
#include <CD_NamespaceHeader.H>

namespace Physics {
  namespace CdrPlasma {
  
    /*!
      @brief Abstract class for evolving the minimal plasma model in time.
      @details This class implements all the required coupling functions for more easily constructing algorithms. Subclasses must
      implement the advance method. This class handles all I/O.
    */
    class CdrPlasmaStepper : public TimeStepper {
    public:

      /*!
	@brief Empty constructor.
      */
      CdrPlasmaStepper();

      /*!
	@brief Full constructor. 
	@param[in] a_physics CDR plasma physics. 
      */
      CdrPlasmaStepper(RefCountedPtr<CdrPlasmaPhysics>& a_physics);

      /*!
	@brief Destructor
      */
      ~CdrPlasmaStepper();

      /*!
	@brief Instantiate solvers
      */
      virtual void setupSolvers() override;

      /*!
	@brief Allocate data for the time stepper and solvers. 
      */      
      virtual void allocate() override;

      /*!
	@brief Fill all solvers with initial data
      */
      virtual void initialData() override;

      /*!
	@brief Post-initialize operations to be performed after filling solvers with initialData.
      */
      virtual void postInitialize() override;

      /*!
	@brief Post-initialize operations to be performed after filling solvers with data read from checkpoint files. 
      */      
      virtual void postCheckpointSetup() override;

      /*!
	@brief Register realms to be used for the simulation.
      */
      virtual void registerRealms() override;      

      /*!
	@brief Register operators to be used for the simulation
      */
      virtual void registerOperators() override;

      /*!
	@brief Parse runtime options. Subclasses must implement this.
      */
      virtual void parseRuntimeOptions() = 0;      

#ifdef CH_USE_HDF5
      /*!  
	@brief Write checkpoint data to file.
	@param[inout] a_handle HDF5 fil
	@param[in]    a_lvl    Grid level
      */      
      virtual void writeCheckpointData(HDF5Handle& a_handle, const int a_lvl) const override;
#endif
      
#ifdef CH_USE_HDF5
      /*!
	@brief Read checkpoint data from file. Used for restarts. 
	@param[inout] a_handle HDF5 file
	@param[in]    a_lvl    Grid level
      */      
      virtual void readCheckpointData(HDF5Handle& a_handle, const int a_lvl) override;
#endif

      /*!
	@brief Write plot data to output holder. 
	@param[inout] a_output            Output data holder.
	@param[in]    a_plotVariableNames Plot variable names.
	@param[inout] a_icomp             Starting component in a_output to begin at. 
      */      
      virtual void writePlotData(EBAMRCellData& a_output, Vector<std::string>& a_plotVariableNames, int& a_icomp) const override;      

      /*!
	@brief Get the number of plot variables for this time stepper. 
	@details This is necessary because Driver, not TimeStepper, is responsible for allocating the necessary memory. 
	@return Returns number of plot variables that will be written during writePlotData
      */
      virtual int getNumberOfPlotVariables() const override;

      /*!
	@brief Compute the time step and how it was restricted.
	@details Subclasses must implement this one. 
      */
      virtual void computeDt(Real& a_dt, TimeCode& a_timeCode) = 0;

      /*!
	@brief Advance method, advances equations.
	@param[in] a_dt Time step
	@returns Actual time step used (can be different from a_dt for adaptive methods)
      */
      virtual Real advance(const Real a_dt) = 0;

      /*!
	@brief Synchronize solver times
	@param[in] a_step Time step
	@param[in] a_time Time (in seconds)
	@param[in] a_dt   Time step that was used. 
      */
      virtual void synchronizeSolverTimes(const int a_step, const Real a_time, const Real a_dt) override;      

      /*!
	@brief Print a step report. 
	@details This is called by Driver after time step. The routine can be used to display use information about the simulation progress. 
      */
      virtual void printStepReport() override;

      /*!
	@brief Pre-regrid function. 
	@param[in] a_lmin           The coarsest level that changes
	@param[in] a_oldFinestLevel The finest level before the regrid. 
      */
      virtual void preRegrid(const int a_lmin, const int a_oldFinestLevel) override;

      /*!
	@brief Regrid method.
	@param[in] a_lmin           The coarsest level that changed. 
	@param[in] a_oldFinestLevel The finest level before the regrid. 
	@param[in] a_newFinestLevel The finest level after the regrid. 
      */
      virtual void regrid(const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel) override;

      /*!
	@brief Perform post-regrid operations. 
	@details This includes all operations to be done AFTER interpolating data to new grids. 
      */
      virtual void postRegrid() override;

      /*!
	@brief Compute the current density
	@param[out] a_J Current density
      */
      virtual void computeJ(EBAMRCellData& a_J) const;      

      /*!
	@brief Compute the cell-centered electric field on both phases
	@param[out] a_electricFieldCell Cell-centered electric field
	@param[in]  a_potential         Cell-centered electrostatic potential
      */
      virtual void computeElectricField(MFAMRCellData& a_electricFieldCell, const MFAMRCellData& a_potential) const;

      /*!
	@brief Compute the cell-centered electric field on a specific phase using whatever is available in m_fieldSolver
	@details This will use the potential from m_fieldSolver.
	@param[out] a_electricFieldCell Cell-centered electric field
	@param[in]  a_phase             Phase
      */
      virtual void computeElectricField(EBAMRCellData& a_electricFieldCell, const phase::which_phase a_phase) const;

      /*!
	@brief Compute the cell-centered electric field on a specific phase
	@param[out] a_electricFieldCell Cell-centered electric field
	@param[in]  a_phase             Phase
	@param[in]  a_potential         Electrostatic potential (cell-centered)
      */
      virtual void computeElectricField(EBAMRCellData& a_E, const phase::which_phase a_phase, const MFAMRCellData& a_potential) const;

      /*!
	@brief Compute the face-centered electric field. This will only do the normal component. 
	@param[out] a_electricFieldFace  Face-centered electric field
	@param[in]  a_phase              Phase
	@param[in]  a_electricFieldCell  Cell-centered electric field (all components). 
      */
      virtual void computeElectricField(EBAMRFluxData& a_electricFieldFace, const phase::which_phase a_phase, const EBAMRCellData& a_electricFieldCell) const;
  
      /*!
	@brief Compute the EB-centered electric field. 
	@param[out] a_electricFieldEB    EB-centered electric field. 
	@param[in]  a_phase              Phase
	@param[in]  a_electricFieldCell  Cell-centered electric field (all components). 
      */
      virtual void computeElectricField(EBAMRIVData& a_electricFieldEB, const phase::which_phase a_phase, const EBAMRCellData& a_electricFieldCell) const;

      /*!
	@brief Compute the maximum of the electric field
	@param[out] a_maxElectricField Maximum electric field magnitude evaluated over the input phase
	@param[in]  a_phase            Input phase
      */
      virtual void computeMaxElectricField(Real& a_maxElectricField, const phase::which_phase a_phase);      

      /*!
	@brief Return time
	@return m_time.
      */
      virtual Real getTime() const;      

      /*!
	@brief Check if RTE solvers are stationary
	@return True if the RTE solvers are stationary. 
      */
      virtual bool stationaryRTE();

      /*!
	@brief Allocate internal storage. Must be implemented by subclasses. 
      */
      virtual void allocateInternals() = 0;

      /*!
	@brief Deallocate internals. Must be implemented by subclasses. 
      */
      virtual void deallocateInternals() = 0;

      /*!
	@brief Parse TimeStepper class options. Must be implemented by subclasses.
      */
      virtual void parseOptions() = 0;

      /*!
	@brief Do a preRegrid operation for internal storage (if needed). 
	@param[in] a_lmin           The coarsest level that changes
	@param[in] a_oldFinestLevel The finest level before the regrid. 
      */
      virtual void preRegridInternals(const int a_lmin, const int a_oldFinestLevel);

      /*!
	@brief Deallocation function. This will deallocate internal storage in the subclasses as well as the solvers. 
      */
      virtual void deallocate();

      /*!
	@brief Compute the centroid-centered space charge density by using the data inside the CDR solvers.
	@details This will call the other version with the storage holders being the space charge density data holder in m_fieldSolver and the 
	cell-centered densities in the CDR solvers. 
      */
      virtual void computeSpaceChargeDensity();

      /*!
	@brief Compute the centroid-centered space charge density.
	@details This will first compute the cell-centered space charge density and then interpolate that to the centroid. 
	@param[out] a_rho          Centroid centered space charge density.
	@param[in]  a_cdrDensities Cell-centered plasma species densities. Must be in the same order as the densities in m_cdr.
      */
      virtual void computeSpaceChargeDensity(MFAMRCellData& a_rho, const Vector<EBAMRCellData*>& a_cdrDensities);

      /*!
	@brief Compute the cell-centered conductivity.
	@param[out] a_cellConductivity Cell-centered conductivity. 
      */
      virtual void computeCellConductivity(EBAMRCellData& a_cellConductivity) const;

      /*!
	@brief Compute the face-centered conductivity from a cell-centered conductivity.
	@param[out] a_conductivityFace Face-centered conductivity.
	@param[out] a_conductivityEB   EB-centered conductivity. 
	@param[in]  a_conductivityCell Cell-centered conductivity. 
      */
      virtual void computeFaceConductivity(EBAMRFluxData&       a_conductivityFace,
					   EBAMRIVData&         a_conductivityEB,
					   const EBAMRCellData& a_conductivityCell) const;      

      /*!
	@brief Set up a semi-implicit Poisson solver.
	@details This will compute the required conductivities first, using data already present in the CDR solvers. After that, it
	will set up the Poisson equation with spatially varying conductivities.
	@param[in] a_dt Time step. 
      */
      virtual void setupSemiImplicitPoisson(const Real a_dt);

      /*!
	@brief Set up a semi-implicit Poisson solver.
	@details This is the version that uses pre-existing conductivities in a_conductivity. The factor dictates the multiplication factor f in the 
	expression div((epsilonr + f*sigma) grad(phi)) where sigma is the conductivity and f is a scaling factor. 
	@param[in] a_conductivityFace Face-centered conductivities (the Poisson solver will interpolate them to face centroids in the multigrid solve).
	@param[in] a_conductivityEB   EB-centered conductivities.
	@param[in] a_factor Factor to multiply conductivities with (they could be pre-scaled by dt/eps0 in which case a_factor = 1).
      */
      virtual void setupSemiImplicitPoisson(const EBAMRFluxData& a_conductivityFace,
					    const EBAMRIVData&   a_conductivityEB,
					    const Real           a_factor);

      /*!
	@brief Solve the electrostatic Poisson equation. 
	@details This will first compute the centroid-centered space charge density (using the cell-centered data in the CDR solvers) and then
	ask the field solver to solve.
      */
      virtual bool solvePoisson();            

      /*!
	@brief General electrostatic Poisson solver routine. 
	@details This will compute the space charge density onto a_rho and then solve for the potential. 
	@param[inout] a_potential    Electrostatic potential
	@param[out]   a_rho          Centroid-centered space charge density. 
	@param[in]    a_cdrDensities Plasma species densities. 
	@param[in]    a_sigma        Surface charge density on dielectric EBs.
      */
      virtual bool solvePoisson(MFAMRCellData&                a_potential,
				MFAMRCellData&                a_rho,
				const Vector<EBAMRCellData*>  a_cdrDensities,
				const EBAMRIVData&            a_sigma);
      
      /*!
	@brief Advance the reaction network. This will compute the electric field (on the appropriate phase) and call the other version.
	@param[in] a_time Time
	@param[in] a_dt   Time step
      */
      virtual void advanceReactionNetwork(const Real a_time, const Real a_dt);
  
      /*!
	@brief Compute reaction network source terms. 
	@details This will call the other version but will first compute the gradients of the plasma densities. 
	@param[out] a_cdrSources   Source terms for the CDR solvers. 
	@param[out] a_rteSources   Source terms for the radiative transfer solvers. 
	@param[in]  a_cdrDensities Cell-centered densities for the plasma species (i.e., CDR solvers).
	@param[in]  a_rteDensities Cell-centered densities for the radiative transfer equations (i.e., RTE solvers).
	@param[in]  a_E            Cell-centered electric field. 
	@param[in]  a_time         Time
	@param[in]  a_dt           Time step.
      */
      virtual void advanceReactionNetwork(Vector<EBAMRCellData*>&       a_cdrSources,
					  Vector<EBAMRCellData*>&       a_rteSources,
					  const Vector<EBAMRCellData*>& a_cdrDensities,
					  const Vector<EBAMRCellData*>& a_rteDensities,
					  const EBAMRCellData&          a_E,
					  const Real&                   a_time,
					  const Real&                   a_dt);

      /*!
	@brief Compute reaction network source terms. This is the AMR version that does all levels. 
	@param[out] a_cdrSources   Source terms for the CDR solvers. 
	@param[out] a_rteSources   Source terms for the radiative transfer solvers. 
	@param[in]  a_cdrDensities Cell-centered densities for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrGradients Cell-centered gradients for the plasma species (i.e., CDR solvers).
	@param[in]  a_rteDensities Cell-centered densities for the radiative transfer equations (i.e., RTE solvers).
	@param[in]  a_E            Cell-centered electric field. 
	@param[in]  a_time         Time
	@param[in]  a_dt           Time step.
      */
      virtual void advanceReactionNetwork(Vector<EBAMRCellData*>&       a_cdrSources,
					  Vector<EBAMRCellData*>&       a_rteSources,
					  const Vector<EBAMRCellData*>& a_cdrDensities,
					  const Vector<EBAMRCellData*>& a_cdrGradients,
					  const Vector<EBAMRCellData*>& a_rteDensities,
					  const EBAMRCellData&          a_E,
					  const Real&                   a_time,
					  const Real&                   a_dt);

      /*!
	@brief Compute reaction network source terms. This is the level version. 
	@param[out] a_cdrSources   Source terms for the CDR solvers. 
	@param[out] a_rteSources   Source terms for the radiative transfer solvers. 
	@param[in]  a_cdrDensities Cell-centered densities for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrGradients Cell-centered gradients for the plasma species (i.e., CDR solvers).
	@param[in]  a_rteDensities Cell-centered densities for the radiative transfer equations (i.e., RTE solvers).
	@param[in]  a_E            Cell-centered electric field. 
	@param[in]  a_time         Time
	@param[in]  a_dt           Time step.
	@param[in]  a_level        Grid level. 
      */
      virtual void advanceReactionNetwork(Vector<LevelData<EBCellFAB>* >&       a_cdrSources,
					  Vector<LevelData<EBCellFAB>* >&       a_rteSources,
					  const Vector<LevelData<EBCellFAB>* >& a_cdrDensities,
					  const Vector<LevelData<EBCellFAB>* >& a_cdrGradients,
					  const Vector<LevelData<EBCellFAB>* >& a_rteDensities,
					  const LevelData<EBCellFAB>&           a_E,
					  const Real&                           a_time,
					  const Real&                           a_dt,
					  const int                             a_level);
      /*!
	@brief Compute reaction network sources. This is the regular version which does not do the cut-cells.
	@param[out] a_cdrSources   Source terms for the CDR solvers. 
	@param[out] a_rteSources   Source terms for the radiative transfer solvers. 
	@param[in]  a_cdrDensities Cell-centered densities for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrGradients Cell-centered gradients for the plasma species (i.e., CDR solvers).
	@param[in]  a_rteDensities Cell-centered densities for the radiative transfer equations (i.e., RTE solvers).
	@param[in]  a_E            Cell-centered electric field. 
	@param[in]  a_time         Time
	@param[in]  a_dt           Time step.
	@param[in]  a_dx           Grid resolution.
	@param[in]  a_cellBox      Cell-centered computational region. 
      */
      virtual void advanceReactionNetworkRegularCells(Vector<FArrayBox*>&       a_cdrSources,
						      Vector<FArrayBox*>&       a_rteSources,
						      const Vector<FArrayBox*>& a_cdrDensities,
						      const Vector<FArrayBox*>& a_cdrGradients,
						      const Vector<FArrayBox*>& a_rteDensities,
						      const FArrayBox&          a_E,
						      const Real&               a_time,
						      const Real&               a_dt,
						      const Real&               a_dx,
						      const Box&                a_cellBox);

      /*!
	@brief Compute reaction network sources. This is the irregular version which only does the cut-cells. 
	@param[out] a_cdrSources     Source terms for the CDR solvers. 
	@param[out] a_rteSources     Source terms for the radiative transfer solvers. 
	@param[in]  a_cdrDensities   Cell-centered densities for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrGradients   Cell-centered gradients for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrVelocities  Cell-centered velocities for the CDR solvers. 
	@param[in]  a_rteDensities   Cell-centered densities for the radiative transfer equations (i.e., RTE solvers).
	@param[in]  a_interpStencils Interpolation stencils for putting cell-centered data on the centroid. 
	@param[in]  a_E              Cell-centered electric field. 
	@param[in]  a_time           Time
	@param[in]  a_dt             Time step.
	@param[in]  a_dx             Grid resolution.
	@param[in]  a_cellBox        Cell-centered computational region. 
	@param[in]  a_lvl            Grid level
	@param[in]  a_dit            Grid patch index
	@note This will call one of the other versions. 
      */
      virtual void advanceReactionNetworkIrreg(Vector<EBCellFAB*>&          a_cdrSources,
					       Vector<EBCellFAB*>&          a_rteSources,
					       const Vector<EBCellFAB*>&    a_cdrDensities,
					       const Vector<EBCellFAB*>&    a_cdrGradients,
					       const Vector<EBCellFAB*>&    a_cdrVelocities,
					       const Vector<EBCellFAB*>&    a_rteDensities,
					       const BaseIVFAB<VoFStencil>& a_interpStencils,
					       const EBCellFAB&             a_E,
					       const Real&                  a_time,
					       const Real&                  a_dt,
					       const Real&                  a_dx,
					       const Box&                   a_cellBox,
					       const int                    a_lvl,
					       const DataIndex&             a_dit);

      /*!
	@brief Compute reaction network sources. This version interpolates everything to the centroid and runs with that data. 
	@param[out] a_cdrSources     Source terms for the CDR solvers. 
	@param[out] a_rteSources     Source terms for the radiative transfer solvers. 
	@param[in]  a_cdrDensities   Cell-centered densities for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrGradients   Cell-centered gradients for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrVelocities  Cell-centered velocities for the CDR solvers. 
	@param[in]  a_rteDensities   Cell-centered densities for the radiative transfer equations (i.e., RTE solvers).
	@param[in]  a_interpStencils Interpolation stencils for putting cell-centered data on the centroid. 
	@param[in]  a_E              Cell-centered electric field. 
	@param[in]  a_time           Time
	@param[in]  a_dt             Time step.
	@param[in]  a_dx             Grid resolution.
	@param[in]  a_cellBox        Cell-centered computational region. 
	@param[in]  a_lvl            Grid level
	@param[in]  a_dit            Grid patch index
      */
      virtual void advanceReactionNetworkIrregInterp(Vector<EBCellFAB*>&          a_cdrSources,
						     Vector<EBCellFAB*>&          a_rteSources,
						     const Vector<EBCellFAB*>&    a_cdrDensities,
						     const Vector<EBCellFAB*>&    a_cdrGradients,
						     const Vector<EBCellFAB*>&    a_cdrVelocities,
						     const Vector<EBCellFAB*>&    a_rteDensities,
						     const BaseIVFAB<VoFStencil>& a_interpStencils,
						     const EBCellFAB&             a_E,
						     const Real&                  a_time,
						     const Real&                  a_dt,
						     const Real&                  a_dx,
						     const Box&                   a_box,
						     const int                    a_lvl,
						     const DataIndex&             a_dit);
      /*!
	@brief Compute reaction network sources. This version assumes that some of the inputs are on the centroid. 
	@param[out] a_cdrSources     Source terms for the CDR solvers. 
	@param[out] a_rteSources     Source terms for the radiative transfer solvers. 
	@param[in]  a_cdrDensities   Centroid-centered densities for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrGradients   Cell-centered gradients for the plasma species (i.e., CDR solvers).
	@param[in]  a_rteDensities   Centroid-centered densities for the radiative transfer equations (i.e., RTE solvers).
	@param[in]  a_interpStencils Interpolation stencils for putting cell-centered data on the centroid. 
	@param[in]  a_E              Cell-centered electric field. 
	@param[in]  a_time           Time
	@param[in]  a_dt             Time step.
	@param[in]  a_dx             Grid resolution.
	@param[in]  a_cellBox        Cell-centered computational region. 
	@param[in]  a_lvl            Grid level
	@param[in]  a_dit            Grid patch index      
      */
      virtual void advanceReactionNetworkIrregKappa(Vector<EBCellFAB*>&          a_cdrSources,
						    Vector<EBCellFAB*>&          a_rteSources,
						    const Vector<EBCellFAB*>&    a_cdrDensities,
						    const Vector<EBCellFAB*>&    a_cdrGradients,
						    const Vector<EBCellFAB*>&    a_rteDensities,
						    const BaseIVFAB<VoFStencil>& a_interpStencils,
						    const EBCellFAB&             a_E,
						    const Real&                  a_time,
						    const Real&                  a_dt,
						    const Real&                  a_dx,
						    const Box&                   a_box,
						    const int                    a_lvl,
						    const DataIndex&             a_dit);

      /*!
	@brief Compute reaction network sources. 
	@details This version is called with the Villa et. al upwind correction. It can also be used with regularly interpolated data, in which 
	case it will turn off reactions in EB cells where the mass flows into the domain. This function assumes that all input is on the cell center. 
	@param[out] a_cdrSources     Source terms for the CDR solvers. 
	@param[out] a_rteSources     Source terms for the radiative transfer solvers. 
	@param[in]  a_cdrDensities   Cell-centered densities for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrGradients   Cell-centered gradients for the plasma species (i.e., CDR solvers).
	@param[in]  a_cdrVelocities  Cell-centered velocities for the CDR solvers. 
	@param[in]  a_rteDensities   Cell-centered densities for the radiative transfer equations (i.e., RTE solvers).
	@param[in]  a_interpStencils Interpolation stencils for putting cell-centered data on the centroid. 
	@param[in]  a_E              Cell-centered electric field. 
	@param[in]  a_time           Time
	@param[in]  a_dt             Time step.
	@param[in]  a_dx             Grid resolution.
	@param[in]  a_cellBox        Cell-centered computational region. 
	@param[in]  a_lvl            Grid level
	@param[in]  a_dit            Grid patch index
      */
      virtual void advanceReactionNetworkIrregUpwind(Vector<EBCellFAB*>&          a_cdrSources,
						     Vector<EBCellFAB*>&          a_rteSources,
						     const Vector<EBCellFAB*>&    a_cdrDensities,
						     const Vector<EBCellFAB*>&    a_cdrGradients,
						     const Vector<EBCellFAB*>&    a_cdrVelocities,
						     const Vector<EBCellFAB*>&    a_rteDensities,
						     const BaseIVFAB<VoFStencil>& a_interpStencils,
						     const EBCellFAB&             a_E,
						     const Real&                  a_time,
						     const Real&                  a_dt,
						     const Real&                  a_dx,
						     const Box&                   a_box,
						     const int                    a_lvl,
						     const DataIndex&             a_dit);      

  
      /*!
	@brief Compute diffusion things using whatever is available in the solvers. 
	@details This will compute the electric field on the cell center and EB, and then call the other version. 
      */
      virtual void computeCdrDiffusion();

      /*!
	@brief Compute diffusion things using whatever is available in the solvers. This version uses the input electric fields.
	@param[in] a_electricFieldCell Electric field on cell centers. 
	@param[in] a_electricFieldEB   Electric field on EB centroids
      */
      virtual void computeCdrDiffusion(const EBAMRCellData& a_electricFieldCell, const EBAMRIVData& a_electricFieldEB);

      /*!
	@brief Compute CDR diffusion coefficients on cell centers. This will call the level version. 
	@param[out] a_cdrDcoCell        CDR diffusion coefficients on cell centers. 
	@param[in]  a_cdrDensities      Cell-centered CDR densities
	@param[in]  a_electricFieldCell Cell-centered electric field
	@param[in]  a_time              Time
      */
      virtual void computeCdrDiffusionCell(Vector<EBAMRCellData>&        a_cdrDcoCell,
					   const Vector<EBAMRCellData*>& a_cdrDensities,
					   const EBAMRCellData&          a_electricFieldCell,
					   const Real&                   a_time);            



      /*!
	@brief Compute diffusion coefficients. This is the level version and it will iterate through grid patches. 
	@param[out] a_cdrDcoCell        CDR diffusion coefficients on cell centers. 
	@param[in]  a_cdrDensities      Cell-centered CDR densities
	@param[in]  a_electricFieldCell Cell-centered electric field
	@param[in]  a_lvl               Grid level
	@param[in]  a_time              Time
      */
      virtual void computeCdrDiffusionCell(Vector<LevelData<EBCellFAB>* >&       a_cdrDcoCell,
					   const Vector<LevelData<EBCellFAB>* >& a_cdrDensities,
					   const LevelData<EBCellFAB>&           a_electricFieldCell,
					   const int                             a_lvl,
					   const Real&                           a_time);      



      /*!
	@brief Compute diffusion coefficients on cell centers. This does all the regular cells. 
	@param[out] a_cdrDcoCell        CDR diffusion coefficients on cell centers. 
	@param[in]  a_cdrDensities      Cell-centered CDR densities
	@param[in]  a_electricFieldCell Cell-centered electric field
	@param[in]  a_cellBox           Kernel region
	@param[in]  a_dx                Grid resolution
	@param[in]  a_time              Time
      */
      virtual void computeCdrDiffusionCellRegular(Vector<FArrayBox*>&       a_cdrDcoCell,
						  const Vector<FArrayBox*>& a_cdrDensities,
						  const FArrayBox&          a_electricFieldCell,
						  const Box                 a_cellBox,
						  const Real                a_dx,
						  const Real                a_time);

      /*!
	@brief Compute diffusion coefficients on cell centers. This version does the irregular cells. 
	@param[out] a_cdrDcoCell        CDR diffusion coefficients on cell centers. 
	@param[in]  a_cdrDensities      Cell-centered CDR densities
	@param[in]  a_electricFieldCell Cell-centered electric field
	@param[in]  a_dx                Grid resolution
	@param[in]  a_time              Time
	@param[in]  a_lvl               Grid level
	@param[in]  a_dit               Grid patch index
      */
      virtual void computeCdrDiffusionCellIrregular(Vector<EBCellFAB*>&          a_cdrDcoCell,
						    const Vector<EBCellFAB*>&    a_cdrDensities,
						    const EBCellFAB&             a_electricFieldCell,
						    const Real                   a_dx,
						    const Real&                  a_time,
						    const int                    a_lvl,
						    const DataIndex&             a_dit);
  
      /*!
	@brief Compute diffusion coefficients on face centers. 
	@details This will first compute the diffusion coefficients on cell centers, and then interpolate the result to face centers.
	@param[out] a_cdrDcoCell        CDR diffusion coefficients on cell centers. 
	@param[in]  a_cdrDensities      Cell-centered CDR densities
	@param[in]  a_electricFieldCell Cell-centered electric field
	@param[in]  a_time              Time
      */
      virtual void computeCdrDiffusionFace(Vector<EBAMRFluxData*>&       a_cdrDcoFace,
					   const Vector<EBAMRCellData*>& a_cdrDensities,
					   const EBAMRCellData&          a_electricFieldCell,
					   const Real&                   a_time);

      /*!
	@brief Compute diffusion coefficients on the EB. This is the AMR version -- it will call the level version. 
	@param[out] a_cdrDcoEB        EB-centered_CDR diffusion coefficients
	@param[in]  a_cdrDensitiesEB  EB-centered CDR densities
	@param[in]  a_electricFieldEB EB-centered electric field
	@param[in]  a_time            Time
      */
      virtual void computeCdrDiffusionEb(Vector<EBAMRIVData*>&       a_cdrDcoEB,
					 const Vector<EBAMRIVData*>& a_cdrDensitiesEB,
					 const EBAMRIVData&          a_electricFieldEB,
					 const Real&                 a_time);

      /*!
	@brief Compute diffusion coefficients on the EB. This is a level version but it will go through all patches. 
	@param[out] a_cdrDcoEB        EB-centered_CDR diffusion coefficients
	@param[in]  a_cdrDensitiesEB  EB-centered CDR densities
	@param[in]  a_electricFieldEB EB-centered electric field
	@param[in]  a_time            Time
	@param[in]  a_lvl             Grid level. 
      */
      virtual void computeCdrDiffusionEb(Vector<LevelData<BaseIVFAB<Real> >* >&       a_cdrDcoEB,
					 const Vector<LevelData<BaseIVFAB<Real> >* >& a_cdrDensitiesEB,
					 const LevelData<BaseIVFAB<Real> >&           a_electricFieldEB,
					 const Real&                                  a_time,
					 const int                                    a_lvl);

      /*!
	@brief Compute the CDR drift velocities.
	@details This will compute the cell-centered electric field and then call the other version.
      */
      virtual void computeCdrDriftVelocities();

      /*!
	@brief Compute the cell-centered CDR velocities. This will call the level version.
	@param[out] a_cdrVelocities Cell-centered CDR drift velocities
	@param[out] a_cdrDensities  Cell-centered CDR densities
	@param[in]  a_electricField The cell-centered electric field
	@param[in]  a_time          Time
      */
      virtual void computeCdrDriftVelocities(Vector<EBAMRCellData*>&       a_velocities,
					     const Vector<EBAMRCellData*>& a_cdrDensities,
					     const EBAMRCellData&          a_E,
					     const Real&                   a_time);      

      /*!
	@brief Compute the cell-centered CDR velocities. 
	@details This is the level version -- it will call the patch version for each patch in the grid. 
	@param[out] a_cdrVelocities Cell-centered CDR drift velocities
	@param[out] a_cdrDensities  Cell-centered CDR densities
	@param[in]  a_electricField The cell-centered electric field
	@param[in]  a_lvl           Grid level
	@param[in]  a_time          Time
      */      
      virtual void computeCdrDriftVelocities(Vector<LevelData<EBCellFAB> *>&       a_cdrVelocities,
					     const Vector<LevelData<EBCellFAB> *>& a_cdrDensities,
					     const LevelData<EBCellFAB> &          a_electricField,
					     const int                             a_lvl,
					     const Real&                           a_time);

      /*!
	@brief Compute the cell-centered CDR velocities. 
	@details This is patch version for regular grid cells. 
	@param[out] a_cdrVelocities Cell-centered CDR drift velocities
	@param[out] a_cdrDensities  Cell-centered CDR densities
	@param[in]  a_electricField The cell-centered electric field
	@param[in]  a_cellBox       Computational region. 
	@param[in]  a_time          Time
	@param[in]  a_dx            Grid resolution
      */            
      virtual void computeCdrDriftVelocitiesRegular(Vector<FArrayBox*>&       a_cdrVelocities,
						    const Vector<FArrayBox*>& a_cdrDensities,
						    const FArrayBox&          a_electricField,
						    const Box&                a_cellBox,
						    const Real&               a_time,
						    const Real&               a_dx);

      /*!
	@brief Compute the cell-centered CDR velocities. 
	@details This is patch version for irregular grid cells. 
	@param[out] a_cdrVelocities Cell-centered CDR drift velocities
	@param[out] a_cdrDensities  Cell-centered CDR densities
	@param[in]  a_electricField The cell-centered electric field
	@param[in]  a_time          Time
	@param[in]  a_dx            Grid resolution
	@param[in]  a_lvl           Grid level
	@param[in]  a_dit           Grid index
      */                  
      virtual void computeCdrDriftVelocitiesIrregular(Vector<EBCellFAB*>&       a_velocities,
						      const Vector<EBCellFAB*>& a_cdrDensities,
						      const EBCellFAB&          a_electricField,
						      const Real&               a_time,
						      const Real&               a_dx,
						      const int                 a_lvl,
						      const DataIndex&          a_dit);

      /*!
	@brief Compute CDR fluxes on the EB. This is the AMR version -- it will call the level version. 
	@param[out] a_cdrFluxesEB         CDR fluxes to be put in CDR solvers as a BC on the EBs.
	@param[in]  a_extrapCdrFluxes     CDR fluxes extrapolated from the inside. Can be used to construct inflow/outflow BCs.
	@param[in]  a_extrapCdrDensities  CDR densities extrapolated from the inside. 
	@param[in]  a_extrapCdrVelocities CDR velocities on the EB, extrapolated from the inside. 
	@param[in]  a_extrapCdrGradients  CDR gradients on the EB, extrapolated from the inside. 
	@param[in]  a_electricField       Electric field on the EB. 
	@param[in]  a_time                Time. 
      */      
      virtual void computeCdrFluxes(Vector<EBAMRIVData*>&       a_cdrFluxesEB,
				    const Vector<EBAMRIVData*>& a_extrapCdrFluxes,
				    const Vector<EBAMRIVData*>& a_extrapCdrDensities,
				    const Vector<EBAMRIVData*>& a_extrapCdrVelocities,
				    const Vector<EBAMRIVData*>& a_extrapCdrGradients,
				    const Vector<EBAMRIVData*>& a_extrapRteFluxes,
				    const EBAMRIVData&          a_electricField,
				    const Real&                 a_time);      

      /*!
	@brief Compute CDR fluxes on the EB. This is the level version which will fill EB fluxes on both electrode and dielectric cells. 
	@param[out] a_cdrFluxesEB         CDR fluxes to be put in CDR solvers as a BC on the EBs.
	@param[in]  a_extrapCdrFluxes     CDR fluxes extrapolated from the inside. Can be used to construct inflow/outflow BCs.
	@param[in]  a_extrapCdrDensities  CDR densities extrapolated from the inside. 
	@param[in]  a_extrapCdrVelocities CDR velocities on the EB, extrapolated from the inside. 
	@param[in]  a_extrapCdrGradients  CDR gradients on the EB, extrapolated from the inside. 
	@param[in]  a_electricField       Electric field on the EB. 
	@param[in]  a_time                Time. 
	@param[in]  a_lvl                 Grid level. 
      */
      virtual void computeCdrFluxes(Vector<LevelData<BaseIVFAB<Real> >*>&       a_cdrFluxesEB,
				    const Vector<LevelData<BaseIVFAB<Real> >*>& a_extrapCdrFluxes,
				    const Vector<LevelData<BaseIVFAB<Real> >*>& a_extrapCdrDensities,
				    const Vector<LevelData<BaseIVFAB<Real> >*>& a_extrapCdrVelocities,
				    const Vector<LevelData<BaseIVFAB<Real> >*>& a_extrapCdrGradients,
				    const Vector<LevelData<BaseIVFAB<Real> >*>& a_extrapRteFluxes,
				    const LevelData<BaseIVFAB<Real> >&          a_electricField,
				    const Real&                                 a_time,
				    const int                                   a_lvl);

      //////// CODE-WALK FROM HERE HERE AND DOWNWARDS /////

      /*!
	@brief Compute cdr fluxes on domain faces
	@note Everything that comes in here should have been computed on the domain faces
      */
      virtual void computeCdrDomainFluxes(Vector<EBAMRIFData*>&       a_cdrFluxes,
					  const Vector<EBAMRIFData*>& a_extrapCdrFluxes,
					  const Vector<EBAMRIFData*>& a_extrapCdrDensities,
					  const Vector<EBAMRIFData*>& a_extrapCdrVelocities,
					  const Vector<EBAMRIFData*>& a_extrapCdrGradients,
					  const Vector<EBAMRIFData*>& a_extrapRteFluxes,
					  const EBAMRIFData&          a_field,
					  const Real&                 a_time);

      /*!
	@brief Compute cdr fluxes on domain faces. Level version
      */
      virtual void computeCdrDomainFluxes(Vector<LevelData<DomainFluxIFFAB>*>        a_cdrFluxes,
					  const Vector<LevelData<DomainFluxIFFAB>*>& a_extrapCdrFluxes,
					  const Vector<LevelData<DomainFluxIFFAB>*>& a_extrapCdrDensities,
					  const Vector<LevelData<DomainFluxIFFAB>*>& a_extrapCdrVelocities,
					  const Vector<LevelData<DomainFluxIFFAB>*>& a_extrapCdrGradients,
					  const Vector<LevelData<DomainFluxIFFAB>*>& a_extrapRteFluxes,
					  const LevelData<DomainFluxIFFAB>&          a_E,
					  const Real&                                a_time,
					  const int                                  a_lvl);

      /*!
	@brief Compute the gradient at the boundary (we also take the dot product w.r.t. to the normal vector)
	@note This version computes the gradients from phi
      */
      virtual void computeGradientsAtEb(Vector<EBAMRIVData*>&         a_grad,
					const phase::which_phase&     a_phase,
					const Vector<EBAMRCellData*>& a_phi);

      /*!
	@brief Compute gradients at domain faces
      */
      virtual void computeGradientsAtDomainFaces(Vector<EBAMRIFData*>&         a_grad,
						 const phase::which_phase&     a_phase,
						 const Vector<EBAMRCellData*>& a_phi);





      /*!
	@brief Compute the cell-centered fluxes and extrapolate these to the EB centroid
      */
      virtual void computeExtrapolatedFluxes(Vector<EBAMRIVData*>&        a_fluxes,
					     const Vector<EBAMRCellData*> a_densities,
					     const Vector<EBAMRCellData*> a_velocities,
					     const phase::which_phase     a_phase);

      /*!
	@brief Compute the cell-centered fluxes and extrapolate these to the EB centroid
      */
      virtual void computeExtrapolatedVelocities(Vector<EBAMRIVData*>&        a_ebvel,
						 const Vector<EBAMRCellData*> a_velocities,
						 const phase::which_phase     a_phase);

      /*!
	@brief Compute the cell-centered fluxes and extrapolate these to the domain faces
      */
      virtual void computeExtrapolatedDomainFluxes(Vector<EBAMRIFData*>&        a_fluxes,
						   const Vector<EBAMRCellData*> a_densities,
						   const Vector<EBAMRCellData*> a_velocities,
						   const phase::which_phase     a_phase);


      /*!
	@brief Compute flux
      */
      virtual void computeFlux(EBAMRCellData&       a_flux,
			       const EBAMRCellData& a_density,
			       const EBAMRCellData& a_velocity);

      virtual void computeFlux(LevelData<EBCellFAB>&       a_flux,
			       const LevelData<EBCellFAB>& a_density,
			       const LevelData<EBCellFAB>& a_velocity,
			       const int                   a_lvl);

      /*!
	@brief Compute charge flux. 
      */
      virtual void computeChargeFlux(EBAMRIVData& a_flux, Vector<EBAMRIVData*>& a_cdr_flxues);



  
      /*!
	@brief Deallocate internal solver storages
      */
      virtual void deallocateSolverInternals();

      virtual void extrapolateToEb(LevelData<BaseIVFAB<Real> >& a_extrap,
				   const phase::which_phase     a_phase,
				   const LevelData<EBCellFAB>&  a_data,
				   const int                    a_lvl);

      /*!
	@brief Extrapolate data to EB centroid
      */
      virtual void extrapolateToEb(EBAMRIVData& a_extrap, const phase::which_phase a_phase, const EBAMRCellData& a_data);

      /*!
	@brief Extrapolate data to EB centroid
      */
      virtual void extrapolateToEb(Vector<EBAMRIVData*>&         a_extrap,
				   const phase::which_phase      a_phase,
				   const Vector<EBAMRCellData*>& a_data);

      /*!
	@brief Extrapolate to domain faces. Calls level version. 
      */
      virtual void extrapolateToDomainFaces(EBAMRIFData& a_extrap, const phase::which_phase a_phase, const EBAMRCellData& a_data);

      /*!
	@brief Extrapolate to domain faces
      */
      virtual void extrapolateToDomainFaces(LevelData<DomainFluxIFFAB>& a_extrap,
					    const phase::which_phase    a_phase,
					    const LevelData<EBCellFAB>& a_data,
					    const int                   a_lvl);

      /*!
	@brief Extrapolate to domain faces
      */
      virtual void extrapolateToDomainFaces(Vector<EBAMRIFData*>&         a_extrap,
					    const phase::which_phase      a_phase,
					    const Vector<EBAMRCellData*>& a_data);
  

      virtual void extrapolateToVectorDomainFaces(EBAMRIFData&             a_extrap,
						  const phase::which_phase a_phase,
						  const EBAMRCellData&     a_data);

      virtual void extrapolateToVectorDomainFaces(Vector<EBAMRIFData*>&         a_extrap,
						  const phase::which_phase      a_phase,
						  const Vector<EBAMRCellData*>& a_data);

      virtual void extrapolateVelocitiesVectorDomainFaces(Vector<EBAMRIFData*>&         a_extrap,
							  const phase::which_phase      a_phase,
							  const Vector<EBAMRCellData*>& a_data);

      /*!
	@brief Get maximum value of the cdr solver stuff
      */
      virtual void getCdrMax(Real& a_cdr_max, std::string& a_solver_name);





      /*!
	@brief Initialize sigma
      */
      virtual void initialSigma();

      /*!
	@brief Project flux
      */
      virtual void projectFlux(LevelData<BaseIVFAB<Real> >& a_proj_flux, const LevelData<BaseIVFAB<Real> >& a_flux, const int a_lvl);

      /*!
	@brief Extrapolated flux to EB and project it onto the normal
      */
      virtual void projectFlux(EBAMRIVData& a_projected_flux, const EBAMRIVData& a_flux);

      /*!
	@brief Project flux on the boundary normal
      */
      virtual void projectDomain(EBAMRIFData& a_projected_flux, const EBAMRIFData& a_flux);



      /*!
	@brief Regrid internal storage. This MUST be overwritten.
      */
      virtual void regridInternals(const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel) = 0;

      /*!
	@brief Regrid individual solvers
      */
      virtual void regridSolvers(const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel);

      /*!
	@brief Set data defined over dielectric cells to zero
      */
      virtual void resetDielectricCells(EBAMRIVData& a_data);

      /*!
	@brief Do a sanity check
      */
      virtual void sanityCheck();

      /*!
	@brief Set fast rte
      */
      virtual void setFastRadiativeTransfer(const int a_fast_rte);

      /*!
	@brief Set fast rte
      */
      virtual void setFastPoisson(const int a_fast_poisson);

      /*!
	@brief Set hardcap on the time step
      */
      virtual void setMinDt(const Real a_min_dt);

      /*!
	@brief Set hardcap on the time step
      */
      virtual void setMaxDt(const Real a_min_dt);

      /*!
	@brief Set CFL condition
      */
      virtual void setCFL(const Real a_cfl);

      /*!
	@brief Set fudge factor for relaxation time
      */
      virtual void setRelaxTime(const Real a_relax_time);

      /*!
	@brief Set plasma kinetics
      */
      virtual void setCdrPlasmaPhysics(const RefCountedPtr<CdrPlasmaPhysics>& a_physics);

      /*!
	@brief Set solver verbosity
      */
      virtual void setSolverVerbosity();

      /*!
	@brief Setup the cdr solvers
      */
      virtual void setupCdr();

      /*!
	@brief Setup the poisson solver
      */
      virtual void setupPoisson();

      /*!
	@brief Setup the rte solvers
      */
      virtual void setupRadiativeTransfer();

      /*!
	@brief Instantiate the sigma solver
      */
      virtual void setupSigma();

      /*!
	@brief Solver dumps data files
      */
      virtual void solverDump();

      /*!
	@brief Set potential
      */
      virtual void setVoltage(std::function<Real(const Real a_time)> a_potential);

      /*!
	@brief RTE advance using data existing in other solvers
      */
      virtual void solveRadiativeTransfer(const Real a_dt);

      /*!
	@brief Set the cdr layout
      */
      virtual void setCdrSolvers(RefCountedPtr<CdrLayout<CdrSolver> >& a_cdr);

      /*!
	@brief Set the Poisson solver
      */
      virtual void setFieldSolver(RefCountedPtr<FieldSolver>& a_poisson);

      /*!
	@brief Set the RTE layout
      */
      virtual void setRadiativeTransferSolvers(RefCountedPtr<RtLayout<RtSolver> >& a_rte);

      /*!
	@brief General RTE advance routine
	@details This computes the source terms at the specified time and then advances the solution
      */
      virtual void solveRadiativeTransfer(Vector<EBAMRCellData*>&       a_phis,
					  Vector<EBAMRCellData*>&       a_rhs,
					  const Vector<EBAMRCellData*>& a_cdr_states,
					  const EBAMRCellData&          a_E,
					  const Real                    a_time,
					  const Real                    a_dt);

      /*!
	@brief Compute the ohmic current on electrodes
      */
      virtual Real computeElectrodeCurrent();

      /*!
	@brief Compute the ohmic current on dielectrics
      */
      virtual Real computeDielectricCurrent();

      /*!
	@brief Compute the ohmic current through the domain faces
      */
      virtual Real computeDomainCurrent();

      /*!
	@brief Compute induced current in external circuit due to ohmic conduction
      */
      virtual Real computeOhmicInductionCurrent();
			     
      /*!
	@brief Compute the relaxation time
      */
      virtual Real computeRelaxationTime();

      /*!
	@brief Restrict dt
      */
      virtual Real restrictDt() = 0;



      /*!
	@brief Get dt
      */
      virtual Real getDt();

      /*!
	@brief Get the CFL time step
      */
      virtual Real getCflDt();

      /*!
	@brief Get cdr solvers
      */
      virtual RefCountedPtr<CdrLayout<CdrSolver> >& getCdrSolvers();

      /*!
	@brief Get cdr solvers
      */
      virtual RefCountedPtr<FieldSolver>& getFieldSolver();
  
      /*!
	@brief Get cdr solvers
      */
      virtual RefCountedPtr<RtLayout<RtSolver>>& getRadiativeTransferSolvers();

      /*!
	@brief Get sigma solver
      */
      virtual RefCountedPtr<SigmaSolver>& getSigmaSolver();
  
    protected:

      /*!
	@brief Enum for switching between source term computations. 'Interpolated' interpolates the cell-centered data
	to cell centroids. InterpolatedStable is the same as Interpolated but with a stability fix near inflow EBs.
	CellAverage assumes centroid-centered data, and Upwind uses the upwind formulation in Villa et. al. 
      */
      enum class SourceTermComputation {
	Interpolated,
	InterpolatedStable,	
	CellAverage,
	Upwind
      };      

      /*!
	@brief Realm where the time stepper is registered. 
	@details This will always be the primal realm because CdrPlasma has no dual-grid functionality.
      */
      std::string m_realm;

      /*!
	@brief Time stepper class name
      */
      std::string m_className;      

      /*!
	@brief Plasma phase
      */
      phase::which_phase m_phase;

      /*!
	@brief Which source term computation
      */
      SourceTermComputation m_whichSourceTermComputation;            

      /*!
	@brief Index space
      */
      RefCountedPtr<MultiFluidIndexSpace> m_multifluidIndexSpace;

      /*!
	@brief Plasma kinetics
      */
      RefCountedPtr<CdrPlasmaPhysics> m_physics;

      /*!
	@brief CDR solvers
      */
      RefCountedPtr<CdrLayout<CdrSolver> > m_cdr;

      /*!
	@brief Radiative transfer solvers
      */
      RefCountedPtr<RtLayout<RtSolver>> m_rte;

      /*!
	@brief Poisson solver
      */
      RefCountedPtr<FieldSolver> m_fieldSolver;

      /*!
	@brief Surface charge solver
      */
      RefCountedPtr<SigmaSolver> m_sigma;

      /*!
	@brief Set the potential
      */
      std::function<Real(const Real a_time) > m_potential;
  
      /*!
	@brief Minimum allowed time step
      */
      Real m_minDt;

      /*!
	@brief Maximum allowed time step
      */
      Real m_maxDt;

      /*!
	@brief CFL
      */
      Real m_cfl;

      /*!
	@brief Fudge factor for relaxation time
      */
      Real m_relax_time;

      /*!
	@brief TIme
      */
      Real m_time;

      /*!
	@brief Previous time step size
      */
      Real m_dt;

      /*!
	@brief Computed CFL time step
      */
      Real m_dt_cfl;

      /*!
	@brief Verbosity for solvers
      */
      int m_solverVerbosity;

      /*!
	@brief Fast RTE solver
      */
      int m_fast_rte;

      /*!
	@brief Fast RTE solver
      */
      int m_fast_poisson;

      /*!
	@brief Upwind factor
      */
      int m_upwindFactor;

      /*!
	@brief Parse class verbosity
      */
      virtual void parseVerbosity();

      /*!
	@brief Parse solver verbosities. 
      */      
      virtual void parseSolverVerbosity();

      /*!
	@brief Parse the CFL number. 
      */            
      virtual void parseCFL();

      /*!
	@brief Parse the relaxation time restriction. 
      */                  
      virtual void parseRelaxationTime();

      virtual void parseMinDt();
      virtual void parseMaxDt();
      virtual void parseFastPoisson();
      virtual void parseFastRadiativeTransfer();
      virtual void parseSourceComputation();      

      /*!
	@brief Compute and put the current density in output data holder
	@param[inout] a_output            Output data holder.
	@param[inout] a_icomp             Starting component in a_output to begin at. On output this is incremented by SpaceDim.
      */
      virtual void writeJ(EBAMRCellData& a_output, int& a_comp) const;

      /*!
	@brief Write physics data to output data holder. 
	@details This will fetch plot variables from m_physics and put them in the data holder. 
	@param[inout] a_output Output data holder.
	@param[inout] a_icomp  Starting component in a_output to begin at. On output this is incremented by the number of plot variables from m_physics. 
      */
      virtual void writePhysics(EBAMRCellData& a_output, int& a_comp) const;      
    };
  }
}

#include <CD_NamespaceFooter.H>

#endif
