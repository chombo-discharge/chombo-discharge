<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: EBHelmholtzOp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classEBHelmholtzOp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EBHelmholtzOp Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho.  
 <a href="classEBHelmholtzOp.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__EBHelmholtzOp_8H_source.html">CD_EBHelmholtzOp.H</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EBHelmholtzOp:</div>
<div class="dyncontent">
<div class="center"><img src="classEBHelmholtzOp__inherit__graph.png" border="0" usemap="#EBHelmholtzOp_inherit__map" alt="Inheritance graph"/></div>
<map name="EBHelmholtzOp_inherit__map" id="EBHelmholtzOp_inherit__map">
<area shape="rect" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho." alt="" coords="53,95,177,121"/>
<area shape="rect" title=" " alt="" coords="5,5,224,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for EBHelmholtzOp:</div>
<div class="dyncontent">
<div class="center"><img src="classEBHelmholtzOp__coll__graph.png" border="0" usemap="#EBHelmholtzOp_coll__map" alt="Collaboration graph"/></div>
<map name="EBHelmholtzOp_coll__map" id="EBHelmholtzOp_coll__map">
<area shape="rect" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho." alt="" coords="311,124,435,151"/>
<area shape="rect" title=" " alt="" coords="5,5,224,47"/>
<area shape="rect" href="classEBMGProlong.html" title="Class for prolongation of multigrid residual onto a finer grid." alt="" coords="249,13,359,39"/>
<area shape="rect" href="classEBMGRestrict.html" title="Class for restricting multigrid residual onto a coarser grid." alt="" coords="389,13,499,39"/>
<area shape="rect" href="classTimer.html" title="Class which is used for run&#45;time monitoring of events." alt="" coords="551,13,611,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a54eab4d142d767aa607a33d7be679f17"><td class="memItemLeft" align="right" valign="top"><a id="a54eab4d142d767aa607a33d7be679f17"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a54eab4d142d767aa607a33d7be679f17">Smoother</a> { <b>NoRelax</b>, 
<b>PointJacobi</b>, 
<b>GauSaiRedBlack</b>, 
<b>GauSaiMultiColor</b>
 }</td></tr>
<tr class="memdesc:a54eab4d142d767aa607a33d7be679f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relaxation method for the operators. <br /></td></tr>
<tr class="separator:a54eab4d142d767aa607a33d7be679f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2cb6d271bb8ed08f9623918179976677"><td class="memItemLeft" align="right" valign="top"><a id="a2cb6d271bb8ed08f9623918179976677"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a2cb6d271bb8ed08f9623918179976677">EBHelmholtzOp</a> ()=delete</td></tr>
<tr class="memdesc:a2cb6d271bb8ed08f9623918179976677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed default constructor. <br /></td></tr>
<tr class="separator:a2cb6d271bb8ed08f9623918179976677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2e306910bfd82381d4c263ae18241e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#acf2e306910bfd82381d4c263ae18241e">EBHelmholtzOp</a> (const <a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;a_other)=delete</td></tr>
<tr class="memdesc:acf2e306910bfd82381d4c263ae18241e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed copy constructor.  <a href="classEBHelmholtzOp.html#acf2e306910bfd82381d4c263ae18241e">More...</a><br /></td></tr>
<tr class="separator:acf2e306910bfd82381d4c263ae18241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8b97e874d4af3ddf9f2b50aa55f504"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a8e8b97e874d4af3ddf9f2b50aa55f504">EBHelmholtzOp</a> (const <a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;&amp;a_other)=delete</td></tr>
<tr class="memdesc:a8e8b97e874d4af3ddf9f2b50aa55f504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed move constructor.  <a href="classEBHelmholtzOp.html#a8e8b97e874d4af3ddf9f2b50aa55f504">More...</a><br /></td></tr>
<tr class="separator:a8e8b97e874d4af3ddf9f2b50aa55f504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeac0ebb0abf0cbda3ce47d3819039ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#afeac0ebb0abf0cbda3ce47d3819039ec">EBHelmholtzOp</a> (const <a class="el" href="namespaceLocation.html#a54eced96f7ad5684263391a0b726c163">Location::Cell</a> a_dataLocation, const EBLevelGrid &amp;a_eblgFine, const EBLevelGrid &amp;a_eblg, const EBLevelGrid &amp;a_eblgCoFi, const EBLevelGrid &amp;a_eblgCoar, const EBLevelGrid &amp;a_eblgCoarMG, const RefCountedPtr&lt; <a class="el" href="classEBMultigridInterpolator.html">EBMultigridInterpolator</a> &gt; &amp;a_interpolator, const RefCountedPtr&lt; EBFluxRegister &gt; &amp;a_fluxReg, const RefCountedPtr&lt; <a class="el" href="classEBCoarAve.html">EBCoarAve</a> &gt; &amp;a_coarAve, const RefCountedPtr&lt; <a class="el" href="classEBHelmholtzDomainBC.html">EBHelmholtzDomainBC</a> &gt; &amp;a_domainBC, const RefCountedPtr&lt; <a class="el" href="classEBHelmholtzEBBC.html">EBHelmholtzEBBC</a> &gt; &amp;a_ebBC, const RealVect &amp;a_probLo, const Real &amp;a_dx, const int &amp;a_refToFine, const int &amp;a_refToCoar, const bool &amp;a_hasFine, const bool &amp;a_hasCoar, const bool &amp;a_hasMGObjects, const Real &amp;a_alpha, const Real &amp;a_beta, const RefCountedPtr&lt; LevelData&lt; EBCellFAB &gt;&gt; &amp;a_Acoef, const RefCountedPtr&lt; LevelData&lt; EBFluxFAB &gt;&gt; &amp;a_Bcoef, const RefCountedPtr&lt; LevelData&lt; BaseIVFAB&lt; Real &gt;&gt;&gt; &amp;a_BcoIrreg, const IntVect &amp;a_ghostCellsPhi, const IntVect &amp;a_ghostCellsRHS, const <a class="el" href="classEBHelmholtzOp.html#a54eab4d142d767aa607a33d7be679f17">Smoother</a> &amp;a_smoother)</td></tr>
<tr class="memdesc:afeac0ebb0abf0cbda3ce47d3819039ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full constructor.  <a href="classEBHelmholtzOp.html#afeac0ebb0abf0cbda3ce47d3819039ec">More...</a><br /></td></tr>
<tr class="separator:afeac0ebb0abf0cbda3ce47d3819039ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d728e76605bb07ea19198787f6ade65"><td class="memItemLeft" align="right" valign="top"><a id="a2d728e76605bb07ea19198787f6ade65"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a2d728e76605bb07ea19198787f6ade65">~EBHelmholtzOp</a> ()</td></tr>
<tr class="memdesc:a2d728e76605bb07ea19198787f6ade65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dtor. <br /></td></tr>
<tr class="separator:a2d728e76605bb07ea19198787f6ade65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e416373921daca959a91a607b0b43d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a80e416373921daca959a91a607b0b43d">operator=</a> (const <a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;a_oper)=delete</td></tr>
<tr class="memdesc:a80e416373921daca959a91a607b0b43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy assigment allowed.  <a href="classEBHelmholtzOp.html#a80e416373921daca959a91a607b0b43d">More...</a><br /></td></tr>
<tr class="separator:a80e416373921daca959a91a607b0b43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a53dc81d65b3ed7216b65ca78fd5434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a1a53dc81d65b3ed7216b65ca78fd5434">operator=</a> (const <a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;&amp;a_oper)=delete</td></tr>
<tr class="memdesc:a1a53dc81d65b3ed7216b65ca78fd5434"><td class="mdescLeft">&#160;</td><td class="mdescRight">No move assigment allowed.  <a href="classEBHelmholtzOp.html#a1a53dc81d65b3ed7216b65ca78fd5434">More...</a><br /></td></tr>
<tr class="separator:a1a53dc81d65b3ed7216b65ca78fd5434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48cbf089cbe718bc2e0cf12041f5a6b"><td class="memItemLeft" align="right" valign="top"><a id="aa48cbf089cbe718bc2e0cf12041f5a6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#aa48cbf089cbe718bc2e0cf12041f5a6b">turnOffCFInterp</a> ()</td></tr>
<tr class="memdesc:aa48cbf089cbe718bc2e0cf12041f5a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off BCs. <br /></td></tr>
<tr class="separator:aa48cbf089cbe718bc2e0cf12041f5a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d12353fb23d282ce5dc66ca01c7c47"><td class="memItemLeft" align="right" valign="top"><a id="a12d12353fb23d282ce5dc66ca01c7c47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a12d12353fb23d282ce5dc66ca01c7c47">turnOnCFInterp</a> ()</td></tr>
<tr class="memdesc:a12d12353fb23d282ce5dc66ca01c7c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on BCs. <br /></td></tr>
<tr class="separator:a12d12353fb23d282ce5dc66ca01c7c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d53b6c0821c782c9ea8eb5e7681ce28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a5d53b6c0821c782c9ea8eb5e7681ce28">turnOffExchange</a> ()</td></tr>
<tr class="memdesc:a5d53b6c0821c782c9ea8eb5e7681ce28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off exchange operation.  <a href="classEBHelmholtzOp.html#a5d53b6c0821c782c9ea8eb5e7681ce28">More...</a><br /></td></tr>
<tr class="separator:a5d53b6c0821c782c9ea8eb5e7681ce28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab901979aec1589777f2eebec85f7992e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ab901979aec1589777f2eebec85f7992e">turnOnExchange</a> ()</td></tr>
<tr class="memdesc:ab901979aec1589777f2eebec85f7992e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on exchange operation.  <a href="classEBHelmholtzOp.html#ab901979aec1589777f2eebec85f7992e">More...</a><br /></td></tr>
<tr class="separator:ab901979aec1589777f2eebec85f7992e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369711725d619cca18ed5f15c0a43a0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a369711725d619cca18ed5f15c0a43a0f">turnOffCoarsening</a> ()</td></tr>
<tr class="memdesc:a369711725d619cca18ed5f15c0a43a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off coarsening operation.  <a href="classEBHelmholtzOp.html#a369711725d619cca18ed5f15c0a43a0f">More...</a><br /></td></tr>
<tr class="separator:a369711725d619cca18ed5f15c0a43a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1421c86a5022532413b4320ccade732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ad1421c86a5022532413b4320ccade732">turnOnCoarsening</a> ()</td></tr>
<tr class="memdesc:ad1421c86a5022532413b4320ccade732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on coarsening operation.  <a href="classEBHelmholtzOp.html#ad1421c86a5022532413b4320ccade732">More...</a><br /></td></tr>
<tr class="separator:ad1421c86a5022532413b4320ccade732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdbaa4d871750098c48a369aa2c8355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a0cdbaa4d871750098c48a369aa2c8355">setAcoAndBco</a> (const RefCountedPtr&lt; LevelData&lt; EBCellFAB &gt;&gt; &amp;a_Acoef, const RefCountedPtr&lt; LevelData&lt; EBFluxFAB &gt;&gt; &amp;a_Bcoef, const RefCountedPtr&lt; LevelData&lt; BaseIVFAB&lt; Real &gt;&gt;&gt; &amp;a_BcoefIrreg)</td></tr>
<tr class="memdesc:a0cdbaa4d871750098c48a369aa2c8355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update with new A and B coefficients.  <a href="classEBHelmholtzOp.html#a0cdbaa4d871750098c48a369aa2c8355">More...</a><br /></td></tr>
<tr class="separator:a0cdbaa4d871750098c48a369aa2c8355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57225143774c072002c4f8f7914d9d8"><td class="memItemLeft" align="right" valign="top">const RefCountedPtr&lt; LevelData&lt; EBCellFAB &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ac57225143774c072002c4f8f7914d9d8">getAcoef</a> ()</td></tr>
<tr class="memdesc:ac57225143774c072002c4f8f7914d9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Helmholtz A-coefficient on cell centers.  <a href="classEBHelmholtzOp.html#ac57225143774c072002c4f8f7914d9d8">More...</a><br /></td></tr>
<tr class="separator:ac57225143774c072002c4f8f7914d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b4f43b2a98a900ef9ebca6888f3b0b"><td class="memItemLeft" align="right" valign="top">const RefCountedPtr&lt; LevelData&lt; EBFluxFAB &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ad0b4f43b2a98a900ef9ebca6888f3b0b">getBcoef</a> ()</td></tr>
<tr class="memdesc:ad0b4f43b2a98a900ef9ebca6888f3b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Helmholtz B-coefficient on faces.  <a href="classEBHelmholtzOp.html#ad0b4f43b2a98a900ef9ebca6888f3b0b">More...</a><br /></td></tr>
<tr class="separator:ad0b4f43b2a98a900ef9ebca6888f3b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a1e2ba2e60c4eee89fbed6668e7067"><td class="memItemLeft" align="right" valign="top">const RefCountedPtr&lt; LevelData&lt; BaseIVFAB&lt; Real &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a16a1e2ba2e60c4eee89fbed6668e7067">getBcoefIrreg</a> ()</td></tr>
<tr class="memdesc:a16a1e2ba2e60c4eee89fbed6668e7067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Helmholtz B-coefficient on the EB.  <a href="classEBHelmholtzOp.html#a16a1e2ba2e60c4eee89fbed6668e7067">More...</a><br /></td></tr>
<tr class="separator:a16a1e2ba2e60c4eee89fbed6668e7067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabaf780d215951b42cdaa13e7bf2832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#afabaf780d215951b42cdaa13e7bf2832">coarsen</a> (LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiFine)</td></tr>
<tr class="memdesc:afabaf780d215951b42cdaa13e7bf2832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsen data from fine to coar level.  <a href="classEBHelmholtzOp.html#afabaf780d215951b42cdaa13e7bf2832">More...</a><br /></td></tr>
<tr class="separator:afabaf780d215951b42cdaa13e7bf2832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492c4e1109d648fa396e52cd686b0a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a492c4e1109d648fa396e52cd686b0a38">coarsen</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_flux, const LevelData&lt; EBFluxFAB &gt; &amp;a_fineFlux)</td></tr>
<tr class="memdesc:a492c4e1109d648fa396e52cd686b0a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsen fluxes on the fine level onto this level.  <a href="classEBHelmholtzOp.html#a492c4e1109d648fa396e52cd686b0a38">More...</a><br /></td></tr>
<tr class="separator:a492c4e1109d648fa396e52cd686b0a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a11630804c46a822948f522c9fd0dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a55a11630804c46a822948f522c9fd0dc">pointJacobiKernel</a> (EBCellFAB &amp;a_Lcorr, EBCellFAB &amp;a_corr, const EBCellFAB &amp;a_resid, const Box &amp;a_cellBox, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:a55a11630804c46a822948f522c9fd0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point Jacobi kernel.  <a href="classEBHelmholtzOp.html#a55a11630804c46a822948f522c9fd0dc">More...</a><br /></td></tr>
<tr class="separator:a55a11630804c46a822948f522c9fd0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a50faa5bc2d89188c726b4ee6e6f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a95a50faa5bc2d89188c726b4ee6e6f57">gauSaiRedBlackKernel</a> (EBCellFAB &amp;a_Lcorr, EBCellFAB &amp;a_corr, const EBCellFAB &amp;a_resid, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const int &amp;a_redBlack)</td></tr>
<tr class="memdesc:a95a50faa5bc2d89188c726b4ee6e6f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Red-black Gauss-Seidel kernel.  <a href="classEBHelmholtzOp.html#a95a50faa5bc2d89188c726b4ee6e6f57">More...</a><br /></td></tr>
<tr class="separator:a95a50faa5bc2d89188c726b4ee6e6f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a2a3d66da7cb7859bdeadc14a33ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a54a2a3d66da7cb7859bdeadc14a33ed0">gauSaiMultiColorKernel</a> (EBCellFAB &amp;a_Lcorr, EBCellFAB &amp;a_corr, const EBCellFAB &amp;a_resid, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const IntVect &amp;a_color)</td></tr>
<tr class="memdesc:a54a2a3d66da7cb7859bdeadc14a33ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-color Gauss-Seidel kernel.  <a href="classEBHelmholtzOp.html#a54a2a3d66da7cb7859bdeadc14a33ed0">More...</a><br /></td></tr>
<tr class="separator:a54a2a3d66da7cb7859bdeadc14a33ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09449a46e618a393b236096bd5374af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a09449a46e618a393b236096bd5374af4">residual</a> (LevelData&lt; EBCellFAB &gt; &amp;a_residual, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const bool a_homogeneousPhysBc)</td></tr>
<tr class="memdesc:a09449a46e618a393b236096bd5374af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute residual on this level.  <a href="classEBHelmholtzOp.html#a09449a46e618a393b236096bd5374af4">More...</a><br /></td></tr>
<tr class="separator:a09449a46e618a393b236096bd5374af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4556e17727b8b07237e3e8ace95aad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a4556e17727b8b07237e3e8ace95aad9a">preCond</a> (LevelData&lt; EBCellFAB &gt; &amp;a_corr, const LevelData&lt; EBCellFAB &gt; &amp;a_residual) override final</td></tr>
<tr class="memdesc:a4556e17727b8b07237e3e8ace95aad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precondition system before bottom solve.  <a href="classEBHelmholtzOp.html#a4556e17727b8b07237e3e8ace95aad9a">More...</a><br /></td></tr>
<tr class="separator:a4556e17727b8b07237e3e8ace95aad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38cb29afeec984561cfb16a7c2aa462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ab38cb29afeec984561cfb16a7c2aa462">interpolateCF</a> (LevelData&lt; EBCellFAB &gt; &amp;a_phiFine, const LevelData&lt; EBCellFAB &gt; *a_phiCoar, const bool a_homogeneousCFBC)</td></tr>
<tr class="memdesc:ab38cb29afeec984561cfb16a7c2aa462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply coarse-fine boundary conditions.  <a href="classEBHelmholtzOp.html#ab38cb29afeec984561cfb16a7c2aa462">More...</a><br /></td></tr>
<tr class="separator:ab38cb29afeec984561cfb16a7c2aa462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb9d314920be914055272d093dd7641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a3bb9d314920be914055272d093dd7641">homogeneousCFInterp</a> (LevelData&lt; EBCellFAB &gt; &amp;a_phi)</td></tr>
<tr class="memdesc:a3bb9d314920be914055272d093dd7641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do homogeneous coarse-fine interpolation.  <a href="classEBHelmholtzOp.html#a3bb9d314920be914055272d093dd7641">More...</a><br /></td></tr>
<tr class="separator:a3bb9d314920be914055272d093dd7641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9024128464d4e8e24aca532295265ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ab9024128464d4e8e24aca532295265ba">inhomogeneousCFInterp</a> (LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiCoar)</td></tr>
<tr class="memdesc:ab9024128464d4e8e24aca532295265ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inhomogeneous coarse-fine interpolation.  <a href="classEBHelmholtzOp.html#ab9024128464d4e8e24aca532295265ba">More...</a><br /></td></tr>
<tr class="separator:ab9024128464d4e8e24aca532295265ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df13a592dcc8ef8db05720521c121e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a0df13a592dcc8ef8db05720521c121e3">gauSaiMultiColor</a> (LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_Lphi, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const IntVect &amp;a_color) const</td></tr>
<tr class="memdesc:a0df13a592dcc8ef8db05720521c121e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-colored Gauss-Seidel kernel. Public because <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> may want to use use.  <a href="classEBHelmholtzOp.html#a0df13a592dcc8ef8db05720521c121e3">More...</a><br /></td></tr>
<tr class="separator:a0df13a592dcc8ef8db05720521c121e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a1d053d3e694e220ff38ebda136da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a20a1d053d3e694e220ff38ebda136da4">applyOp</a> (LevelData&lt; EBCellFAB &gt; &amp;a_Lphi, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; *const a_phiCoar, const bool a_homogeneousPhysBC, const bool a_homogeneousCFBC)</td></tr>
<tr class="memdesc:a20a1d053d3e694e220ff38ebda136da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator on this level. This is a more general version which can turn on/off homogeneous and CF bcs.  <a href="classEBHelmholtzOp.html#a20a1d053d3e694e220ff38ebda136da4">More...</a><br /></td></tr>
<tr class="separator:a20a1d053d3e694e220ff38ebda136da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc685d503be92f7fdc4c2abf0f9ff7a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#abc685d503be92f7fdc4c2abf0f9ff7a9">applyOp</a> (LevelData&lt; EBCellFAB &gt; &amp;a_Lphi, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, bool a_homogeneousPhysBc) override final</td></tr>
<tr class="memdesc:abc685d503be92f7fdc4c2abf0f9ff7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator.  <a href="classEBHelmholtzOp.html#abc685d503be92f7fdc4c2abf0f9ff7a9">More...</a><br /></td></tr>
<tr class="separator:abc685d503be92f7fdc4c2abf0f9ff7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d69b63b2071bcdaa8cad2fc210e5917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a1d69b63b2071bcdaa8cad2fc210e5917">applyOp</a> (EBCellFAB &amp;a_Lphi, EBCellFAB &amp;a_phi, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const bool a_homogeneousPhysBC)</td></tr>
<tr class="memdesc:a1d69b63b2071bcdaa8cad2fc210e5917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator in a grid box.  <a href="classEBHelmholtzOp.html#a1d69b63b2071bcdaa8cad2fc210e5917">More...</a><br /></td></tr>
<tr class="separator:a1d69b63b2071bcdaa8cad2fc210e5917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c190a7fbae1686926c1247c9b5b29b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a99c190a7fbae1686926c1247c9b5b29b">applyOpRegular</a> (EBCellFAB &amp;a_Lphi, EBCellFAB &amp;a_phi, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const bool a_homogeneousPhysBC)</td></tr>
<tr class="memdesc:a99c190a7fbae1686926c1247c9b5b29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator in regular cells.  <a href="classEBHelmholtzOp.html#a99c190a7fbae1686926c1247c9b5b29b">More...</a><br /></td></tr>
<tr class="separator:a99c190a7fbae1686926c1247c9b5b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c84d18c5437d9bd530fe8e5a58378a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a9c84d18c5437d9bd530fe8e5a58378a0">applyDomainFlux</a> (EBCellFAB &amp;a_phi, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const bool a_homogeneousPhysBc)</td></tr>
<tr class="memdesc:a9c84d18c5437d9bd530fe8e5a58378a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply domain flux.  <a href="classEBHelmholtzOp.html#a9c84d18c5437d9bd530fe8e5a58378a0">More...</a><br /></td></tr>
<tr class="separator:a9c84d18c5437d9bd530fe8e5a58378a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd96a0878237551c9896f32aefa8b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a8dd96a0878237551c9896f32aefa8b59">fillDomainFlux</a> (EBFluxFAB &amp;a_flux, const EBCellFAB &amp;a_phi, const Box &amp;a_cellBox, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:a8dd96a0878237551c9896f32aefa8b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill domain flux. This fills the flux on the domain face using centered differencing ala applyDomainFlux.  <a href="classEBHelmholtzOp.html#a8dd96a0878237551c9896f32aefa8b59">More...</a><br /></td></tr>
<tr class="separator:a8dd96a0878237551c9896f32aefa8b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee6d047d1f9dec4e4d3642175a01b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a6aee6d047d1f9dec4e4d3642175a01b3">applyOpIrregular</a> (EBCellFAB &amp;a_Lphi, const EBCellFAB &amp;a_phi, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const bool a_homogeneousPhysBC)</td></tr>
<tr class="memdesc:a6aee6d047d1f9dec4e4d3642175a01b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator in irregular cells.  <a href="classEBHelmholtzOp.html#a6aee6d047d1f9dec4e4d3642175a01b3">More...</a><br /></td></tr>
<tr class="separator:a6aee6d047d1f9dec4e4d3642175a01b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5f92a5e0e4c04d53848174f8a595e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a0d5f92a5e0e4c04d53848174f8a595e5">create</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs) override final</td></tr>
<tr class="memdesc:a0d5f92a5e0e4c04d53848174f8a595e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create data which clones the layout of the other.  <a href="classEBHelmholtzOp.html#a0d5f92a5e0e4c04d53848174f8a595e5">More...</a><br /></td></tr>
<tr class="separator:a0d5f92a5e0e4c04d53848174f8a595e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663d6bbea4c9ba8e5427929d20dc87f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a663d6bbea4c9ba8e5427929d20dc87f1">assign</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs) override final</td></tr>
<tr class="memdesc:a663d6bbea4c9ba8e5427929d20dc87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign data.  <a href="classEBHelmholtzOp.html#a663d6bbea4c9ba8e5427929d20dc87f1">More...</a><br /></td></tr>
<tr class="separator:a663d6bbea4c9ba8e5427929d20dc87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f56d178a4158b3167c057c25fe55f4"><td class="memItemLeft" align="right" valign="top"><a id="a44f56d178a4158b3167c057c25fe55f4"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a44f56d178a4158b3167c057c25fe55f4">dotProduct</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs) override final</td></tr>
<tr class="memdesc:a44f56d178a4158b3167c057c25fe55f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product?? <br /></td></tr>
<tr class="separator:a44f56d178a4158b3167c057c25fe55f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89913ad920e33c937e58a14d4501639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ac89913ad920e33c937e58a14d4501639">incr</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const Real a_scale) override final</td></tr>
<tr class="memdesc:ac89913ad920e33c937e58a14d4501639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment operator.  <a href="classEBHelmholtzOp.html#ac89913ad920e33c937e58a14d4501639">More...</a><br /></td></tr>
<tr class="separator:ac89913ad920e33c937e58a14d4501639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b4cd2407b1c002ad9e8139477df05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a0d5b4cd2407b1c002ad9e8139477df05">axby</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_x, const LevelData&lt; EBCellFAB &gt; &amp;a_y, const Real a_a, const Real a_b) override final</td></tr>
<tr class="memdesc:a0d5b4cd2407b1c002ad9e8139477df05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a_lhs = a*x + b*y.  <a href="classEBHelmholtzOp.html#a0d5b4cd2407b1c002ad9e8139477df05">More...</a><br /></td></tr>
<tr class="separator:a0d5b4cd2407b1c002ad9e8139477df05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca0f8913246ab54445107bf3c7e0df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a2ca0f8913246ab54445107bf3c7e0df1">scale</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const Real &amp;a_scale) override final</td></tr>
<tr class="memdesc:a2ca0f8913246ab54445107bf3c7e0df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data. Returns a_lhs = a_lhs*a_scale.  <a href="classEBHelmholtzOp.html#a2ca0f8913246ab54445107bf3c7e0df1">More...</a><br /></td></tr>
<tr class="separator:a2ca0f8913246ab54445107bf3c7e0df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86378e94ab21f2482ae813df99093751"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a86378e94ab21f2482ae813df99093751">norm</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const int a_order) override final</td></tr>
<tr class="memdesc:a86378e94ab21f2482ae813df99093751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute norm of data.  <a href="classEBHelmholtzOp.html#a86378e94ab21f2482ae813df99093751">More...</a><br /></td></tr>
<tr class="separator:a86378e94ab21f2482ae813df99093751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab067e4cd5069c9d6dcc075047c2d86fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ab067e4cd5069c9d6dcc075047c2d86fd">setToZero</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs) override final</td></tr>
<tr class="memdesc:ab067e4cd5069c9d6dcc075047c2d86fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data to zero.  <a href="classEBHelmholtzOp.html#ab067e4cd5069c9d6dcc075047c2d86fd">More...</a><br /></td></tr>
<tr class="separator:ab067e4cd5069c9d6dcc075047c2d86fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1393143c05c84514c0c68e9fa81ccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a9a1393143c05c84514c0c68e9fa81ccb">createCoarser</a> (LevelData&lt; EBCellFAB &gt; &amp;a_coarse, const LevelData&lt; EBCellFAB &gt; &amp;a_fine, bool a_ghosted) override final</td></tr>
<tr class="memdesc:a9a1393143c05c84514c0c68e9fa81ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create coarsened data.  <a href="classEBHelmholtzOp.html#a9a1393143c05c84514c0c68e9fa81ccb">More...</a><br /></td></tr>
<tr class="separator:a9a1393143c05c84514c0c68e9fa81ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8a9c316590e8931f66b7e161655c36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a2d8a9c316590e8931f66b7e161655c36">relax</a> (LevelData&lt; EBCellFAB &gt; &amp;a_correction, const LevelData&lt; EBCellFAB &gt; &amp;a_residual, int a_iterations) override final</td></tr>
<tr class="memdesc:a2d8a9c316590e8931f66b7e161655c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relaxation method. This does smoothing for the system L(correction) = residual.  <a href="classEBHelmholtzOp.html#a2d8a9c316590e8931f66b7e161655c36">More...</a><br /></td></tr>
<tr class="separator:a2d8a9c316590e8931f66b7e161655c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cbf35310032f60e23f2851f815a039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a63cbf35310032f60e23f2851f815a039">restrictResidual</a> (LevelData&lt; EBCellFAB &gt; &amp;a_resCoar, LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs) override final</td></tr>
<tr class="memdesc:a63cbf35310032f60e23f2851f815a039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict residual onto coarse level.  <a href="classEBHelmholtzOp.html#a63cbf35310032f60e23f2851f815a039">More...</a><br /></td></tr>
<tr class="separator:a63cbf35310032f60e23f2851f815a039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78dc97388108d554273ce013367221a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#af78dc97388108d554273ce013367221a">prolongIncrement</a> (LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_correctCoarse) override final</td></tr>
<tr class="memdesc:af78dc97388108d554273ce013367221a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prolongation method.  <a href="classEBHelmholtzOp.html#af78dc97388108d554273ce013367221a">More...</a><br /></td></tr>
<tr class="separator:af78dc97388108d554273ce013367221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7876823880aee493be5e54bb956eda6e"><td class="memItemLeft" align="right" valign="top"><a id="a7876823880aee493be5e54bb956eda6e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a7876823880aee493be5e54bb956eda6e">refToCoarser</a> () override final</td></tr>
<tr class="memdesc:a7876823880aee493be5e54bb956eda6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return coarsening factor to coarser level (1 if there is no coarser level);. <br /></td></tr>
<tr class="separator:a7876823880aee493be5e54bb956eda6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735497e11967e45bbdb87e166675b572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a735497e11967e45bbdb87e166675b572">AMROperator</a> (LevelData&lt; EBCellFAB &gt; &amp;a_Lphi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiFine, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiCoar, const bool a_homogeneousPhysBC, AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *a_finerOp)</td></tr>
<tr class="memdesc:a735497e11967e45bbdb87e166675b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the AMR operator, i.e. compute L(phi) in an AMR context.  <a href="classEBHelmholtzOp.html#a735497e11967e45bbdb87e166675b572">More...</a><br /></td></tr>
<tr class="separator:a735497e11967e45bbdb87e166675b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bd80f7129900c761f5400613ffbd53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a42bd80f7129900c761f5400613ffbd53">refluxFreeAMROperator</a> (LevelData&lt; EBCellFAB &gt; &amp;a_Lphi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiFine, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiCoar, const bool a_homogeneousPhysBC, AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *a_finerOp)</td></tr>
<tr class="memdesc:a42bd80f7129900c761f5400613ffbd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the AMR operator, i.e. compute L(phi) in an AMR context.  <a href="classEBHelmholtzOp.html#a42bd80f7129900c761f5400613ffbd53">More...</a><br /></td></tr>
<tr class="separator:a42bd80f7129900c761f5400613ffbd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2abfffd5efab0c32b37c745d85d70d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#adb2abfffd5efab0c32b37c745d85d70d">AMRResidual</a> (LevelData&lt; EBCellFAB &gt; &amp;a_residual, const LevelData&lt; EBCellFAB &gt; &amp;a_phiFine, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiCoar, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, bool a_homogeneousPhysBC, AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *a_finerOp) override final</td></tr>
<tr class="memdesc:adb2abfffd5efab0c32b37c745d85d70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute residual on this level. AMR version.  <a href="classEBHelmholtzOp.html#adb2abfffd5efab0c32b37c745d85d70d">More...</a><br /></td></tr>
<tr class="separator:adb2abfffd5efab0c32b37c745d85d70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebe51fd405b5a885093f542d90e0131"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a1ebe51fd405b5a885093f542d90e0131">AMRResidualNF</a> (LevelData&lt; EBCellFAB &gt; &amp;a_residual, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiCoar, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, bool a_homogeneousPhysBC) override final</td></tr>
<tr class="memdesc:a1ebe51fd405b5a885093f542d90e0131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute AMR residual on finest AMR level.  <a href="classEBHelmholtzOp.html#a1ebe51fd405b5a885093f542d90e0131">More...</a><br /></td></tr>
<tr class="separator:a1ebe51fd405b5a885093f542d90e0131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb87b2a22419fc9a03e2a7d401b38d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#abb87b2a22419fc9a03e2a7d401b38d37">AMRResidualNC</a> (LevelData&lt; EBCellFAB &gt; &amp;a_residual, const LevelData&lt; EBCellFAB &gt; &amp;a_phiFine, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, bool a_homogeneousPhysBC, AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *a_finerOp) override final</td></tr>
<tr class="memdesc:abb87b2a22419fc9a03e2a7d401b38d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute AMR residual on coarsest.  <a href="classEBHelmholtzOp.html#abb87b2a22419fc9a03e2a7d401b38d37">More...</a><br /></td></tr>
<tr class="separator:abb87b2a22419fc9a03e2a7d401b38d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717d1a583fc5a6ac5fd7aeee2720c17d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a717d1a583fc5a6ac5fd7aeee2720c17d">AMROperatorNF</a> (LevelData&lt; EBCellFAB &gt; &amp;a_Lphi, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiCoar, bool a_homogeneousPhysBC) override final</td></tr>
<tr class="memdesc:a717d1a583fc5a6ac5fd7aeee2720c17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the AMR operator, i.e. compute L(phi) in an AMR context, assuming no finer levels.  <a href="classEBHelmholtzOp.html#a717d1a583fc5a6ac5fd7aeee2720c17d">More...</a><br /></td></tr>
<tr class="separator:a717d1a583fc5a6ac5fd7aeee2720c17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca5be69ce25f34578c53e768724d1d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#abca5be69ce25f34578c53e768724d1d7">AMROperatorNC</a> (LevelData&lt; EBCellFAB &gt; &amp;a_Lphi, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiCoar, bool a_homogeneousPhysBC, AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *a_finerOp) override final</td></tr>
<tr class="memdesc:abca5be69ce25f34578c53e768724d1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the AMR operator, i.e. compute L(phi) in an AMR context, assuming no coarser AMR levels.  <a href="classEBHelmholtzOp.html#abca5be69ce25f34578c53e768724d1d7">More...</a><br /></td></tr>
<tr class="separator:abca5be69ce25f34578c53e768724d1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaf3e29546ad6b66faeaa93e90c0e5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#adaaf3e29546ad6b66faeaa93e90c0e5e">AMRRestrict</a> (LevelData&lt; EBCellFAB &gt; &amp;a_residualCoarse, const LevelData&lt; EBCellFAB &gt; &amp;a_residual, const LevelData&lt; EBCellFAB &gt; &amp;a_correction, const LevelData&lt; EBCellFAB &gt; &amp;a_coarseCorrection, bool a_skip_res) override final</td></tr>
<tr class="memdesc:adaaf3e29546ad6b66faeaa93e90c0e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict residual.  <a href="classEBHelmholtzOp.html#adaaf3e29546ad6b66faeaa93e90c0e5e">More...</a><br /></td></tr>
<tr class="separator:adaaf3e29546ad6b66faeaa93e90c0e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e45529e4923bccc5b5df7830c690f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a16e45529e4923bccc5b5df7830c690f7">AMRProlong</a> (LevelData&lt; EBCellFAB &gt; &amp;a_correction, const LevelData&lt; EBCellFAB &gt; &amp;a_coarseCorrection) override final</td></tr>
<tr class="memdesc:a16e45529e4923bccc5b5df7830c690f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prolongation onto AMR level.  <a href="classEBHelmholtzOp.html#a16e45529e4923bccc5b5df7830c690f7">More...</a><br /></td></tr>
<tr class="separator:a16e45529e4923bccc5b5df7830c690f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc255b80bc733939b06593d9965c5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#aeecc255b80bc733939b06593d9965c5d">AMRUpdateResidual</a> (LevelData&lt; EBCellFAB &gt; &amp;a_residual, const LevelData&lt; EBCellFAB &gt; &amp;a_correction, const LevelData&lt; EBCellFAB &gt; &amp;a_coarseCorrection) override final</td></tr>
<tr class="memdesc:aeecc255b80bc733939b06593d9965c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update AMR residual.  <a href="classEBHelmholtzOp.html#aeecc255b80bc733939b06593d9965c5d">More...</a><br /></td></tr>
<tr class="separator:aeecc255b80bc733939b06593d9965c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17abf716e3500aa843843d9dc720917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ab17abf716e3500aa843843d9dc720917">setAlphaAndBeta</a> (const Real &amp;a_alpha, const Real &amp;a_beta) override final</td></tr>
<tr class="memdesc:ab17abf716e3500aa843843d9dc720917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set alpha coefficient and beta coefficient (can change as diffusion solvers progress)  <a href="classEBHelmholtzOp.html#ab17abf716e3500aa843843d9dc720917">More...</a><br /></td></tr>
<tr class="separator:ab17abf716e3500aa843843d9dc720917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d067e1d8b54e213aef086df56076b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ae3d067e1d8b54e213aef086df56076b0">createCoarsened</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const int &amp;a_refRat) override final</td></tr>
<tr class="memdesc:ae3d067e1d8b54e213aef086df56076b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create coarsening of data holder.  <a href="classEBHelmholtzOp.html#ae3d067e1d8b54e213aef086df56076b0">More...</a><br /></td></tr>
<tr class="separator:ae3d067e1d8b54e213aef086df56076b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e618302f9056c8888e24dc0c65a5c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#aa2e618302f9056c8888e24dc0c65a5c6">diagonalScale</a> (LevelData&lt; EBCellFAB &gt; &amp;a_rhs, bool a_kappaWeighted)</td></tr>
<tr class="memdesc:aa2e618302f9056c8888e24dc0c65a5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do diagonal scaling.  <a href="classEBHelmholtzOp.html#aa2e618302f9056c8888e24dc0c65a5c6">More...</a><br /></td></tr>
<tr class="separator:aa2e618302f9056c8888e24dc0c65a5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647f29b8543314c4c3234399a7b9fa99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a647f29b8543314c4c3234399a7b9fa99">divideByIdentityCoef</a> (LevelData&lt; EBCellFAB &gt; &amp;a_rhs) override final</td></tr>
<tr class="memdesc:a647f29b8543314c4c3234399a7b9fa99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide by the a-coefficient.  <a href="classEBHelmholtzOp.html#a647f29b8543314c4c3234399a7b9fa99">More...</a><br /></td></tr>
<tr class="separator:a647f29b8543314c4c3234399a7b9fa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814cae4d8db97331d161f50f22a25c5a"><td class="memItemLeft" align="right" valign="top"><a id="a814cae4d8db97331d161f50f22a25c5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a814cae4d8db97331d161f50f22a25c5a">applyOpNoBoundary</a> (LevelData&lt; EBCellFAB &gt; &amp;a_ans, const LevelData&lt; EBCellFAB &gt; &amp;a_phi) override final</td></tr>
<tr class="memdesc:a814cae4d8db97331d161f50f22a25c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply operator but turn off all BCs. <br /></td></tr>
<tr class="separator:a814cae4d8db97331d161f50f22a25c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62790e1666fb3ddf2b17c426586ee85f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a62790e1666fb3ddf2b17c426586ee85f">fillGrad</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_phi) override final</td></tr>
<tr class="memdesc:a62790e1666fb3ddf2b17c426586ee85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not called, I think.  <a href="classEBHelmholtzOp.html#a62790e1666fb3ddf2b17c426586ee85f">More...</a><br /></td></tr>
<tr class="separator:a62790e1666fb3ddf2b17c426586ee85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164212e03d6b1e80cfd79135b9e08fac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a164212e03d6b1e80cfd79135b9e08fac">getFlux</a> (EBFluxFAB &amp;a_flux, const LevelData&lt; EBCellFAB &gt; &amp;a_data, const Box &amp;a_grid, const DataIndex &amp;a_dit, Real a_scale) override final</td></tr>
<tr class="memdesc:a164212e03d6b1e80cfd79135b9e08fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill flux.  <a href="classEBHelmholtzOp.html#a164212e03d6b1e80cfd79135b9e08fac">More...</a><br /></td></tr>
<tr class="separator:a164212e03d6b1e80cfd79135b9e08fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0482b62c5ea81f59ef58c0065cef3617"><td class="memItemLeft" align="right" valign="top"><a id="a0482b62c5ea81f59ef58c0065cef3617"></a>
LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a0482b62c5ea81f59ef58c0065cef3617">getFlux</a> () const</td></tr>
<tr class="memdesc:a0482b62c5ea81f59ef58c0065cef3617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns m_flux. This is used in refluxing routines. <br /></td></tr>
<tr class="separator:a0482b62c5ea81f59ef58c0065cef3617"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3717f7d10bc215ac63ceea26d537dbf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a3717f7d10bc215ac63ceea26d537dbf6">relaxPointJacobi</a> (LevelData&lt; EBCellFAB &gt; &amp;a_correction, const LevelData&lt; EBCellFAB &gt; &amp;a_residual, const int a_iterations)</td></tr>
<tr class="memdesc:a3717f7d10bc215ac63ceea26d537dbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi relaxation.  <a href="classEBHelmholtzOp.html#a3717f7d10bc215ac63ceea26d537dbf6">More...</a><br /></td></tr>
<tr class="separator:a3717f7d10bc215ac63ceea26d537dbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eac3d95af403d716f7646c9ff2bf700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a5eac3d95af403d716f7646c9ff2bf700">relaxGSRedBlack</a> (LevelData&lt; EBCellFAB &gt; &amp;a_correction, const LevelData&lt; EBCellFAB &gt; &amp;a_residual, const int a_iterations)</td></tr>
<tr class="memdesc:a5eac3d95af403d716f7646c9ff2bf700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi relaxation.  <a href="classEBHelmholtzOp.html#a5eac3d95af403d716f7646c9ff2bf700">More...</a><br /></td></tr>
<tr class="separator:a5eac3d95af403d716f7646c9ff2bf700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01995f0b9cac6833fd90bc6336845c04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a01995f0b9cac6833fd90bc6336845c04">relaxGSMultiColor</a> (LevelData&lt; EBCellFAB &gt; &amp;a_correction, const LevelData&lt; EBCellFAB &gt; &amp;a_residual, const int a_iterations)</td></tr>
<tr class="memdesc:a01995f0b9cac6833fd90bc6336845c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-colored gauss-seidel relaxation.  <a href="classEBHelmholtzOp.html#a01995f0b9cac6833fd90bc6336845c04">More...</a><br /></td></tr>
<tr class="separator:a01995f0b9cac6833fd90bc6336845c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4e8202869126ba34ed41369a81b71c"><td class="memItemLeft" align="right" valign="top"><a id="a2b4e8202869126ba34ed41369a81b71c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a2b4e8202869126ba34ed41369a81b71c">computeDiagWeight</a> ()</td></tr>
<tr class="memdesc:a2b4e8202869126ba34ed41369a81b71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the weight of the diagonal term. <br /></td></tr>
<tr class="separator:a2b4e8202869126ba34ed41369a81b71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1aa298b65f2361aac473eb4a485818"><td class="memItemLeft" align="right" valign="top"><a id="a6d1aa298b65f2361aac473eb4a485818"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a6d1aa298b65f2361aac473eb4a485818">computeRelaxationCoefficient</a> ()</td></tr>
<tr class="memdesc:a6d1aa298b65f2361aac473eb4a485818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate relaxation coefficient. <br /></td></tr>
<tr class="separator:a6d1aa298b65f2361aac473eb4a485818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac61f40ecdd28ebd7f0d40ca8edb733"><td class="memItemLeft" align="right" valign="top"><a id="a3ac61f40ecdd28ebd7f0d40ca8edb733"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a3ac61f40ecdd28ebd7f0d40ca8edb733">makeAggStencil</a> ()</td></tr>
<tr class="memdesc:a3ac61f40ecdd28ebd7f0d40ca8edb733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute aggregated stencils. <br /></td></tr>
<tr class="separator:a3ac61f40ecdd28ebd7f0d40ca8edb733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e883965165f53ff42eb0312c835788"><td class="memItemLeft" align="right" valign="top"><a id="af1e883965165f53ff42eb0312c835788"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#af1e883965165f53ff42eb0312c835788">defineStencils</a> ()</td></tr>
<tr class="memdesc:af1e883965165f53ff42eb0312c835788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define stencils. <br /></td></tr>
<tr class="separator:af1e883965165f53ff42eb0312c835788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b4bfad4d0f236ad1ae4b71b1936ee0"><td class="memItemLeft" align="right" valign="top">VoFStencil&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a63b4bfad4d0f236ad1ae4b71b1936ee0">getFaceCenterFluxStencil</a> (const FaceIndex &amp;a_face, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:a63b4bfad4d0f236ad1ae4b71b1936ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the face-centered flux stencil.  <a href="classEBHelmholtzOp.html#a63b4bfad4d0f236ad1ae4b71b1936ee0">More...</a><br /></td></tr>
<tr class="separator:a63b4bfad4d0f236ad1ae4b71b1936ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b0d77f18b42122614b17bcb832a8df"><td class="memItemLeft" align="right" valign="top">VoFStencil&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a00b0d77f18b42122614b17bcb832a8df">getFaceCentroidFluxStencil</a> (const FaceIndex &amp;a_face, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:a00b0d77f18b42122614b17bcb832a8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the face-centroid flux stencil.  <a href="classEBHelmholtzOp.html#a00b0d77f18b42122614b17bcb832a8df">More...</a><br /></td></tr>
<tr class="separator:a00b0d77f18b42122614b17bcb832a8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9776b4ff1bd1b8b738aa7b1ae9724c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a9776b4ff1bd1b8b738aa7b1ae9724c89">getFaceCentroidFlux</a> (EBFaceFAB &amp;a_fluxCentroid, const EBCellFAB &amp;a_phi, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const int a_dir)</td></tr>
<tr class="memdesc:a9776b4ff1bd1b8b738aa7b1ae9724c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute centroid fluxes in a direction.  <a href="classEBHelmholtzOp.html#a9776b4ff1bd1b8b738aa7b1ae9724c89">More...</a><br /></td></tr>
<tr class="separator:a9776b4ff1bd1b8b738aa7b1ae9724c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da44f2e73bc14bf78d04067635c8460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a6da44f2e73bc14bf78d04067635c8460">computeFaceCenteredFlux</a> (EBFaceFAB &amp;a_fluxCenter, const EBCellFAB &amp;a_phi, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const int a_dir)</td></tr>
<tr class="memdesc:a6da44f2e73bc14bf78d04067635c8460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face-centered fluxes.  <a href="classEBHelmholtzOp.html#a6da44f2e73bc14bf78d04067635c8460">More...</a><br /></td></tr>
<tr class="separator:a6da44f2e73bc14bf78d04067635c8460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef10fff10e74c67de808c5ef081b590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a1ef10fff10e74c67de808c5ef081b590">computeFaceCentroidFlux</a> (EBFaceFAB &amp;a_flux, const EBCellFAB &amp;a_phi, const Box &amp;a_cellBox, const DataIndex &amp;a_dit, const int a_dir)</td></tr>
<tr class="memdesc:a1ef10fff10e74c67de808c5ef081b590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face-centered fluxes.  <a href="classEBHelmholtzOp.html#a1ef10fff10e74c67de808c5ef081b590">More...</a><br /></td></tr>
<tr class="separator:a1ef10fff10e74c67de808c5ef081b590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaacce511ffcf17c35c8feec84b24a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#adaacce511ffcf17c35c8feec84b24a22">computeFlux</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_phi)</td></tr>
<tr class="memdesc:adaacce511ffcf17c35c8feec84b24a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill face centroid-centered fluxes on this level.  <a href="classEBHelmholtzOp.html#adaacce511ffcf17c35c8feec84b24a22">More...</a><br /></td></tr>
<tr class="separator:adaacce511ffcf17c35c8feec84b24a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03bf5de8b696312d49d5219bb5f2cdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ae03bf5de8b696312d49d5219bb5f2cdb">incrementFRCoar</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_phi)</td></tr>
<tr class="memdesc:ae03bf5de8b696312d49d5219bb5f2cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment coarse flux register.  <a href="classEBHelmholtzOp.html#ae03bf5de8b696312d49d5219bb5f2cdb">More...</a><br /></td></tr>
<tr class="separator:ae03bf5de8b696312d49d5219bb5f2cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae819a25bf009109ad79e6e7e73992654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ae819a25bf009109ad79e6e7e73992654">incrementFRFine</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_phiFine, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; &amp;a_finerOp)</td></tr>
<tr class="memdesc:ae819a25bf009109ad79e6e7e73992654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment coarse flux register.  <a href="classEBHelmholtzOp.html#ae819a25bf009109ad79e6e7e73992654">More...</a><br /></td></tr>
<tr class="separator:ae819a25bf009109ad79e6e7e73992654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79ad244a5f004a5659c742f1af045a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#aa79ad244a5f004a5659c742f1af045a8">reflux</a> (LevelData&lt; EBCellFAB &gt; &amp;a_Lphi, const LevelData&lt; EBCellFAB &gt; &amp;a_phiFine, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; &amp;a_finerOp)</td></tr>
<tr class="memdesc:aa79ad244a5f004a5659c742f1af045a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflux algorithm.  <a href="classEBHelmholtzOp.html#aa79ad244a5f004a5659c742f1af045a8">More...</a><br /></td></tr>
<tr class="separator:aa79ad244a5f004a5659c742f1af045a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a93f7d13f56b4b1571acee2affabd3c33"><td class="memItemLeft" align="right" valign="top"><a id="a93f7d13f56b4b1571acee2affabd3c33"></a>
<a class="el" href="classTimer.html">Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a93f7d13f56b4b1571acee2affabd3c33">m_timer</a></td></tr>
<tr class="memdesc:a93f7d13f56b4b1571acee2affabd3c33"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTimer.html" title="Class which is used for run-time monitoring of events.">Timer</a> so user can profile. <br /></td></tr>
<tr class="separator:a93f7d13f56b4b1571acee2affabd3c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80743c35212206afd44aea6c4a5a8265"><td class="memItemLeft" align="right" valign="top"><a id="a80743c35212206afd44aea6c4a5a8265"></a>
Interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a80743c35212206afd44aea6c4a5a8265">m_interval</a></td></tr>
<tr class="memdesc:a80743c35212206afd44aea6c4a5a8265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval. <br /></td></tr>
<tr class="separator:a80743c35212206afd44aea6c4a5a8265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b0db5de2d391e3ac3631cc9ccc664a"><td class="memItemLeft" align="right" valign="top"><a id="a19b0db5de2d391e3ac3631cc9ccc664a"></a>
<a class="el" href="classEBHelmholtzOp.html#a54eab4d142d767aa607a33d7be679f17">Smoother</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a19b0db5de2d391e3ac3631cc9ccc664a">m_smoother</a></td></tr>
<tr class="memdesc:a19b0db5de2d391e3ac3631cc9ccc664a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relaxation method. <br /></td></tr>
<tr class="separator:a19b0db5de2d391e3ac3631cc9ccc664a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9885702db598ef57d6ee1c88a2a6a714"><td class="memItemLeft" align="right" valign="top"><a id="a9885702db598ef57d6ee1c88a2a6a714"></a>
<a class="el" href="namespaceLocation.html#a54eced96f7ad5684263391a0b726c163">Location::Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a9885702db598ef57d6ee1c88a2a6a714">m_dataLocation</a></td></tr>
<tr class="memdesc:a9885702db598ef57d6ee1c88a2a6a714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data centering. <br /></td></tr>
<tr class="separator:a9885702db598ef57d6ee1c88a2a6a714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435a4db01dad9ce21d02b954ba369896"><td class="memItemLeft" align="right" valign="top"><a id="a435a4db01dad9ce21d02b954ba369896"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a435a4db01dad9ce21d02b954ba369896">m_refluxFree</a></td></tr>
<tr class="memdesc:a435a4db01dad9ce21d02b954ba369896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use reflux-free formulation or not. <br /></td></tr>
<tr class="separator:a435a4db01dad9ce21d02b954ba369896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caf666b228aa4846124cf59fff59489"><td class="memItemLeft" align="right" valign="top"><a id="a5caf666b228aa4846124cf59fff59489"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a5caf666b228aa4846124cf59fff59489">m_profile</a></td></tr>
<tr class="memdesc:a5caf666b228aa4846124cf59fff59489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profile the operator. <br /></td></tr>
<tr class="separator:a5caf666b228aa4846124cf59fff59489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58286af71a1baa26c298290a83119485"><td class="memItemLeft" align="right" valign="top"><a id="a58286af71a1baa26c298290a83119485"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a58286af71a1baa26c298290a83119485">m_hasMGObjects</a></td></tr>
<tr class="memdesc:a58286af71a1baa26c298290a83119485"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there is a multigrid level below this operator. <br /></td></tr>
<tr class="separator:a58286af71a1baa26c298290a83119485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2ceaf123a67a4dd567cc65e2e3072a"><td class="memItemLeft" align="right" valign="top"><a id="abc2ceaf123a67a4dd567cc65e2e3072a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#abc2ceaf123a67a4dd567cc65e2e3072a">m_hasFine</a></td></tr>
<tr class="memdesc:abc2ceaf123a67a4dd567cc65e2e3072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there's a finer level. <br /></td></tr>
<tr class="separator:abc2ceaf123a67a4dd567cc65e2e3072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6230d2a60ad4dd356dcfe7f00923ad"><td class="memItemLeft" align="right" valign="top"><a id="a1b6230d2a60ad4dd356dcfe7f00923ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a1b6230d2a60ad4dd356dcfe7f00923ad">m_hasCoar</a></td></tr>
<tr class="memdesc:a1b6230d2a60ad4dd356dcfe7f00923ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if there's a coarser level. <br /></td></tr>
<tr class="separator:a1b6230d2a60ad4dd356dcfe7f00923ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa861820534b69b632c014b7a489c7bea"><td class="memItemLeft" align="right" valign="top"><a id="aa861820534b69b632c014b7a489c7bea"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#aa861820534b69b632c014b7a489c7bea">m_refToCoar</a></td></tr>
<tr class="memdesc:aa861820534b69b632c014b7a489c7bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement factor to coarse level. <br /></td></tr>
<tr class="separator:aa861820534b69b632c014b7a489c7bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538f9d934de68c90d6984f6f12f14b52"><td class="memItemLeft" align="right" valign="top"><a id="a538f9d934de68c90d6984f6f12f14b52"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a538f9d934de68c90d6984f6f12f14b52">m_refToFine</a></td></tr>
<tr class="memdesc:a538f9d934de68c90d6984f6f12f14b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement factor to fine level. <br /></td></tr>
<tr class="separator:a538f9d934de68c90d6984f6f12f14b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488cb7bfd1b5c53eeb42ef7aada04dd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a488cb7bfd1b5c53eeb42ef7aada04dd9">m_doInterpCF</a></td></tr>
<tr class="memdesc:a488cb7bfd1b5c53eeb42ef7aada04dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do coarse-fine interpolation or not.  <a href="classEBHelmholtzOp.html#a488cb7bfd1b5c53eeb42ef7aada04dd9">More...</a><br /></td></tr>
<tr class="separator:a488cb7bfd1b5c53eeb42ef7aada04dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e458a426b5054f15876184bdf86e91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a81e458a426b5054f15876184bdf86e91">m_doExchange</a></td></tr>
<tr class="memdesc:a81e458a426b5054f15876184bdf86e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on/off exchange operation.  <a href="classEBHelmholtzOp.html#a81e458a426b5054f15876184bdf86e91">More...</a><br /></td></tr>
<tr class="separator:a81e458a426b5054f15876184bdf86e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9fc7b10d58f9e22b3d51d4bf6c6327"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#abc9fc7b10d58f9e22b3d51d4bf6c6327">m_doCoarsen</a></td></tr>
<tr class="memdesc:abc9fc7b10d58f9e22b3d51d4bf6c6327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on/off exchange operation.  <a href="classEBHelmholtzOp.html#abc9fc7b10d58f9e22b3d51d4bf6c6327">More...</a><br /></td></tr>
<tr class="separator:abc9fc7b10d58f9e22b3d51d4bf6c6327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e45b06e04297ed3e73cc9191c6b4ad1"><td class="memItemLeft" align="right" valign="top"><a id="a9e45b06e04297ed3e73cc9191c6b4ad1"></a>
IntVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a9e45b06e04297ed3e73cc9191c6b4ad1">m_ghostPhi</a></td></tr>
<tr class="memdesc:a9e45b06e04297ed3e73cc9191c6b4ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ghost cells for phi. <br /></td></tr>
<tr class="separator:a9e45b06e04297ed3e73cc9191c6b4ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c4b3fd0ac8a5a456f869eaa8fc21fb"><td class="memItemLeft" align="right" valign="top"><a id="a75c4b3fd0ac8a5a456f869eaa8fc21fb"></a>
IntVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a75c4b3fd0ac8a5a456f869eaa8fc21fb">m_ghostRhs</a></td></tr>
<tr class="memdesc:a75c4b3fd0ac8a5a456f869eaa8fc21fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ghost cells for rhs (note, the operator rhs) <br /></td></tr>
<tr class="separator:a75c4b3fd0ac8a5a456f869eaa8fc21fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4920c1fa6293e7848864defc4a2aaf"><td class="memItemLeft" align="right" valign="top"><a id="aaa4920c1fa6293e7848864defc4a2aaf"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#aaa4920c1fa6293e7848864defc4a2aaf">m_alpha</a></td></tr>
<tr class="memdesc:aaa4920c1fa6293e7848864defc4a2aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alpha-coefficient. <br /></td></tr>
<tr class="separator:aaa4920c1fa6293e7848864defc4a2aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ff095f345f7110db48ebeb819c5061"><td class="memItemLeft" align="right" valign="top"><a id="ae5ff095f345f7110db48ebeb819c5061"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ae5ff095f345f7110db48ebeb819c5061">m_beta</a></td></tr>
<tr class="memdesc:ae5ff095f345f7110db48ebeb819c5061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beta-coefficient. <br /></td></tr>
<tr class="separator:ae5ff095f345f7110db48ebeb819c5061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594dced6a63648a54821c3de3982d6f1"><td class="memItemLeft" align="right" valign="top"><a id="a594dced6a63648a54821c3de3982d6f1"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a594dced6a63648a54821c3de3982d6f1">m_dx</a></td></tr>
<tr class="memdesc:a594dced6a63648a54821c3de3982d6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid resolution;. <br /></td></tr>
<tr class="separator:a594dced6a63648a54821c3de3982d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78b8a900cd999bd21e4d88f929a5c98"><td class="memItemLeft" align="right" valign="top"><a id="ac78b8a900cd999bd21e4d88f929a5c98"></a>
RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ac78b8a900cd999bd21e4d88f929a5c98">m_vecDx</a></td></tr>
<tr class="memdesc:ac78b8a900cd999bd21e4d88f929a5c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector resolution. <br /></td></tr>
<tr class="separator:ac78b8a900cd999bd21e4d88f929a5c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668a7e8c64b616d4083334086b38fbb8"><td class="memItemLeft" align="right" valign="top"><a id="a668a7e8c64b616d4083334086b38fbb8"></a>
RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a668a7e8c64b616d4083334086b38fbb8">m_probLo</a></td></tr>
<tr class="memdesc:a668a7e8c64b616d4083334086b38fbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower-left corner of domain. <br /></td></tr>
<tr class="separator:a668a7e8c64b616d4083334086b38fbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dceeaf762d6783aac0c8640c8d9553"><td class="memItemLeft" align="right" valign="top"><a id="aa0dceeaf762d6783aac0c8640c8d9553"></a>
EBLevelGrid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#aa0dceeaf762d6783aac0c8640c8d9553">m_eblgFine</a></td></tr>
<tr class="memdesc:aa0dceeaf762d6783aac0c8640c8d9553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fine level grid (if the operator has a fine level) <br /></td></tr>
<tr class="separator:aa0dceeaf762d6783aac0c8640c8d9553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcbe54393ac126a583bbdd439c5c3fb"><td class="memItemLeft" align="right" valign="top"><a id="a3bcbe54393ac126a583bbdd439c5c3fb"></a>
EBLevelGrid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a3bcbe54393ac126a583bbdd439c5c3fb">m_eblg</a></td></tr>
<tr class="memdesc:a3bcbe54393ac126a583bbdd439c5c3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid. <br /></td></tr>
<tr class="separator:a3bcbe54393ac126a583bbdd439c5c3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133b3dd2fec08a22f486c8ad28203547"><td class="memItemLeft" align="right" valign="top"><a id="a133b3dd2fec08a22f486c8ad28203547"></a>
EBLevelGrid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a133b3dd2fec08a22f486c8ad28203547">m_eblgCoFi</a></td></tr>
<tr class="memdesc:a133b3dd2fec08a22f486c8ad28203547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsened of m_eblg. <br /></td></tr>
<tr class="separator:a133b3dd2fec08a22f486c8ad28203547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b045a565f93bab3a681ea5753a07aea"><td class="memItemLeft" align="right" valign="top"><a id="a9b045a565f93bab3a681ea5753a07aea"></a>
EBLevelGrid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a9b045a565f93bab3a681ea5753a07aea">m_eblgCoar</a></td></tr>
<tr class="memdesc:a9b045a565f93bab3a681ea5753a07aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarse level grid (if the operator has a coarse level) <br /></td></tr>
<tr class="separator:a9b045a565f93bab3a681ea5753a07aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97169e501ec2753602a17a036965d41"><td class="memItemLeft" align="right" valign="top"><a id="af97169e501ec2753602a17a036965d41"></a>
EBLevelGrid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#af97169e501ec2753602a17a036965d41">m_eblgCoarMG</a></td></tr>
<tr class="memdesc:af97169e501ec2753602a17a036965d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarser grids (multigrid level) <br /></td></tr>
<tr class="separator:af97169e501ec2753602a17a036965d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a88482a371edd69315efd0a2eace72"><td class="memItemLeft" align="right" valign="top"><a id="a42a88482a371edd69315efd0a2eace72"></a>
<a class="el" href="classEBMGRestrict.html">EBMGRestrict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a42a88482a371edd69315efd0a2eace72">m_restrictOp</a></td></tr>
<tr class="memdesc:a42a88482a371edd69315efd0a2eace72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restriction operator for AMR levels. <br /></td></tr>
<tr class="separator:a42a88482a371edd69315efd0a2eace72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2af3c7ffaec567f4c36cc136e51b95"><td class="memItemLeft" align="right" valign="top"><a id="ade2af3c7ffaec567f4c36cc136e51b95"></a>
<a class="el" href="classEBMGRestrict.html">EBMGRestrict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ade2af3c7ffaec567f4c36cc136e51b95">m_restrictOpMG</a></td></tr>
<tr class="memdesc:ade2af3c7ffaec567f4c36cc136e51b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restriction operator if this is an MG level. <br /></td></tr>
<tr class="separator:ade2af3c7ffaec567f4c36cc136e51b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b2ee58b9ddea7e0c2459a80921d5d9"><td class="memItemLeft" align="right" valign="top"><a id="a74b2ee58b9ddea7e0c2459a80921d5d9"></a>
<a class="el" href="classEBMGProlong.html">EBMGProlong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a74b2ee58b9ddea7e0c2459a80921d5d9">m_prolongOp</a></td></tr>
<tr class="memdesc:a74b2ee58b9ddea7e0c2459a80921d5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prolongation operator for AMR levels. <br /></td></tr>
<tr class="separator:a74b2ee58b9ddea7e0c2459a80921d5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8263d9cdaf26393e567b4c9c7d02a83f"><td class="memItemLeft" align="right" valign="top"><a id="a8263d9cdaf26393e567b4c9c7d02a83f"></a>
<a class="el" href="classEBMGProlong.html">EBMGProlong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a8263d9cdaf26393e567b4c9c7d02a83f">m_prolongOpMG</a></td></tr>
<tr class="memdesc:a8263d9cdaf26393e567b4c9c7d02a83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prolongation operator for MG levels. <br /></td></tr>
<tr class="separator:a8263d9cdaf26393e567b4c9c7d02a83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43efc38b910817a754526fd136e6ca58"><td class="memItemLeft" align="right" valign="top"><a id="a43efc38b910817a754526fd136e6ca58"></a>
RefCountedPtr&lt; <a class="el" href="classEBHelmholtzDomainBC.html">EBHelmholtzDomainBC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a43efc38b910817a754526fd136e6ca58">m_domainBc</a></td></tr>
<tr class="memdesc:a43efc38b910817a754526fd136e6ca58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain bc object. <br /></td></tr>
<tr class="separator:a43efc38b910817a754526fd136e6ca58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c069793638000e71eb9ff8c4d8189d"><td class="memItemLeft" align="right" valign="top"><a id="a38c069793638000e71eb9ff8c4d8189d"></a>
RefCountedPtr&lt; <a class="el" href="classEBHelmholtzEBBC.html">EBHelmholtzEBBC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a38c069793638000e71eb9ff8c4d8189d">m_ebBc</a></td></tr>
<tr class="memdesc:a38c069793638000e71eb9ff8c4d8189d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain bc object. <br /></td></tr>
<tr class="separator:a38c069793638000e71eb9ff8c4d8189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67459fed74ac57daa9ac8f882394ce3d"><td class="memItemLeft" align="right" valign="top"><a id="a67459fed74ac57daa9ac8f882394ce3d"></a>
RefCountedPtr&lt; <a class="el" href="classEBMultigridInterpolator.html">EBMultigridInterpolator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a67459fed74ac57daa9ac8f882394ce3d">m_interpolator</a></td></tr>
<tr class="memdesc:a67459fed74ac57daa9ac8f882394ce3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolator object. <br /></td></tr>
<tr class="separator:a67459fed74ac57daa9ac8f882394ce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564841cc35a444d7c7ab53de8a2c6183"><td class="memItemLeft" align="right" valign="top"><a id="a564841cc35a444d7c7ab53de8a2c6183"></a>
RefCountedPtr&lt; EBFluxRegister &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a564841cc35a444d7c7ab53de8a2c6183">m_fluxReg</a></td></tr>
<tr class="memdesc:a564841cc35a444d7c7ab53de8a2c6183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flux register. <br /></td></tr>
<tr class="separator:a564841cc35a444d7c7ab53de8a2c6183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dd2c114bcf9db6b4ccd274948ca539"><td class="memItemLeft" align="right" valign="top"><a id="a08dd2c114bcf9db6b4ccd274948ca539"></a>
RefCountedPtr&lt; <a class="el" href="classEBCoarAve.html">EBCoarAve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a08dd2c114bcf9db6b4ccd274948ca539">m_coarAve</a></td></tr>
<tr class="memdesc:a08dd2c114bcf9db6b4ccd274948ca539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conservative coarsener. <br /></td></tr>
<tr class="separator:a08dd2c114bcf9db6b4ccd274948ca539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11828530f0c90bb1f98646bfec66a43"><td class="memItemLeft" align="right" valign="top"><a id="ad11828530f0c90bb1f98646bfec66a43"></a>
RefCountedPtr&lt; LevelData&lt; EBCellFAB &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ad11828530f0c90bb1f98646bfec66a43">m_Acoef</a></td></tr>
<tr class="memdesc:ad11828530f0c90bb1f98646bfec66a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">A-coefficient in Helmholtz equation. <br /></td></tr>
<tr class="separator:ad11828530f0c90bb1f98646bfec66a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ac3c5d0c80f125a3b0c70a9b33be22"><td class="memItemLeft" align="right" valign="top"><a id="a90ac3c5d0c80f125a3b0c70a9b33be22"></a>
RefCountedPtr&lt; LevelData&lt; EBFluxFAB &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a90ac3c5d0c80f125a3b0c70a9b33be22">m_Bcoef</a></td></tr>
<tr class="memdesc:a90ac3c5d0c80f125a3b0c70a9b33be22"><td class="mdescLeft">&#160;</td><td class="mdescRight">B-coefficient in Helmholtz equation. <br /></td></tr>
<tr class="separator:a90ac3c5d0c80f125a3b0c70a9b33be22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4b5eb3a396d60114627d885ef01863"><td class="memItemLeft" align="right" valign="top"><a id="afe4b5eb3a396d60114627d885ef01863"></a>
RefCountedPtr&lt; LevelData&lt; BaseIVFAB&lt; Real &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#afe4b5eb3a396d60114627d885ef01863">m_BcoefIrreg</a></td></tr>
<tr class="memdesc:afe4b5eb3a396d60114627d885ef01863"><td class="mdescLeft">&#160;</td><td class="mdescRight">B-coefficient in Helmholtz equation, but on EB faces. <br /></td></tr>
<tr class="separator:afe4b5eb3a396d60114627d885ef01863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa57ce5aac50371b34c0e88fc00518da"><td class="memItemLeft" align="right" valign="top"><a id="aaa57ce5aac50371b34c0e88fc00518da"></a>
LevelData&lt; EBCellFAB &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#aaa57ce5aac50371b34c0e88fc00518da">m_relCoef</a></td></tr>
<tr class="memdesc:aaa57ce5aac50371b34c0e88fc00518da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relaxation coefficient. <br /></td></tr>
<tr class="separator:aaa57ce5aac50371b34c0e88fc00518da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6584b7ba7010960671c6cc836189e27"><td class="memItemLeft" align="right" valign="top"><a id="ac6584b7ba7010960671c6cc836189e27"></a>
LevelData&lt; EBFluxFAB &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ac6584b7ba7010960671c6cc836189e27">m_flux</a></td></tr>
<tr class="memdesc:ac6584b7ba7010960671c6cc836189e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">For holding fluxes. <br /></td></tr>
<tr class="separator:ac6584b7ba7010960671c6cc836189e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fbde9adb894d1c3912530898448de2"><td class="memItemLeft" align="right" valign="top"><a id="ab8fbde9adb894d1c3912530898448de2"></a>
LayoutData&lt; BaseIFFAB&lt; Real &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ab8fbde9adb894d1c3912530898448de2">m_interpolant</a> [SpaceDim]</td></tr>
<tr class="memdesc:ab8fbde9adb894d1c3912530898448de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolant for when we want centroid fluxes. <br /></td></tr>
<tr class="separator:ab8fbde9adb894d1c3912530898448de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a63e6352919d6d010b4d927590f20ec"><td class="memItemLeft" align="right" valign="top"><a id="a8a63e6352919d6d010b4d927590f20ec"></a>
LayoutData&lt; BaseIFFAB&lt; FaceStencil &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a8a63e6352919d6d010b4d927590f20ec">m_interpStencil</a> [SpaceDim]</td></tr>
<tr class="memdesc:a8a63e6352919d6d010b4d927590f20ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Face centroid interpolation stencil. <br /></td></tr>
<tr class="separator:a8a63e6352919d6d010b4d927590f20ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7891db3b6888082217981499168e3a18"><td class="memItemLeft" align="right" valign="top"><a id="a7891db3b6888082217981499168e3a18"></a>
LayoutData&lt; BaseIFFAB&lt; VoFStencil &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a7891db3b6888082217981499168e3a18">m_centroidFluxStencil</a> [SpaceDim]</td></tr>
<tr class="memdesc:a7891db3b6888082217981499168e3a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Face centroid flux stencil. Defined on all faces connecting one or more irregular vofs. <br /></td></tr>
<tr class="separator:a7891db3b6888082217981499168e3a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dcd06b3d6626ea49878eaec6e404d3"><td class="memItemLeft" align="right" valign="top">LayoutData&lt; BaseIVFAB&lt; VoFStencil &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a19dcd06b3d6626ea49878eaec6e404d3">m_relaxStencils</a></td></tr>
<tr class="memdesc:a19dcd06b3d6626ea49878eaec6e404d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator stencils in irregular cells (and ones that border irregular cells if using a centroid discretization).  <a href="classEBHelmholtzOp.html#a19dcd06b3d6626ea49878eaec6e404d3">More...</a><br /></td></tr>
<tr class="separator:a19dcd06b3d6626ea49878eaec6e404d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e00b437e4fa34bb970084238f8e3f77"><td class="memItemLeft" align="right" valign="top">LayoutData&lt; RefCountedPtr&lt; VCAggStencil &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a3e00b437e4fa34bb970084238f8e3f77">m_aggRelaxStencil</a></td></tr>
<tr class="memdesc:a3e00b437e4fa34bb970084238f8e3f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">For making irregular stencil applications go faster.  <a href="classEBHelmholtzOp.html#a3e00b437e4fa34bb970084238f8e3f77">More...</a><br /></td></tr>
<tr class="separator:a3e00b437e4fa34bb970084238f8e3f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609e76459499d34b50477cbdc522ad3d"><td class="memItemLeft" align="right" valign="top"><a id="a609e76459499d34b50477cbdc522ad3d"></a>
LayoutData&lt; BaseIVFAB&lt; Real &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a609e76459499d34b50477cbdc522ad3d">m_alphaDiagWeight</a></td></tr>
<tr class="memdesc:a609e76459499d34b50477cbdc522ad3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights of diagonal alpha terms. <br /></td></tr>
<tr class="separator:a609e76459499d34b50477cbdc522ad3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea5cf8ca9f7263092ccb9304e686619"><td class="memItemLeft" align="right" valign="top"><a id="acea5cf8ca9f7263092ccb9304e686619"></a>
LayoutData&lt; BaseIVFAB&lt; Real &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#acea5cf8ca9f7263092ccb9304e686619">m_betaDiagWeight</a></td></tr>
<tr class="memdesc:acea5cf8ca9f7263092ccb9304e686619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights of diagonal beta terms. <br /></td></tr>
<tr class="separator:acea5cf8ca9f7263092ccb9304e686619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c9733f4e3307e0fc422c3c2e67dc3a"><td class="memItemLeft" align="right" valign="top"><a id="ad6c9733f4e3307e0fc422c3c2e67dc3a"></a>
LayoutData&lt; VoFIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ad6c9733f4e3307e0fc422c3c2e67dc3a">m_vofIterIrreg</a></td></tr>
<tr class="memdesc:ad6c9733f4e3307e0fc422c3c2e67dc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">VoFIterator for irregular cells. <br /></td></tr>
<tr class="separator:ad6c9733f4e3307e0fc422c3c2e67dc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc76f16d1c63a55e740c526ef3659521"><td class="memItemLeft" align="right" valign="top"><a id="acc76f16d1c63a55e740c526ef3659521"></a>
LayoutData&lt; VoFIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#acc76f16d1c63a55e740c526ef3659521">m_vofIterMulti</a></td></tr>
<tr class="memdesc:acc76f16d1c63a55e740c526ef3659521"><td class="mdescLeft">&#160;</td><td class="mdescRight">VoFIterator for "multi-cells". <br /></td></tr>
<tr class="separator:acc76f16d1c63a55e740c526ef3659521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f4d75ca9a3f96102fd4a9557b293f7"><td class="memItemLeft" align="right" valign="top"><a id="ac2f4d75ca9a3f96102fd4a9557b293f7"></a>
LayoutData&lt; VoFIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ac2f4d75ca9a3f96102fd4a9557b293f7">m_vofIterStenc</a></td></tr>
<tr class="memdesc:ac2f4d75ca9a3f96102fd4a9557b293f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">VoFIterator which iterates over all cells that are 1) a cut-cell or 2) borders a cut-cell. <br /></td></tr>
<tr class="separator:ac2f4d75ca9a3f96102fd4a9557b293f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad444863b54f6e7e2db3f94cb23e860e4"><td class="memItemLeft" align="right" valign="top"><a id="ad444863b54f6e7e2db3f94cb23e860e4"></a>
LayoutData&lt; VoFIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ad444863b54f6e7e2db3f94cb23e860e4">m_vofIterDomLo</a> [SpaceDim]</td></tr>
<tr class="memdesc:ad444863b54f6e7e2db3f94cb23e860e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">VoF iterators for lo domain side. <br /></td></tr>
<tr class="separator:ad444863b54f6e7e2db3f94cb23e860e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0853e8be2807dbe403b30680474a256"><td class="memItemLeft" align="right" valign="top"><a id="af0853e8be2807dbe403b30680474a256"></a>
LayoutData&lt; VoFIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#af0853e8be2807dbe403b30680474a256">m_vofIterDomHi</a> [SpaceDim]</td></tr>
<tr class="memdesc:af0853e8be2807dbe403b30680474a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">VoF iterators for hi domain side. <br /></td></tr>
<tr class="separator:af0853e8be2807dbe403b30680474a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac102826540a335e1087e506e6c87a38d"><td class="memItemLeft" align="right" valign="top"><a id="ac102826540a335e1087e506e6c87a38d"></a>
std::map&lt; std::pair&lt; int, Side::LoHiSide &gt;, Box &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ac102826540a335e1087e506e6c87a38d">m_sideBox</a></td></tr>
<tr class="memdesc:ac102826540a335e1087e506e6c87a38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain boxes on each side. <br /></td></tr>
<tr class="separator:ac102826540a335e1087e506e6c87a38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a9e2d87e1f4abcd5e39fe2f18319e4"><td class="memItemLeft" align="right" valign="top"><a id="ad0a9e2d87e1f4abcd5e39fe2f18319e4"></a>
Vector&lt; IntVect &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#ad0a9e2d87e1f4abcd5e39fe2f18319e4">m_colors</a></td></tr>
<tr class="memdesc:ad0a9e2d87e1f4abcd5e39fe2f18319e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Colors" for the relaxation methods <br /></td></tr>
<tr class="separator:ad0a9e2d87e1f4abcd5e39fe2f18319e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a068e63512d3300e5d6fca66b23d6097a"><td class="memItemLeft" align="right" valign="top"><a id="a068e63512d3300e5d6fca66b23d6097a"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a068e63512d3300e5d6fca66b23d6097a">m_nComp</a> = 1</td></tr>
<tr class="memdesc:a068e63512d3300e5d6fca66b23d6097a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of components that we solve for (always one..) <br /></td></tr>
<tr class="separator:a068e63512d3300e5d6fca66b23d6097a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1253835ba1bed54b9142e79268069cc9"><td class="memItemLeft" align="right" valign="top"><a id="a1253835ba1bed54b9142e79268069cc9"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBHelmholtzOp.html#a1253835ba1bed54b9142e79268069cc9">m_comp</a> = 0</td></tr>
<tr class="memdesc:a1253835ba1bed54b9142e79268069cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component that we solve for. <br /></td></tr>
<tr class="separator:a1253835ba1bed54b9142e79268069cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho. </p>
<p>This can be used with TGA time stepping. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acf2e306910bfd82381d4c263ae18241e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2e306910bfd82381d4c263ae18241e">&#9670;&nbsp;</a></span>EBHelmholtzOp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EBHelmholtzOp::EBHelmholtzOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e8b97e874d4af3ddf9f2b50aa55f504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8b97e874d4af3ddf9f2b50aa55f504">&#9670;&nbsp;</a></span>EBHelmholtzOp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EBHelmholtzOp::EBHelmholtzOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeac0ebb0abf0cbda3ce47d3819039ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeac0ebb0abf0cbda3ce47d3819039ec">&#9670;&nbsp;</a></span>EBHelmholtzOp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EBHelmholtzOp::EBHelmholtzOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceLocation.html#a54eced96f7ad5684263391a0b726c163">Location::Cell</a>&#160;</td>
          <td class="paramname"><em>a_dataLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBLevelGrid &amp;&#160;</td>
          <td class="paramname"><em>a_eblgFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBLevelGrid &amp;&#160;</td>
          <td class="paramname"><em>a_eblg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBLevelGrid &amp;&#160;</td>
          <td class="paramname"><em>a_eblgCoFi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBLevelGrid &amp;&#160;</td>
          <td class="paramname"><em>a_eblgCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBLevelGrid &amp;&#160;</td>
          <td class="paramname"><em>a_eblgCoarMG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classEBMultigridInterpolator.html">EBMultigridInterpolator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_interpolator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; EBFluxRegister &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_fluxReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classEBCoarAve.html">EBCoarAve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_coarAve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classEBHelmholtzDomainBC.html">EBHelmholtzDomainBC</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domainBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classEBHelmholtzEBBC.html">EBHelmholtzEBBC</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect &amp;&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>a_refToFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>a_refToCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>a_hasFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>a_hasCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>a_hasMGObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; LevelData&lt; EBCellFAB &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Acoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; LevelData&lt; EBFluxFAB &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Bcoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; LevelData&lt; BaseIVFAB&lt; Real &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_BcoIrreg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVect &amp;&#160;</td>
          <td class="paramname"><em>a_ghostCellsPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVect &amp;&#160;</td>
          <td class="paramname"><em>a_ghostCellsRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBHelmholtzOp.html#a54eab4d142d767aa607a33d7be679f17">Smoother</a> &amp;&#160;</td>
          <td class="paramname"><em>a_smoother</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dataLocation</td><td>Data location, either cell center or cell centroid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_eblgFine</td><td>Fine grids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_eblg</td><td>Grids on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_eblgCoFi</td><td>Coarsening of fine level grids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_eblgCoar</td><td>Coarse grids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_eblgCoarMG</td><td>Multigrid-grids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpolator</td><td>Interpolator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fluxReg</td><td>Flux register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarAve</td><td>Coarsener </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainBC</td><td>Domain BC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebBC</td><td>Boundary conditions on EBs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of computational domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_refToFine</td><td>Refinement ratio to fine level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_refToCoar</td><td>Refinement ratio to coarse level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hasFine</td><td>Has fine level or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hasCoar</td><td>Has coarse level or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hasMGObjects</td><td>Has multigrid-objects (special objects between AMR levels, or below the AMR levels) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_alpha</td><td>Operator alpha </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_beta</td><td>Operator beta </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_Acoef</td><td>Operator A-coefficient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_Bcoef</td><td>Operator B-coefficient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_BcoefIrreg</td><td>Operator B-coefficient (on EB faces) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ghostCellsPhi</td><td>Ghost cells in data holders </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ghostCellsPhi</td><td>Ghost cells in data holders </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_smoother</td><td>Which smoother to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a735497e11967e45bbdb87e166675b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735497e11967e45bbdb87e166675b572">&#9670;&nbsp;</a></span>AMROperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMROperator </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *&#160;</td>
          <td class="paramname"><em>a_finerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the AMR operator, i.e. compute L(phi) in an AMR context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_residual</td><td>Residual on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiFine</td><td>Phi on fine level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiCoar</td><td>Phi on coar level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finerOp</td><td>Finer operatator</td></tr>
  </table>
  </dd>
</dl>
<p>This involves ghost cell interpolation if there's a coarse level, and refluxing if there's a fine level. </p>

</div>
</div>
<a id="abca5be69ce25f34578c53e768724d1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca5be69ce25f34578c53e768724d1d7">&#9670;&nbsp;</a></span>AMROperatorNC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMROperatorNC </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *&#160;</td>
          <td class="paramname"><em>a_finerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the AMR operator, i.e. compute L(phi) in an AMR context, assuming no coarser AMR levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_Lphi</td><td>L(phi) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiFine</td><td>Phi on finer level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not</td></tr>
  </table>
  </dd>
</dl>
<p>This involves ghost cell interpolation if there's a coarse level, and refluxing if there's a fine level. </p>

</div>
</div>
<a id="a717d1a583fc5a6ac5fd7aeee2720c17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717d1a583fc5a6ac5fd7aeee2720c17d">&#9670;&nbsp;</a></span>AMROperatorNF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMROperatorNF </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the AMR operator, i.e. compute L(phi) in an AMR context, assuming no finer levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_Lphi</td><td>L(phi) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiCoar</td><td>Phi on coar level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not</td></tr>
  </table>
  </dd>
</dl>
<p>This involves ghost cell interpolation if there's a coarse level, and refluxing if there's a fine level. </p>

</div>
</div>
<a id="a16e45529e4923bccc5b5df7830c690f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e45529e4923bccc5b5df7830c690f7">&#9670;&nbsp;</a></span>AMRProlong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMRProlong </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_coarseCorrection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prolongation onto AMR level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_correction</td><td>Interpolated correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseCorrection</td><td>Correction on coarse level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb2abfffd5efab0c32b37c745d85d70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2abfffd5efab0c32b37c745d85d70d">&#9670;&nbsp;</a></span>AMRResidual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMRResidual </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *&#160;</td>
          <td class="paramname"><em>a_finerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute residual on this level. AMR version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_residual</td><td>Residual on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiFine</td><td>Phi on fine level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiCoar</td><td>Phi on coar level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Right-hand side on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finerOp</td><td>Finer operatator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb87b2a22419fc9a03e2a7d401b38d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb87b2a22419fc9a03e2a7d401b38d37">&#9670;&nbsp;</a></span>AMRResidualNC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMRResidualNC </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *&#160;</td>
          <td class="paramname"><em>a_finerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute AMR residual on coarsest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_residual</td><td>Residual on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiFine</td><td>Phi on fine level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Right-hand side on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finerOp</td><td>Finer operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ebe51fd405b5a885093f542d90e0131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebe51fd405b5a885093f542d90e0131">&#9670;&nbsp;</a></span>AMRResidualNF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMRResidualNF </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute AMR residual on finest AMR level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_residual</td><td>Residual on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiCoar</td><td>Phi on coar level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Right-hand side on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaaf3e29546ad6b66faeaa93e90c0e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaf3e29546ad6b66faeaa93e90c0e5e">&#9670;&nbsp;</a></span>AMRRestrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMRRestrict </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residualCoarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_coarseCorrection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_skip_res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restrict residual. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_residualCoarse</td><td>Coarse residual </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_residual</td><td>Residual </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_correction</td><td>Correction on this level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_coarseCorrection</td><td>Coarse level correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_skip_res</td><td>I have no idea what this one is supposed to do. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeecc255b80bc733939b06593d9965c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecc255b80bc733939b06593d9965c5d">&#9670;&nbsp;</a></span>AMRUpdateResidual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::AMRUpdateResidual </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_coarseCorrection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update AMR residual. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_residual</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_correction</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseCorrection</td><td>Coarse-level correction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c84d18c5437d9bd530fe8e5a58378a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c84d18c5437d9bd530fe8e5a58378a0">&#9670;&nbsp;</a></span>applyDomainFlux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::applyDomainFlux </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply domain flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>Cell data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Computation box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Homogeneous BC or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets the ghost cells of phi to phi(i-1) = phi(i) + F*dx/bco such that when we take the centered difference we get -bco*(phi(i) - phi(i-1))/dx = F. </dd></dl>

</div>
</div>
<a id="a1d69b63b2071bcdaa8cad2fc210e5917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d69b63b2071bcdaa8cad2fc210e5917">&#9670;&nbsp;</a></span>applyOp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::applyOp </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply operator in a grid box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_Lphi</td><td>L(phi) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Grid box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data indxe </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Homogeneous physical BCs or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc685d503be92f7fdc4c2abf0f9ff7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc685d503be92f7fdc4c2abf0f9ff7a9">&#9670;&nbsp;</a></span>applyOp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::applyOp </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_Lphi</td><td>L(phi) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBc</td><td>Homogeneous physical BCs or not</td></tr>
  </table>
  </dd>
</dl>
<p>This computes a_Lphi = L(a_phi) using homogeneous physical BCs or not </p>

</div>
</div>
<a id="a20a1d053d3e694e220ff38ebda136da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a1d053d3e694e220ff38ebda136da4">&#9670;&nbsp;</a></span>applyOp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::applyOp </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; *const&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousCFBC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply operator on this level. This is a more general version which can turn on/off homogeneous and CF bcs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_Lphi</td><td>L(phi) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phiCoar</td><td>Coarse-level phi. If you have a coar this </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousCFBC</td><td>Use homogeneous coarse-fine bcs or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_phi is not really const and we do a nasty cast. Leaving it as const because we only modify the ghost cells! </dd></dl>

</div>
</div>
<a id="a6aee6d047d1f9dec4e4d3642175a01b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aee6d047d1f9dec4e4d3642175a01b3">&#9670;&nbsp;</a></span>applyOpIrregular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::applyOpIrregular </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply operator in irregular cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_Lphi</td><td>L(phi) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Cell box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Homogeneous physical BCs or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99c190a7fbae1686926c1247c9b5b29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c190a7fbae1686926c1247c9b5b29b">&#9670;&nbsp;</a></span>applyOpRegular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::applyOpRegular </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply operator in regular cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_Lphi</td><td>L(phi) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Grid box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data indxe </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Homogeneous physical BCs or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a663d6bbea4c9ba8e5427929d20dc87f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663d6bbea4c9ba8e5427929d20dc87f1">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::assign </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign data. </p>
<p>This does a local copy from rhs to lhs </p>

</div>
</div>
<a id="a0d5b4cd2407b1c002ad9e8139477df05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5b4cd2407b1c002ad9e8139477df05">&#9670;&nbsp;</a></span>axby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::axby </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a_lhs = a*x + b*y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Result data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_x</td><td>x-data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_y</td><td>y-data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_a</td><td>Scaling factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_b</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afabaf780d215951b42cdaa13e7bf2832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabaf780d215951b42cdaa13e7bf2832">&#9670;&nbsp;</a></span>coarsen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::coarsen </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiFine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coarsen data from fine to coar level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Data on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiFine</td><td>Data on finer level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine is used in AMROperator to ensure that EB fluxes which are described by stencils get consistent data under the fine level. </dd></dl>

</div>
</div>
<a id="a492c4e1109d648fa396e52cd686b0a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492c4e1109d648fa396e52cd686b0a38">&#9670;&nbsp;</a></span>coarsen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::coarsen </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_fineFlux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coarsen fluxes on the fine level onto this level. </p>
<p>User must update fluxes before calling this routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_flux</td><td>Flux on this level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fineFlux</td><td>Flux on finer level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine is used in the reflux-free AMROperator </dd></dl>

</div>
</div>
<a id="a6da44f2e73bc14bf78d04067635c8460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da44f2e73bc14bf78d04067635c8460">&#9670;&nbsp;</a></span>computeFaceCenteredFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::computeFaceCenteredFlux </td>
          <td>(</td>
          <td class="paramtype">EBFaceFAB &amp;&#160;</td>
          <td class="paramname"><em>a_fluxCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute face-centered fluxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_fluxCenter</td><td>Flux on center </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in</td><td>a_phi Cell-centered data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Cell-centered compute box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes the flux for all dir-oriented faces in a_cellBox except for boundary faces. </dd></dl>

</div>
</div>
<a id="a1ef10fff10e74c67de808c5ef081b590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef10fff10e74c67de808c5ef081b590">&#9670;&nbsp;</a></span>computeFaceCentroidFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::computeFaceCentroidFlux </td>
          <td>(</td>
          <td class="paramtype">EBFaceFAB &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute face-centered fluxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_fluxCenter</td><td>Flux on center </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in</td><td>a_phi Cell-centered data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Cell-centered compute box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes the flux for all dir-oriented faces in a_cellBox except for boundary faces. </dd></dl>

</div>
</div>
<a id="adaacce511ffcf17c35c8feec84b24a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaacce511ffcf17c35c8feec84b24a22">&#9670;&nbsp;</a></span>computeFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::computeFlux </td>
          <td>(</td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill face centroid-centered fluxes on this level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered data. Must have updated ghost cells for this to make any sense. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes the flux onto m_flux everywhere except on boundary faces. </dd></dl>

</div>
</div>
<a id="a0d5f92a5e0e4c04d53848174f8a595e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5f92a5e0e4c04d53848174f8a595e5">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::create </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create data which clones the layout of the other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data clone (returned data is not initialized) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_rhs</td><td>Data layout to be cloned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3d067e1d8b54e213aef086df56076b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d067e1d8b54e213aef086df56076b0">&#9670;&nbsp;</a></span>createCoarsened()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::createCoarsened </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>a_refRat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create coarsening of data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Coarsened data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Fine data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_refRat</td><td>Coarsening factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a1393143c05c84514c0c68e9fa81ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1393143c05c84514c0c68e9fa81ccb">&#9670;&nbsp;</a></span>createCoarser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::createCoarser </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_ghosted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create coarsened data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_coarse</td><td>Coarse data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fine</td><td>Fine data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ghosted</td><td>Include ghost cells or nto </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e618302f9056c8888e24dc0c65a5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e618302f9056c8888e24dc0c65a5c6">&#9670;&nbsp;</a></span>diagonalScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::diagonalScale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_kappaWeighted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do diagonal scaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_rhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_kappaWeighted</td><td>Use kappa-weighted scaling or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a647f29b8543314c4c3234399a7b9fa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647f29b8543314c4c3234399a7b9fa99">&#9670;&nbsp;</a></span>divideByIdentityCoef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::divideByIdentityCoef </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide by the a-coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_rhs</td><td>Divided data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dd96a0878237551c9896f32aefa8b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd96a0878237551c9896f32aefa8b59">&#9670;&nbsp;</a></span>fillDomainFlux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::fillDomainFlux </td>
          <td>(</td>
          <td class="paramtype">EBFluxFAB &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill domain flux. This fills the flux on the domain face using centered differencing ala applyDomainFlux. </p>
<p>a_flux is replaced by the user-specified flux on the domain faces. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_flux</td><td>Flux data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>Cell-centered data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Computation box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62790e1666fb3ddf2b17c426586ee85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62790e1666fb3ddf2b17c426586ee85f">&#9670;&nbsp;</a></span>fillGrad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::fillGrad </td>
          <td>(</td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not called, I think. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0df13a592dcc8ef8db05720521c121e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df13a592dcc8ef8db05720521c121e3">&#9670;&nbsp;</a></span>gauSaiMultiColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::gauSaiMultiColor </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVect &amp;&#160;</td>
          <td class="paramname"><em>a_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-colored Gauss-Seidel kernel. Public because <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> may want to use use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Lphi L(corrcetion) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_color</td><td>"Color": </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54a2a3d66da7cb7859bdeadc14a33ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a2a3d66da7cb7859bdeadc14a33ed0">&#9670;&nbsp;</a></span>gauSaiMultiColorKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::gauSaiMultiColorKernel </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_Lcorr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_resid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVect &amp;&#160;</td>
          <td class="paramname"><em>a_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-color Gauss-Seidel kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_Lcorr</td><td>Storage for computing L(a_corr) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_corr</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_resid</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_color</td><td>Color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95a50faa5bc2d89188c726b4ee6e6f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a50faa5bc2d89188c726b4ee6e6f57">&#9670;&nbsp;</a></span>gauSaiRedBlackKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::gauSaiRedBlackKernel </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_Lcorr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_resid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>a_redBlack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Red-black Gauss-Seidel kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_Lcorr</td><td>Storage for computing L(a_corr) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_corr</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_resid</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_redBlack</td><td>Red or black </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Grid box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac57225143774c072002c4f8f7914d9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57225143774c072002c4f8f7914d9d8">&#9670;&nbsp;</a></span>getAcoef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const RefCountedPtr&lt; LevelData&lt; EBCellFAB &gt; &gt; &amp; EBHelmholtzOp::getAcoef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Helmholtz A-coefficient on cell centers. </p>
<dl class="section return"><dt>Returns</dt><dd>m_Acoef </dd></dl>

</div>
</div>
<a id="ad0b4f43b2a98a900ef9ebca6888f3b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b4f43b2a98a900ef9ebca6888f3b0b">&#9670;&nbsp;</a></span>getBcoef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const RefCountedPtr&lt; LevelData&lt; EBFluxFAB &gt; &gt; &amp; EBHelmholtzOp::getBcoef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Helmholtz B-coefficient on faces. </p>
<dl class="section return"><dt>Returns</dt><dd>m_Bcoef </dd></dl>

</div>
</div>
<a id="a16a1e2ba2e60c4eee89fbed6668e7067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a1e2ba2e60c4eee89fbed6668e7067">&#9670;&nbsp;</a></span>getBcoefIrreg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const RefCountedPtr&lt; LevelData&lt; BaseIVFAB&lt; Real &gt; &gt; &gt; &amp; EBHelmholtzOp::getBcoefIrreg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Helmholtz B-coefficient on the EB. </p>
<dl class="section return"><dt>Returns</dt><dd>m_Bcoef </dd></dl>

</div>
</div>
<a id="a63b4bfad4d0f236ad1ae4b71b1936ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b4bfad4d0f236ad1ae4b71b1936ee0">&#9670;&nbsp;</a></span>getFaceCenterFluxStencil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VoFStencil EBHelmholtzOp::getFaceCenterFluxStencil </td>
          <td>(</td>
          <td class="paramtype">const FaceIndex &amp;&#160;</td>
          <td class="paramname"><em>a_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the face-centered flux stencil. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_face</td><td>Face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index. Need because we multiply by B-coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a stencil for the face-centered flux for the given face </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the face is a boundary face the returned stencil is empty. </dd></dl>

</div>
</div>
<a id="a9776b4ff1bd1b8b738aa7b1ae9724c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9776b4ff1bd1b8b738aa7b1ae9724c89">&#9670;&nbsp;</a></span>getFaceCentroidFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::getFaceCentroidFlux </td>
          <td>(</td>
          <td class="paramtype">EBFaceFAB &amp;&#160;</td>
          <td class="paramname"><em>a_fluxCentroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute centroid fluxes in a direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_fluxCentroid</td><td>Flux on face centroid </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in</td><td>a_phi Cell-centered data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Cell-centered compute box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes the flux for all dir-oriented faces in a_cellBox except for boundary faces. </dd></dl>

</div>
</div>
<a id="a00b0d77f18b42122614b17bcb832a8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b0d77f18b42122614b17bcb832a8df">&#9670;&nbsp;</a></span>getFaceCentroidFluxStencil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VoFStencil EBHelmholtzOp::getFaceCentroidFluxStencil </td>
          <td>(</td>
          <td class="paramtype">const FaceIndex &amp;&#160;</td>
          <td class="paramname"><em>a_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the face-centroid flux stencil. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_face</td><td>Face </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index. Need because we multiply by B-coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a stencil for the face-centroid flux for the given face </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current version just interpolates the centered fluxes. </dd></dl>

</div>
</div>
<a id="a164212e03d6b1e80cfd79135b9e08fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164212e03d6b1e80cfd79135b9e08fac">&#9670;&nbsp;</a></span>getFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::getFlux </td>
          <td>(</td>
          <td class="paramtype">EBFluxFAB &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_flux</td><td>Flux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Data for which we will compute the flux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_grid</td><td>Grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Corresponding data index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bb9d314920be914055272d093dd7641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb9d314920be914055272d093dd7641">&#9670;&nbsp;</a></span>homogeneousCFInterp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::homogeneousCFInterp </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do homogeneous coarse-fine interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac89913ad920e33c937e58a14d4501639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89913ad920e33c937e58a14d4501639">&#9670;&nbsp;</a></span>incr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::incr </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae03bf5de8b696312d49d5219bb5f2cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03bf5de8b696312d49d5219bb5f2cdb">&#9670;&nbsp;</a></span>incrementFRCoar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::incrementFRCoar </td>
          <td>(</td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment coarse flux register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered data on the coarse level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae819a25bf009109ad79e6e7e73992654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae819a25bf009109ad79e6e7e73992654">&#9670;&nbsp;</a></span>incrementFRFine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::incrementFRFine </td>
          <td>(</td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_finerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment coarse flux register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiFine</td><td>Cell-centered data on the fine level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered data on the coarse level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finerOp</td><td>Finer operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9024128464d4e8e24aca532295265ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9024128464d4e8e24aca532295265ba">&#9670;&nbsp;</a></span>inhomogeneousCFInterp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::inhomogeneousCFInterp </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inhomogeneous coarse-fine interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phiFine</td><td>Fine data. Ghost cells will be filled. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phiCoar</td><td>Coarse data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab38cb29afeec984561cfb16a7c2aa462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38cb29afeec984561cfb16a7c2aa462">&#9670;&nbsp;</a></span>interpolateCF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::interpolateCF </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; *&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousCFBC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply coarse-fine boundary conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phiFine</td><td>Fine data </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phiCoar</td><td>Coarse data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousCFBC</td><td>Homogeneous CF or not (i.e. coar data is zero); </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86378e94ab21f2482ae813df99093751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86378e94ab21f2482ae813df99093751">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real EBHelmholtzOp::norm </td>
          <td>(</td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute norm of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a53dc81d65b3ed7216b65ca78fd5434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a53dc81d65b3ed7216b65ca78fd5434">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a>&amp; EBHelmholtzOp::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_oper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No move assigment allowed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80e416373921daca959a91a607b0b43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e416373921daca959a91a607b0b43d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a>&amp; EBHelmholtzOp::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBHelmholtzOp.html">EBHelmholtzOp</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No copy assigment allowed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55a11630804c46a822948f522c9fd0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a11630804c46a822948f522c9fd0dc">&#9670;&nbsp;</a></span>pointJacobiKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::pointJacobiKernel </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_Lcorr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_resid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_cellBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point Jacobi kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_Lcorr</td><td>Storage for computing L(a_corr) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_corr</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_resid</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellBox</td><td>Grid box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Data index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4556e17727b8b07237e3e8ace95aad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4556e17727b8b07237e3e8ace95aad9a">&#9670;&nbsp;</a></span>preCond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::preCond </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Precondition system before bottom solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_corr</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_residual</td><td>Residual</td></tr>
  </table>
  </dd>
</dl>
<p>This just runs a few relaxations. </p>

</div>
</div>
<a id="af78dc97388108d554273ce013367221a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78dc97388108d554273ce013367221a">&#9670;&nbsp;</a></span>prolongIncrement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::prolongIncrement </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_correctCoarse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prolongation method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Correction on this level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_correctCoarse</td><td>Correction on coarse level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa79ad244a5f004a5659c742f1af045a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79ad244a5f004a5659c742f1af045a8">&#9670;&nbsp;</a></span>reflux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::reflux </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_finerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflux algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_Lphi</td><td>L(phiFine, phiCoar). This is modified along the CF interface to consistently account for fine-level fluxes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiFine</td><td>Data on finer level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Data on this operator's level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finerOp</td><td>Operator on fine level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42bd80f7129900c761f5400613ffbd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bd80f7129900c761f5400613ffbd53">&#9670;&nbsp;</a></span>refluxFreeAMROperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::refluxFreeAMROperator </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Lphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiFine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phiCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AMRLevelOp&lt; LevelData&lt; EBCellFAB &gt;&gt; *&#160;</td>
          <td class="paramname"><em>a_finerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the AMR operator, i.e. compute L(phi) in an AMR context. </p>
<p>This is the reflux-free version of AMROperator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_residual</td><td>Residual on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiFine</td><td>Phi on fine level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phiCoar</td><td>Phi on coar level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finerOp</td><td>Finer operatator</td></tr>
  </table>
  </dd>
</dl>
<p>This involves ghost cell interpolation if there's a coarse level, and refluxing if there's a fine level. </p>

</div>
</div>
<a id="a2d8a9c316590e8931f66b7e161655c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8a9c316590e8931f66b7e161655c36">&#9670;&nbsp;</a></span>relax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::relax </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relaxation method. This does smoothing for the system L(correction) = residual. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_correction</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_residual</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_iterations</td><td>Number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01995f0b9cac6833fd90bc6336845c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01995f0b9cac6833fd90bc6336845c04">&#9670;&nbsp;</a></span>relaxGSMultiColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::relaxGSMultiColor </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multi-colored gauss-seidel relaxation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_correction</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_residual</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_iterations</td><td>Number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5eac3d95af403d716f7646c9ff2bf700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eac3d95af403d716f7646c9ff2bf700">&#9670;&nbsp;</a></span>relaxGSRedBlack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::relaxGSRedBlack </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Jacobi relaxation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_correction</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_residual</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_iterations</td><td>Number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3717f7d10bc215ac63ceea26d537dbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3717f7d10bc215ac63ceea26d537dbf6">&#9670;&nbsp;</a></span>relaxPointJacobi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::relaxPointJacobi </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Jacobi relaxation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_correction</td><td>Correction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_residual</td><td>Residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_iterations</td><td>Number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09449a46e618a393b236096bd5374af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09449a46e618a393b236096bd5374af4">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::residual </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_homogeneousPhysBc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute residual on this level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_residual</td><td>Residual rhs - L(phi) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>phi </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Right-hand side of system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_homogeneousPhysBC</td><td>Use homogeneous physical BCs or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63cbf35310032f60e23f2851f815a039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cbf35310032f60e23f2851f815a039">&#9670;&nbsp;</a></span>restrictResidual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::restrictResidual </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_resCoar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restrict residual onto coarse level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_resCoar</td><td>Coarse residual </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>Phi on this level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Rhs on this level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ca0f8913246ab54445107bf3c7e0df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca0f8913246ab54445107bf3c7e0df1">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::scale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data. Returns a_lhs = a_lhs*a_scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[i]</td><td>a_scale Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cdbaa4d871750098c48a369aa2c8355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdbaa4d871750098c48a369aa2c8355">&#9670;&nbsp;</a></span>setAcoAndBco()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::setAcoAndBco </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; LevelData&lt; EBCellFAB &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Acoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; LevelData&lt; EBFluxFAB &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_Bcoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; LevelData&lt; BaseIVFAB&lt; Real &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_BcoefIrreg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update with new A and B coefficients. </p>
<dl class="section note"><dt>Note</dt><dd>This will call defineStencils but will not recompute the stencils from the BC objects. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_Acoef</td><td>Operator A-coefficient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_Bcoef</td><td>Operator B-coefficient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_BcoefIrreg</td><td>Operator B-coefficient (on EB faces) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab17abf716e3500aa843843d9dc720917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17abf716e3500aa843843d9dc720917">&#9670;&nbsp;</a></span>setAlphaAndBeta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::setAlphaAndBeta </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set alpha coefficient and beta coefficient (can change as diffusion solvers progress) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_alpha</td><td>Alpha-coefficient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_beta</td><td>Beta-coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab067e4cd5069c9d6dcc075047c2d86fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab067e4cd5069c9d6dcc075047c2d86fd">&#9670;&nbsp;</a></span>setToZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::setToZero </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set data to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be set to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a369711725d619cca18ed5f15c0a43a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369711725d619cca18ed5f15c0a43a0f">&#9670;&nbsp;</a></span>turnOffCoarsening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::turnOffCoarsening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn off coarsening operation. </p>
<dl class="section note"><dt>Note</dt><dd>Done when <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> does the coarsening and we don't want <a class="el" href="classEBHelmholtzOp.html" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho.">EBHelmholtzOp</a> to redo it. </dd></dl>

</div>
</div>
<a id="a5d53b6c0821c782c9ea8eb5e7681ce28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d53b6c0821c782c9ea8eb5e7681ce28">&#9670;&nbsp;</a></span>turnOffExchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::turnOffExchange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn off exchange operation. </p>
<dl class="section note"><dt>Note</dt><dd>Done when <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> does the exchange and we don't want <a class="el" href="classEBHelmholtzOp.html" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho.">EBHelmholtzOp</a> to redo it. </dd></dl>

</div>
</div>
<a id="ad1421c86a5022532413b4320ccade732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1421c86a5022532413b4320ccade732">&#9670;&nbsp;</a></span>turnOnCoarsening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::turnOnCoarsening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on coarsening operation. </p>
<dl class="section note"><dt>Note</dt><dd>Done when <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> does the coarsening and we don't want <a class="el" href="classEBHelmholtzOp.html" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho.">EBHelmholtzOp</a> to redo it. </dd></dl>

</div>
</div>
<a id="ab901979aec1589777f2eebec85f7992e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab901979aec1589777f2eebec85f7992e">&#9670;&nbsp;</a></span>turnOnExchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBHelmholtzOp::turnOnExchange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on exchange operation. </p>
<dl class="section note"><dt>Note</dt><dd>Done when <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> does the exchange and we don't want <a class="el" href="classEBHelmholtzOp.html" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho.">EBHelmholtzOp</a> to redo it. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3e00b437e4fa34bb970084238f8e3f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e00b437e4fa34bb970084238f8e3f77">&#9670;&nbsp;</a></span>m_aggRelaxStencil</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayoutData&lt;RefCountedPtr&lt;VCAggStencil&gt; &gt; EBHelmholtzOp::m_aggRelaxStencil</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For making irregular stencil applications go faster. </p>
<p>This wraps m_relaxStencils in VCAggStencil (which computes explicit stencil offsets) </p>

</div>
</div>
<a id="abc9fc7b10d58f9e22b3d51d4bf6c6327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9fc7b10d58f9e22b3d51d4bf6c6327">&#9670;&nbsp;</a></span>m_doCoarsen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EBHelmholtzOp::m_doCoarsen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn on/off exchange operation. </p>
<dl class="section note"><dt>Note</dt><dd>Used by <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> for optimizing how calls in <a class="el" href="classEBHelmholtzOp.html" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho.">EBHelmholtzOp</a> are made </dd></dl>

</div>
</div>
<a id="a81e458a426b5054f15876184bdf86e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e458a426b5054f15876184bdf86e91">&#9670;&nbsp;</a></span>m_doExchange</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EBHelmholtzOp::m_doExchange</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn on/off exchange operation. </p>
<dl class="section note"><dt>Note</dt><dd>Used by <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> for optimizing how calls in <a class="el" href="classEBHelmholtzOp.html" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho.">EBHelmholtzOp</a> are made </dd></dl>

</div>
</div>
<a id="a488cb7bfd1b5c53eeb42ef7aada04dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488cb7bfd1b5c53eeb42ef7aada04dd9">&#9670;&nbsp;</a></span>m_doInterpCF</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EBHelmholtzOp::m_doInterpCF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do coarse-fine interpolation or not. </p>
<dl class="section note"><dt>Note</dt><dd>Used by <a class="el" href="classMFHelmholtzOp.html" title="Operator for solving multifluid Helmholtz on a grid level.">MFHelmholtzOp</a> for optimizing how calls in <a class="el" href="classEBHelmholtzOp.html" title="Helmholtz operator for equations like alpha*a(x)*phi(x) + beta*div(b(x)*grad(phi(x))) = rho.">EBHelmholtzOp</a> are made </dd></dl>

</div>
</div>
<a id="a19dcd06b3d6626ea49878eaec6e404d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dcd06b3d6626ea49878eaec6e404d3">&#9670;&nbsp;</a></span>m_relaxStencils</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayoutData&lt;BaseIVFAB&lt;VoFStencil&gt; &gt; EBHelmholtzOp::m_relaxStencils</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator stencils in irregular cells (and ones that border irregular cells if using a centroid discretization). </p>
<p>This stencil is =&gt; sum(fluxes)/dx, not including boundary faces or EB faces. I.e. this is the same as kappa*div(F) with the exclusion of faces where we have boundary conditions. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/Elliptic/<a class="el" href="CD__EBHelmholtzOp_8H_source.html">CD_EBHelmholtzOp.H</a></li>
<li>Source/Elliptic/CD_EBHelmholtzOp.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
