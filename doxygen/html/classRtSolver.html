<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: RtSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classRtSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RtSolver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract RTE solver class for doing various kinds of radiative transfer equations. This class is a pure class and it is basically just an interface.  
 <a href="classRtSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__RtSolver_8H_source.html">CD_RtSolver.H</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RtSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classRtSolver__inherit__graph.png" border="0" usemap="#aRtSolver_inherit__map" alt="Inheritance graph"/></div>
<map name="aRtSolver_inherit__map" id="aRtSolver_inherit__map">
<area shape="rect" title="Abstract RTE solver class for doing various kinds of radiative transfer equations...." alt="" coords="81,5,158,32"/>
<area shape="rect" href="classEddingtonSP1.html" title="Radiative tranfer equation solver in the SP1 (diffusion) approximation." alt="" coords="5,80,116,107"/>
<area shape="rect" href="classMcPhoto.html" title="Radiative tranfer equation solver using Monte&#45;Carlo simulation." alt="" coords="140,80,219,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for RtSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classRtSolver__coll__graph.png" border="0" usemap="#aRtSolver_coll__map" alt="Collaboration graph"/></div>
<map name="aRtSolver_coll__map" id="aRtSolver_coll__map">
<area shape="rect" title="Abstract RTE solver class for doing various kinds of radiative transfer equations...." alt="" coords="273,228,351,255"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="5,95,189,136"/>
<area shape="rect" href="classEBAMRData.html" title="Default class for holding LevelData&lt;T&gt; data across an EBAMR realm." alt="" coords="243,5,381,32"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="214,102,410,129"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="434,102,633,129"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a159dfdd246795e94f9f18be45b7590e9"><td class="memItemLeft" align="right" valign="top"><a id="a159dfdd246795e94f9f18be45b7590e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a159dfdd246795e94f9f18be45b7590e9">RtSolver</a> ()</td></tr>
<tr class="memdesc:a159dfdd246795e94f9f18be45b7590e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a159dfdd246795e94f9f18be45b7590e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4fc6b99803bfe6acf688f649b98b53"><td class="memItemLeft" align="right" valign="top"><a id="a7c4fc6b99803bfe6acf688f649b98b53"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a7c4fc6b99803bfe6acf688f649b98b53">~RtSolver</a> ()</td></tr>
<tr class="memdesc:a7c4fc6b99803bfe6acf688f649b98b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (does nothing) <br /></td></tr>
<tr class="separator:a7c4fc6b99803bfe6acf688f649b98b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e8fe119256dde3d9c091cdfaaa11d4"><td class="memItemLeft" align="right" valign="top"><a id="af3e8fe119256dde3d9c091cdfaaa11d4"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#af3e8fe119256dde3d9c091cdfaaa11d4">getName</a> ()</td></tr>
<tr class="memdesc:af3e8fe119256dde3d9c091cdfaaa11d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get solver name. <br /></td></tr>
<tr class="separator:af3e8fe119256dde3d9c091cdfaaa11d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc0f190f552e16dbc89b408fde1d0f5"><td class="memItemLeft" align="right" valign="top"><a id="accc0f190f552e16dbc89b408fde1d0f5"></a>
virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#accc0f190f552e16dbc89b408fde1d0f5">getRealm</a> () const</td></tr>
<tr class="memdesc:accc0f190f552e16dbc89b408fde1d0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the realm where the solver lives. <br /></td></tr>
<tr class="separator:accc0f190f552e16dbc89b408fde1d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1ee47e4eabfe2cca13ce6b96fd13fe"><td class="memItemLeft" align="right" valign="top"><a id="a7b1ee47e4eabfe2cca13ce6b96fd13fe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a7b1ee47e4eabfe2cca13ce6b96fd13fe">parseOptions</a> ()=0</td></tr>
<tr class="memdesc:a7b1ee47e4eabfe2cca13ce6b96fd13fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse options. <br /></td></tr>
<tr class="separator:a7b1ee47e4eabfe2cca13ce6b96fd13fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdfbf37f18272cf983eaceb8eb52771"><td class="memItemLeft" align="right" valign="top"><a id="adcdfbf37f18272cf983eaceb8eb52771"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#adcdfbf37f18272cf983eaceb8eb52771">parseRuntimeOptions</a> ()=0</td></tr>
<tr class="memdesc:adcdfbf37f18272cf983eaceb8eb52771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse runtime options. <br /></td></tr>
<tr class="separator:adcdfbf37f18272cf983eaceb8eb52771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab22f65be49033a88f611ed0d98c8e3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#afab22f65be49033a88f611ed0d98c8e3">advance</a> (const Real a_dt, const bool a_zeroPhi=false)</td></tr>
<tr class="memdesc:afab22f65be49033a88f611ed0d98c8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance equation one time step.  <a href="classRtSolver.html#afab22f65be49033a88f611ed0d98c8e3">More...</a><br /></td></tr>
<tr class="separator:afab22f65be49033a88f611ed0d98c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0803ec0ad6bed502bc7cb229efdcd062"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a0803ec0ad6bed502bc7cb229efdcd062">advance</a> (const Real a_dt, <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const bool a_zeroPhi=false)</td></tr>
<tr class="memdesc:a0803ec0ad6bed502bc7cb229efdcd062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance method. Advances one time step.  <a href="classRtSolver.html#a0803ec0ad6bed502bc7cb229efdcd062">More...</a><br /></td></tr>
<tr class="separator:a0803ec0ad6bed502bc7cb229efdcd062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c549d050929d2a183add227e2811fe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a55c549d050929d2a183add227e2811fe">advance</a> (const Real a_dt, <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_source, const bool a_zeroPhi=false)=0</td></tr>
<tr class="memdesc:a55c549d050929d2a183add227e2811fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance method. Advances one time step.  <a href="classRtSolver.html#a55c549d050929d2a183add227e2811fe">More...</a><br /></td></tr>
<tr class="separator:a55c549d050929d2a183add227e2811fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8036d7aa354200389a9f2fecc6cc35c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#ab8036d7aa354200389a9f2fecc6cc35c">setRealm</a> (const std::string a_realm)</td></tr>
<tr class="memdesc:ab8036d7aa354200389a9f2fecc6cc35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set realm where this solver lives.  <a href="classRtSolver.html#ab8036d7aa354200389a9f2fecc6cc35c">More...</a><br /></td></tr>
<tr class="separator:ab8036d7aa354200389a9f2fecc6cc35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00eb23b092393b8df6a902ba98a3175c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a00eb23b092393b8df6a902ba98a3175c">setRtSpecies</a> (const RefCountedPtr&lt; <a class="el" href="classRtSpecies.html">RtSpecies</a> &gt; &amp;a_species)</td></tr>
<tr class="memdesc:a00eb23b092393b8df6a902ba98a3175c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radiative transfer species (<a class="el" href="classRtSpecies.html" title="Declaration of a class that defines an interface to radiative transfer solvers, i....">RtSpecies</a>)  <a href="classRtSolver.html#a00eb23b092393b8df6a902ba98a3175c">More...</a><br /></td></tr>
<tr class="separator:a00eb23b092393b8df6a902ba98a3175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf26205b8fe427419686946e4b4e6460"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#aaf26205b8fe427419686946e4b4e6460">setComputationalGeometry</a> (const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; a_computationalGeometry)</td></tr>
<tr class="memdesc:aaf26205b8fe427419686946e4b4e6460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set computational geometry.  <a href="classRtSolver.html#aaf26205b8fe427419686946e4b4e6460">More...</a><br /></td></tr>
<tr class="separator:aaf26205b8fe427419686946e4b4e6460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243e895c4e3e528849a0555ea28b284a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a243e895c4e3e528849a0555ea28b284a">computeLoads</a> (Vector&lt; long long &gt; &amp;a_loads, const DisjointBoxLayout &amp;a_dbl, const int a_level) const noexcept</td></tr>
<tr class="memdesc:a243e895c4e3e528849a0555ea28b284a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get computational loads for a specific grid level.  <a href="classRtSolver.html#a243e895c4e3e528849a0555ea28b284a">More...</a><br /></td></tr>
<tr class="separator:a243e895c4e3e528849a0555ea28b284a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b8a6ecb69b68033a00a2e2197c137a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a01b8a6ecb69b68033a00a2e2197c137a">setAmr</a> (const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;a_amr)</td></tr>
<tr class="memdesc:a01b8a6ecb69b68033a00a2e2197c137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amr object.  <a href="classRtSolver.html#a01b8a6ecb69b68033a00a2e2197c137a">More...</a><br /></td></tr>
<tr class="separator:a01b8a6ecb69b68033a00a2e2197c137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d4509c766880c6047ceb84cde4efa6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a56d4509c766880c6047ceb84cde4efa6">setPhase</a> (phase::which_phase a_phase=phase::gas)</td></tr>
<tr class="memdesc:a56d4509c766880c6047ceb84cde4efa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set phase.  <a href="classRtSolver.html#a56d4509c766880c6047ceb84cde4efa6">More...</a><br /></td></tr>
<tr class="separator:a56d4509c766880c6047ceb84cde4efa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622d20e4452eaa134441b8c84936772e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a622d20e4452eaa134441b8c84936772e">setVerbosity</a> (const int a_verbosity)</td></tr>
<tr class="memdesc:a622d20e4452eaa134441b8c84936772e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set verbosity.  <a href="classRtSolver.html#a622d20e4452eaa134441b8c84936772e">More...</a><br /></td></tr>
<tr class="separator:a622d20e4452eaa134441b8c84936772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7760b7f5fa5514e43433616069f840f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a7760b7f5fa5514e43433616069f840f9">setTime</a> (const int a_step, const Real a_time, const Real a_dt)</td></tr>
<tr class="memdesc:a7760b7f5fa5514e43433616069f840f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time for this solver.  <a href="classRtSolver.html#a7760b7f5fa5514e43433616069f840f9">More...</a><br /></td></tr>
<tr class="separator:a7760b7f5fa5514e43433616069f840f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16ad3c86f4eac52f8393b6346ed53ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#ac16ad3c86f4eac52f8393b6346ed53ab">setStationary</a> (const bool a_stationary)</td></tr>
<tr class="memdesc:ac16ad3c86f4eac52f8393b6346ed53ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stationary solver or not.  <a href="classRtSolver.html#ac16ad3c86f4eac52f8393b6346ed53ab">More...</a><br /></td></tr>
<tr class="separator:ac16ad3c86f4eac52f8393b6346ed53ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752e1379763cd8b33fe645119870a3a2"><td class="memItemLeft" align="right" valign="top"><a id="a752e1379763cd8b33fe645119870a3a2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a752e1379763cd8b33fe645119870a3a2">sanityCheck</a> ()</td></tr>
<tr class="memdesc:a752e1379763cd8b33fe645119870a3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanity check. <br /></td></tr>
<tr class="separator:a752e1379763cd8b33fe645119870a3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4167be0c920b8c720e6fb604821bef7"><td class="memItemLeft" align="right" valign="top"><a id="aa4167be0c920b8c720e6fb604821bef7"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#aa4167be0c920b8c720e6fb604821bef7">isStationary</a> ()</td></tr>
<tr class="memdesc:aa4167be0c920b8c720e6fb604821bef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if solver is stationary. <br /></td></tr>
<tr class="separator:aa4167be0c920b8c720e6fb604821bef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78513adf16ac8c90ec2a619936d637fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a78513adf16ac8c90ec2a619936d637fa">computeBoundaryFlux</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_ebFlux, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi)=0</td></tr>
<tr class="memdesc:a78513adf16ac8c90ec2a619936d637fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the boundary flux given a state (a_phi will be different for different RTE approximations)  <a href="classRtSolver.html#a78513adf16ac8c90ec2a619936d637fa">More...</a><br /></td></tr>
<tr class="separator:a78513adf16ac8c90ec2a619936d637fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1c214be74dbd90ed6e472be2e481c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a4b1c214be74dbd90ed6e472be2e481c1">computeDomainFlux</a> (<a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;a_domainflux, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi)=0</td></tr>
<tr class="memdesc:a4b1c214be74dbd90ed6e472be2e481c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the domain flux given a state (a_phi will be different for different RTE approximations)  <a href="classRtSolver.html#a4b1c214be74dbd90ed6e472be2e481c1">More...</a><br /></td></tr>
<tr class="separator:a4b1c214be74dbd90ed6e472be2e481c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686bc53955acb79c2157d56193f5d00c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a686bc53955acb79c2157d56193f5d00c">computeFlux</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_flux, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi)=0</td></tr>
<tr class="memdesc:a686bc53955acb79c2157d56193f5d00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the flux.  <a href="classRtSolver.html#a686bc53955acb79c2157d56193f5d00c">More...</a><br /></td></tr>
<tr class="separator:a686bc53955acb79c2157d56193f5d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8ae2062ffae73a68e02be1e31085e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a0d8ae2062ffae73a68e02be1e31085e4">computeDensity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_isotropic, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi)=0</td></tr>
<tr class="memdesc:a0d8ae2062ffae73a68e02be1e31085e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get isotropic part.  <a href="classRtSolver.html#a0d8ae2062ffae73a68e02be1e31085e4">More...</a><br /></td></tr>
<tr class="separator:a0d8ae2062ffae73a68e02be1e31085e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5880ce9b6efcbcca377c476b0c298c84"><td class="memItemLeft" align="right" valign="top"><a id="a5880ce9b6efcbcca377c476b0c298c84"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a5880ce9b6efcbcca377c476b0c298c84">allocate</a> ()=0</td></tr>
<tr class="memdesc:a5880ce9b6efcbcca377c476b0c298c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate internal storage. <br /></td></tr>
<tr class="separator:a5880ce9b6efcbcca377c476b0c298c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293ee41b9c7b130b156fc27494bd33dc"><td class="memItemLeft" align="right" valign="top"><a id="a293ee41b9c7b130b156fc27494bd33dc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a293ee41b9c7b130b156fc27494bd33dc">deallocate</a> ()=0</td></tr>
<tr class="memdesc:a293ee41b9c7b130b156fc27494bd33dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate internal storage. <br /></td></tr>
<tr class="separator:a293ee41b9c7b130b156fc27494bd33dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b3ea39efa4bdde9807003e7335c1df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a92b3ea39efa4bdde9807003e7335c1df">preRegrid</a> (const int a_lbase, const int a_oldFinestLevel)=0</td></tr>
<tr class="memdesc:a92b3ea39efa4bdde9807003e7335c1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pre-regrid operations.  <a href="classRtSolver.html#a92b3ea39efa4bdde9807003e7335c1df">More...</a><br /></td></tr>
<tr class="separator:a92b3ea39efa4bdde9807003e7335c1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac789e6fd29391b49b3bc7e9df12f9603"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#ac789e6fd29391b49b3bc7e9df12f9603">regrid</a> (const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel)=0</td></tr>
<tr class="memdesc:ac789e6fd29391b49b3bc7e9df12f9603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid this solver.  <a href="classRtSolver.html#ac789e6fd29391b49b3bc7e9df12f9603">More...</a><br /></td></tr>
<tr class="separator:ac789e6fd29391b49b3bc7e9df12f9603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ba606d2ab6c1e8238063ed12d53076"><td class="memItemLeft" align="right" valign="top"><a id="aa5ba606d2ab6c1e8238063ed12d53076"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#aa5ba606d2ab6c1e8238063ed12d53076">registerOperators</a> ()=0</td></tr>
<tr class="memdesc:aa5ba606d2ab6c1e8238063ed12d53076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register operators. <br /></td></tr>
<tr class="separator:aa5ba606d2ab6c1e8238063ed12d53076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9ff80791eb1abe86043834f8bc7d38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a8c9ff80791eb1abe86043834f8bc7d38">initialData</a> ()</td></tr>
<tr class="memdesc:a8c9ff80791eb1abe86043834f8bc7d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill solver with initial data. By default, this sets internal data to zero.  <a href="classRtSolver.html#a8c9ff80791eb1abe86043834f8bc7d38">More...</a><br /></td></tr>
<tr class="separator:a8c9ff80791eb1abe86043834f8bc7d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8d8cad248f9f2c483737d67095b06f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#acf8d8cad248f9f2c483737d67095b06f">setSource</a> (const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_source)</td></tr>
<tr class="memdesc:acf8d8cad248f9f2c483737d67095b06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set source term.  <a href="classRtSolver.html#acf8d8cad248f9f2c483737d67095b06f">More...</a><br /></td></tr>
<tr class="separator:acf8d8cad248f9f2c483737d67095b06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84736055c8def8d6e5f32acb042143e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a84736055c8def8d6e5f32acb042143e3">setSource</a> (const Real a_source)</td></tr>
<tr class="memdesc:a84736055c8def8d6e5f32acb042143e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set source.  <a href="classRtSolver.html#a84736055c8def8d6e5f32acb042143e3">More...</a><br /></td></tr>
<tr class="separator:a84736055c8def8d6e5f32acb042143e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4737b50759400092d1fb2e78c2f0451"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#ac4737b50759400092d1fb2e78c2f0451">setSource</a> (const std::function&lt; Real(const RealVect a_pos)&gt; a_source)</td></tr>
<tr class="memdesc:ac4737b50759400092d1fb2e78c2f0451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set source.  <a href="classRtSolver.html#ac4737b50759400092d1fb2e78c2f0451">More...</a><br /></td></tr>
<tr class="separator:ac4737b50759400092d1fb2e78c2f0451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f3b8b1a5790d30efd2e2317b171ac0"><td class="memItemLeft" align="right" valign="top"><a id="a85f3b8b1a5790d30efd2e2317b171ac0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a85f3b8b1a5790d30efd2e2317b171ac0">writePlotFile</a> ()=0</td></tr>
<tr class="memdesc:a85f3b8b1a5790d30efd2e2317b171ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write plot file. <br /></td></tr>
<tr class="separator:a85f3b8b1a5790d30efd2e2317b171ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ef9ae5ac5333f9c562d4496346c480"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a61ef9ae5ac5333f9c562d4496346c480">getNumberOfPlotVariables</a> () const</td></tr>
<tr class="memdesc:a61ef9ae5ac5333f9c562d4496346c480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of output fields.  <a href="classRtSolver.html#a61ef9ae5ac5333f9c562d4496346c480">More...</a><br /></td></tr>
<tr class="separator:a61ef9ae5ac5333f9c562d4496346c480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804f78527ec2e9d5a1079e5d84b7a19b"><td class="memItemLeft" align="right" valign="top"><a id="a804f78527ec2e9d5a1079e5d84b7a19b"></a>
virtual Vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a804f78527ec2e9d5a1079e5d84b7a19b">getPlotVariableNames</a> () const</td></tr>
<tr class="memdesc:a804f78527ec2e9d5a1079e5d84b7a19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output plot names. <br /></td></tr>
<tr class="separator:a804f78527ec2e9d5a1079e5d84b7a19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2b90f183af78630cdd7211d962b9c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a1f2b90f183af78630cdd7211d962b9c3">writePlotData</a> (LevelData&lt; EBCellFAB &gt; &amp;a_output, int &amp;a_comp, const std::string a_outputRealm, const int a_level) const noexcept</td></tr>
<tr class="memdesc:a1f2b90f183af78630cdd7211d962b9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write output data to a_output.  <a href="classRtSolver.html#a1f2b90f183af78630cdd7211d962b9c3">More...</a><br /></td></tr>
<tr class="separator:a1f2b90f183af78630cdd7211d962b9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3b079fde1768aa6f7b951020c0a63"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a0ff3b079fde1768aa6f7b951020c0a63">getTime</a> () const</td></tr>
<tr class="memdesc:a0ff3b079fde1768aa6f7b951020c0a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current time.  <a href="classRtSolver.html#a0ff3b079fde1768aa6f7b951020c0a63">More...</a><br /></td></tr>
<tr class="separator:a0ff3b079fde1768aa6f7b951020c0a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2a4a345a8e4830d8bbd65207f6430"><td class="memItemLeft" align="right" valign="top">virtual phase::which_phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a13f2a4a345a8e4830d8bbd65207f6430">getPhase</a> ()</td></tr>
<tr class="memdesc:a13f2a4a345a8e4830d8bbd65207f6430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RTE phase.  <a href="classRtSolver.html#a13f2a4a345a8e4830d8bbd65207f6430">More...</a><br /></td></tr>
<tr class="separator:a13f2a4a345a8e4830d8bbd65207f6430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b876edea4718bdee9cc4436e107c9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a19b876edea4718bdee9cc4436e107c9d">getPhi</a> ()</td></tr>
<tr class="memdesc:a19b876edea4718bdee9cc4436e107c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get solver state.  <a href="classRtSolver.html#a19b876edea4718bdee9cc4436e107c9d">More...</a><br /></td></tr>
<tr class="separator:a19b876edea4718bdee9cc4436e107c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b56f888f09a4dc38c8ecd172e6eb0ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a9b56f888f09a4dc38c8ecd172e6eb0ed">getSource</a> ()</td></tr>
<tr class="memdesc:a9b56f888f09a4dc38c8ecd172e6eb0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multifluid source.  <a href="classRtSolver.html#a9b56f888f09a4dc38c8ecd172e6eb0ed">More...</a><br /></td></tr>
<tr class="separator:a9b56f888f09a4dc38c8ecd172e6eb0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b88752ec61d7f506bb6cff96a5b97d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a6b88752ec61d7f506bb6cff96a5b97d5">getKappa</a> ()</td></tr>
<tr class="memdesc:a6b88752ec61d7f506bb6cff96a5b97d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absorption length.  <a href="classRtSolver.html#a6b88752ec61d7f506bb6cff96a5b97d5">More...</a><br /></td></tr>
<tr class="separator:a6b88752ec61d7f506bb6cff96a5b97d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684fb7325af1b1912e0c4cec9fb90770"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a684fb7325af1b1912e0c4cec9fb90770">getKappaEb</a> ()</td></tr>
<tr class="memdesc:a684fb7325af1b1912e0c4cec9fb90770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absorption coefficient on irregular EB faces.  <a href="classRtSolver.html#a684fb7325af1b1912e0c4cec9fb90770">More...</a><br /></td></tr>
<tr class="separator:a684fb7325af1b1912e0c4cec9fb90770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4957a57c3c1caad571d3284a9c95155a"><td class="memItemLeft" align="right" valign="top"><a id="a4957a57c3c1caad571d3284a9c95155a"></a>
virtual RefCountedPtr&lt; <a class="el" href="classRtSpecies.html">RtSpecies</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a4957a57c3c1caad571d3284a9c95155a">getSpecies</a> ()</td></tr>
<tr class="memdesc:a4957a57c3c1caad571d3284a9c95155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get species. <br /></td></tr>
<tr class="separator:a4957a57c3c1caad571d3284a9c95155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0bde04785c5e7d9dca2537391d5ead5a"><td class="memItemLeft" align="right" valign="top"><a id="a0bde04785c5e7d9dca2537391d5ead5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a0bde04785c5e7d9dca2537391d5ead5a">setEbIndexSpace</a> (const RefCountedPtr&lt; EBIndexSpace &gt; &amp;a_ebis)</td></tr>
<tr class="memdesc:a0bde04785c5e7d9dca2537391d5ead5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ebis. <br /></td></tr>
<tr class="separator:a0bde04785c5e7d9dca2537391d5ead5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f024c83df8b2b33c11e6a675a37e3"><td class="memItemLeft" align="right" valign="top"><a id="a431f024c83df8b2b33c11e6a675a37e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a431f024c83df8b2b33c11e6a675a37e3">parseVerbosity</a> () noexcept</td></tr>
<tr class="memdesc:a431f024c83df8b2b33c11e6a675a37e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse verbosity. <br /></td></tr>
<tr class="separator:a431f024c83df8b2b33c11e6a675a37e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec6324d8518126de3cc196b4fa53d51"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#acec6324d8518126de3cc196b4fa53d51">writeData</a> (LevelData&lt; EBCellFAB &gt; &amp;a_output, int &amp;a_comp, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_outputRealm, const int a_level, const bool a_interpToCentroids, const bool a_interpGhost) const noexcept</td></tr>
<tr class="memdesc:acec6324d8518126de3cc196b4fa53d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to output. Convenience function.  <a href="classRtSolver.html#acec6324d8518126de3cc196b4fa53d51">More...</a><br /></td></tr>
<tr class="separator:acec6324d8518126de3cc196b4fa53d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acdc7153b78223db7b2723dd7d008de72"><td class="memItemLeft" align="right" valign="top"><a id="acdc7153b78223db7b2723dd7d008de72"></a>
<a class="el" href="namespaceLocation.html#a54eced96f7ad5684263391a0b726c163">Location::Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#acdc7153b78223db7b2723dd7d008de72">m_dataLocation</a></td></tr>
<tr class="memdesc:acdc7153b78223db7b2723dd7d008de72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data location. <br /></td></tr>
<tr class="separator:acdc7153b78223db7b2723dd7d008de72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b737a4f483b7b3303432e217bbd4d7"><td class="memItemLeft" align="right" valign="top"><a id="a40b737a4f483b7b3303432e217bbd4d7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a40b737a4f483b7b3303432e217bbd4d7">m_realm</a></td></tr>
<tr class="memdesc:a40b737a4f483b7b3303432e217bbd4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where this solver lives. <br /></td></tr>
<tr class="separator:a40b737a4f483b7b3303432e217bbd4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90c4e5a17ac10aa7e5c5fe174aaa3ce"><td class="memItemLeft" align="right" valign="top"><a id="ac90c4e5a17ac10aa7e5c5fe174aaa3ce"></a>
RefCountedPtr&lt; EBIndexSpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#ac90c4e5a17ac10aa7e5c5fe174aaa3ce">m_ebis</a></td></tr>
<tr class="memdesc:ac90c4e5a17ac10aa7e5c5fe174aaa3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">EBIndexSpace for this solver. <br /></td></tr>
<tr class="separator:ac90c4e5a17ac10aa7e5c5fe174aaa3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7e803c4f504ef51e6ea49a0cd34f7a"><td class="memItemLeft" align="right" valign="top"><a id="aee7e803c4f504ef51e6ea49a0cd34f7a"></a>
RefCountedPtr&lt; <a class="el" href="classRtSpecies.html">RtSpecies</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#aee7e803c4f504ef51e6ea49a0cd34f7a">m_rtSpecies</a></td></tr>
<tr class="memdesc:aee7e803c4f504ef51e6ea49a0cd34f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radiative transfer species (contains meta-information like initial conditions) <br /></td></tr>
<tr class="separator:aee7e803c4f504ef51e6ea49a0cd34f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83055aa4851bcfffe37e3ebb02c0af1a"><td class="memItemLeft" align="right" valign="top"><a id="a83055aa4851bcfffe37e3ebb02c0af1a"></a>
RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a83055aa4851bcfffe37e3ebb02c0af1a">m_computationalGeometry</a></td></tr>
<tr class="memdesc:a83055aa4851bcfffe37e3ebb02c0af1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational geometry. <br /></td></tr>
<tr class="separator:a83055aa4851bcfffe37e3ebb02c0af1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be6481630f7823d6d9c878b70547692"><td class="memItemLeft" align="right" valign="top"><a id="a4be6481630f7823d6d9c878b70547692"></a>
RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a4be6481630f7823d6d9c878b70547692">m_amr</a></td></tr>
<tr class="memdesc:a4be6481630f7823d6d9c878b70547692"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMR; needed for grid stuff. <br /></td></tr>
<tr class="separator:a4be6481630f7823d6d9c878b70547692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867990a2d576dbac63ebea6025b2ff9b"><td class="memItemLeft" align="right" valign="top"><a id="a867990a2d576dbac63ebea6025b2ff9b"></a>
phase::which_phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a867990a2d576dbac63ebea6025b2ff9b">m_phase</a></td></tr>
<tr class="memdesc:a867990a2d576dbac63ebea6025b2ff9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase. <br /></td></tr>
<tr class="separator:a867990a2d576dbac63ebea6025b2ff9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a3cfbe7398e27f0638effd2d6b8bbf"><td class="memItemLeft" align="right" valign="top"><a id="a82a3cfbe7398e27f0638effd2d6b8bbf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a82a3cfbe7398e27f0638effd2d6b8bbf">m_name</a></td></tr>
<tr class="memdesc:a82a3cfbe7398e27f0638effd2d6b8bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for this solver. <br /></td></tr>
<tr class="separator:a82a3cfbe7398e27f0638effd2d6b8bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa678dd961614107076486084f300d5b2"><td class="memItemLeft" align="right" valign="top"><a id="aa678dd961614107076486084f300d5b2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#aa678dd961614107076486084f300d5b2">m_className</a></td></tr>
<tr class="memdesc:aa678dd961614107076486084f300d5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class name &ndash; needed because inherited classes will be named different. <br /></td></tr>
<tr class="separator:aa678dd961614107076486084f300d5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5f3964061b742e46636a2b7f2f9df"><td class="memItemLeft" align="right" valign="top"><a id="a9cf5f3964061b742e46636a2b7f2f9df"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a9cf5f3964061b742e46636a2b7f2f9df">m_cachePhi</a></td></tr>
<tr class="memdesc:a9cf5f3964061b742e46636a2b7f2f9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached state used for regridding. <br /></td></tr>
<tr class="separator:a9cf5f3964061b742e46636a2b7f2f9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82687b0e09a0c731b282bebc8ba6047e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a82687b0e09a0c731b282bebc8ba6047e">m_phi</a></td></tr>
<tr class="memdesc:a82687b0e09a0c731b282bebc8ba6047e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal state.  <a href="classRtSolver.html#a82687b0e09a0c731b282bebc8ba6047e">More...</a><br /></td></tr>
<tr class="separator:a82687b0e09a0c731b282bebc8ba6047e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3156fd486cd828dffc5d8a0fb380772e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a3156fd486cd828dffc5d8a0fb380772e">m_source</a></td></tr>
<tr class="memdesc:a3156fd486cd828dffc5d8a0fb380772e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source term.  <a href="classRtSolver.html#a3156fd486cd828dffc5d8a0fb380772e">More...</a><br /></td></tr>
<tr class="separator:a3156fd486cd828dffc5d8a0fb380772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02749194fbf5eaf3610cf2aa13bfc546"><td class="memItemLeft" align="right" valign="top"><a id="a02749194fbf5eaf3610cf2aa13bfc546"></a>
<a class="el" href="classEBAMRData.html">EBAMRFluxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a02749194fbf5eaf3610cf2aa13bfc546">m_kappa</a></td></tr>
<tr class="memdesc:a02749194fbf5eaf3610cf2aa13bfc546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absorption coefficient. <br /></td></tr>
<tr class="separator:a02749194fbf5eaf3610cf2aa13bfc546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e48c707308f5c75d3fb0d121014e378"><td class="memItemLeft" align="right" valign="top"><a id="a4e48c707308f5c75d3fb0d121014e378"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a4e48c707308f5c75d3fb0d121014e378">m_kappaEB</a></td></tr>
<tr class="memdesc:a4e48c707308f5c75d3fb0d121014e378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absorption coefficient on EB faces. <br /></td></tr>
<tr class="separator:a4e48c707308f5c75d3fb0d121014e378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83a547335a4beb10898f76234cc0344"><td class="memItemLeft" align="right" valign="top"><a id="ac83a547335a4beb10898f76234cc0344"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#ac83a547335a4beb10898f76234cc0344">m_time</a></td></tr>
<tr class="memdesc:ac83a547335a4beb10898f76234cc0344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time. <br /></td></tr>
<tr class="separator:ac83a547335a4beb10898f76234cc0344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6396c7ae094530cf9c30091279d34d5f"><td class="memItemLeft" align="right" valign="top"><a id="a6396c7ae094530cf9c30091279d34d5f"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a6396c7ae094530cf9c30091279d34d5f">m_dt</a></td></tr>
<tr class="memdesc:a6396c7ae094530cf9c30091279d34d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time increment. <br /></td></tr>
<tr class="separator:a6396c7ae094530cf9c30091279d34d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70c1ed7e5517995a856d822792ae6f2"><td class="memItemLeft" align="right" valign="top"><a id="af70c1ed7e5517995a856d822792ae6f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#af70c1ed7e5517995a856d822792ae6f2">m_stationary</a></td></tr>
<tr class="memdesc:af70c1ed7e5517995a856d822792ae6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stationary solver or not. <br /></td></tr>
<tr class="separator:af70c1ed7e5517995a856d822792ae6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b38776a07869df0dc0d36871ec39c3c"><td class="memItemLeft" align="right" valign="top"><a id="a8b38776a07869df0dc0d36871ec39c3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a8b38776a07869df0dc0d36871ec39c3c">m_plotPhi</a></td></tr>
<tr class="memdesc:a8b38776a07869df0dc0d36871ec39c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output state. <br /></td></tr>
<tr class="separator:a8b38776a07869df0dc0d36871ec39c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9fa29014a1974fd243545afd9b4cf3"><td class="memItemLeft" align="right" valign="top"><a id="a6f9fa29014a1974fd243545afd9b4cf3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a6f9fa29014a1974fd243545afd9b4cf3">m_plotSource</a></td></tr>
<tr class="memdesc:a6f9fa29014a1974fd243545afd9b4cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output source term. <br /></td></tr>
<tr class="separator:a6f9fa29014a1974fd243545afd9b4cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754253053b06ff7adfe5ba4a0689154"><td class="memItemLeft" align="right" valign="top"><a id="ab754253053b06ff7adfe5ba4a0689154"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_verbosity</b></td></tr>
<tr class="separator:ab754253053b06ff7adfe5ba4a0689154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6014e7cdca13c65327f8ea142ff7325"><td class="memItemLeft" align="right" valign="top"><a id="af6014e7cdca13c65327f8ea142ff7325"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#af6014e7cdca13c65327f8ea142ff7325">m_timeStep</a></td></tr>
<tr class="memdesc:af6014e7cdca13c65327f8ea142ff7325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step. <br /></td></tr>
<tr class="separator:af6014e7cdca13c65327f8ea142ff7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ad90640b4c905c032ac5c71be6bd4a3a2"><td class="memItemLeft" align="right" valign="top"><a id="ad90640b4c905c032ac5c71be6bd4a3a2"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#ad90640b4c905c032ac5c71be6bd4a3a2">m_comp</a> = 0</td></tr>
<tr class="memdesc:ad90640b4c905c032ac5c71be6bd4a3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default component that we solve for. <br /></td></tr>
<tr class="separator:ad90640b4c905c032ac5c71be6bd4a3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e37fa6937f1cdd789b063c5f56b575e"><td class="memItemLeft" align="right" valign="top"><a id="a2e37fa6937f1cdd789b063c5f56b575e"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRtSolver.html#a2e37fa6937f1cdd789b063c5f56b575e">m_nComp</a> = 1</td></tr>
<tr class="memdesc:a2e37fa6937f1cdd789b063c5f56b575e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of components. <br /></td></tr>
<tr class="separator:a2e37fa6937f1cdd789b063c5f56b575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract RTE solver class for doing various kinds of radiative transfer equations. This class is a pure class and it is basically just an interface. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="afab22f65be49033a88f611ed0d98c8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab22f65be49033a88f611ed0d98c8e3">&#9670;&nbsp;</a></span>advance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RtSolver::advance </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_zeroPhi</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance equation one time step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_zeroPhi</td><td>An optional argument for e.g. elliptic solves which can start from previous solution or zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0803ec0ad6bed502bc7cb229efdcd062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0803ec0ad6bed502bc7cb229efdcd062">&#9670;&nbsp;</a></span>advance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RtSolver::advance </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_zeroPhi</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance method. Advances one time step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Mesh solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_zeroPhi</td><td>An optional argument for e.g. elliptic solves which can start from previous solution or zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55c549d050929d2a183add227e2811fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c549d050929d2a183add227e2811fe">&#9670;&nbsp;</a></span>advance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RtSolver::advance </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_zeroPhi</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance method. Advances one time step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Mesh solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_zeroPhi</td><td>An optional argument for e.g. elliptic solves which can start from previous solution or zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMcPhoto.html#adc6e367b73c037c53d71871db7733658">McPhoto</a>, and <a class="el" href="classEddingtonSP1.html#a5537f12b6f3c8990b4835edd4da1f470">EddingtonSP1</a>.</p>

</div>
</div>
<a id="a78513adf16ac8c90ec2a619936d637fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78513adf16ac8c90ec2a619936d637fa">&#9670;&nbsp;</a></span>computeBoundaryFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RtSolver::computeBoundaryFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_ebFlux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the boundary flux given a state (a_phi will be different for different RTE approximations) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_ebFlux</td><td>The flux on the EB </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered solution for the RTE state (e.g. for Eddington this is just the isotropic part). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMcPhoto.html#a681a513ffc82b1879b6c1c1b1d2a9cf0">McPhoto</a>, and <a class="el" href="classEddingtonSP1.html#a0df26d11d7a4cfa215add2c78ab55f32">EddingtonSP1</a>.</p>

</div>
</div>
<a id="a0d8ae2062ffae73a68e02be1e31085e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8ae2062ffae73a68e02be1e31085e4">&#9670;&nbsp;</a></span>computeDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RtSolver::computeDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_isotropic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get isotropic part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_isotropic</td><td>Isotropic part of the RTE solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Full RTE solution.</td></tr>
  </table>
  </dd>
</dl>
<p>This is normally just a copy, but I need the function signature in order to have a clear plasma-coupling interface </p>

<p>Implemented in <a class="el" href="classMcPhoto.html#a448449129511613333d2ae4224f41dd2">McPhoto</a>, and <a class="el" href="classEddingtonSP1.html#aa7086eebcc6e479cc7cb7873486fe501">EddingtonSP1</a>.</p>

</div>
</div>
<a id="a4b1c214be74dbd90ed6e472be2e481c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1c214be74dbd90ed6e472be2e481c1">&#9670;&nbsp;</a></span>computeDomainFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RtSolver::computeDomainFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_domainflux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the domain flux given a state (a_phi will be different for different RTE approximations) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_domainFlux</td><td>The flux on the domain wall </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered solution for the RTE state (e.g. for Eddington this is just the isotropic part). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMcPhoto.html#a7fd8797c7de7a25b480022a8a05fb068">McPhoto</a>, and <a class="el" href="classEddingtonSP1.html#aa893ff0fe500ac086f79091160082085">EddingtonSP1</a>.</p>

</div>
</div>
<a id="a686bc53955acb79c2157d56193f5d00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686bc53955acb79c2157d56193f5d00c">&#9670;&nbsp;</a></span>computeFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RtSolver::computeFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_flux</td><td>The RTE flux on the domain wall </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered solution for the RTE state (e.g. for Eddington this is just the isotropic part).</td></tr>
  </table>
  </dd>
</dl>
<p>For diffusive models, the flux will be something like grad(a_phi). For higher-order models, the flux will be contained in a_phi (somehow). </p>

<p>Implemented in <a class="el" href="classMcPhoto.html#a16166b0bf3e5d6b2435b53faa6a69a32">McPhoto</a>, and <a class="el" href="classEddingtonSP1.html#a35d252832e553dff62434ada8b4e3f61">EddingtonSP1</a>.</p>

</div>
</div>
<a id="a243e895c4e3e528849a0555ea28b284a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243e895c4e3e528849a0555ea28b284a">&#9670;&nbsp;</a></span>computeLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::computeLoads </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; long long &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_loads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DisjointBoxLayout &amp;&#160;</td>
          <td class="paramname"><em>a_dbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get computational loads for a specific grid level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_loads</td><td>Grid loads for this level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dbl</td><td>Grids on input level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Input level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Loads for each box on a grid level. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The return vector should have the same order as the boxes in a_dbl. E.g. ret[0] must be the load for a_dbl.boxArray()[0];</dd></dl>
<p>The default implementation returns the number of cells in the grid patch as a proxy for the load. </p>

<p>Reimplemented in <a class="el" href="classMcPhoto.html#a2fe39d06c9b0c7e64323f4abbf8ca189">McPhoto</a>.</p>

</div>
</div>
<a id="a6b88752ec61d7f506bb6cff96a5b97d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b88752ec61d7f506bb6cff96a5b97d5">&#9670;&nbsp;</a></span>getKappa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp; RtSolver::getKappa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absorption length. </p>
<dl class="section return"><dt>Returns</dt><dd>m_kappa </dd></dl>

</div>
</div>
<a id="a684fb7325af1b1912e0c4cec9fb90770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684fb7325af1b1912e0c4cec9fb90770">&#9670;&nbsp;</a></span>getKappaEb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp; RtSolver::getKappaEb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absorption coefficient on irregular EB faces. </p>
<dl class="section return"><dt>Returns</dt><dd>m_kappaEB </dd></dl>

</div>
</div>
<a id="a61ef9ae5ac5333f9c562d4496346c480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ef9ae5ac5333f9c562d4496346c480">&#9670;&nbsp;</a></span>getNumberOfPlotVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RtSolver::getNumberOfPlotVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of output fields. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns number of variables that will be plotted to file. </dd></dl>

<p>Reimplemented in <a class="el" href="classMcPhoto.html#af04b800b80296202d8ec2b9131ea6a20">McPhoto</a>.</p>

</div>
</div>
<a id="a13f2a4a345a8e4830d8bbd65207f6430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f2a4a345a8e4830d8bbd65207f6430">&#9670;&nbsp;</a></span>getPhase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">phase::which_phase RtSolver::getPhase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the RTE phase. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_phase </dd></dl>

</div>
</div>
<a id="a19b876edea4718bdee9cc4436e107c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b876edea4718bdee9cc4436e107c9d">&#9670;&nbsp;</a></span>getPhi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; RtSolver::getPhi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get solver state. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_phi. For diffusive solves this will have a single component. </dd></dl>

</div>
</div>
<a id="a9b56f888f09a4dc38c8ecd172e6eb0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b56f888f09a4dc38c8ecd172e6eb0ed">&#9670;&nbsp;</a></span>getSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; RtSolver::getSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get multifluid source. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_source. For diffusive solves this will have a single component. </dd></dl>

</div>
</div>
<a id="a0ff3b079fde1768aa6f7b951020c0a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3b079fde1768aa6f7b951020c0a63">&#9670;&nbsp;</a></span>getTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real RtSolver::getTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current time. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_time </dd></dl>

</div>
</div>
<a id="a8c9ff80791eb1abe86043834f8bc7d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9ff80791eb1abe86043834f8bc7d38">&#9670;&nbsp;</a></span>initialData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::initialData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill solver with initial data. By default, this sets internal data to zero. </p>
<p>Default implementation sets to zero &ndash; override if you want to have different initial conditions. </p>

</div>
</div>
<a id="a92b3ea39efa4bdde9807003e7335c1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b3ea39efa4bdde9807003e7335c1df">&#9670;&nbsp;</a></span>preRegrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RtSolver::preRegrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pre-regrid operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lbase</td><td>Coarsest level that changed during regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest grid level before the regrid operation. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMcPhoto.html#a1ca87608627761f39fb02ec898ce2af5">McPhoto</a>, and <a class="el" href="classEddingtonSP1.html#a637beaa45215e9be0e27b99b56d62938">EddingtonSP1</a>.</p>

</div>
</div>
<a id="ac789e6fd29391b49b3bc7e9df12f9603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac789e6fd29391b49b3bc7e9df12f9603">&#9670;&nbsp;</a></span>regrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RtSolver::regrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regrid this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level where grids did not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest AMR level before the regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>Finest AMR level after the regrid. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMcPhoto.html#a1edfc9d2176da3818632cee7ea9abb6d">McPhoto</a>, and <a class="el" href="classEddingtonSP1.html#a1e60ee664dd9b0c4d9fa9bdeff774a48">EddingtonSP1</a>.</p>

</div>
</div>
<a id="a01b8a6ecb69b68033a00a2e2197c137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b8a6ecb69b68033a00a2e2197c137a">&#9670;&nbsp;</a></span>setAmr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setAmr </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_amr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the amr object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_amr</td><td><a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf26205b8fe427419686946e4b4e6460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf26205b8fe427419686946e4b4e6460">&#9670;&nbsp;</a></span>setComputationalGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setComputationalGeometry </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt;&#160;</td>
          <td class="paramname"><em>a_computationalGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set computational geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_computationalGeometry</td><td>Computational geometry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56d4509c766880c6047ceb84cde4efa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d4509c766880c6047ceb84cde4efa6">&#9670;&nbsp;</a></span>setPhase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setPhase </td>
          <td>(</td>
          <td class="paramtype">phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em> = <code>phase::gas</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas/solid) where the solver lives.</td></tr>
  </table>
  </dd>
</dl>
<p>This must be done BEFORE callilng setComputationalGeometry </p>

</div>
</div>
<a id="ab8036d7aa354200389a9f2fecc6cc35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8036d7aa354200389a9f2fecc6cc35c">&#9670;&nbsp;</a></span>setRealm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setRealm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set realm where this solver lives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00eb23b092393b8df6a902ba98a3175c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00eb23b092393b8df6a902ba98a3175c">&#9670;&nbsp;</a></span>setRtSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setRtSpecies </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classRtSpecies.html">RtSpecies</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_species</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the radiative transfer species (<a class="el" href="classRtSpecies.html" title="Declaration of a class that defines an interface to radiative transfer solvers, i....">RtSpecies</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_species</td><td>Species (see RtSpecies.H) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf8d8cad248f9f2c483737d67095b06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8d8cad248f9f2c483737d67095b06f">&#9670;&nbsp;</a></span>setSource() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set source term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84736055c8def8d6e5f32acb042143e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84736055c8def8d6e5f32acb042143e3">&#9670;&nbsp;</a></span>setSource() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setSource </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4737b50759400092d1fb2e78c2f0451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4737b50759400092d1fb2e78c2f0451">&#9670;&nbsp;</a></span>setSource() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setSource </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Real(const RealVect a_pos)&gt;&#160;</td>
          <td class="paramname"><em>a_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term (varies in space) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac16ad3c86f4eac52f8393b6346ed53ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16ad3c86f4eac52f8393b6346ed53ab">&#9670;&nbsp;</a></span>setStationary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setStationary </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_stationary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set stationary solver or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_stationary</td><td>If true, the solver is set to stationary mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7760b7f5fa5514e43433616069f840f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7760b7f5fa5514e43433616069f840f9">&#9670;&nbsp;</a></span>setTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setTime </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time for this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_step</td><td>Time step number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_time</td><td>Time (in seconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step increment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets m_step=a_step, m_time=a_time, m_dt=a_dt </dd></dl>

</div>
</div>
<a id="a622d20e4452eaa134441b8c84936772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622d20e4452eaa134441b8c84936772e">&#9670;&nbsp;</a></span>setVerbosity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::setVerbosity </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set verbosity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_verbosity</td><td>Verbosity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acec6324d8518126de3cc196b4fa53d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec6324d8518126de3cc196b4fa53d51">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::writeData </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_outputRealm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_interpToCentroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_interpGhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to output. Convenience function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_outputRealm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> to which a_output belongs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpToCentroids</td><td>If true, a_data will be interpolated to cell centroids before writing to a_output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpGhost</td><td>If true, interpolate ghost cells </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f2b90f183af78630cdd7211d962b9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2b90f183af78630cdd7211d962b9c3">&#9670;&nbsp;</a></span>writePlotData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RtSolver::writePlotData </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_outputRealm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write output data to a_output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_outputRealm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where a_output belongs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine writes m_phi on centroids (and not cell-centers). </dd></dl>

<p>Reimplemented in <a class="el" href="classMcPhoto.html#ac92ea0a12fc857448b303bbceeb10df9">McPhoto</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a82687b0e09a0c731b282bebc8ba6047e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82687b0e09a0c731b282bebc8ba6047e">&#9670;&nbsp;</a></span>m_phi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> RtSolver::m_phi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal state. </p>
<p>For diffusive models, this will only contain the isotropic density. For higher order models, this should also include the flux, Eddigton tensor etc. </p>

</div>
</div>
<a id="a3156fd486cd828dffc5d8a0fb380772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3156fd486cd828dffc5d8a0fb380772e">&#9670;&nbsp;</a></span>m_source</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> RtSolver::m_source</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source term. </p>
<p>For diffusive models, this will only contain the isotropic source. For higher order models, this should also include beam sources. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/RadiativeTransfer/<a class="el" href="CD__RtSolver_8H_source.html">CD_RtSolver.H</a></li>
<li>Source/RadiativeTransfer/<a class="el" href="CD__RtSolver_8cpp.html">CD_RtSolver.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
