<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: AmrMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classAmrMesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AmrMesh Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for handling spatial operations.  
 <a href="classAmrMesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__AmrMesh_8H_source.html">CD_AmrMesh.H</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaf2154348b6e3f8c7691e4aed716961b" id="r_aaf2154348b6e3f8c7691e4aed716961b"><td class="memItemLeft" align="right" valign="top"><a id="aaf2154348b6e3f8c7691e4aed716961b" name="aaf2154348b6e3f8c7691e4aed716961b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AmrMesh</b> ()</td></tr>
<tr class="memdesc:aaf2154348b6e3f8c7691e4aed716961b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aaf2154348b6e3f8c7691e4aed716961b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dbdbd76308b0f823ac99ba8c96b030" id="r_ad3dbdbd76308b0f823ac99ba8c96b030"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad3dbdbd76308b0f823ac99ba8c96b030">AmrMesh</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_other</a>)=<a class="el" href="classTracerParticleSolver.html">delete</a></td></tr>
<tr class="memdesc:ad3dbdbd76308b0f823ac99ba8c96b030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed copy constructor.  <br /></td></tr>
<tr class="separator:ad3dbdbd76308b0f823ac99ba8c96b030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169cb0dcdb19e5bf08061ac7fd6b5780" id="r_a169cb0dcdb19e5bf08061ac7fd6b5780"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a169cb0dcdb19e5bf08061ac7fd6b5780">AmrMesh</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&amp;<a class="el" href="classTracerParticleSolver.html">a_other</a>)=<a class="el" href="classTracerParticleSolver.html">delete</a></td></tr>
<tr class="memdesc:a169cb0dcdb19e5bf08061ac7fd6b5780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed move constructor.  <br /></td></tr>
<tr class="separator:a169cb0dcdb19e5bf08061ac7fd6b5780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcc6b58e9fc585510258ae7c3c9332a" id="r_a3fcc6b58e9fc585510258ae7c3c9332a"><td class="memItemLeft" align="right" valign="top"><a id="a3fcc6b58e9fc585510258ae7c3c9332a" name="a3fcc6b58e9fc585510258ae7c3c9332a"></a>
<a class="el" href="classTracerParticleSolver.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>~AmrMesh</b> ()</td></tr>
<tr class="memdesc:a3fcc6b58e9fc585510258ae7c3c9332a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a3fcc6b58e9fc585510258ae7c3c9332a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a1f146cdda3a4b47a0a3b78d583f64" id="r_a00a1f146cdda3a4b47a0a3b78d583f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a00a1f146cdda3a4b47a0a3b78d583f64">operator=</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_other</a>)=<a class="el" href="classTracerParticleSolver.html">delete</a></td></tr>
<tr class="memdesc:a00a1f146cdda3a4b47a0a3b78d583f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed copy assignment.  <br /></td></tr>
<tr class="separator:a00a1f146cdda3a4b47a0a3b78d583f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aab4befd4adb40e39afa6713db794ab" id="r_a9aab4befd4adb40e39afa6713db794ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9aab4befd4adb40e39afa6713db794ab">operator=</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&amp;<a class="el" href="classTracerParticleSolver.html">a_other</a>)=<a class="el" href="classTracerParticleSolver.html">delete</a></td></tr>
<tr class="memdesc:a9aab4befd4adb40e39afa6713db794ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed move assignment.  <br /></td></tr>
<tr class="separator:a9aab4befd4adb40e39afa6713db794ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2354431a853db080b55495a7b20f4512" id="r_a2354431a853db080b55495a7b20f4512"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a2354431a853db080b55495a7b20f4512"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2354431a853db080b55495a7b20f4512">copyData</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_dst</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_src</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_toRegion</a>=CopyStrategy::Valid, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_fromRegion</a>=CopyStrategy::Valid) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a2354431a853db080b55495a7b20f4512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for copying from a source container to a destination container. User supplies information about from/to regions.  <br /></td></tr>
<tr class="separator:a2354431a853db080b55495a7b20f4512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c261aa8445bbe634131faf865dee15" id="r_a66c261aa8445bbe634131faf865dee15"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a66c261aa8445bbe634131faf865dee15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a66c261aa8445bbe634131faf865dee15">copyData</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_dst</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_src</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_dstComps</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_srcComps</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_toRegion</a>=CopyStrategy::Valid, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_fromRegion</a>=CopyStrategy::Valid) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a66c261aa8445bbe634131faf865dee15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for copying from a source container to a destination container. User supplies information.  <br /></td></tr>
<tr class="separator:a66c261aa8445bbe634131faf865dee15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2fbca514264f27a0106a49df839ae5" id="r_a6e2fbca514264f27a0106a49df839ae5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6e2fbca514264f27a0106a49df839ae5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6e2fbca514264f27a0106a49df839ae5">copyData</a> (<a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_dst</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_src</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_level</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_toRealm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_fromRealm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_toRegion</a>=CopyStrategy::Valid, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_fromRegion</a>=CopyStrategy::Valid) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a6e2fbca514264f27a0106a49df839ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for copying from a source container to a destination container. User supplies information about from/to regions.  <br /></td></tr>
<tr class="separator:a6e2fbca514264f27a0106a49df839ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0ceb890b1dde44995215e93f514180" id="r_a7f0ceb890b1dde44995215e93f514180"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7f0ceb890b1dde44995215e93f514180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a7f0ceb890b1dde44995215e93f514180">copyData</a> (<a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_dst</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_src</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_level</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_toRealm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_fromRealm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_dstComps</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_srcComps</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_toRegion</a>=CopyStrategy::Valid, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_fromRegion</a>=CopyStrategy::Valid) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a7f0ceb890b1dde44995215e93f514180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for copying from a source container to a destination container. User supplies information about from/to regions.  <br /></td></tr>
<tr class="separator:a7f0ceb890b1dde44995215e93f514180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ab65c2e423aaa581d3adb4fd883b92" id="r_ae5ab65c2e423aaa581d3adb4fd883b92"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae5ab65c2e423aaa581d3adb4fd883b92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae5ab65c2e423aaa581d3adb4fd883b92">deallocate</a> (<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; T * &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ae5ab65c2e423aaa581d3adb4fd883b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate data.  <br /></td></tr>
<tr class="separator:ae5ab65c2e423aaa581d3adb4fd883b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865d6b29a7193591db2372b920cbf053" id="r_a865d6b29a7193591db2372b920cbf053"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a865d6b29a7193591db2372b920cbf053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a865d6b29a7193591db2372b920cbf053">deallocate</a> (<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; T &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a865d6b29a7193591db2372b920cbf053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate smart pointer data.  <br /></td></tr>
<tr class="separator:a865d6b29a7193591db2372b920cbf053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe76068a86db2799fc9e6e96d6a2ccf" id="r_aebe76068a86db2799fc9e6e96d6a2ccf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aebe76068a86db2799fc9e6e96d6a2ccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aebe76068a86db2799fc9e6e96d6a2ccf">deallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aebe76068a86db2799fc9e6e96d6a2ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate data.  <br /></td></tr>
<tr class="separator:aebe76068a86db2799fc9e6e96d6a2ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ddc1a34de9ef274d73256add61232" id="r_adf3ddc1a34de9ef274d73256add61232"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adf3ddc1a34de9ef274d73256add61232"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#adf3ddc1a34de9ef274d73256add61232">alias</a> (<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; T * &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_alias</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; T &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:adf3ddc1a34de9ef274d73256add61232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn smart-pointer data structure into regular-pointer data structure.  <br /></td></tr>
<tr class="separator:adf3ddc1a34de9ef274d73256add61232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7129b60d83999a8e9ebb473987a8f4" id="r_add7129b60d83999a8e9ebb473987a8f4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T , <a class="el" href="classTracerParticleSolver.html">typename</a> <a class="el" href="classTracerParticleSolver.html">S</a> &gt; </td></tr>
<tr class="memitem:add7129b60d83999a8e9ebb473987a8f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#add7129b60d83999a8e9ebb473987a8f4">alias</a> (<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; T * &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_alias</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; <a class="el" href="classTracerParticleSolver.html">S</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:add7129b60d83999a8e9ebb473987a8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn smart-pointer data structure into regular-pointer data structure.  <br /></td></tr>
<tr class="separator:add7129b60d83999a8e9ebb473987a8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efee08ad6a36b934fbd15283be5f48e" id="r_a9efee08ad6a36b934fbd15283be5f48e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9efee08ad6a36b934fbd15283be5f48e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9efee08ad6a36b934fbd15283be5f48e">allocate</a> (<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">ParticleData</a>&lt; T &gt; &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a9efee08ad6a36b934fbd15283be5f48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for generic allocation of particle data.  <br /></td></tr>
<tr class="separator:a9efee08ad6a36b934fbd15283be5f48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f77ca80a54f034ec88ad6451677757" id="r_a14f77ca80a54f034ec88ad6451677757"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a14f77ca80a54f034ec88ad6451677757"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a14f77ca80a54f034ec88ad6451677757">allocate</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_container</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a14f77ca80a54f034ec88ad6451677757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for generic allocation of particle containers.  <br /></td></tr>
<tr class="separator:a14f77ca80a54f034ec88ad6451677757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb01d4e408f7f60da0197fec9941edc" id="r_a0eb01d4e408f7f60da0197fec9941edc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0eb01d4e408f7f60da0197fec9941edc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0eb01d4e408f7f60da0197fec9941edc">allocatePointer</a> (<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; T &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a0eb01d4e408f7f60da0197fec9941edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate pointer but not any memory blocks.  <br /></td></tr>
<tr class="separator:a0eb01d4e408f7f60da0197fec9941edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41a86c671f5b090c19b4a604443c28f" id="r_ab41a86c671f5b090c19b4a604443c28f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab41a86c671f5b090c19b4a604443c28f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab41a86c671f5b090c19b4a604443c28f">allocatePointer</a> (<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; T &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_finestLevel</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ab41a86c671f5b090c19b4a604443c28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate pointer but not any memory blocks.  <br /></td></tr>
<tr class="separator:ab41a86c671f5b090c19b4a604443c28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141a99f99626423405e502361000a9c0" id="r_a141a99f99626423405e502361000a9c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a141a99f99626423405e502361000a9c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a141a99f99626423405e502361000a9c0">allocatePointer</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a141a99f99626423405e502361000a9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate pointer but not any memory blocks.  <br /></td></tr>
<tr class="separator:a141a99f99626423405e502361000a9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fc14c3621ffc8935c074024b067452" id="r_a25fc14c3621ffc8935c074024b067452"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a25fc14c3621ffc8935c074024b067452"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a25fc14c3621ffc8935c074024b067452">allocatePointer</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_finestLevel</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a25fc14c3621ffc8935c074024b067452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate pointer but not any memory.  <br /></td></tr>
<tr class="separator:a25fc14c3621ffc8935c074024b067452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab607b773c624e394f178e7f09446a656" id="r_ab607b773c624e394f178e7f09446a656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab607b773c624e394f178e7f09446a656">slice</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_original</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> <a class="el" href="classTracerParticleSolver.html">a_variables</a>) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:ab607b773c624e394f178e7f09446a656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice cell-centered data in order to fetch a subset of components.  <br /></td></tr>
<tr class="separator:ab607b773c624e394f178e7f09446a656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdab30ee7155984c3e75bcf25e50dc3" id="r_a8bdab30ee7155984c3e75bcf25e50dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8bdab30ee7155984c3e75bcf25e50dc3">slice</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_original</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> <a class="el" href="classTracerParticleSolver.html">a_variables</a>) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a8bdab30ee7155984c3e75bcf25e50dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice cell-centered data in order to fetch a subset of components.  <br /></td></tr>
<tr class="separator:a8bdab30ee7155984c3e75bcf25e50dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63a0de47e3bbe424ae5231cab2a963" id="r_a7c63a0de47e3bbe424ae5231cab2a963"><td class="memItemLeft" align="right" valign="top"><a id="a7c63a0de47e3bbe424ae5231cab2a963" name="a7c63a0de47e3bbe424ae5231cab2a963"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseOptions</b> ()</td></tr>
<tr class="memdesc:a7c63a0de47e3bbe424ae5231cab2a963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse options. Called during the constructor. <br /></td></tr>
<tr class="separator:a7c63a0de47e3bbe424ae5231cab2a963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6d9f11ede790783a919c1cd20870ba" id="r_a0d6d9f11ede790783a919c1cd20870ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0d6d9f11ede790783a919c1cd20870ba">parseRuntimeOptions</a> ()</td></tr>
<tr class="memdesc:a0d6d9f11ede790783a919c1cd20870ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse runtime options.  <br /></td></tr>
<tr class="separator:a0d6d9f11ede790783a919c1cd20870ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb365cb3691098693eb0bba6b552fe6" id="r_a2bb365cb3691098693eb0bba6b552fe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2bb365cb3691098693eb0bba6b552fe6">registerOperator</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_operator</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>)</td></tr>
<tr class="memdesc:a2bb365cb3691098693eb0bba6b552fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an operator over a realm and a phase.  <br /></td></tr>
<tr class="separator:a2bb365cb3691098693eb0bba6b552fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9b6818c634e2585a628f30362af1b0" id="r_acf9b6818c634e2585a628f30362af1b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#acf9b6818c634e2585a628f30362af1b0">registerMask</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_mask</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_buffer</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>)</td></tr>
<tr class="memdesc:acf9b6818c634e2585a628f30362af1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a boolean mask over a realm.  <br /></td></tr>
<tr class="separator:acf9b6818c634e2585a628f30362af1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429a94d3c17f51f138121c95b8bfe2bf" id="r_a429a94d3c17f51f138121c95b8bfe2bf"><td class="memItemLeft" align="right" valign="top"><a id="a429a94d3c17f51f138121c95b8bfe2bf" name="a429a94d3c17f51f138121c95b8bfe2bf"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buildDomains</b> ()</td></tr>
<tr class="memdesc:a429a94d3c17f51f138121c95b8bfe2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build domains. <br /></td></tr>
<tr class="separator:a429a94d3c17f51f138121c95b8bfe2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcbb2334af9b06815262abc2ceda9e2" id="r_a3dcbb2334af9b06815262abc2ceda9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3dcbb2334af9b06815262abc2ceda9e2">setFinestLevel</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_finestLevel</a>)</td></tr>
<tr class="memdesc:a3dcbb2334af9b06815262abc2ceda9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the finest level.  <br /></td></tr>
<tr class="separator:a3dcbb2334af9b06815262abc2ceda9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e8f0c7d2300cba44150fff100efb4" id="r_a362e8f0c7d2300cba44150fff100efb4"><td class="memItemLeft" align="right" valign="top"><a id="a362e8f0c7d2300cba44150fff100efb4" name="a362e8f0c7d2300cba44150fff100efb4"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setCoarsestGrid</b> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">IntVect</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_nCells</a>)</td></tr>
<tr class="memdesc:a362e8f0c7d2300cba44150fff100efb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coarsest grid cells. <br /></td></tr>
<tr class="separator:a362e8f0c7d2300cba44150fff100efb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7105b45dc3d5db23e1029f9fa95ef2" id="r_a3f7105b45dc3d5db23e1029f9fa95ef2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3f7105b45dc3d5db23e1029f9fa95ef2">queryRealm</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a3f7105b45dc3d5db23e1029f9fa95ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a realm exists.  <br /></td></tr>
<tr class="separator:a3f7105b45dc3d5db23e1029f9fa95ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f0c7045c11ff7348a421675cf5ff6b" id="r_a70f0c7045c11ff7348a421675cf5ff6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a70f0c7045c11ff7348a421675cf5ff6b">getEbCf</a> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a70f0c7045c11ff7348a421675cf5ff6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if mesh has an EBCF.  <br /></td></tr>
<tr class="separator:a70f0c7045c11ff7348a421675cf5ff6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd2b0e8c918e6057647103c8193fa17" id="r_a6dd2b0e8c918e6057647103c8193fa17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6dd2b0e8c918e6057647103c8193fa17">registerRealm</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>)</td></tr>
<tr class="memdesc:a6dd2b0e8c918e6057647103c8193fa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new realm.  <br /></td></tr>
<tr class="separator:a6dd2b0e8c918e6057647103c8193fa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0c09b67c82352fe4ebd4f9f6ae5fbc" id="r_a5e0c09b67c82352fe4ebd4f9f6ae5fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5e0c09b67c82352fe4ebd4f9f6ae5fbc">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_mfdata</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_finestLevel</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a5e0c09b67c82352fe4ebd4f9f6ae5fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias multifluid data up to a specified level.  <br /></td></tr>
<tr class="separator:a5e0c09b67c82352fe4ebd4f9f6ae5fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e201260012be3d1709f86689af5abf0" id="r_a3e201260012be3d1709f86689af5abf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3e201260012be3d1709f86689af5abf0">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_mfdata</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_finestLevel</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a3e201260012be3d1709f86689af5abf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias multifluid data up to a specified level.  <br /></td></tr>
<tr class="separator:a3e201260012be3d1709f86689af5abf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd8f12c2f367eaed5f168dfc54bd275" id="r_a9bd8f12c2f367eaed5f168dfc54bd275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9bd8f12c2f367eaed5f168dfc54bd275">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_mfdata</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a9bd8f12c2f367eaed5f168dfc54bd275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <br /></td></tr>
<tr class="separator:a9bd8f12c2f367eaed5f168dfc54bd275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c7a7cb2e3783a26312d3533f4cb0f" id="r_a648c7a7cb2e3783a26312d3533f4cb0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a648c7a7cb2e3783a26312d3533f4cb0f">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_mfdata</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a648c7a7cb2e3783a26312d3533f4cb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <br /></td></tr>
<tr class="separator:a648c7a7cb2e3783a26312d3533f4cb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567e5bc873abc63dc52aee60efa1ba44" id="r_a567e5bc873abc63dc52aee60efa1ba44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a567e5bc873abc63dc52aee60efa1ba44">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_mfdata</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a567e5bc873abc63dc52aee60efa1ba44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <br /></td></tr>
<tr class="separator:a567e5bc873abc63dc52aee60efa1ba44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fe5b8146a945e4fe8911fbb57494e7" id="r_a82fe5b8146a945e4fe8911fbb57494e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a82fe5b8146a945e4fe8911fbb57494e7">alias</a> (<a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_mfdata</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a82fe5b8146a945e4fe8911fbb57494e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <br /></td></tr>
<tr class="separator:a82fe5b8146a945e4fe8911fbb57494e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0d11dbe8ad04d37008c260df025374" id="r_a5f0d11dbe8ad04d37008c260df025374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5f0d11dbe8ad04d37008c260df025374">alias</a> (<a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_mfdata</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a5f0d11dbe8ad04d37008c260df025374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <br /></td></tr>
<tr class="separator:a5f0d11dbe8ad04d37008c260df025374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8da582e3c2910ba6c168e6a24d5679" id="r_abd8da582e3c2910ba6c168e6a24d5679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#abd8da582e3c2910ba6c168e6a24d5679">alias</a> (<a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_mfdata</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:abd8da582e3c2910ba6c168e6a24d5679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <br /></td></tr>
<tr class="separator:abd8da582e3c2910ba6c168e6a24d5679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03736c8164011068783b32d6c0342caf" id="r_a03736c8164011068783b32d6c0342caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a03736c8164011068783b32d6c0342caf">computeGradient</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_gradient</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_phi</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a03736c8164011068783b32d6c0342caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell-centered gradient over an AMR hierarchy.  <br /></td></tr>
<tr class="separator:a03736c8164011068783b32d6c0342caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5468ec45f9d206c1d2d99fd74cf42521" id="r_a5468ec45f9d206c1d2d99fd74cf42521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5468ec45f9d206c1d2d99fd74cf42521">computeGradient</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_gradient</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_phi</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a5468ec45f9d206c1d2d99fd74cf42521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face-centered gradient over an AMR hierarchy.  <br /></td></tr>
<tr class="separator:a5468ec45f9d206c1d2d99fd74cf42521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc77b754e28f3212863848aaba964db5" id="r_adc77b754e28f3212863848aaba964db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#adc77b754e28f3212863848aaba964db5">computeGradient</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_gradient</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_phi</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:adc77b754e28f3212863848aaba964db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell-centered gradient over an AMR hierarchy.  <br /></td></tr>
<tr class="separator:adc77b754e28f3212863848aaba964db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4b4cd76b62eaaca138fbdcd5ec3090" id="r_a9e4b4cd76b62eaaca138fbdcd5ec3090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9e4b4cd76b62eaaca138fbdcd5ec3090">computeGradient</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_gradient</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_phi</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a9e4b4cd76b62eaaca138fbdcd5ec3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face-centered gradient over an AMR hierarchy.  <br /></td></tr>
<tr class="separator:a9e4b4cd76b62eaaca138fbdcd5ec3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a408d2381f605f562b01a7de04ef2c" id="r_a97a408d2381f605f562b01a7de04ef2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a97a408d2381f605f562b01a7de04ef2c">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nGhost</a>=-1) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a97a408d2381f605f562b01a7de04ef2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <br /></td></tr>
<tr class="separator:a97a408d2381f605f562b01a7de04ef2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eda2721c69cdd09b48dd604ede5a769" id="r_a6eda2721c69cdd09b48dd604ede5a769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6eda2721c69cdd09b48dd604ede5a769">allocate</a> (<a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_level</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nGhost</a>=-1) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a6eda2721c69cdd09b48dd604ede5a769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate data on specific level.  <br /></td></tr>
<tr class="separator:a6eda2721c69cdd09b48dd604ede5a769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8000cf94e2d87a651cf49c7e853ce6f4" id="r_a8000cf94e2d87a651cf49c7e853ce6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8000cf94e2d87a651cf49c7e853ce6f4">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nGhost</a>=-1) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a8000cf94e2d87a651cf49c7e853ce6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <br /></td></tr>
<tr class="separator:a8000cf94e2d87a651cf49c7e853ce6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e05b28f775f47845a231661f708c963" id="r_a4e05b28f775f47845a231661f708c963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4e05b28f775f47845a231661f708c963">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nGhost</a>=-1) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a4e05b28f775f47845a231661f708c963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <br /></td></tr>
<tr class="separator:a4e05b28f775f47845a231661f708c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ebef713ce593b19fe2ffbbba9ce2ea" id="r_a74ebef713ce593b19fe2ffbbba9ce2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a74ebef713ce593b19fe2ffbbba9ce2ea">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nGhost</a>=-1) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a74ebef713ce593b19fe2ffbbba9ce2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <br /></td></tr>
<tr class="separator:a74ebef713ce593b19fe2ffbbba9ce2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c89795f369b846f251f1fec56c48a5" id="r_af5c89795f369b846f251f1fec56c48a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af5c89795f369b846f251f1fec56c48a5">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRBool</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nGhost</a>=-1) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af5c89795f369b846f251f1fec56c48a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate Boolean data over a specific realm.  <br /></td></tr>
<tr class="separator:af5c89795f369b846f251f1fec56c48a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02342a1d423fc64ed7bd1d3f08fafae6" id="r_a02342a1d423fc64ed7bd1d3f08fafae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a02342a1d423fc64ed7bd1d3f08fafae6">allocate</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nGhost</a>=-1) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a02342a1d423fc64ed7bd1d3f08fafae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <br /></td></tr>
<tr class="separator:a02342a1d423fc64ed7bd1d3f08fafae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a666605ffc876316d34fe42318a13bb" id="r_a6a666605ffc876316d34fe42318a13bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6a666605ffc876316d34fe42318a13bb">allocate</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_ghost</a>=-1) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a6a666605ffc876316d34fe42318a13bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <br /></td></tr>
<tr class="separator:a6a666605ffc876316d34fe42318a13bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5010f466f55bebc90afc212bd78e494c" id="r_a5010f466f55bebc90afc212bd78e494c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5010f466f55bebc90afc212bd78e494c">allocate</a> (<a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_nComp</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_ghost</a>=0) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a5010f466f55bebc90afc212bd78e494c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <br /></td></tr>
<tr class="separator:a5010f466f55bebc90afc212bd78e494c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a0c3e11d835a5bd9e3ab8c5950e2ca" id="r_a87a0c3e11d835a5bd9e3ab8c5950e2ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a87a0c3e11d835a5bd9e3ab8c5950e2ca">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a87a0c3e11d835a5bd9e3ab8c5950e2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <br /></td></tr>
<tr class="separator:a87a0c3e11d835a5bd9e3ab8c5950e2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612f5b753bfe06523d77d8ffe49d9459" id="r_a612f5b753bfe06523d77d8ffe49d9459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a612f5b753bfe06523d77d8ffe49d9459">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a612f5b753bfe06523d77d8ffe49d9459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <br /></td></tr>
<tr class="separator:a612f5b753bfe06523d77d8ffe49d9459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad120065536a58ff9f0c4662c03a8449" id="r_aad120065536a58ff9f0c4662c03a8449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aad120065536a58ff9f0c4662c03a8449">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aad120065536a58ff9f0c4662c03a8449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <br /></td></tr>
<tr class="separator:aad120065536a58ff9f0c4662c03a8449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ec9fb80cd2579acf88acb51738403" id="r_a991ec9fb80cd2579acf88acb51738403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a991ec9fb80cd2579acf88acb51738403">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a991ec9fb80cd2579acf88acb51738403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <br /></td></tr>
<tr class="separator:a991ec9fb80cd2579acf88acb51738403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074cd4a99c5c29bf499cd20688d5ca2" id="r_a5074cd4a99c5c29bf499cd20688d5ca2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5074cd4a99c5c29bf499cd20688d5ca2">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRBool</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a5074cd4a99c5c29bf499cd20688d5ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <br /></td></tr>
<tr class="separator:a5074cd4a99c5c29bf499cd20688d5ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9a31a2a37e7d804a6aa80ca3e7fc7d" id="r_acc9a31a2a37e7d804a6aa80ca3e7fc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#acc9a31a2a37e7d804a6aa80ca3e7fc7d">reallocate</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:acc9a31a2a37e7d804a6aa80ca3e7fc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <br /></td></tr>
<tr class="separator:acc9a31a2a37e7d804a6aa80ca3e7fc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac523d5d24140c8f8e84e118ff8c4123e" id="r_ac523d5d24140c8f8e84e118ff8c4123e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac523d5d24140c8f8e84e118ff8c4123e">reallocate</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ac523d5d24140c8f8e84e118ff8c4123e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <br /></td></tr>
<tr class="separator:ac523d5d24140c8f8e84e118ff8c4123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e98284a18faae8ac933f5cbe469f74" id="r_a14e98284a18faae8ac933f5cbe469f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a14e98284a18faae8ac933f5cbe469f74">reallocate</a> (<a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a14e98284a18faae8ac933f5cbe469f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <br /></td></tr>
<tr class="separator:a14e98284a18faae8ac933f5cbe469f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9db6f208842207e02524d7cc61d0961" id="r_ac9db6f208842207e02524d7cc61d0961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac9db6f208842207e02524d7cc61d0961">average</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_average</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ac9db6f208842207e02524d7cc61d0961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average multifluid data over a specified realm.  <br /></td></tr>
<tr class="separator:ac9db6f208842207e02524d7cc61d0961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c3e36e18a1b3feefe1bc12e0b59a8d" id="r_a41c3e36e18a1b3feefe1bc12e0b59a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a41c3e36e18a1b3feefe1bc12e0b59a8d">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a41c3e36e18a1b3feefe1bc12e0b59a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic coarsening of multifluid data.  <br /></td></tr>
<tr class="separator:a41c3e36e18a1b3feefe1bc12e0b59a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186c852306b0260ad0637599217ea035" id="r_a186c852306b0260ad0637599217ea035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a186c852306b0260ad0637599217ea035">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a186c852306b0260ad0637599217ea035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonic coarsening of multifluid data.  <br /></td></tr>
<tr class="separator:a186c852306b0260ad0637599217ea035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b3f8d395e81592ba629ebc11b9141e" id="r_a53b3f8d395e81592ba629ebc11b9141e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a53b3f8d395e81592ba629ebc11b9141e">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a53b3f8d395e81592ba629ebc11b9141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conservative coarsening of multifluid data.  <br /></td></tr>
<tr class="separator:a53b3f8d395e81592ba629ebc11b9141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35796165052eb306d772d0471eca391b" id="r_a35796165052eb306d772d0471eca391b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a35796165052eb306d772d0471eca391b">average</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_average</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a35796165052eb306d772d0471eca391b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average multifluid data over a specified realm.  <br /></td></tr>
<tr class="separator:a35796165052eb306d772d0471eca391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64caac626d5f6846785a8ad7a855303" id="r_ad64caac626d5f6846785a8ad7a855303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad64caac626d5f6846785a8ad7a855303">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ad64caac626d5f6846785a8ad7a855303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average multifluid data over a realm.  <br /></td></tr>
<tr class="separator:ad64caac626d5f6846785a8ad7a855303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e9d87d1e36b48c25847153b44b2db2" id="r_ae4e9d87d1e36b48c25847153b44b2db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae4e9d87d1e36b48c25847153b44b2db2">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ae4e9d87d1e36b48c25847153b44b2db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average multifluid data over a realm.  <br /></td></tr>
<tr class="separator:ae4e9d87d1e36b48c25847153b44b2db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe7ab07b30103513af9784864aba639" id="r_aabe7ab07b30103513af9784864aba639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aabe7ab07b30103513af9784864aba639">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aabe7ab07b30103513af9784864aba639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down multifluid data over a realm.  <br /></td></tr>
<tr class="separator:aabe7ab07b30103513af9784864aba639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6540dc8db6193a32c989936f8b47da1" id="r_af6540dc8db6193a32c989936f8b47da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af6540dc8db6193a32c989936f8b47da1">average</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_average</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af6540dc8db6193a32c989936f8b47da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <br /></td></tr>
<tr class="separator:af6540dc8db6193a32c989936f8b47da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07eed6758ee76431667b3832f36b966" id="r_aa07eed6758ee76431667b3832f36b966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa07eed6758ee76431667b3832f36b966">average</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_average</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_variables</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aa07eed6758ee76431667b3832f36b966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <br /></td></tr>
<tr class="separator:aa07eed6758ee76431667b3832f36b966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eb5733b4a2fce7c522c37d3c1347ff" id="r_af6eb5733b4a2fce7c522c37d3c1347ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af6eb5733b4a2fce7c522c37d3c1347ff">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af6eb5733b4a2fce7c522c37d3c1347ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic average of data. Does all components.  <br /></td></tr>
<tr class="separator:af6eb5733b4a2fce7c522c37d3c1347ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c8382e0e99edfdbf353d60b46d41ba" id="r_a57c8382e0e99edfdbf353d60b46d41ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a57c8382e0e99edfdbf353d60b46d41ba">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_variables</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a57c8382e0e99edfdbf353d60b46d41ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic average of data.  <br /></td></tr>
<tr class="separator:a57c8382e0e99edfdbf353d60b46d41ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b49e5fa25c6a4bb059a6c3e25b1c078" id="r_a4b49e5fa25c6a4bb059a6c3e25b1c078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4b49e5fa25c6a4bb059a6c3e25b1c078">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a4b49e5fa25c6a4bb059a6c3e25b1c078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonic average of data. Does all components.  <br /></td></tr>
<tr class="separator:a4b49e5fa25c6a4bb059a6c3e25b1c078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3e29a7ec2d7e88c8ba7410e1fda2ea" id="r_adb3e29a7ec2d7e88c8ba7410e1fda2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#adb3e29a7ec2d7e88c8ba7410e1fda2ea">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_variables</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:adb3e29a7ec2d7e88c8ba7410e1fda2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonic average of data. Does all components.  <br /></td></tr>
<tr class="separator:adb3e29a7ec2d7e88c8ba7410e1fda2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae69d99efb79d91bbf8ddfa33b61ab0f" id="r_aae69d99efb79d91bbf8ddfa33b61ab0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aae69d99efb79d91bbf8ddfa33b61ab0f">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aae69d99efb79d91bbf8ddfa33b61ab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conseratively average data. Does all components.  <br /></td></tr>
<tr class="separator:aae69d99efb79d91bbf8ddfa33b61ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd84b6a06ba937f38448a89a3f6882b" id="r_a0bd84b6a06ba937f38448a89a3f6882b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0bd84b6a06ba937f38448a89a3f6882b">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_variables</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a0bd84b6a06ba937f38448a89a3f6882b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conseratively average data. Does all components.  <br /></td></tr>
<tr class="separator:a0bd84b6a06ba937f38448a89a3f6882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1459b80feff30769ea928f10907fcc89" id="r_a1459b80feff30769ea928f10907fcc89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1459b80feff30769ea928f10907fcc89">average</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_average</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a1459b80feff30769ea928f10907fcc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <br /></td></tr>
<tr class="separator:a1459b80feff30769ea928f10907fcc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb661908599529bdc686d2de016a16f" id="r_abdb661908599529bdc686d2de016a16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#abdb661908599529bdc686d2de016a16f">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:abdb661908599529bdc686d2de016a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <br /></td></tr>
<tr class="separator:abdb661908599529bdc686d2de016a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b2fdcbb8c36d6ccd8e6b836980ab3c" id="r_a00b2fdcbb8c36d6ccd8e6b836980ab3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a00b2fdcbb8c36d6ccd8e6b836980ab3c">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a00b2fdcbb8c36d6ccd8e6b836980ab3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <br /></td></tr>
<tr class="separator:a00b2fdcbb8c36d6ccd8e6b836980ab3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32fe0c1d230d0a0dadee647d7d2730b" id="r_af32fe0c1d230d0a0dadee647d7d2730b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af32fe0c1d230d0a0dadee647d7d2730b">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af32fe0c1d230d0a0dadee647d7d2730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <br /></td></tr>
<tr class="separator:af32fe0c1d230d0a0dadee647d7d2730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3a4063ef5b08f363743daa70496b45" id="r_acc3a4063ef5b08f363743daa70496b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#acc3a4063ef5b08f363743daa70496b45">average</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_average</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:acc3a4063ef5b08f363743daa70496b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <br /></td></tr>
<tr class="separator:acc3a4063ef5b08f363743daa70496b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbddcd21848988ec71d1525f80076bc" id="r_a2bbddcd21848988ec71d1525f80076bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2bbddcd21848988ec71d1525f80076bc">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a2bbddcd21848988ec71d1525f80076bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic average on specific realm and phase.  <br /></td></tr>
<tr class="separator:a2bbddcd21848988ec71d1525f80076bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259cb2f2336f091eeb1955b7c525a040" id="r_a259cb2f2336f091eeb1955b7c525a040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a259cb2f2336f091eeb1955b7c525a040">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a259cb2f2336f091eeb1955b7c525a040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonic average on specific realm and phase.  <br /></td></tr>
<tr class="separator:a259cb2f2336f091eeb1955b7c525a040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ebca4c73310fecee761a9f74b8fe01" id="r_ae9ebca4c73310fecee761a9f74b8fe01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae9ebca4c73310fecee761a9f74b8fe01">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ae9ebca4c73310fecee761a9f74b8fe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conservative averaging on specific realm and phase.  <br /></td></tr>
<tr class="separator:ae9ebca4c73310fecee761a9f74b8fe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578" id="r_a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a> &amp;(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleScalarField&gt; </td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_meshData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> <a class="el" href="classTracerParticleSolver.html">a_depositionType</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> <a class="el" href="classTracerParticleSolver.html">a_coarseFineDeposition</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a> <a class="el" href="classTracerParticleSolver.html">a_forceIrregNGP</a>=<a class="el" href="classTracerParticleSolver.html">false</a>)</td></tr>
<tr class="memdesc:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit scalar particle quantities on the mesh.  <br /></td></tr>
<tr class="separator:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578" id="r_a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">Real</a>(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleScalarField&gt; </td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_meshData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> <a class="el" href="classTracerParticleSolver.html">a_depositionType</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> <a class="el" href="classTracerParticleSolver.html">a_coarseFineDeposition</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a> <a class="el" href="classTracerParticleSolver.html">a_forceIrregNGP</a>=<a class="el" href="classTracerParticleSolver.html">false</a>)</td></tr>
<tr class="memdesc:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit scalar particle quantities on the mesh.  <br /></td></tr>
<tr class="separator:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578" id="r_a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RealVect</a> &amp;(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleVectorField&gt; </td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_meshData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> <a class="el" href="classTracerParticleSolver.html">a_depositionType</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> <a class="el" href="classTracerParticleSolver.html">a_coarseFineDeposition</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a> <a class="el" href="classTracerParticleSolver.html">a_forceIrregNGP</a>=<a class="el" href="classTracerParticleSolver.html">false</a>)</td></tr>
<tr class="memdesc:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit vector particle quantities on the mesh.  <br /></td></tr>
<tr class="separator:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578" id="r_a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">RealVect</a>(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleVectorField&gt; </td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_meshData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> <a class="el" href="classTracerParticleSolver.html">a_depositionType</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> <a class="el" href="classTracerParticleSolver.html">a_coarseFineDeposition</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a> <a class="el" href="classTracerParticleSolver.html">a_forceIrregNGP</a>=<a class="el" href="classTracerParticleSolver.html">false</a>)</td></tr>
<tr class="memdesc:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit vector particle quantities on the mesh.  <br /></td></tr>
<tr class="separator:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d10979cb476e42f07f59f8473110d7" id="r_ac9d10979cb476e42f07f59f8473110d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a> &amp;(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleScalarField&gt; </td></tr>
<tr class="memitem:ac9d10979cb476e42f07f59f8473110d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac9d10979cb476e42f07f59f8473110d7">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_meshData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:ac9d10979cb476e42f07f59f8473110d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit scalar particle quantities on the mesh.  <br /></td></tr>
<tr class="separator:ac9d10979cb476e42f07f59f8473110d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d10979cb476e42f07f59f8473110d7" id="r_ac9d10979cb476e42f07f59f8473110d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">Real</a>(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleScalarField&gt; </td></tr>
<tr class="memitem:ac9d10979cb476e42f07f59f8473110d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac9d10979cb476e42f07f59f8473110d7">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_meshData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:ac9d10979cb476e42f07f59f8473110d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit scalar particle quantities on the mesh.  <br /></td></tr>
<tr class="separator:ac9d10979cb476e42f07f59f8473110d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07d5998e160d5430c49bc238e819e77" id="r_aa07d5998e160d5430c49bc238e819e77"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">Real</a> &amp;(P::*)() particleScalarField&gt; </td></tr>
<tr class="memitem:aa07d5998e160d5430c49bc238e819e77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa07d5998e160d5430c49bc238e819e77">interpolateParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_meshScalarField</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> <a class="el" href="classTracerParticleSolver.html">a_interpType</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a> <a class="el" href="classTracerParticleSolver.html">a_forceIrregNGP</a>=<a class="el" href="classTracerParticleSolver.html">false</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aa07d5998e160d5430c49bc238e819e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a scalar field onto the particle position.  <br /></td></tr>
<tr class="separator:aa07d5998e160d5430c49bc238e819e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac073bb1b20ac52395c1a2403af462996" id="r_ac073bb1b20ac52395c1a2403af462996"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">RealVect</a> &amp;(P::*)() particleVectorField&gt; </td></tr>
<tr class="memitem:ac073bb1b20ac52395c1a2403af462996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac073bb1b20ac52395c1a2403af462996">interpolateParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_meshVectorField</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> <a class="el" href="classTracerParticleSolver.html">a_interpType</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a> <a class="el" href="classTracerParticleSolver.html">a_forceIrregNGP</a>=<a class="el" href="classTracerParticleSolver.html">false</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ac073bb1b20ac52395c1a2403af462996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector field onto the particle position.  <br /></td></tr>
<tr class="separator:ac073bb1b20ac52395c1a2403af462996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412d58b270f56e04aa17127c0fcf5f46" id="r_a412d58b270f56e04aa17127c0fcf5f46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a412d58b270f56e04aa17127c0fcf5f46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a412d58b270f56e04aa17127c0fcf5f46">removeCoveredParticlesIF</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a> <a class="el" href="classTracerParticleSolver.html">a_tolerance</a>=0.0) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a412d58b270f56e04aa17127c0fcf5f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which removes particles from the domain if they fall inside the EB.  <br /></td></tr>
<tr class="separator:a412d58b270f56e04aa17127c0fcf5f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb1b3008526e53b38e09e96e0e88487" id="r_a6fb1b3008526e53b38e09e96e0e88487"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a6fb1b3008526e53b38e09e96e0e88487"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6fb1b3008526e53b38e09e96e0e88487">removeCoveredParticlesDiscrete</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a> <a class="el" href="classTracerParticleSolver.html">a_tolerance</a>=0.0) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a6fb1b3008526e53b38e09e96e0e88487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which removes particles from the domain if they fall inside the EB.  <br /></td></tr>
<tr class="separator:a6fb1b3008526e53b38e09e96e0e88487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036c315af1e9c46ba5320a3de0017927" id="r_a036c315af1e9c46ba5320a3de0017927"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a036c315af1e9c46ba5320a3de0017927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a036c315af1e9c46ba5320a3de0017927">removeCoveredParticlesVoxels</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a036c315af1e9c46ba5320a3de0017927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which removes particles from the domain if they fall inside the EB.  <br /></td></tr>
<tr class="separator:a036c315af1e9c46ba5320a3de0017927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c75449e9996805572bc01bd43042b2" id="r_a25c75449e9996805572bc01bd43042b2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a25c75449e9996805572bc01bd43042b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a25c75449e9996805572bc01bd43042b2">transferCoveredParticlesIF</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particlesFrom</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particlesTo</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a> <a class="el" href="classTracerParticleSolver.html">a_tolerance</a>=0.0) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a25c75449e9996805572bc01bd43042b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which transferse particles from one particle container to another if they fall inside the EB.  <br /></td></tr>
<tr class="separator:a25c75449e9996805572bc01bd43042b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b91aa63e558054ea913b05e797ec50" id="r_a06b91aa63e558054ea913b05e797ec50"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a06b91aa63e558054ea913b05e797ec50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a06b91aa63e558054ea913b05e797ec50">transferCoveredParticlesDiscrete</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particlesFrom</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particlesTo</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a> <a class="el" href="classTracerParticleSolver.html">a_tolerance</a>=0.0) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a06b91aa63e558054ea913b05e797ec50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which transferse particles from one particle container to another if they fall inside the EB.  <br /></td></tr>
<tr class="separator:a06b91aa63e558054ea913b05e797ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccc54b19b8398a8c48c4ef8b2ea026c" id="r_adccc54b19b8398a8c48c4ef8b2ea026c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:adccc54b19b8398a8c48c4ef8b2ea026c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#adccc54b19b8398a8c48c4ef8b2ea026c">transferCoveredParticlesVoxels</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particlesFrom</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particlesTo</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;<a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:adccc54b19b8398a8c48c4ef8b2ea026c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which transferse particles from one particle container to another if they fall inside the EB.  <br /></td></tr>
<tr class="separator:adccc54b19b8398a8c48c4ef8b2ea026c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef231600b61769b61c6fb4e07db725c" id="r_a3ef231600b61769b61c6fb4e07db725c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a3ef231600b61769b61c6fb4e07db725c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3ef231600b61769b61c6fb4e07db725c">transferIrregularParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_dstParticles</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_srcParticles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::function</a>&lt; <a class="el" href="classTracerParticleSolver.html">void</a>(<a class="el" href="classTracerParticleSolver.html">P</a> &amp;)&gt; <a class="el" href="classTracerParticleSolver.html">a_transferModifier</a>=[](<a class="el" href="classTracerParticleSolver.html">P</a> &amp;) -&gt; <a class="el" href="classTracerParticleSolver.html">void</a> { <a class="el" href="classTracerParticleSolver.html">return</a>;}) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a3ef231600b61769b61c6fb4e07db725c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer particles that are on the wrong side of the EB to a different container.  <br /></td></tr>
<tr class="separator:a3ef231600b61769b61c6fb4e07db725c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a68b7e8b0a7d9062db13f1b002cc39" id="r_a60a68b7e8b0a7d9062db13f1b002cc39"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a60a68b7e8b0a7d9062db13f1b002cc39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a60a68b7e8b0a7d9062db13f1b002cc39">intersectParticlesRaycastIF</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_activeParticles</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_ebParticles</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_domainParticles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a> <a class="el" href="classTracerParticleSolver.html">a_tolerance</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a> <a class="el" href="classTracerParticleSolver.html">a_deleteParticles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::function</a>&lt; <a class="el" href="classTracerParticleSolver.html">void</a>(<a class="el" href="classTracerParticleSolver.html">P</a> &amp;)&gt; <a class="el" href="classTracerParticleSolver.html">a_nonDeletionModifier</a>=[](<a class="el" href="classTracerParticleSolver.html">P</a> &amp;) -&gt; <a class="el" href="classTracerParticleSolver.html">void</a> { <a class="el" href="classTracerParticleSolver.html">return</a>;}) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a60a68b7e8b0a7d9062db13f1b002cc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle intersection algorithm based on ray-casting.  <br /></td></tr>
<tr class="separator:a60a68b7e8b0a7d9062db13f1b002cc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785050ce35bae77bac1d1bfa3358a7cb" id="r_a785050ce35bae77bac1d1bfa3358a7cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a785050ce35bae77bac1d1bfa3358a7cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a785050ce35bae77bac1d1bfa3358a7cb">intersectParticlesBisectIF</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_activeParticles</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_ebParticles</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_domainParticles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a> <a class="el" href="classTracerParticleSolver.html">a_bisectionStep</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a> <a class="el" href="classTracerParticleSolver.html">a_deleteParticles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::function</a>&lt; <a class="el" href="classTracerParticleSolver.html">void</a>(<a class="el" href="classTracerParticleSolver.html">P</a> &amp;)&gt; <a class="el" href="classTracerParticleSolver.html">a_nonDeletionModifier</a>=[](<a class="el" href="classTracerParticleSolver.html">P</a> &amp;) -&gt; <a class="el" href="classTracerParticleSolver.html">void</a> { <a class="el" href="classTracerParticleSolver.html">return</a>;}) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a785050ce35bae77bac1d1bfa3358a7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle intersection algorithm based on bisection.  <br /></td></tr>
<tr class="separator:a785050ce35bae77bac1d1bfa3358a7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980ef520e5d9c3a2977a6c43d432b523" id="r_a980ef520e5d9c3a2977a6c43d432b523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a980ef520e5d9c3a2977a6c43d432b523">interpGhost</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a980ef520e5d9c3a2977a6c43d432b523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost vectors over a realm, using the default ghost cell interpolation method.  <br /></td></tr>
<tr class="separator:a980ef520e5d9c3a2977a6c43d432b523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff48bbba8105fcfea99d8796268eaab" id="r_a5ff48bbba8105fcfea99d8796268eaab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5ff48bbba8105fcfea99d8796268eaab">interpGhost</a> (<a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_fineData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_coarData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_level</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a5ff48bbba8105fcfea99d8796268eaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm, using the default ghost cell interpolation method on a specific level.  <br /></td></tr>
<tr class="separator:a5ff48bbba8105fcfea99d8796268eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f71b81c581b084edff3a03e61ce943" id="r_a03f71b81c581b084edff3a03e61ce943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a03f71b81c581b084edff3a03e61ce943">interpGhost</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a03f71b81c581b084edff3a03e61ce943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm. Calls the default ghost cell interpolation method.  <br /></td></tr>
<tr class="separator:a03f71b81c581b084edff3a03e61ce943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa6a3ddddeb4ffdda877719e545eaef" id="r_a3aa6a3ddddeb4ffdda877719e545eaef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3aa6a3ddddeb4ffdda877719e545eaef">interpGhostPwl</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a3aa6a3ddddeb4ffdda877719e545eaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm and phase. This uses piecewise linear interpolation (with limiters)  <br /></td></tr>
<tr class="separator:a3aa6a3ddddeb4ffdda877719e545eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b4b8c5a83b8df8a3f23c93cd81a834" id="r_a88b4b8c5a83b8df8a3f23c93cd81a834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a88b4b8c5a83b8df8a3f23c93cd81a834">interpGhostPwl</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a88b4b8c5a83b8df8a3f23c93cd81a834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm and phase. This uses piecewise linear interpolation (with limiters)  <br /></td></tr>
<tr class="separator:a88b4b8c5a83b8df8a3f23c93cd81a834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a019193845e8ff43c846575570b0c0a" id="r_a4a019193845e8ff43c846575570b0c0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4a019193845e8ff43c846575570b0c0a">interpGhostMG</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a4a019193845e8ff43c846575570b0c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm and phase.  <br /></td></tr>
<tr class="separator:a4a019193845e8ff43c846575570b0c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187f9807eae7f2c90a6b0ac1c32f8cb1" id="r_a187f9807eae7f2c90a6b0ac1c32f8cb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a187f9807eae7f2c90a6b0ac1c32f8cb1">interpGhostMG</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a187f9807eae7f2c90a6b0ac1c32f8cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm and phase.  <br /></td></tr>
<tr class="separator:a187f9807eae7f2c90a6b0ac1c32f8cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8c62ee3fbc0bac33784f1abf312816" id="r_adb8c62ee3fbc0bac33784f1abf312816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#adb8c62ee3fbc0bac33784f1abf312816">interpToNewGrids</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_newData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_oldData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_oldFinestLevel</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_newFinestLevel</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBCoarseToFineInterp.html#a7da81d645a467200cc6ad9b2667c1c08">EBCoarseToFineInterp::Type</a> <a class="el" href="classTracerParticleSolver.html">a_type</a>)</td></tr>
<tr class="memdesc:adb8c62ee3fbc0bac33784f1abf312816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to new grids.  <br /></td></tr>
<tr class="separator:adb8c62ee3fbc0bac33784f1abf312816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195914bb2a8bace5985d1960d6074100" id="r_a195914bb2a8bace5985d1960d6074100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a195914bb2a8bace5985d1960d6074100">interpToNewGrids</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_newData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_oldData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_oldFinestLevel</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_newFinestLevel</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBCoarseToFineInterp.html#a7da81d645a467200cc6ad9b2667c1c08">EBCoarseToFineInterp::Type</a> <a class="el" href="classTracerParticleSolver.html">a_type</a>)</td></tr>
<tr class="memdesc:a195914bb2a8bace5985d1960d6074100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to new grids.  <br /></td></tr>
<tr class="separator:a195914bb2a8bace5985d1960d6074100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb81553cf7712d97c54615f69634f03" id="r_a6fb81553cf7712d97c54615f69634f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6fb81553cf7712d97c54615f69634f03">interpToNewGrids</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_newData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_oldData</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_oldFinestLevel</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_newFinestLevel</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBCoarseToFineInterp.html#a7da81d645a467200cc6ad9b2667c1c08">EBCoarseToFineInterp::Type</a> <a class="el" href="classTracerParticleSolver.html">a_type</a>)</td></tr>
<tr class="memdesc:a6fb81553cf7712d97c54615f69634f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to new grids.  <br /></td></tr>
<tr class="separator:a6fb81553cf7712d97c54615f69634f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33518b8e6bc4daf6ce94d33d5905c357" id="r_a33518b8e6bc4daf6ce94d33d5905c357"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </td></tr>
<tr class="memitem:a33518b8e6bc4daf6ce94d33d5905c357"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a33518b8e6bc4daf6ce94d33d5905c357">remapToNewGrids</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_particles</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_newFinestLevel</a>) <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">noexcept</a></td></tr>
<tr class="memdesc:a33518b8e6bc4daf6ce94d33d5905c357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid particle to new grids.  <br /></td></tr>
<tr class="separator:a33518b8e6bc4daf6ce94d33d5905c357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58008f166bc2d7de06c4c24d879513fe" id="r_a58008f166bc2d7de06c4c24d879513fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a58008f166bc2d7de06c4c24d879513fe">interpToCentroids</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a58008f166bc2d7de06c4c24d879513fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to centroids on realm and phase.  <br /></td></tr>
<tr class="separator:a58008f166bc2d7de06c4c24d879513fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e42a6fb2e20aae67933c15a2b5e604" id="r_a69e42a6fb2e20aae67933c15a2b5e604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a69e42a6fb2e20aae67933c15a2b5e604">interpToCentroids</a> (<a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_data</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_level</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a69e42a6fb2e20aae67933c15a2b5e604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to centroids.  <br /></td></tr>
<tr class="separator:a69e42a6fb2e20aae67933c15a2b5e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0ed99e2d6e6edf3fb65ad4b79d9a0" id="r_a80a0ed99e2d6e6edf3fb65ad4b79d9a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a80a0ed99e2d6e6edf3fb65ad4b79d9a0">setMultifluidIndexSpace</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classMultiFluidIndexSpace.html">MultiFluidIndexSpace</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_multiFluidIndexSpace</a>)</td></tr>
<tr class="memdesc:a80a0ed99e2d6e6edf3fb65ad4b79d9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets multifluid index space.  <br /></td></tr>
<tr class="separator:a80a0ed99e2d6e6edf3fb65ad4b79d9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc74d0037dc972aea59860feeb54a6e3" id="r_afc74d0037dc972aea59860feeb54a6e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#afc74d0037dc972aea59860feeb54a6e3">setBaseImplicitFunction</a> (<a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; BaseIF &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_baseIF</a>)</td></tr>
<tr class="memdesc:afc74d0037dc972aea59860feeb54a6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set implicit function for a specific phase. Need <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">e.g</a>. for level-sets.  <br /></td></tr>
<tr class="separator:afc74d0037dc972aea59860feeb54a6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace51b171107edeb5a8d901f8869a16ee" id="r_ace51b171107edeb5a8d901f8869a16ee"><td class="memItemLeft" align="right" valign="top"><a id="ace51b171107edeb5a8d901f8869a16ee" name="ace51b171107edeb5a8d901f8869a16ee"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>preRegrid</b> ()</td></tr>
<tr class="memdesc:ace51b171107edeb5a8d901f8869a16ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run pre-regrid operations. <br /></td></tr>
<tr class="separator:ace51b171107edeb5a8d901f8869a16ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8897dc00f6ac738080aba2ec29ad7a" id="r_a9a8897dc00f6ac738080aba2ec29ad7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9a8897dc00f6ac738080aba2ec29ad7a">regridAmr</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">IntVectSet</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_tags</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_hardcap</a>=-1)</td></tr>
<tr class="memdesc:a9a8897dc00f6ac738080aba2ec29ad7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid AMR. This versions generates the grids and Realms, but not the operator.  <br /></td></tr>
<tr class="separator:a9a8897dc00f6ac738080aba2ec29ad7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8162ae90fb308b1fb84e8c8986f8b61" id="r_af8162ae90fb308b1fb84e8c8986f8b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af8162ae90fb308b1fb84e8c8986f8b61">regridRealm</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">int</a> &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_procs</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Box</a> &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_boxes</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>)</td></tr>
<tr class="memdesc:af8162ae90fb308b1fb84e8c8986f8b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid a realm. This generates the grids for the realm, but does not do the operators on the realm.  <br /></td></tr>
<tr class="separator:af8162ae90fb308b1fb84e8c8986f8b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275a50e9c39fca6ad59cf5eaa7a0ca40" id="r_a275a50e9c39fca6ad59cf5eaa7a0ca40"><td class="memItemLeft" align="right" valign="top"><a id="a275a50e9c39fca6ad59cf5eaa7a0ca40" name="a275a50e9c39fca6ad59cf5eaa7a0ca40"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>postRegrid</b> ()</td></tr>
<tr class="memdesc:a275a50e9c39fca6ad59cf5eaa7a0ca40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run post-regrid operations. <br /></td></tr>
<tr class="separator:a275a50e9c39fca6ad59cf5eaa7a0ca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38a00d59a1a0fecbf0f453e2ce77a48" id="r_aa38a00d59a1a0fecbf0f453e2ce77a48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa38a00d59a1a0fecbf0f453e2ce77a48">setGrids</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Box</a> &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_boxes</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">long</a> <a class="el" href="classTracerParticleSolver.html">int</a> &gt; &gt; &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_realmsAndLoads</a>)</td></tr>
<tr class="memdesc:aa38a00d59a1a0fecbf0f453e2ce77a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set grids from boxes and computational loads.  <br /></td></tr>
<tr class="separator:aa38a00d59a1a0fecbf0f453e2ce77a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8e3a7de269ef9be0121c22eed428d5" id="r_aee8e3a7de269ef9be0121c22eed428d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aee8e3a7de269ef9be0121c22eed428d5">regridOperators</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>)</td></tr>
<tr class="memdesc:aee8e3a7de269ef9be0121c22eed428d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid AMR operators. This is done for all realms.  <br /></td></tr>
<tr class="separator:aee8e3a7de269ef9be0121c22eed428d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3ac55867e7dc229ccbadf737dcd5c6" id="r_aaa3ac55867e7dc229ccbadf737dcd5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aaa3ac55867e7dc229ccbadf737dcd5c6">regridOperators</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>)</td></tr>
<tr class="memdesc:aaa3ac55867e7dc229ccbadf737dcd5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid AMR operators. This is done for a specific realm.  <br /></td></tr>
<tr class="separator:aaa3ac55867e7dc229ccbadf737dcd5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673a01e951aa1b355b60416c3ea3f55f" id="r_a673a01e951aa1b355b60416c3ea3f55f"><td class="memItemLeft" align="right" valign="top"><a id="a673a01e951aa1b355b60416c3ea3f55f" name="a673a01e951aa1b355b60416c3ea3f55f"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sanityCheck</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a673a01e951aa1b355b60416c3ea3f55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a sanity check to make sure everything is set up correctly. <br /></td></tr>
<tr class="separator:a673a01e951aa1b355b60416c3ea3f55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff00899eeda16c714410146ecc2c8af7" id="r_aff00899eeda16c714410146ecc2c8af7"><td class="memItemLeft" align="right" valign="top"><a id="aff00899eeda16c714410146ecc2c8af7" name="aff00899eeda16c714410146ecc2c8af7"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getFinestLevel</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aff00899eeda16c714410146ecc2c8af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get finest grid level. <br /></td></tr>
<tr class="separator:aff00899eeda16c714410146ecc2c8af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65edfcba2c19e22298dce39d524cfc5" id="r_ae65edfcba2c19e22298dce39d524cfc5"><td class="memItemLeft" align="right" valign="top"><a id="ae65edfcba2c19e22298dce39d524cfc5" name="ae65edfcba2c19e22298dce39d524cfc5"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxAmrDepth</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ae65edfcba2c19e22298dce39d524cfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum permitted amr depth. <br /></td></tr>
<tr class="separator:ae65edfcba2c19e22298dce39d524cfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22db83d03132b22c64dbe04918d6c0" id="r_a3a22db83d03132b22c64dbe04918d6c0"><td class="memItemLeft" align="right" valign="top"><a id="a3a22db83d03132b22c64dbe04918d6c0" name="a3a22db83d03132b22c64dbe04918d6c0"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxSimulationDepth</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a3a22db83d03132b22c64dbe04918d6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum permitted simulation depth. <br /></td></tr>
<tr class="separator:a3a22db83d03132b22c64dbe04918d6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41d05854bb69a10ac374a1c785a8142" id="r_ac41d05854bb69a10ac374a1c785a8142"><td class="memItemLeft" align="right" valign="top"><a id="ac41d05854bb69a10ac374a1c785a8142" name="ac41d05854bb69a10ac374a1c785a8142"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBlockingFactor</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ac41d05854bb69a10ac374a1c785a8142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get blocking factor (<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">i.e</a>. the smallest possible box). <br /></td></tr>
<tr class="separator:ac41d05854bb69a10ac374a1c785a8142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf47a8b74e8fe8527ac9e97779c5e1e" id="r_aabf47a8b74e8fe8527ac9e97779c5e1e"><td class="memItemLeft" align="right" valign="top"><a id="aabf47a8b74e8fe8527ac9e97779c5e1e" name="aabf47a8b74e8fe8527ac9e97779c5e1e"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxBoxSize</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aabf47a8b74e8fe8527ac9e97779c5e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum permitted box size. <br /></td></tr>
<tr class="separator:aabf47a8b74e8fe8527ac9e97779c5e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa14b4ba44f64a8bc5164ae97591032d" id="r_aaa14b4ba44f64a8bc5164ae97591032d"><td class="memItemLeft" align="right" valign="top"><a id="aaa14b4ba44f64a8bc5164ae97591032d" name="aaa14b4ba44f64a8bc5164ae97591032d"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBrBuffer</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aaa14b4ba44f64a8bc5164ae97591032d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return buffer for B-R mesh refinement algorithm. <br /></td></tr>
<tr class="separator:aaa14b4ba44f64a8bc5164ae97591032d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee371b14070e14d0a7624b943ff2441" id="r_aaee371b14070e14d0a7624b943ff2441"><td class="memItemLeft" align="right" valign="top"><a id="aaee371b14070e14d0a7624b943ff2441" name="aaee371b14070e14d0a7624b943ff2441"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxEbisBoxSize</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aaee371b14070e14d0a7624b943ff2441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum box size for EBIS generation. <br /></td></tr>
<tr class="separator:aaee371b14070e14d0a7624b943ff2441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9644428ada5f48e3fcdb512898cc1e62" id="r_a9644428ada5f48e3fcdb512898cc1e62"><td class="memItemLeft" align="right" valign="top"><a id="a9644428ada5f48e3fcdb512898cc1e62" name="a9644428ada5f48e3fcdb512898cc1e62"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberOfGhostCells</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a9644428ada5f48e3fcdb512898cc1e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default number of ghost cells. <br /></td></tr>
<tr class="separator:a9644428ada5f48e3fcdb512898cc1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a363c78f0c85f9c8d0a66da2b40d37" id="r_af6a363c78f0c85f9c8d0a66da2b40d37"><td class="memItemLeft" align="right" valign="top"><a id="af6a363c78f0c85f9c8d0a66da2b40d37" name="af6a363c78f0c85f9c8d0a66da2b40d37"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberOfEbGhostCells</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af6a363c78f0c85f9c8d0a66da2b40d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of ghost cells used for EB grid generation. <br /></td></tr>
<tr class="separator:af6a363c78f0c85f9c8d0a66da2b40d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0797ec9054cf1b463a3202f99409651" id="r_af0797ec9054cf1b463a3202f99409651"><td class="memItemLeft" align="right" valign="top"><a id="af0797ec9054cf1b463a3202f99409651" name="af0797ec9054cf1b463a3202f99409651"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getRedistributionRadius</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af0797ec9054cf1b463a3202f99409651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default redistribution radius. <br /></td></tr>
<tr class="separator:af0797ec9054cf1b463a3202f99409651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dad5645ed0341ada0681607da1d600" id="r_a13dad5645ed0341ada0681607da1d600"><td class="memItemLeft" align="right" valign="top"><a id="a13dad5645ed0341ada0681607da1d600" name="a13dad5645ed0341ada0681607da1d600"></a>
<a class="el" href="classTracerParticleSolver.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getFinestDx</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a13dad5645ed0341ada0681607da1d600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get resolution on the finest grid level. <br /></td></tr>
<tr class="separator:a13dad5645ed0341ada0681607da1d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e22af33b0bc2737eb911562b2796ee4" id="r_a7e22af33b0bc2737eb911562b2796ee4"><td class="memItemLeft" align="right" valign="top"><a id="a7e22af33b0bc2737eb911562b2796ee4" name="a7e22af33b0bc2737eb911562b2796ee4"></a>
<a class="el" href="classTracerParticleSolver.html">RealVect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getProbLo</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a7e22af33b0bc2737eb911562b2796ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lower-left corner of computational domain. <br /></td></tr>
<tr class="separator:a7e22af33b0bc2737eb911562b2796ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e8e100d4851aa4088ac38c857a6882" id="r_a10e8e100d4851aa4088ac38c857a6882"><td class="memItemLeft" align="right" valign="top"><a id="a10e8e100d4851aa4088ac38c857a6882" name="a10e8e100d4851aa4088ac38c857a6882"></a>
<a class="el" href="classTracerParticleSolver.html">RealVect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getProbHi</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a10e8e100d4851aa4088ac38c857a6882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get upper-left corner of computational domain. <br /></td></tr>
<tr class="separator:a10e8e100d4851aa4088ac38c857a6882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dec51dbb9d0a3aa8023d63d538a8dc7" id="r_a1dec51dbb9d0a3aa8023d63d538a8dc7"><td class="memItemLeft" align="right" valign="top"><a id="a1dec51dbb9d0a3aa8023d63d538a8dc7" name="a1dec51dbb9d0a3aa8023d63d538a8dc7"></a>
<a class="el" href="classTracerParticleSolver.html">ProblemDomain</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getFinestDomain</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a1dec51dbb9d0a3aa8023d63d538a8dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get finest domain. <br /></td></tr>
<tr class="separator:a1dec51dbb9d0a3aa8023d63d538a8dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dc8db2ef220a83ac5dc391d1a1ce79" id="r_aa8dc8db2ef220a83ac5dc391d1a1ce79"><td class="memItemLeft" align="right" valign="top"><a id="aa8dc8db2ef220a83ac5dc391d1a1ce79" name="aa8dc8db2ef220a83ac5dc391d1a1ce79"></a>
<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Real</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDx</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aa8dc8db2ef220a83ac5dc391d1a1ce79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get spatial resolutions. <br /></td></tr>
<tr class="separator:aa8dc8db2ef220a83ac5dc391d1a1ce79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9e442e363ef5f63143d438619cd334" id="r_aea9e442e363ef5f63143d438619cd334"><td class="memItemLeft" align="right" valign="top"><a id="aea9e442e363ef5f63143d438619cd334" name="aea9e442e363ef5f63143d438619cd334"></a>
<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getRefinementRatios</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aea9e442e363ef5f63143d438619cd334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get refinement ratios. <br /></td></tr>
<tr class="separator:aea9e442e363ef5f63143d438619cd334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a316dd3977e3f60c27c0e2f71cf4fc" id="r_ab7a316dd3977e3f60c27c0e2f71cf4fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab7a316dd3977e3f60c27c0e2f71cf4fc">getRefinementRatio</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_level1</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_level2</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ab7a316dd3977e3f60c27c0e2f71cf4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get refinement factor between two levels.  <br /></td></tr>
<tr class="separator:ab7a316dd3977e3f60c27c0e2f71cf4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1662c260b08bddf92838f6061040619b" id="r_a1662c260b08bddf92838f6061040619b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; BaseIF &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1662c260b08bddf92838f6061040619b">getBaseImplicitFunction</a> (<a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a1662c260b08bddf92838f6061040619b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get implicit function for a specific phase.  <br /></td></tr>
<tr class="separator:a1662c260b08bddf92838f6061040619b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23821170fc1949807a3896dcc9f33b1a" id="r_a23821170fc1949807a3896dcc9f33b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">DisjointBoxLayout</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a23821170fc1949807a3896dcc9f33b1a">getProxyGrids</a> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a23821170fc1949807a3896dcc9f33b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "proxy" grids in <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a>.  <br /></td></tr>
<tr class="separator:a23821170fc1949807a3896dcc9f33b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758abcbca57d397805fcc6ad4b6fa632" id="r_a758abcbca57d397805fcc6ad4b6fa632"><td class="memItemLeft" align="right" valign="top"><a id="a758abcbca57d397805fcc6ad4b6fa632" name="a758abcbca57d397805fcc6ad4b6fa632"></a>
<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">DisjointBoxLayout</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getGrids</b> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a758abcbca57d397805fcc6ad4b6fa632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the grids. <br /></td></tr>
<tr class="separator:a758abcbca57d397805fcc6ad4b6fa632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6bd8d2bc234f35a6f54d86ce485f05" id="r_aff6bd8d2bc234f35a6f54d86ce485f05"><td class="memItemLeft" align="right" valign="top"><a id="aff6bd8d2bc234f35a6f54d86ce485f05" name="aff6bd8d2bc234f35a6f54d86ce485f05"></a>
<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">ProblemDomain</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDomains</b> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aff6bd8d2bc234f35a6f54d86ce485f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get domains. <br /></td></tr>
<tr class="separator:aff6bd8d2bc234f35a6f54d86ce485f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94bae000d35d8820cfef27bd9c1c890" id="r_ac94bae000d35d8820cfef27bd9c1c890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Realm_8H.html#a906b67939aa45e674c3a94d40c0e5e34">AMRMask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac94bae000d35d8820cfef27bd9c1c890">getMask</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_mask</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_buffer</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ac94bae000d35d8820cfef27bd9c1c890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a registered mask.  <br /></td></tr>
<tr class="separator:ac94bae000d35d8820cfef27bd9c1c890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1492043709c933fca6e7c51a42aebf40" id="r_a1492043709c933fca6e7c51a42aebf40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Realm_8H.html#a906b67939aa45e674c3a94d40c0e5e34">AMRMask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1492043709c933fca6e7c51a42aebf40">getValidCells</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a1492043709c933fca6e7c51a42aebf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a map of all valid cells on a specified realm.  <br /></td></tr>
<tr class="separator:a1492043709c933fca6e7c51a42aebf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12361318b9d25503a7d850ef96a6a5a" id="r_af12361318b9d25503a7d850ef96a6a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classLevelTiles.html">LevelTiles</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af12361318b9d25503a7d850ef96a6a5a">getLevelTiles</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af12361318b9d25503a7d850ef96a6a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tiled space representation.  <br /></td></tr>
<tr class="separator:af12361318b9d25503a7d850ef96a6a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1071a09cfc3ff93bd467ae8c63da08" id="r_a6b1071a09cfc3ff93bd467ae8c63da08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBLevelGrid</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6b1071a09cfc3ff93bd467ae8c63da08">getEBLevelGrid</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a6b1071a09cfc3ff93bd467ae8c63da08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the EBLevelGrid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase.  <br /></td></tr>
<tr class="separator:a6b1071a09cfc3ff93bd467ae8c63da08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff109a783f6987d82f9ca37349605fc7" id="r_aff109a783f6987d82f9ca37349605fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBLevelGrid</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aff109a783f6987d82f9ca37349605fc7">getEBLevelGridCoFi</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aff109a783f6987d82f9ca37349605fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the coarsened fine EBLevelGrid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase.  <br /></td></tr>
<tr class="separator:aff109a783f6987d82f9ca37349605fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db2254121059379e82f6569b2c6641a" id="r_a8db2254121059379e82f6569b2c6641a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBISLayout</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8db2254121059379e82f6569b2c6641a">getEBISLayout</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a8db2254121059379e82f6569b2c6641a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get EBISLayouts for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase.  <br /></td></tr>
<tr class="separator:a8db2254121059379e82f6569b2c6641a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a7c78576d46ae8ced617b78ab0ae30" id="r_a99a7c78576d46ae8ced617b78ab0ae30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classMFLevelGrid.html">MFLevelGrid</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a99a7c78576d46ae8ced617b78ab0ae30">getMFLevelGrid</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a99a7c78576d46ae8ced617b78ab0ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get EBISLayouts for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a>.  <br /></td></tr>
<tr class="separator:a99a7c78576d46ae8ced617b78ab0ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a0d0f998de1a920a638a7b23c8056a" id="r_ae3a0d0f998de1a920a638a7b23c8056a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">LayoutData</a>&lt; <a class="el" href="classTracerParticleSolver.html">VoFIterator</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae3a0d0f998de1a920a638a7b23c8056a">getVofIterator</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ae3a0d0f998de1a920a638a7b23c8056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vof iterators for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. This has the capability of iterating through cut-cells.  <br /></td></tr>
<tr class="separator:ae3a0d0f998de1a920a638a7b23c8056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ae0a0c9ceba11621bc8f1ba1682824" id="r_af6ae0a0c9ceba11621bc8f1ba1682824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRFAB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af6ae0a0c9ceba11621bc8f1ba1682824">getLevelset</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af6ae0a0c9ceba11621bc8f1ba1682824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get levelset function, allocated over a grid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase.  <br /></td></tr>
<tr class="separator:af6ae0a0c9ceba11621bc8f1ba1682824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01ad6d63e8fed8c1615a06a9ccb534a" id="r_ae01ad6d63e8fed8c1615a06a9ccb534a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRParticleMesh.html">EBAMRParticleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae01ad6d63e8fed8c1615a06a9ccb534a">getParticleMesh</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ae01ad6d63e8fed8c1615a06a9ccb534a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classEBAMRParticleMesh.html" title="Class for handling particle-mesh operations with AMR.">EBAMRParticleMesh</a> operator.  <br /></td></tr>
<tr class="separator:ae01ad6d63e8fed8c1615a06a9ccb534a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc021d3b64ddaabdc982230621e254c4" id="r_acc021d3b64ddaabdc982230621e254c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRSurfaceDeposition.html">EBAMRSurfaceDeposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#acc021d3b64ddaabdc982230621e254c4">getSurfaceDeposition</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:acc021d3b64ddaabdc982230621e254c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classEBAMRSurfaceDeposition.html" title="class for handling surface deposition of particles with EB and AMR.">EBAMRSurfaceDeposition</a> surface deposition operator.  <br /></td></tr>
<tr class="separator:acc021d3b64ddaabdc982230621e254c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04c32d16bc55edc5fe1147eb32bda67" id="r_ab04c32d16bc55edc5fe1147eb32bda67"><td class="memItemLeft" align="right" valign="top"><a id="ab04c32d16bc55edc5fe1147eb32bda67" name="ab04c32d16bc55edc5fe1147eb32bda67"></a>
<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBCoarAve.html">EBCoarAve</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCoarseAverage</b> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ab04c32d16bc55edc5fe1147eb32bda67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the coarsening utility. <br /></td></tr>
<tr class="separator:ab04c32d16bc55edc5fe1147eb32bda67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d1aa576ea1b98c23378f127212844e" id="r_a28d1aa576ea1b98c23378f127212844e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBMultigridInterpolator.html">EBMultigridInterpolator</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a28d1aa576ea1b98c23378f127212844e">getMultigridInterpolator</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a28d1aa576ea1b98c23378f127212844e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multigrid interpolation utility.  <br /></td></tr>
<tr class="separator:a28d1aa576ea1b98c23378f127212844e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568f8a5e5bd4d2778cf051ff28da380c" id="r_a568f8a5e5bd4d2778cf051ff28da380c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBCoarseToFineInterp.html">EBCoarseToFineInterp</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a568f8a5e5bd4d2778cf051ff28da380c">getFineInterp</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a568f8a5e5bd4d2778cf051ff28da380c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolator.  <br /></td></tr>
<tr class="separator:a568f8a5e5bd4d2778cf051ff28da380c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd953629079c965c72a6a6b742f507a" id="r_a8dd953629079c965c72a6a6b742f507a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBReflux.html">EBReflux</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8dd953629079c965c72a6a6b742f507a">getFluxRegister</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a8dd953629079c965c72a6a6b742f507a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flux register.  <br /></td></tr>
<tr class="separator:a8dd953629079c965c72a6a6b742f507a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9334b1e32789d5014a0285ecbff0a854" id="r_a9334b1e32789d5014a0285ecbff0a854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBFluxRedistribution.html">EBFluxRedistribution</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9334b1e32789d5014a0285ecbff0a854">getRedistributionOp</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a9334b1e32789d5014a0285ecbff0a854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the redistribution operators.  <br /></td></tr>
<tr class="separator:a9334b1e32789d5014a0285ecbff0a854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a85437e92d6b8493258d04c05d30db" id="r_ab8a85437e92d6b8493258d04c05d30db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classCentroidInterpolationStencil.html">CentroidInterpolationStencil</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab8a85437e92d6b8493258d04c05d30db">getCentroidInterpolationStencils</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:ab8a85437e92d6b8493258d04c05d30db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolation stencils for going from cell center to cell centroid.  <br /></td></tr>
<tr class="separator:ab8a85437e92d6b8493258d04c05d30db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8721574be5dce546f43bc88f9ca9cd" id="r_a9e8721574be5dce546f43bc88f9ca9cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classEbCentroidInterpolationStencil.html">EbCentroidInterpolationStencil</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9e8721574be5dce546f43bc88f9ca9cd">getEbCentroidInterpolationStencils</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a9e8721574be5dce546f43bc88f9ca9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolation stencils for going from cell center to cell boundary centroid.  <br /></td></tr>
<tr class="separator:a9e8721574be5dce546f43bc88f9ca9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71d4093fe3c996f104348eec16cf0bd" id="r_aa71d4093fe3c996f104348eec16cf0bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classNonConservativeDivergenceStencil.html">NonConservativeDivergenceStencil</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa71d4093fe3c996f104348eec16cf0bd">getNonConservativeDivergenceStencils</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:aa71d4093fe3c996f104348eec16cf0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nonconservative divergence stencils.  <br /></td></tr>
<tr class="separator:aa71d4093fe3c996f104348eec16cf0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa1580b30fe66ec3e313435c44d1f1" id="r_a10aa1580b30fe66ec3e313435c44d1f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::vector</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a10aa1580b30fe66ec3e313435c44d1f1">getRealms</a> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a10aa1580b30fe66ec3e313435c44d1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of all Realms.  <br /></td></tr>
<tr class="separator:a10aa1580b30fe66ec3e313435c44d1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18f3ce3d1d5310f7f18518a84fdf1dc" id="r_af18f3ce3d1d5310f7f18518a84fdf1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CD__BoxSorting_8H.html#ab5db8b3a96e3a04473aaa898f7eb2128">BoxSorting</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af18f3ce3d1d5310f7f18518a84fdf1dc">getBoxSorting</a> () <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:af18f3ce3d1d5310f7f18518a84fdf1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get box sorting method.  <br /></td></tr>
<tr class="separator:af18f3ce3d1d5310f7f18518a84fdf1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e61c7d908b578e90ef400943e58501c" id="r_a9e61c7d908b578e90ef400943e58501c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBIndexSpace</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9e61c7d908b578e90ef400943e58501c">getEBIndexSpace</a> (<a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>)</td></tr>
<tr class="memdesc:a9e61c7d908b578e90ef400943e58501c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get EBIndexSpace corresponding to a particular phase.  <br /></td></tr>
<tr class="separator:a9e61c7d908b578e90ef400943e58501c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a6b1adbb06620c67d0b168f649c796289" id="r_a6b1adbb06620c67d0b168f649c796289"><td class="memItemLeft" align="right" valign="top"><a id="a6b1adbb06620c67d0b168f649c796289" name="a6b1adbb06620c67d0b168f649c796289"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6b1adbb06620c67d0b168f649c796289">GridGenerationMethod</a> { <b>BergerRigoutsous</b>
, <b>Tiled</b>
 }</td></tr>
<tr class="memdesc:a6b1adbb06620c67d0b168f649c796289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for having understandable notation for grid generation. <br /></td></tr>
<tr class="separator:a6b1adbb06620c67d0b168f649c796289"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a82b28bf393e8ff6ed5cc544a48ea75ea" id="r_a82b28bf393e8ff6ed5cc544a48ea75ea"><td class="memItemLeft" align="right" valign="top"><a id="a82b28bf393e8ff6ed5cc544a48ea75ea" name="a82b28bf393e8ff6ed5cc544a48ea75ea"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>defineRealms</b> ()</td></tr>
<tr class="memdesc:a82b28bf393e8ff6ed5cc544a48ea75ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define Realms. <br /></td></tr>
<tr class="separator:a82b28bf393e8ff6ed5cc544a48ea75ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e4f0db7383a8a926a9bcb59defb67e" id="r_a69e4f0db7383a8a926a9bcb59defb67e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a69e4f0db7383a8a926a9bcb59defb67e">buildGrids</a> (<a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">IntVectSet</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_tags</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lmin</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_hardcap</a>=-1)</td></tr>
<tr class="memdesc:a69e4f0db7383a8a926a9bcb59defb67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build new internal AMR grids.  <br /></td></tr>
<tr class="separator:a69e4f0db7383a8a926a9bcb59defb67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d384fb87bd71ccdc5ee53673685ce48" id="r_a7d384fb87bd71ccdc5ee53673685ce48"><td class="memItemLeft" align="right" valign="top"><a id="a7d384fb87bd71ccdc5ee53673685ce48" name="a7d384fb87bd71ccdc5ee53673685ce48"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buildCopiers</b> ()</td></tr>
<tr class="memdesc:a7d384fb87bd71ccdc5ee53673685ce48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build copiers for copying between realms. <br /></td></tr>
<tr class="separator:a7d384fb87bd71ccdc5ee53673685ce48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64b6dda8135d3f53ec299c945ad5b4b" id="r_ad64b6dda8135d3f53ec299c945ad5b4b"><td class="memItemLeft" align="right" valign="top"><a id="ad64b6dda8135d3f53ec299c945ad5b4b" name="ad64b6dda8135d3f53ec299c945ad5b4b"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseProbLoHiCorners</b> ()</td></tr>
<tr class="memdesc:ad64b6dda8135d3f53ec299c945ad5b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the low/high corners of the computational domain. <br /></td></tr>
<tr class="separator:ad64b6dda8135d3f53ec299c945ad5b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67cab9a8a5cf3d884a07df809ca72ba" id="r_ad67cab9a8a5cf3d884a07df809ca72ba"><td class="memItemLeft" align="right" valign="top"><a id="ad67cab9a8a5cf3d884a07df809ca72ba" name="ad67cab9a8a5cf3d884a07df809ca72ba"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseGridGeneration</b> ()</td></tr>
<tr class="memdesc:ad67cab9a8a5cf3d884a07df809ca72ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the grid generation algorithm. <br /></td></tr>
<tr class="separator:ad67cab9a8a5cf3d884a07df809ca72ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fc82644d6c1aff9aa67931d3eceb44" id="r_a69fc82644d6c1aff9aa67931d3eceb44"><td class="memItemLeft" align="right" valign="top"><a id="a69fc82644d6c1aff9aa67931d3eceb44" name="a69fc82644d6c1aff9aa67931d3eceb44"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseVerbosity</b> ()</td></tr>
<tr class="memdesc:a69fc82644d6c1aff9aa67931d3eceb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the verbosity for <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a>. <br /></td></tr>
<tr class="separator:a69fc82644d6c1aff9aa67931d3eceb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e128ab04f54e27a3372f1296de58252" id="r_a9e128ab04f54e27a3372f1296de58252"><td class="memItemLeft" align="right" valign="top"><a id="a9e128ab04f54e27a3372f1296de58252" name="a9e128ab04f54e27a3372f1296de58252"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseCoarsestLevelNumCells</b> ()</td></tr>
<tr class="memdesc:a9e128ab04f54e27a3372f1296de58252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the coarsest domain grid. <br /></td></tr>
<tr class="separator:a9e128ab04f54e27a3372f1296de58252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2862782a7c22f1f38543d7d21cf9b65c" id="r_a2862782a7c22f1f38543d7d21cf9b65c"><td class="memItemLeft" align="right" valign="top"><a id="a2862782a7c22f1f38543d7d21cf9b65c" name="a2862782a7c22f1f38543d7d21cf9b65c"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseMaxAmrDepth</b> ()</td></tr>
<tr class="memdesc:a2862782a7c22f1f38543d7d21cf9b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the maximum permitted AMR depth. <br /></td></tr>
<tr class="separator:a2862782a7c22f1f38543d7d21cf9b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37af95890a678148aee6107045c7d43b" id="r_a37af95890a678148aee6107045c7d43b"><td class="memItemLeft" align="right" valign="top"><a id="a37af95890a678148aee6107045c7d43b" name="a37af95890a678148aee6107045c7d43b"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseMaxSimulationDepth</b> ()</td></tr>
<tr class="memdesc:a37af95890a678148aee6107045c7d43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum simulation depth. <br /></td></tr>
<tr class="separator:a37af95890a678148aee6107045c7d43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a233392deb63bc7f5ee8eb1739e8f28" id="r_a4a233392deb63bc7f5ee8eb1739e8f28"><td class="memItemLeft" align="right" valign="top"><a id="a4a233392deb63bc7f5ee8eb1739e8f28" name="a4a233392deb63bc7f5ee8eb1739e8f28"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseRefinementRatios</b> ()</td></tr>
<tr class="memdesc:a4a233392deb63bc7f5ee8eb1739e8f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse refinement ratios. <br /></td></tr>
<tr class="separator:a4a233392deb63bc7f5ee8eb1739e8f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1395b197e29ccb700e412f112cfa2fbb" id="r_a1395b197e29ccb700e412f112cfa2fbb"><td class="memItemLeft" align="right" valign="top"><a id="a1395b197e29ccb700e412f112cfa2fbb" name="a1395b197e29ccb700e412f112cfa2fbb"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseBrBufferSize</b> ()</td></tr>
<tr class="memdesc:a1395b197e29ccb700e412f112cfa2fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse buffer size for Berger-Rigoutsous grid algorithm. <br /></td></tr>
<tr class="separator:a1395b197e29ccb700e412f112cfa2fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e48f42538637c9afc04975cfc192e" id="r_ad40e48f42538637c9afc04975cfc192e"><td class="memItemLeft" align="right" valign="top"><a id="ad40e48f42538637c9afc04975cfc192e" name="ad40e48f42538637c9afc04975cfc192e"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseBrFillRatio</b> ()</td></tr>
<tr class="memdesc:ad40e48f42538637c9afc04975cfc192e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the Berger-Rigoutsos fill ratio. <br /></td></tr>
<tr class="separator:ad40e48f42538637c9afc04975cfc192e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f012242b01a0b252a8a513d3d2f6a4" id="r_a57f012242b01a0b252a8a513d3d2f6a4"><td class="memItemLeft" align="right" valign="top"><a id="a57f012242b01a0b252a8a513d3d2f6a4" name="a57f012242b01a0b252a8a513d3d2f6a4"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseMaxBoxSize</b> ()</td></tr>
<tr class="memdesc:a57f012242b01a0b252a8a513d3d2f6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the maximum permitted box size. <br /></td></tr>
<tr class="separator:a57f012242b01a0b252a8a513d3d2f6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add290a067d272d1e544cdedd2c54a896" id="r_add290a067d272d1e544cdedd2c54a896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#add290a067d272d1e544cdedd2c54a896">parseMaxEbisBoxSize</a> ()</td></tr>
<tr class="memdesc:add290a067d272d1e544cdedd2c54a896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the maximum permitted box size.  <br /></td></tr>
<tr class="separator:add290a067d272d1e544cdedd2c54a896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe173b70b8b8c15cfb7fd9caaadd77c4" id="r_abe173b70b8b8c15cfb7fd9caaadd77c4"><td class="memItemLeft" align="right" valign="top"><a id="abe173b70b8b8c15cfb7fd9caaadd77c4" name="abe173b70b8b8c15cfb7fd9caaadd77c4"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseBlockingFactor</b> ()</td></tr>
<tr class="memdesc:abe173b70b8b8c15cfb7fd9caaadd77c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the B-R blocking factor. For tiled mesh refinement this parses the tile size. <br /></td></tr>
<tr class="separator:abe173b70b8b8c15cfb7fd9caaadd77c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02dccfc4e434c6ee612908413498d50" id="r_ab02dccfc4e434c6ee612908413498d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab02dccfc4e434c6ee612908413498d50">parseEbGhostCells</a> ()</td></tr>
<tr class="memdesc:ab02dccfc4e434c6ee612908413498d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse number of ghost cells for eb stuff.  <br /></td></tr>
<tr class="separator:ab02dccfc4e434c6ee612908413498d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ec2b203e0b6b4c0b22ac3d3e126277" id="r_a60ec2b203e0b6b4c0b22ac3d3e126277"><td class="memItemLeft" align="right" valign="top"><a id="a60ec2b203e0b6b4c0b22ac3d3e126277" name="a60ec2b203e0b6b4c0b22ac3d3e126277"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseNumGhostCells</b> ()</td></tr>
<tr class="memdesc:a60ec2b203e0b6b4c0b22ac3d3e126277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the number of ghost cells. <br /></td></tr>
<tr class="separator:a60ec2b203e0b6b4c0b22ac3d3e126277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab035e11d56e0978fc386769706f5f40b" id="r_ab035e11d56e0978fc386769706f5f40b"><td class="memItemLeft" align="right" valign="top"><a id="ab035e11d56e0978fc386769706f5f40b" name="ab035e11d56e0978fc386769706f5f40b"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseMultigridInterpolator</b> ()</td></tr>
<tr class="memdesc:ab035e11d56e0978fc386769706f5f40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse settings for the multigrid interpolator. <br /></td></tr>
<tr class="separator:ab035e11d56e0978fc386769706f5f40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e931207fee7ef2897c99de6d8c5e819" id="r_a9e931207fee7ef2897c99de6d8c5e819"><td class="memItemLeft" align="right" valign="top"><a id="a9e931207fee7ef2897c99de6d8c5e819" name="a9e931207fee7ef2897c99de6d8c5e819"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseRedistributionRadius</b> ()</td></tr>
<tr class="memdesc:a9e931207fee7ef2897c99de6d8c5e819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the default redistribution radius. <br /></td></tr>
<tr class="separator:a9e931207fee7ef2897c99de6d8c5e819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fb548d469776e55ee3194bfb6a90d9" id="r_af1fb548d469776e55ee3194bfb6a90d9"><td class="memItemLeft" align="right" valign="top"><a id="af1fb548d469776e55ee3194bfb6a90d9" name="af1fb548d469776e55ee3194bfb6a90d9"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseCentroidStencils</b> ()</td></tr>
<tr class="memdesc:af1fb548d469776e55ee3194bfb6a90d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse centroid interpolation stencils. <br /></td></tr>
<tr class="separator:af1fb548d469776e55ee3194bfb6a90d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d87299e60f6cda07e9c4d00e7bbe8d" id="r_a40d87299e60f6cda07e9c4d00e7bbe8d"><td class="memItemLeft" align="right" valign="top"><a id="a40d87299e60f6cda07e9c4d00e7bbe8d" name="a40d87299e60f6cda07e9c4d00e7bbe8d"></a>
<a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseEbCentroidStencils</b> ()</td></tr>
<tr class="memdesc:a40d87299e60f6cda07e9c4d00e7bbe8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse EB interpolation (or extrapolation) stencils. <br /></td></tr>
<tr class="separator:a40d87299e60f6cda07e9c4d00e7bbe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8748090e8b37b8b2f678ce4002ebeb" id="r_a0a8748090e8b37b8b2f678ce4002ebeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0a8748090e8b37b8b2f678ce4002ebeb">computeGradient</a> (<a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_gradient</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;<a class="el" href="classTracerParticleSolver.html">a_phi</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> <a class="el" href="classTracerParticleSolver.html">a_realm</a>, <a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase <a class="el" href="classTracerParticleSolver.html">a_phase</a>, <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a> <a class="el" href="classTracerParticleSolver.html">a_lvl</a>) <a class="el" href="classTracerParticleSolver.html">const</a></td></tr>
<tr class="memdesc:a0a8748090e8b37b8b2f678ce4002ebeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell-centered gradient for a grid level.  <br /></td></tr>
<tr class="separator:a0a8748090e8b37b8b2f678ce4002ebeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aacde379809f5856a15d71f6d5c0056d6" id="r_aacde379809f5856a15d71f6d5c0056d6"><td class="memItemLeft" align="right" valign="top"><a id="aacde379809f5856a15d71f6d5c0056d6" name="aacde379809f5856a15d71f6d5c0056d6"></a>
<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classRealm.html">Realm</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_realms</b></td></tr>
<tr class="memdesc:aacde379809f5856a15d71f6d5c0056d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are all the Realms. <br /></td></tr>
<tr class="separator:aacde379809f5856a15d71f6d5c0056d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c109ce8345145d8d5373abf9c6280b" id="r_a93c109ce8345145d8d5373abf9c6280b"><td class="memItemLeft" align="right" valign="top"><a id="a93c109ce8345145d8d5373abf9c6280b" name="a93c109ce8345145d8d5373abf9c6280b"></a>
<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; phase::which_phase, <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; BaseIF &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_baseif</b></td></tr>
<tr class="memdesc:a93c109ce8345145d8d5373abf9c6280b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit functions. <br /></td></tr>
<tr class="separator:a93c109ce8345145d8d5373abf9c6280b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dee8155ef6b291c9a5ff85b39b4155" id="r_ac7dee8155ef6b291c9a5ff85b39b4155"><td class="memItemLeft" align="right" valign="top"><a id="ac7dee8155ef6b291c9a5ff85b39b4155" name="ac7dee8155ef6b291c9a5ff85b39b4155"></a>
<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">DisjointBoxLayout</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_oldGrids</b></td></tr>
<tr class="memdesc:ac7dee8155ef6b291c9a5ff85b39b4155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Old grids. <br /></td></tr>
<tr class="separator:ac7dee8155ef6b291c9a5ff85b39b4155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2169012fe5dc50728c7e9053483362" id="r_a0e2169012fe5dc50728c7e9053483362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Copier</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0e2169012fe5dc50728c7e9053483362">m_oldToNewCellCopiers</a></td></tr>
<tr class="memdesc:a0e2169012fe5dc50728c7e9053483362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for copiers from the old grids to the new ones.  <br /></td></tr>
<tr class="separator:a0e2169012fe5dc50728c7e9053483362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3919497262c0bbae39e0ca65ec1aa4" id="r_a8c3919497262c0bbae39e0ca65ec1aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Copier</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8c3919497262c0bbae39e0ca65ec1aa4">m_oldToNewEBCopiers</a></td></tr>
<tr class="memdesc:a8c3919497262c0bbae39e0ca65ec1aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for copiers from the old grids to the new ones.  <br /></td></tr>
<tr class="separator:a8c3919497262c0bbae39e0ca65ec1aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4c06b25de01bb1be380e84dc93dbc8" id="r_a5e4c06b25de01bb1be380e84dc93dbc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::pair</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &gt;, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Copier</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5e4c06b25de01bb1be380e84dc93dbc8">m_validToValidRealmCopiers</a></td></tr>
<tr class="memdesc:a5e4c06b25de01bb1be380e84dc93dbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map for copying between various Realms. First index is the "from" realm and second index is the "to" realm.  <br /></td></tr>
<tr class="separator:a5e4c06b25de01bb1be380e84dc93dbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74f5894b9a4eeebaa3cbb12ac2d0ab2" id="r_aa74f5894b9a4eeebaa3cbb12ac2d0ab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::pair</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &gt;, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Copier</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa74f5894b9a4eeebaa3cbb12ac2d0ab2">m_validToValidGhostRealmCopiers</a></td></tr>
<tr class="memdesc:aa74f5894b9a4eeebaa3cbb12ac2d0ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map for copying between various Realms. First index is the "from" realm and second index is the "to" realm.  <br /></td></tr>
<tr class="separator:aa74f5894b9a4eeebaa3cbb12ac2d0ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8d11b276504693095d4336c2b77c72" id="r_a5e8d11b276504693095d4336c2b77c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::pair</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &gt;, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Copier</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5e8d11b276504693095d4336c2b77c72">m_validGhostToValidRealmCopiers</a></td></tr>
<tr class="memdesc:a5e8d11b276504693095d4336c2b77c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map for copying between various Realms. First index is the "from" realm and second index is the "to" realm.  <br /></td></tr>
<tr class="separator:a5e8d11b276504693095d4336c2b77c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce4c98a9de19649eafaa1abd68e2866" id="r_a6ce4c98a9de19649eafaa1abd68e2866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::pair</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &gt;, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Copier</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6ce4c98a9de19649eafaa1abd68e2866">m_validGhostToValidGhostRealmCopiers</a></td></tr>
<tr class="memdesc:a6ce4c98a9de19649eafaa1abd68e2866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map for copying between various Realms. First index is the "from" realm and second index is the "to" realm.  <br /></td></tr>
<tr class="separator:a6ce4c98a9de19649eafaa1abd68e2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb87ee604d972a4afabc46eb48e2c4" id="r_a45cb87ee604d972a4afabc46eb48e2c4"><td class="memItemLeft" align="right" valign="top"><a id="a45cb87ee604d972a4afabc46eb48e2c4" name="a45cb87ee604d972a4afabc46eb48e2c4"></a>
<a class="el" href="classAmrMesh.html#a6b1adbb06620c67d0b168f649c796289">GridGenerationMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_gridGenerationMethod</b></td></tr>
<tr class="memdesc:a45cb87ee604d972a4afabc46eb48e2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid generation method. <br /></td></tr>
<tr class="separator:a45cb87ee604d972a4afabc46eb48e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4167481a292dba71d5d6a4a70f5d90" id="r_a7e4167481a292dba71d5d6a4a70f5d90"><td class="memItemLeft" align="right" valign="top"><a id="a7e4167481a292dba71d5d6a4a70f5d90" name="a7e4167481a292dba71d5d6a4a70f5d90"></a>
<a class="el" href="CD__BoxSorting_8H.html#ab5db8b3a96e3a04473aaa898f7eb2128">BoxSorting</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_boxSort</b></td></tr>
<tr class="memdesc:a7e4167481a292dba71d5d6a4a70f5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Box sorting. <br /></td></tr>
<tr class="separator:a7e4167481a292dba71d5d6a4a70f5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3102844226abdcb46fa75c97c33ae42b" id="r_a3102844226abdcb46fa75c97c33ae42b"><td class="memItemLeft" align="right" valign="top"><a id="a3102844226abdcb46fa75c97c33ae42b" name="a3102844226abdcb46fa75c97c33ae42b"></a>
<a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classMultiFluidIndexSpace.html">MultiFluidIndexSpace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_multifluidIndexSpace</b></td></tr>
<tr class="memdesc:a3102844226abdcb46fa75c97c33ae42b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMultiFluidIndexSpace.html" title="Two-fluid index space.">MultiFluidIndexSpace</a>. <br /></td></tr>
<tr class="separator:a3102844226abdcb46fa75c97c33ae42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddedc6810af3dc75b50cb6c66f44978" id="r_a7ddedc6810af3dc75b50cb6c66f44978"><td class="memItemLeft" align="right" valign="top"><a id="a7ddedc6810af3dc75b50cb6c66f44978" name="a7ddedc6810af3dc75b50cb6c66f44978"></a>
<a class="el" href="classIrregStencil.html#ac2a71148a30087346575360af4cacd6f">IrregStencil::StencilType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_stencilType</b></td></tr>
<tr class="memdesc:a7ddedc6810af3dc75b50cb6c66f44978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil type. <br /></td></tr>
<tr class="separator:a7ddedc6810af3dc75b50cb6c66f44978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2b00f54754547efee1e6ba8c5235bc" id="r_afb2b00f54754547efee1e6ba8c5235bc"><td class="memItemLeft" align="right" valign="top"><a id="afb2b00f54754547efee1e6ba8c5235bc" name="afb2b00f54754547efee1e6ba8c5235bc"></a>
<a class="el" href="classIrregStencil.html#ac2a71148a30087346575360af4cacd6f">IrregStencil::StencilType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_centroidStencilType</b></td></tr>
<tr class="memdesc:afb2b00f54754547efee1e6ba8c5235bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil type for centroid interpolation. <br /></td></tr>
<tr class="separator:afb2b00f54754547efee1e6ba8c5235bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae492d45eb81aa01d7d2e7a8921158508" id="r_ae492d45eb81aa01d7d2e7a8921158508"><td class="memItemLeft" align="right" valign="top"><a id="ae492d45eb81aa01d7d2e7a8921158508" name="ae492d45eb81aa01d7d2e7a8921158508"></a>
<a class="el" href="classIrregStencil.html#ac2a71148a30087346575360af4cacd6f">IrregStencil::StencilType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_ebCentroidStencilType</b></td></tr>
<tr class="memdesc:ae492d45eb81aa01d7d2e7a8921158508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil type for EB interpolation. <br /></td></tr>
<tr class="separator:ae492d45eb81aa01d7d2e7a8921158508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26419b21e9239407e5108f4ba7f1d773" id="r_a26419b21e9239407e5108f4ba7f1d773"><td class="memItemLeft" align="right" valign="top"><a id="a26419b21e9239407e5108f4ba7f1d773" name="a26419b21e9239407e5108f4ba7f1d773"></a>
<a class="el" href="classTracerParticleSolver.html">IntVect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_numCells</b></td></tr>
<tr class="memdesc:a26419b21e9239407e5108f4ba7f1d773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsest box where we compute. <br /></td></tr>
<tr class="separator:a26419b21e9239407e5108f4ba7f1d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b974f78b58899e25a439e47cdb15161" id="r_a1b974f78b58899e25a439e47cdb15161"><td class="memItemLeft" align="right" valign="top"><a id="a1b974f78b58899e25a439e47cdb15161" name="a1b974f78b58899e25a439e47cdb15161"></a>
<a class="el" href="classTracerParticleSolver.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_fillRatioBR</b></td></tr>
<tr class="memdesc:a1b974f78b58899e25a439e47cdb15161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill ratio. <br /></td></tr>
<tr class="separator:a1b974f78b58899e25a439e47cdb15161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c4af19deea668e528e1539492ba6a7" id="r_a32c4af19deea668e528e1539492ba6a7"><td class="memItemLeft" align="right" valign="top"><a id="a32c4af19deea668e528e1539492ba6a7" name="a32c4af19deea668e528e1539492ba6a7"></a>
<a class="el" href="classTracerParticleSolver.html">RealVect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_probLo</b></td></tr>
<tr class="memdesc:a32c4af19deea668e528e1539492ba6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain simulation corner. <br /></td></tr>
<tr class="separator:a32c4af19deea668e528e1539492ba6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29140588beef4314843c96c03a5e700f" id="r_a29140588beef4314843c96c03a5e700f"><td class="memItemLeft" align="right" valign="top"><a id="a29140588beef4314843c96c03a5e700f" name="a29140588beef4314843c96c03a5e700f"></a>
<a class="el" href="classTracerParticleSolver.html">RealVect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_probHi</b></td></tr>
<tr class="memdesc:a29140588beef4314843c96c03a5e700f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain simulation corner. <br /></td></tr>
<tr class="separator:a29140588beef4314843c96c03a5e700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cf1b204e7125308d078061d54ef2c7" id="r_a07cf1b204e7125308d078061d54ef2c7"><td class="memItemLeft" align="right" valign="top"><a id="a07cf1b204e7125308d078061d54ef2c7" name="a07cf1b204e7125308d078061d54ef2c7"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_refRatio</b></td></tr>
<tr class="memdesc:a07cf1b204e7125308d078061d54ef2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement ratio. <br /></td></tr>
<tr class="separator:a07cf1b204e7125308d078061d54ef2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50336ab4f43dc66bf6f5ee8fde4a9acd" id="r_a50336ab4f43dc66bf6f5ee8fde4a9acd"><td class="memItemLeft" align="right" valign="top"><a id="a50336ab4f43dc66bf6f5ee8fde4a9acd" name="a50336ab4f43dc66bf6f5ee8fde4a9acd"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_verbosity</b></td></tr>
<tr class="memdesc:a50336ab4f43dc66bf6f5ee8fde4a9acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verbosity. <br /></td></tr>
<tr class="separator:a50336ab4f43dc66bf6f5ee8fde4a9acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836d00237da8ce294102747a9ad27439" id="r_a836d00237da8ce294102747a9ad27439"><td class="memItemLeft" align="right" valign="top"><a id="a836d00237da8ce294102747a9ad27439" name="a836d00237da8ce294102747a9ad27439"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_finestLevel</b></td></tr>
<tr class="memdesc:a836d00237da8ce294102747a9ad27439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finest level. <br /></td></tr>
<tr class="separator:a836d00237da8ce294102747a9ad27439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234e7a64df9cdfe0cba4bc8375c9c9f2" id="r_a234e7a64df9cdfe0cba4bc8375c9c9f2"><td class="memItemLeft" align="right" valign="top"><a id="a234e7a64df9cdfe0cba4bc8375c9c9f2" name="a234e7a64df9cdfe0cba4bc8375c9c9f2"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_oldFinestLevel</b></td></tr>
<tr class="memdesc:a234e7a64df9cdfe0cba4bc8375c9c9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finest level before a regrid. <br /></td></tr>
<tr class="separator:a234e7a64df9cdfe0cba4bc8375c9c9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82395aa042ef543322cbfee5b05be1d3" id="r_a82395aa042ef543322cbfee5b05be1d3"><td class="memItemLeft" align="right" valign="top"><a id="a82395aa042ef543322cbfee5b05be1d3" name="a82395aa042ef543322cbfee5b05be1d3"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxAmrDepth</b></td></tr>
<tr class="memdesc:a82395aa042ef543322cbfee5b05be1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum amr depth. <br /></td></tr>
<tr class="separator:a82395aa042ef543322cbfee5b05be1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd7ea7c8886171bd2533b6ec39c7f3" id="r_a3cdd7ea7c8886171bd2533b6ec39c7f3"><td class="memItemLeft" align="right" valign="top"><a id="a3cdd7ea7c8886171bd2533b6ec39c7f3" name="a3cdd7ea7c8886171bd2533b6ec39c7f3"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxSimulationDepth</b></td></tr>
<tr class="memdesc:a3cdd7ea7c8886171bd2533b6ec39c7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed depth for simulation. <br /></td></tr>
<tr class="separator:a3cdd7ea7c8886171bd2533b6ec39c7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b355417f9a9dca3aaabdc0c3aae47f3" id="r_a2b355417f9a9dca3aaabdc0c3aae47f3"><td class="memItemLeft" align="right" valign="top"><a id="a2b355417f9a9dca3aaabdc0c3aae47f3" name="a2b355417f9a9dca3aaabdc0c3aae47f3"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxBoxSize</b></td></tr>
<tr class="memdesc:a2b355417f9a9dca3aaabdc0c3aae47f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max box size. <br /></td></tr>
<tr class="separator:a2b355417f9a9dca3aaabdc0c3aae47f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68cd81210ec67a38e8c85dfe24c594f" id="r_af68cd81210ec67a38e8c85dfe24c594f"><td class="memItemLeft" align="right" valign="top"><a id="af68cd81210ec67a38e8c85dfe24c594f" name="af68cd81210ec67a38e8c85dfe24c594f"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxEbisBoxSize</b></td></tr>
<tr class="memdesc:af68cd81210ec67a38e8c85dfe24c594f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum box size for EBIS generation. <br /></td></tr>
<tr class="separator:af68cd81210ec67a38e8c85dfe24c594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3496bd4e53289c5636ea90b97b837545" id="r_a3496bd4e53289c5636ea90b97b837545"><td class="memItemLeft" align="right" valign="top"><a id="a3496bd4e53289c5636ea90b97b837545" name="a3496bd4e53289c5636ea90b97b837545"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_bufferSizeBR</b></td></tr>
<tr class="memdesc:a3496bd4e53289c5636ea90b97b837545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer size. <br /></td></tr>
<tr class="separator:a3496bd4e53289c5636ea90b97b837545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b28d2dedb85c12c6f4cd7ec0fc7325" id="r_ab6b28d2dedb85c12c6f4cd7ec0fc7325"><td class="memItemLeft" align="right" valign="top"><a id="ab6b28d2dedb85c12c6f4cd7ec0fc7325" name="ab6b28d2dedb85c12c6f4cd7ec0fc7325"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_blockingFactor</b></td></tr>
<tr class="memdesc:ab6b28d2dedb85c12c6f4cd7ec0fc7325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking factor. <br /></td></tr>
<tr class="separator:ab6b28d2dedb85c12c6f4cd7ec0fc7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d5cb0ef5642c27c6c485b81652eaa1" id="r_a78d5cb0ef5642c27c6c485b81652eaa1"><td class="memItemLeft" align="right" valign="top"><a id="a78d5cb0ef5642c27c6c485b81652eaa1" name="a78d5cb0ef5642c27c6c485b81652eaa1"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_numEbGhostsCells</b></td></tr>
<tr class="memdesc:a78d5cb0ef5642c27c6c485b81652eaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost cells to use for eb stuff. <br /></td></tr>
<tr class="separator:a78d5cb0ef5642c27c6c485b81652eaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6859cfe9346388b089a4bdb324d2d019" id="r_a6859cfe9346388b089a4bdb324d2d019"><td class="memItemLeft" align="right" valign="top"><a id="a6859cfe9346388b089a4bdb324d2d019" name="a6859cfe9346388b089a4bdb324d2d019"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_numGhostCells</b></td></tr>
<tr class="memdesc:a6859cfe9346388b089a4bdb324d2d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost cells. <br /></td></tr>
<tr class="separator:a6859cfe9346388b089a4bdb324d2d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb0c9bbc493aa6d83ca0a97cf919c70" id="r_affb0c9bbc493aa6d83ca0a97cf919c70"><td class="memItemLeft" align="right" valign="top"><a id="affb0c9bbc493aa6d83ca0a97cf919c70" name="affb0c9bbc493aa6d83ca0a97cf919c70"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_numLsfGhostCells</b></td></tr>
<tr class="memdesc:affb0c9bbc493aa6d83ca0a97cf919c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost cells to use when writing level-set to grid. <br /></td></tr>
<tr class="separator:affb0c9bbc493aa6d83ca0a97cf919c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb291dba0cc74ada1f95640077ea494" id="r_a5bb291dba0cc74ada1f95640077ea494"><td class="memItemLeft" align="right" valign="top"><a id="a5bb291dba0cc74ada1f95640077ea494" name="a5bb291dba0cc74ada1f95640077ea494"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_multigridInterpOrder</b></td></tr>
<tr class="memdesc:a5bb291dba0cc74ada1f95640077ea494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid interpolation order. <br /></td></tr>
<tr class="separator:a5bb291dba0cc74ada1f95640077ea494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419a9ee9c2d3b16a2466dafff0c5c0f2" id="r_a419a9ee9c2d3b16a2466dafff0c5c0f2"><td class="memItemLeft" align="right" valign="top"><a id="a419a9ee9c2d3b16a2466dafff0c5c0f2" name="a419a9ee9c2d3b16a2466dafff0c5c0f2"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_multigridInterpRadius</b></td></tr>
<tr class="memdesc:a419a9ee9c2d3b16a2466dafff0c5c0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid interpolation radius. <br /></td></tr>
<tr class="separator:a419a9ee9c2d3b16a2466dafff0c5c0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d601f57b4a712db238cd5301636ff3" id="r_ac7d601f57b4a712db238cd5301636ff3"><td class="memItemLeft" align="right" valign="top"><a id="ac7d601f57b4a712db238cd5301636ff3" name="ac7d601f57b4a712db238cd5301636ff3"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_multigridInterpWeight</b></td></tr>
<tr class="memdesc:ac7d601f57b4a712db238cd5301636ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid interpolation weights. <br /></td></tr>
<tr class="separator:ac7d601f57b4a712db238cd5301636ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4be2723b347e649654ab7cb8f84b6f" id="r_aff4be2723b347e649654ab7cb8f84b6f"><td class="memItemLeft" align="right" valign="top"><a id="aff4be2723b347e649654ab7cb8f84b6f" name="aff4be2723b347e649654ab7cb8f84b6f"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_redistributionRadius</b></td></tr>
<tr class="memdesc:aff4be2723b347e649654ab7cb8f84b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribution radius. <br /></td></tr>
<tr class="separator:aff4be2723b347e649654ab7cb8f84b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6e06b89404fbb52f7e4886c6aed004" id="r_a2d6e06b89404fbb52f7e4886c6aed004"><td class="memItemLeft" align="right" valign="top"><a id="a2d6e06b89404fbb52f7e4886c6aed004" name="a2d6e06b89404fbb52f7e4886c6aed004"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_centroidStencilOrder</b></td></tr>
<tr class="memdesc:a2d6e06b89404fbb52f7e4886c6aed004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order for interpolation stencils to centroids. <br /></td></tr>
<tr class="separator:a2d6e06b89404fbb52f7e4886c6aed004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8713127781f8c965ccd1c98b63dac5" id="r_a5d8713127781f8c965ccd1c98b63dac5"><td class="memItemLeft" align="right" valign="top"><a id="a5d8713127781f8c965ccd1c98b63dac5" name="a5d8713127781f8c965ccd1c98b63dac5"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_centroidStencilRadius</b></td></tr>
<tr class="memdesc:a5d8713127781f8c965ccd1c98b63dac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius for centroid interpolation stencil. <br /></td></tr>
<tr class="separator:a5d8713127781f8c965ccd1c98b63dac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa459d5ca131c5f8c97c61ae7830437bb" id="r_aa459d5ca131c5f8c97c61ae7830437bb"><td class="memItemLeft" align="right" valign="top"><a id="aa459d5ca131c5f8c97c61ae7830437bb" name="aa459d5ca131c5f8c97c61ae7830437bb"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_ebCentroidStencilOrder</b></td></tr>
<tr class="memdesc:aa459d5ca131c5f8c97c61ae7830437bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order for interpolation stencilst to EB. <br /></td></tr>
<tr class="separator:aa459d5ca131c5f8c97c61ae7830437bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d85fcac14583ec31cebae2c77da39" id="r_a433d85fcac14583ec31cebae2c77da39"><td class="memItemLeft" align="right" valign="top"><a id="a433d85fcac14583ec31cebae2c77da39" name="a433d85fcac14583ec31cebae2c77da39"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_ebCentroidStencilRadius</b></td></tr>
<tr class="memdesc:a433d85fcac14583ec31cebae2c77da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius for EB interpolation stencil. <br /></td></tr>
<tr class="separator:a433d85fcac14583ec31cebae2c77da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dc909ecfabbc7eaeb976ca587ad75c" id="r_ac0dc909ecfabbc7eaeb976ca587ad75c"><td class="memItemLeft" align="right" valign="top"><a id="ac0dc909ecfabbc7eaeb976ca587ad75c" name="ac0dc909ecfabbc7eaeb976ca587ad75c"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_irregStenOrder</b></td></tr>
<tr class="memdesc:ac0dc909ecfabbc7eaeb976ca587ad75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil order for irregular stencils. <br /></td></tr>
<tr class="separator:ac0dc909ecfabbc7eaeb976ca587ad75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d51f9deb305d018b7886b63e5ea130" id="r_ac1d51f9deb305d018b7886b63e5ea130"><td class="memItemLeft" align="right" valign="top"><a id="ac1d51f9deb305d018b7886b63e5ea130" name="ac1d51f9deb305d018b7886b63e5ea130"></a>
<a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_irregStenRadius</b></td></tr>
<tr class="memdesc:ac1d51f9deb305d018b7886b63e5ea130"><td class="mdescLeft">&#160;</td><td class="mdescRight">radius for irregular stencils <br /></td></tr>
<tr class="separator:ac1d51f9deb305d018b7886b63e5ea130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fb5e315cfc9e853def28d39c4259f1" id="r_ae2fb5e315cfc9e853def28d39c4259f1"><td class="memItemLeft" align="right" valign="top"><a id="ae2fb5e315cfc9e853def28d39c4259f1" name="ae2fb5e315cfc9e853def28d39c4259f1"></a>
<a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_hasGrids</b></td></tr>
<tr class="memdesc:ae2fb5e315cfc9e853def28d39c4259f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has grids or not. <br /></td></tr>
<tr class="separator:ae2fb5e315cfc9e853def28d39c4259f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561e57718876fd11fcf3129004b4a27e" id="r_a561e57718876fd11fcf3129004b4a27e"><td class="memItemLeft" align="right" valign="top"><a id="a561e57718876fd11fcf3129004b4a27e" name="a561e57718876fd11fcf3129004b4a27e"></a>
<a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_hasRegridCopiers</b></td></tr>
<tr class="memdesc:a561e57718876fd11fcf3129004b4a27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has regrid copiers or not. <br /></td></tr>
<tr class="separator:a561e57718876fd11fcf3129004b4a27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b7f70026f6bcf705bcfc9770730417" id="r_a30b7f70026f6bcf705bcfc9770730417"><td class="memItemLeft" align="right" valign="top"><a id="a30b7f70026f6bcf705bcfc9770730417" name="a30b7f70026f6bcf705bcfc9770730417"></a>
<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">DisjointBoxLayout</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_grids</b></td></tr>
<tr class="memdesc:a30b7f70026f6bcf705bcfc9770730417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grids. <br /></td></tr>
<tr class="separator:a30b7f70026f6bcf705bcfc9770730417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6264ea87b2d6fc5803f7ac01ba9219e" id="r_ad6264ea87b2d6fc5803f7ac01ba9219e"><td class="memItemLeft" align="right" valign="top"><a id="ad6264ea87b2d6fc5803f7ac01ba9219e" name="ad6264ea87b2d6fc5803f7ac01ba9219e"></a>
<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">ProblemDomain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_domains</b></td></tr>
<tr class="memdesc:ad6264ea87b2d6fc5803f7ac01ba9219e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem domains. <br /></td></tr>
<tr class="separator:ad6264ea87b2d6fc5803f7ac01ba9219e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a46b00edbd08fb6f3851035d7d2520a" id="r_a4a46b00edbd08fb6f3851035d7d2520a"><td class="memItemLeft" align="right" valign="top"><a id="a4a46b00edbd08fb6f3851035d7d2520a" name="a4a46b00edbd08fb6f3851035d7d2520a"></a>
<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_refinementRatios</b></td></tr>
<tr class="memdesc:a4a46b00edbd08fb6f3851035d7d2520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMR resolutions. <br /></td></tr>
<tr class="separator:a4a46b00edbd08fb6f3851035d7d2520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496a7ae2b97d7e6b609c82a22586433" id="r_a7496a7ae2b97d7e6b609c82a22586433"><td class="memItemLeft" align="right" valign="top"><a id="a7496a7ae2b97d7e6b609c82a22586433" name="a7496a7ae2b97d7e6b609c82a22586433"></a>
<a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_dx</b></td></tr>
<tr class="memdesc:a7496a7ae2b97d7e6b609c82a22586433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level resolutions. <br /></td></tr>
<tr class="separator:a7496a7ae2b97d7e6b609c82a22586433"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for handling spatial operations. </p>
<p>This class handles most (if not all) spatial operations. Examples are grid generation, coarsening of data, interpolation of data, memory allocations etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad3dbdbd76308b0f823ac99ba8c96b030" name="ad3dbdbd76308b0f823ac99ba8c96b030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dbdbd76308b0f823ac99ba8c96b030">&#9670;&#160;</a></span>AmrMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AmrMesh::AmrMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169cb0dcdb19e5bf08061ac7fd6b5780" name="a169cb0dcdb19e5bf08061ac7fd6b5780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169cb0dcdb19e5bf08061ac7fd6b5780">&#9670;&#160;</a></span>AmrMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AmrMesh::AmrMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a82fe5b8146a945e4fe8911fbb57494e7" name="a82fe5b8146a945e4fe8911fbb57494e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fe5b8146a945e4fe8911fbb57494e7">&#9670;&#160;</a></span>alias() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single-phase alias of the multifluid data, having the same size as the input data. </dd></dl>

</div>
</div>
<a id="a5f0d11dbe8ad04d37008c260df025374" name="a5f0d11dbe8ad04d37008c260df025374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0d11dbe8ad04d37008c260df025374">&#9670;&#160;</a></span>alias() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single-phase alias of the multifluid data, having the same size as the input data. </dd></dl>

</div>
</div>
<a id="abd8da582e3c2910ba6c168e6a24d5679" name="abd8da582e3c2910ba6c168e6a24d5679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8da582e3c2910ba6c168e6a24d5679">&#9670;&#160;</a></span>alias() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single-phase alias of the multifluid data, having the same size as the input data. </dd></dl>

</div>
</div>
<a id="a9bd8f12c2f367eaed5f168dfc54bd275" name="a9bd8f12c2f367eaed5f168dfc54bd275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd8f12c2f367eaed5f168dfc54bd275">&#9670;&#160;</a></span>alias() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e0c09b67c82352fe4ebd4f9f6ae5fbc" name="a5e0c09b67c82352fe4ebd4f9f6ae5fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0c09b67c82352fe4ebd4f9f6ae5fbc">&#9670;&#160;</a></span>alias() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias multifluid data up to a specified level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Maximum grid level for aliasing operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a648c7a7cb2e3783a26312d3533f4cb0f" name="a648c7a7cb2e3783a26312d3533f4cb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c7a7cb2e3783a26312d3533f4cb0f">&#9670;&#160;</a></span>alias() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e201260012be3d1709f86689af5abf0" name="a3e201260012be3d1709f86689af5abf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e201260012be3d1709f86689af5abf0">&#9670;&#160;</a></span>alias() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias multifluid data up to a specified level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Maximum grid level for aliasing operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a567e5bc873abc63dc52aee60efa1ba44" name="a567e5bc873abc63dc52aee60efa1ba44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567e5bc873abc63dc52aee60efa1ba44">&#9670;&#160;</a></span>alias() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add7129b60d83999a8e9ebb473987a8f4" name="add7129b60d83999a8e9ebb473987a8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7129b60d83999a8e9ebb473987a8f4">&#9670;&#160;</a></span>alias() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T , <a class="el" href="classTracerParticleSolver.html">typename</a> <a class="el" href="classTracerParticleSolver.html">S</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; <a class="el" href="classTracerParticleSolver.html">S</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn smart-pointer data structure into regular-pointer data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_alias</td><td>Raw pointer aliased </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Smart-pointer data</td></tr>
  </table>
  </dd>
</dl>
<p>This fetches the bare pointer from a_data and sets it in a_alias. </p>

</div>
</div>
<a id="adf3ddc1a34de9ef274d73256add61232" name="adf3ddc1a34de9ef274d73256add61232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3ddc1a34de9ef274d73256add61232">&#9670;&#160;</a></span>alias() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn smart-pointer data structure into regular-pointer data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_alias</td><td>Raw pointer aliased </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Smart-pointer data</td></tr>
  </table>
  </dd>
</dl>
<p>This fetches the bare pointer from a_data and sets it in a_alias. </p>

</div>
</div>
<a id="af5c89795f369b846f251f1fec56c48a5" name="af5c89795f369b846f251f1fec56c48a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c89795f369b846f251f1fec56c48a5">&#9670;&#160;</a></span>allocate() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRBool</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate Boolean data over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a97a408d2381f605f562b01a7de04ef2c" name="a97a408d2381f605f562b01a7de04ef2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a408d2381f605f562b01a7de04ef2c">&#9670;&#160;</a></span>allocate() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a8000cf94e2d87a651cf49c7e853ce6f4" name="a8000cf94e2d87a651cf49c7e853ce6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8000cf94e2d87a651cf49c7e853ce6f4">&#9670;&#160;</a></span>allocate() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a74ebef713ce593b19fe2ffbbba9ce2ea" name="a74ebef713ce593b19fe2ffbbba9ce2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ebef713ce593b19fe2ffbbba9ce2ea">&#9670;&#160;</a></span>allocate() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a4e05b28f775f47845a231661f708c963" name="a4e05b28f775f47845a231661f708c963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e05b28f775f47845a231661f708c963">&#9670;&#160;</a></span>allocate() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a6eda2721c69cdd09b48dd604ede5a769" name="a6eda2721c69cdd09b48dd604ede5a769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eda2721c69cdd09b48dd604ede5a769">&#9670;&#160;</a></span>allocate() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate data on specific level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>AMR level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a02342a1d423fc64ed7bd1d3f08fafae6" name="a02342a1d423fc64ed7bd1d3f08fafae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02342a1d423fc64ed7bd1d3f08fafae6">&#9670;&#160;</a></span>allocate() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a6a666605ffc876316d34fe42318a13bb" name="a6a666605ffc876316d34fe42318a13bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a666605ffc876316d34fe42318a13bb">&#9670;&#160;</a></span>allocate() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_ghost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a5010f466f55bebc90afc212bd78e494c" name="a5010f466f55bebc90afc212bd78e494c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5010f466f55bebc90afc212bd78e494c">&#9670;&#160;</a></span>allocate() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_ghost</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a14f77ca80a54f034ec88ad6451677757" name="a14f77ca80a54f034ec88ad6451677757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f77ca80a54f034ec88ad6451677757">&#9670;&#160;</a></span>allocate() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template class for generic allocation of particle containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_container</td><td>Particle container to be allocated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> on which the particles will be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9efee08ad6a36b934fbd15283be5f48e" name="a9efee08ad6a36b934fbd15283be5f48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efee08ad6a36b934fbd15283be5f48e">&#9670;&#160;</a></span>allocate() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">ParticleData</a>&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template class for generic allocation of particle data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_particles</td><td>Particle data holder. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> on which the particles will be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a141a99f99626423405e502361000a9c0" name="a141a99f99626423405e502361000a9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141a99f99626423405e502361000a9c0">&#9670;&#160;</a></span>allocatePointer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocatePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate pointer but not any memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data structure for which pointers will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> associated with the data</td></tr>
  </table>
  </dd>
</dl>
<p>This sets all the elements in a_data to be RefCountedPtr&lt;T&gt;(nullptr) </p>

</div>
</div>
<a id="a25fc14c3621ffc8935c074024b067452" name="a25fc14c3621ffc8935c074024b067452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fc14c3621ffc8935c074024b067452">&#9670;&#160;</a></span>allocatePointer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocatePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate pointer but not any memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data structure for which pointers will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> associated with the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Finest grid level on which a_data will be defined.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets all the elements in the vector to be RefCountedPtr&lt;T&gt;(nullptr) </p>

</div>
</div>
<a id="a0eb01d4e408f7f60da0197fec9941edc" name="a0eb01d4e408f7f60da0197fec9941edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb01d4e408f7f60da0197fec9941edc">&#9670;&#160;</a></span>allocatePointer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocatePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate pointer but not any memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data structure for which pointers will be constructed.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets all the elements in the vector to be RefCountedPtr&lt;T&gt;(nullptr) </p>

</div>
</div>
<a id="ab41a86c671f5b090c19b4a604443c28f" name="ab41a86c671f5b090c19b4a604443c28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41a86c671f5b090c19b4a604443c28f">&#9670;&#160;</a></span>allocatePointer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::allocatePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate pointer but not any memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data structure for which pointers will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Finest grid level on which a_data will be defined.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets all the elements in the vector to be RefCountedPtr&lt;T&gt;(nullptr) </p>

</div>
</div>
<a id="af6eb5733b4a2fce7c522c37d3c1347ff" name="af6eb5733b4a2fce7c522c37d3c1347ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6eb5733b4a2fce7c522c37d3c1347ff">&#9670;&#160;</a></span>arithmeticAverage() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic average of data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57c8382e0e99edfdbf353d60b46d41ba" name="a57c8382e0e99edfdbf353d60b46d41ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c8382e0e99edfdbf353d60b46d41ba">&#9670;&#160;</a></span>arithmeticAverage() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic average of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdb661908599529bdc686d2de016a16f" name="abdb661908599529bdc686d2de016a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb661908599529bdc686d2de016a16f">&#9670;&#160;</a></span>arithmeticAverage() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<p>This computes an arithmetic average of the face data. Data on coarse faces is replaced by the arithmetic average of the fine face data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be average. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bbddcd21848988ec71d1525f80076bc" name="a2bbddcd21848988ec71d1525f80076bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbddcd21848988ec71d1525f80076bc">&#9670;&#160;</a></span>arithmeticAverage() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic average on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41c3e36e18a1b3feefe1bc12e0b59a8d" name="a41c3e36e18a1b3feefe1bc12e0b59a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c3e36e18a1b3feefe1bc12e0b59a8d">&#9670;&#160;</a></span>arithmeticAverage() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic coarsening of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad64caac626d5f6846785a8ad7a855303" name="ad64caac626d5f6846785a8ad7a855303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64caac626d5f6846785a8ad7a855303">&#9670;&#160;</a></span>arithmeticAverage() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average multifluid data over a realm. </p>
<p>This computes an arithmetic average of the face data. Data on coarse faces is replaced by the arithmetic average of the fine face data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6540dc8db6193a32c989936f8b47da1" name="af6540dc8db6193a32c989936f8b47da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6540dc8db6193a32c989936f8b47da1">&#9670;&#160;</a></span>average() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa07eed6758ee76431667b3832f36b966" name="aa07eed6758ee76431667b3832f36b966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07eed6758ee76431667b3832f36b966">&#9670;&#160;</a></span>average() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables to average </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1459b80feff30769ea928f10907fcc89" name="a1459b80feff30769ea928f10907fcc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1459b80feff30769ea928f10907fcc89">&#9670;&#160;</a></span>average() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc3a4063ef5b08f363743daa70496b45" name="acc3a4063ef5b08f363743daa70496b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3a4063ef5b08f363743daa70496b45">&#9670;&#160;</a></span>average() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9db6f208842207e02524d7cc61d0961" name="ac9db6f208842207e02524d7cc61d0961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9db6f208842207e02524d7cc61d0961">&#9670;&#160;</a></span>average() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average multifluid data over a specified realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35796165052eb306d772d0471eca391b" name="a35796165052eb306d772d0471eca391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35796165052eb306d772d0471eca391b">&#9670;&#160;</a></span>average() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average multifluid data over a specified realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69e4f0db7383a8a926a9bcb59defb67e" name="a69e4f0db7383a8a926a9bcb59defb67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e4f0db7383a8a926a9bcb59defb67e">&#9670;&#160;</a></span>buildGrids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::buildGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">IntVectSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_hardcap</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build new internal AMR grids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_tags</td><td>Sets of cell tags used for the grid generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The finest grid level which changes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hardcap</td><td>Hardcap for the maximum grid level which can be generated. If a_hardcap &lt; 0 there is no restriction beyond the <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> restrictions.</td></tr>
  </table>
  </dd>
</dl>
<p>This will call the specified grid generation method and fill m_grids with the new grids. </p>

</div>
</div>
<a id="a03736c8164011068783b32d6c0342caf" name="a03736c8164011068783b32d6c0342caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03736c8164011068783b32d6c0342caf">&#9670;&#160;</a></span>computeGradient() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute cell-centered gradient over an AMR hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Cell centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the realm where the data lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells are updated before using this routine. </dd></dl>

</div>
</div>
<a id="a5468ec45f9d206c1d2d99fd74cf42521" name="a5468ec45f9d206c1d2d99fd74cf42521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5468ec45f9d206c1d2d99fd74cf42521">&#9670;&#160;</a></span>computeGradient() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute face-centered gradient over an AMR hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Face centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the realm where the data lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells are updated before using this routine. </dd></dl>

</div>
</div>
<a id="a0a8748090e8b37b8b2f678ce4002ebeb" name="a0a8748090e8b37b8b2f678ce4002ebeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8748090e8b37b8b2f678ce4002ebeb">&#9670;&#160;</a></span>computeGradient() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell-centered gradient for a grid level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Cell centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the realm where the data lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which the data lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level where the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells updated before using this routine. </dd></dl>

</div>
</div>
<a id="adc77b754e28f3212863848aaba964db5" name="adc77b754e28f3212863848aaba964db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc77b754e28f3212863848aaba964db5">&#9670;&#160;</a></span>computeGradient() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute cell-centered gradient over an AMR hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Cell centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells are updated before using this routine. </dd></dl>

</div>
</div>
<a id="a9e4b4cd76b62eaaca138fbdcd5ec3090" name="a9e4b4cd76b62eaaca138fbdcd5ec3090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4b4cd76b62eaaca138fbdcd5ec3090">&#9670;&#160;</a></span>computeGradient() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute face-centered gradient over an AMR hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Face centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells are updated before using this routine. </dd></dl>

</div>
</div>
<a id="aae69d99efb79d91bbf8ddfa33b61ab0f" name="aae69d99efb79d91bbf8ddfa33b61ab0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae69d99efb79d91bbf8ddfa33b61ab0f">&#9670;&#160;</a></span>conservativeAverage() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conseratively average data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bd84b6a06ba937f38448a89a3f6882b" name="a0bd84b6a06ba937f38448a89a3f6882b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd84b6a06ba937f38448a89a3f6882b">&#9670;&#160;</a></span>conservativeAverage() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conseratively average data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af32fe0c1d230d0a0dadee647d7d2730b" name="af32fe0c1d230d0a0dadee647d7d2730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32fe0c1d230d0a0dadee647d7d2730b">&#9670;&#160;</a></span>conservativeAverage() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ebca4c73310fecee761a9f74b8fe01" name="ae9ebca4c73310fecee761a9f74b8fe01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ebca4c73310fecee761a9f74b8fe01">&#9670;&#160;</a></span>conservativeAverage() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conservative averaging on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53b3f8d395e81592ba629ebc11b9141e" name="a53b3f8d395e81592ba629ebc11b9141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b3f8d395e81592ba629ebc11b9141e">&#9670;&#160;</a></span>conservativeAverage() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conservative coarsening of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabe7ab07b30103513af9784864aba639" name="aabe7ab07b30103513af9784864aba639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe7ab07b30103513af9784864aba639">&#9670;&#160;</a></span>conservativeAverage() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down multifluid data over a realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2354431a853db080b55495a7b20f4512" name="a2354431a853db080b55495a7b20f4512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2354431a853db080b55495a7b20f4512">&#9670;&#160;</a></span>copyData() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>a_toRegion</em> = <code>CopyStrategy::Valid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>a_fromRegion</em> = <code>CopyStrategy::Valid</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for copying from a source container to a destination container. User supplies information about from/to regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_dst</td><td>Destination data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_src</td><td>Source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_toRegion</td><td>Region we copy into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fromRegion</td><td>Region we copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the user requests copying into ghosted regions, the Copiers MUST USE THE CORRECT NUMBER OF GHOST CELLS </dd>
<dd>
This routine will not work if copying between grids before/after regrids. </dd></dl>

</div>
</div>
<a id="a66c261aa8445bbe634131faf865dee15" name="a66c261aa8445bbe634131faf865dee15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c261aa8445bbe634131faf865dee15">&#9670;&#160;</a></span>copyData() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>a_dstComps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>a_srcComps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>a_toRegion</em> = <code>CopyStrategy::Valid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>a_fromRegion</em> = <code>CopyStrategy::Valid</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for copying from a source container to a destination container. User supplies information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_dst</td><td>Destination data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_src</td><td>Source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dstComps</td><td>Destination components </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_srcComps</td><td>Source components </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_toRegion</td><td>Region we copy into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fromRegion</td><td>Region we copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the user requests copying into ghosted regions, the Copiers MUST USE THE CORRECT NUMBER OF GHOST CELLS </dd>
<dd>
This routine will not work if copying between grids before/after regrids. </dd></dl>

</div>
</div>
<a id="a6e2fbca514264f27a0106a49df839ae5" name="a6e2fbca514264f27a0106a49df839ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2fbca514264f27a0106a49df839ae5">&#9670;&#160;</a></span>copyData() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_toRealm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_fromRealm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>a_toRegion</em> = <code>CopyStrategy::Valid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>a_fromRegion</em> = <code>CopyStrategy::Valid</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for copying from a source container to a destination container. User supplies information about from/to regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_dst</td><td>Destination data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_src</td><td>Source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_toRealm</td><td>Destination realm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fromRealm</td><td>Source realm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fromRegion</td><td>Region we copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_toRegion</td><td>Region we copy into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the user requests copying into ghosted regions, the Copiers MUST USE THE CORRECT NUMBER OF GHOST CELLS </dd>
<dd>
This routine will not work if copying between grids before/after regrids. </dd></dl>

</div>
</div>
<a id="a7f0ceb890b1dde44995215e93f514180" name="a7f0ceb890b1dde44995215e93f514180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0ceb890b1dde44995215e93f514180">&#9670;&#160;</a></span>copyData() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_toRealm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_fromRealm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>a_dstComps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>a_srcComps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>a_toRegion</em> = <code>CopyStrategy::Valid</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CopyStrategy_8H.html#a5bce9d77ba68a01d7c2644c2d8fd83b6">CopyStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>a_fromRegion</em> = <code>CopyStrategy::Valid</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for copying from a source container to a destination container. User supplies information about from/to regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_dst</td><td>Destination data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_src</td><td>Source data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_toRealm</td><td>Destination realm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fromRealm</td><td>Source realm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dstComps</td><td>Destination components </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_srcComps</td><td>Source components </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fromRegion</td><td>Region we copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_toRegion</td><td>Region we copy into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the user requests copying into ghosted regions, the Copiers MUST USE THE CORRECT NUMBER OF GHOST CELLS </dd>
<dd>
This routine will not work if copying between grids before/after regrids. </dd></dl>

</div>
</div>
<a id="aebe76068a86db2799fc9e6e96d6a2ccf" name="aebe76068a86db2799fc9e6e96d6a2ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe76068a86db2799fc9e6e96d6a2ccf">&#9670;&#160;</a></span>deallocate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a865d6b29a7193591db2372b920cbf053" name="a865d6b29a7193591db2372b920cbf053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865d6b29a7193591db2372b920cbf053">&#9670;&#160;</a></span>deallocate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate smart pointer data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ab65c2e423aaa581d3adb4fd883b92" name="ae5ab65c2e423aaa581d3adb4fd883b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ab65c2e423aaa581d3adb4fd883b92">&#9670;&#160;</a></span>deallocate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5032e0accfccfbc5c77cd8d4e6bbe578" name="a5032e0accfccfbc5c77cd8d4e6bbe578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032e0accfccfbc5c77cd8d4e6bbe578">&#9670;&#160;</a></span>depositParticles() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RealVect</a> &amp;(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code><a class="el" href="classTracerParticleSolver.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deposit scalar particle quantities on the mesh. </p>
<p>This routine will switch between various algorithms depending on the user input. If the user chooses to deposit with "halos" near the refinement boundaries then this function requires the "halo" particles to be filled before entering this routine. Thus, if depositing with halos (which requires kernels with 2x or 4x the particle width), the user must first call ParticleContainer::copyMaskParticles(AMRMask). If the user does not do this, he will lose mass near the refinement boundaries. Other than that, this function is just like regular particle-mesh deposition. The mesh field should have exactly one component and the quantity to be deposited is fetched from the specified template parameter 'a_particleScalarField'. This should be a pointer to a member function with signature const Real&amp; P::function() const. <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">E.g</a>. if we are depositing mass through a function const Real&amp; P::mass() const we will specifiy</p>
<p>interpolate&lt;P, &amp;P::mass&gt; (...)</p>
<p>To deposit a different quantity, simply change the function pointer in the input parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">e.g</a>., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5032e0accfccfbc5c77cd8d4e6bbe578" name="a5032e0accfccfbc5c77cd8d4e6bbe578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032e0accfccfbc5c77cd8d4e6bbe578">&#9670;&#160;</a></span>depositParticles() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">Real</a>(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleScalarField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code><a class="el" href="classTracerParticleSolver.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deposit scalar particle quantities on the mesh. </p>
<p>Precisely like the above function, except that the function signature is Real P::particleScalarField() const (C++ is not too smart about these things) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">e.g</a>., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5032e0accfccfbc5c77cd8d4e6bbe578" name="a5032e0accfccfbc5c77cd8d4e6bbe578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032e0accfccfbc5c77cd8d4e6bbe578">&#9670;&#160;</a></span>depositParticles() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RealVect</a> &amp;(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code><a class="el" href="classTracerParticleSolver.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deposit vector particle quantities on the mesh. </p>
<p>This routine will switch between various algorithms depending on the user input. If the user chooses to deposit with "halos" near the refinement boundaries then this function requires the "halo" particles to be filled before entering this routine. Thus, if depositing with halos (which requires kernels with 2x or 4x the particle width), the user must first call ParticleContainer::copyMaskParticles(AMRMask). If the user does not do this, he will lose mass near the refinement boundaries. Other than that, this function is just like regular particle-mesh deposition. The mesh field should have exactly SpaceDim components and the quantity to be deposited is fetched from the specified template parameter 'a_particleVectorField'. This should be a pointer to a member function with signature const RealVect&amp; P::function() const. <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">E.g</a>. if we are depositing current through a function const RealVect&amp; P::current() const we will specifiy</p>
<p>interpolate&lt;P, &amp;P::current&gt; (...)</p>
<p>To deposit a different quantity, simply change the function pointer in the input parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">e.g</a>., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5032e0accfccfbc5c77cd8d4e6bbe578" name="a5032e0accfccfbc5c77cd8d4e6bbe578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032e0accfccfbc5c77cd8d4e6bbe578">&#9670;&#160;</a></span>depositParticles() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">RealVect</a>(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code><a class="el" href="classTracerParticleSolver.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deposit vector particle quantities on the mesh. </p>
<p>Precisely like the above function, except that the function signature is RealVect P::particleVectorField() const (C++ is not too smart about these things) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">e.g</a>., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9d10979cb476e42f07f59f8473110d7" name="ac9d10979cb476e42f07f59f8473110d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d10979cb476e42f07f59f8473110d7">&#9670;&#160;</a></span>depositParticles() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">Real</a>(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit scalar particle quantities on the mesh. </p>
<p>Usage has signature <a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578" title="Deposit scalar particle quantities on the mesh.">depositParticles&lt;P, &amp;P::mass&gt;</a> (...)</p>
<p>To deposit a different quantity, simply change the function pointer in the input parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. MUST have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9d10979cb476e42f07f59f8473110d7" name="ac9d10979cb476e42f07f59f8473110d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d10979cb476e42f07f59f8473110d7">&#9670;&#160;</a></span>depositParticles() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">Real</a>(P::*)() <a class="el" href="classTracerParticleSolver.html">const</a> particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit scalar particle quantities on the mesh. </p>
<p>Usage has signature <a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578" title="Deposit scalar particle quantities on the mesh.">depositParticles&lt;P, &amp;P::mass&gt;</a> (...)</p>
<p>To deposit a different quantity, simply change the function pointer in the input parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. MUST have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1662c260b08bddf92838f6061040619b" name="a1662c260b08bddf92838f6061040619b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1662c260b08bddf92838f6061040619b">&#9670;&#160;</a></span>getBaseImplicitFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; BaseIF &gt; &amp; AmrMesh::getBaseImplicitFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get implicit function for a specific phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase 8gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af18f3ce3d1d5310f7f18518a84fdf1dc" name="af18f3ce3d1d5310f7f18518a84fdf1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18f3ce3d1d5310f7f18518a84fdf1dc">&#9670;&#160;</a></span>getBoxSorting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CD__BoxSorting_8H.html#ab5db8b3a96e3a04473aaa898f7eb2128">BoxSorting</a> AmrMesh::getBoxSorting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get box sorting method. </p>
<dl class="section return"><dt>Returns</dt><dd>Box sorting method. </dd></dl>

</div>
</div>
<a id="ab8a85437e92d6b8493258d04c05d30db" name="ab8a85437e92d6b8493258d04c05d30db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a85437e92d6b8493258d04c05d30db">&#9670;&#160;</a></span>getCentroidInterpolationStencils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classCentroidInterpolationStencil.html">CentroidInterpolationStencil</a> &gt; &amp; AmrMesh::getCentroidInterpolationStencils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interpolation stencils for going from cell center to cell centroid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e8721574be5dce546f43bc88f9ca9cd" name="a9e8721574be5dce546f43bc88f9ca9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8721574be5dce546f43bc88f9ca9cd">&#9670;&#160;</a></span>getEbCentroidInterpolationStencils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classEbCentroidInterpolationStencil.html">EbCentroidInterpolationStencil</a> &gt; &amp; AmrMesh::getEbCentroidInterpolationStencils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interpolation stencils for going from cell center to cell boundary centroid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f0c7045c11ff7348a421675cf5ff6b" name="a70f0c7045c11ff7348a421675cf5ff6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f0c7045c11ff7348a421675cf5ff6b">&#9670;&#160;</a></span>getEbCf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">bool</a> AmrMesh::getEbCf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if mesh has an EBCF. </p>
<dl class="section note"><dt>Note</dt><dd>Always returns true, non-EBCF cases are a thing of the past. </dd></dl>

</div>
</div>
<a id="a9e61c7d908b578e90ef400943e58501c" name="a9e61c7d908b578e90ef400943e58501c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e61c7d908b578e90ef400943e58501c">&#9670;&#160;</a></span>getEBIndexSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBIndexSpace</a> &gt; &amp; AmrMesh::getEBIndexSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get EBIndexSpace corresponding to a particular phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas/solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db2254121059379e82f6569b2c6641a" name="a8db2254121059379e82f6569b2c6641a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db2254121059379e82f6569b2c6641a">&#9670;&#160;</a></span>getEBISLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBISLayout</a> &gt; &amp; AmrMesh::getEBISLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get EBISLayouts for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b1071a09cfc3ff93bd467ae8c63da08" name="a6b1071a09cfc3ff93bd467ae8c63da08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1071a09cfc3ff93bd467ae8c63da08">&#9670;&#160;</a></span>getEBLevelGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBLevelGrid</a> &gt; &gt; &amp; AmrMesh::getEBLevelGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the EBLevelGrid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff109a783f6987d82f9ca37349605fc7" name="aff109a783f6987d82f9ca37349605fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff109a783f6987d82f9ca37349605fc7">&#9670;&#160;</a></span>getEBLevelGridCoFi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBLevelGrid</a> &gt; &gt; &amp; AmrMesh::getEBLevelGridCoFi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the coarsened fine EBLevelGrid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a568f8a5e5bd4d2778cf051ff28da380c" name="a568f8a5e5bd4d2778cf051ff28da380c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568f8a5e5bd4d2778cf051ff28da380c">&#9670;&#160;</a></span>getFineInterp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBCoarseToFineInterp.html">EBCoarseToFineInterp</a> &gt; &gt; &amp; AmrMesh::getFineInterp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interpolator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dd953629079c965c72a6a6b742f507a" name="a8dd953629079c965c72a6a6b742f507a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd953629079c965c72a6a6b742f507a">&#9670;&#160;</a></span>getFluxRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBReflux.html">EBReflux</a> &gt; &gt; &amp; AmrMesh::getFluxRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flux register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6ae0a0c9ceba11621bc8f1ba1682824" name="af6ae0a0c9ceba11621bc8f1ba1682824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ae0a0c9ceba11621bc8f1ba1682824">&#9670;&#160;</a></span>getLevelset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRFAB</a> &amp; AmrMesh::getLevelset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get levelset function, allocated over a grid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af12361318b9d25503a7d850ef96a6a5a" name="af12361318b9d25503a7d850ef96a6a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12361318b9d25503a7d850ef96a6a5a">&#9670;&#160;</a></span>getLevelTiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classLevelTiles.html">LevelTiles</a> &gt; &gt; &amp; AmrMesh::getLevelTiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tiled space representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac94bae000d35d8820cfef27bd9c1c890" name="ac94bae000d35d8820cfef27bd9c1c890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94bae000d35d8820cfef27bd9c1c890">&#9670;&#160;</a></span>getMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Realm_8H.html#a906b67939aa45e674c3a94d40c0e5e34">AMRMask</a> &amp; AmrMesh::getMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a registered mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mask</td><td>Mask name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_buffer</td><td>Buffer (used when registering mask) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99a7c78576d46ae8ced617b78ab0ae30" name="a99a7c78576d46ae8ced617b78ab0ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a7c78576d46ae8ced617b78ab0ae30">&#9670;&#160;</a></span>getMFLevelGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classMFLevelGrid.html">MFLevelGrid</a> &gt; &gt; &amp; AmrMesh::getMFLevelGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get EBISLayouts for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28d1aa576ea1b98c23378f127212844e" name="a28d1aa576ea1b98c23378f127212844e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d1aa576ea1b98c23378f127212844e">&#9670;&#160;</a></span>getMultigridInterpolator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBMultigridInterpolator.html">EBMultigridInterpolator</a> &gt; &gt; &amp; AmrMesh::getMultigridInterpolator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get multigrid interpolation utility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa71d4093fe3c996f104348eec16cf0bd" name="aa71d4093fe3c996f104348eec16cf0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71d4093fe3c996f104348eec16cf0bd">&#9670;&#160;</a></span>getNonConservativeDivergenceStencils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classNonConservativeDivergenceStencil.html">NonConservativeDivergenceStencil</a> &gt; &amp; AmrMesh::getNonConservativeDivergenceStencils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nonconservative divergence stencils. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae01ad6d63e8fed8c1615a06a9ccb534a" name="ae01ad6d63e8fed8c1615a06a9ccb534a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01ad6d63e8fed8c1615a06a9ccb534a">&#9670;&#160;</a></span>getParticleMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRParticleMesh.html">EBAMRParticleMesh</a> &amp; AmrMesh::getParticleMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classEBAMRParticleMesh.html" title="Class for handling particle-mesh operations with AMR.">EBAMRParticleMesh</a> operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23821170fc1949807a3896dcc9f33b1a" name="a23821170fc1949807a3896dcc9f33b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23821170fc1949807a3896dcc9f33b1a">&#9670;&#160;</a></span>getProxyGrids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">DisjointBoxLayout</a> &gt; &amp; AmrMesh::getProxyGrids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "proxy" grids in <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a>. </p>
<p>Returns m_grids </p>

</div>
</div>
<a id="a10aa1580b30fe66ec3e313435c44d1f1" name="a10aa1580b30fe66ec3e313435c44d1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa1580b30fe66ec3e313435c44d1f1">&#9670;&#160;</a></span>getRealms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::vector</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &gt; AmrMesh::getRealms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of all Realms. </p>
<dl class="section return"><dt>Returns</dt><dd>Names of all Realms </dd></dl>

</div>
</div>
<a id="a9334b1e32789d5014a0285ecbff0a854" name="a9334b1e32789d5014a0285ecbff0a854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9334b1e32789d5014a0285ecbff0a854">&#9670;&#160;</a></span>getRedistributionOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classEBFluxRedistribution.html">EBFluxRedistribution</a> &gt; &gt; &amp; AmrMesh::getRedistributionOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the redistribution operators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7a316dd3977e3f60c27c0e2f71cf4fc" name="ab7a316dd3977e3f60c27c0e2f71cf4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a316dd3977e3f60c27c0e2f71cf4fc">&#9670;&#160;</a></span>getRefinementRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">int</a> AmrMesh::getRefinementRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_level1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_level2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get refinement factor between two levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level1</td><td>First level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level2</td><td>Second level</td></tr>
  </table>
  </dd>
</dl>
<p>This will work correctly in reverse as well. </p>

</div>
</div>
<a id="acc021d3b64ddaabdc982230621e254c4" name="acc021d3b64ddaabdc982230621e254c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc021d3b64ddaabdc982230621e254c4">&#9670;&#160;</a></span>getSurfaceDeposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRSurfaceDeposition.html">EBAMRSurfaceDeposition</a> &amp; AmrMesh::getSurfaceDeposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classEBAMRSurfaceDeposition.html" title="class for handling surface deposition of particles with EB and AMR.">EBAMRSurfaceDeposition</a> surface deposition operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1492043709c933fca6e7c51a42aebf40" name="a1492043709c933fca6e7c51a42aebf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1492043709c933fca6e7c51a42aebf40">&#9670;&#160;</a></span>getValidCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__Realm_8H.html#a906b67939aa45e674c3a94d40c0e5e34">AMRMask</a> &amp; AmrMesh::getValidCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a map of all valid cells on a specified realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3a0d0f998de1a920a638a7b23c8056a" name="ae3a0d0f998de1a920a638a7b23c8056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a0d0f998de1a920a638a7b23c8056a">&#9670;&#160;</a></span>getVofIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classTracerParticleSolver.html">LayoutData</a>&lt; <a class="el" href="classTracerParticleSolver.html">VoFIterator</a> &gt; &gt; &gt; &amp; AmrMesh::getVofIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get vof iterators for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. This has the capability of iterating through cut-cells. </p>
<p>Not const because we need to reset the vofiterator </p>

</div>
</div>
<a id="a4b49e5fa25c6a4bb059a6c3e25b1c078" name="a4b49e5fa25c6a4bb059a6c3e25b1c078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b49e5fa25c6a4bb059a6c3e25b1c078">&#9670;&#160;</a></span>harmonicAverage() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonic average of data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb3e29a7ec2d7e88c8ba7410e1fda2ea" name="adb3e29a7ec2d7e88c8ba7410e1fda2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3e29a7ec2d7e88c8ba7410e1fda2ea">&#9670;&#160;</a></span>harmonicAverage() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonic average of data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00b2fdcbb8c36d6ccd8e6b836980ab3c" name="a00b2fdcbb8c36d6ccd8e6b836980ab3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b2fdcbb8c36d6ccd8e6b836980ab3c">&#9670;&#160;</a></span>harmonicAverage() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<p>This computes an arithmetic average of the face data. Data on coarse faces is replaced by the arithmetic average of the fine face data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be average. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a259cb2f2336f091eeb1955b7c525a040" name="a259cb2f2336f091eeb1955b7c525a040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb2f2336f091eeb1955b7c525a040">&#9670;&#160;</a></span>harmonicAverage() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonic average on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a186c852306b0260ad0637599217ea035" name="a186c852306b0260ad0637599217ea035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186c852306b0260ad0637599217ea035">&#9670;&#160;</a></span>harmonicAverage() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonic coarsening of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4e9d87d1e36b48c25847153b44b2db2" name="ae4e9d87d1e36b48c25847153b44b2db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e9d87d1e36b48c25847153b44b2db2">&#9670;&#160;</a></span>harmonicAverage() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average multifluid data over a realm. </p>
<p>This computes an arithmetic average of the face data. Data on coarse faces is replaced by the arithmetic average of the fine face data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a980ef520e5d9c3a2977a6c43d432b523" name="a980ef520e5d9c3a2977a6c43d432b523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980ef520e5d9c3a2977a6c43d432b523">&#9670;&#160;</a></span>interpGhost() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpGhost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost vectors over a realm, using the default ghost cell interpolation method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff48bbba8105fcfea99d8796268eaab" name="a5ff48bbba8105fcfea99d8796268eaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff48bbba8105fcfea99d8796268eaab">&#9670;&#160;</a></span>interpGhost() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpGhost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_fineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_coarData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm, using the default ghost cell interpolation method on a specific level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_fineData</td><td>Fine grid data </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_coarData</td><td>Coarse grid data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>The grid level corresponding to a_fineData </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03f71b81c581b084edff3a03e61ce943" name="a03f71b81c581b084edff3a03e61ce943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f71b81c581b084edff3a03e61ce943">&#9670;&#160;</a></span>interpGhost() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpGhost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm. Calls the default ghost cell interpolation method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187f9807eae7f2c90a6b0ac1c32f8cb1" name="a187f9807eae7f2c90a6b0ac1c32f8cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187f9807eae7f2c90a6b0ac1c32f8cb1">&#9670;&#160;</a></span>interpGhostMG() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpGhostMG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm and phase. </p>
<p>This routine uses the multigrid interpolator, which does not reach into invalid regions. <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">I.e</a>., all ghost cells are interpolated using valid data only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a019193845e8ff43c846575570b0c0a" name="a4a019193845e8ff43c846575570b0c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a019193845e8ff43c846575570b0c0a">&#9670;&#160;</a></span>interpGhostMG() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpGhostMG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm and phase. </p>
<p>This routine uses the multigrid interpolator, which does not reach into invalid regions. <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">I.e</a>., all ghost cells are interpolated using valid data only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b4b8c5a83b8df8a3f23c93cd81a834" name="a88b4b8c5a83b8df8a3f23c93cd81a834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b4b8c5a83b8df8a3f23c93cd81a834">&#9670;&#160;</a></span>interpGhostPwl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpGhostPwl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm and phase. This uses piecewise linear interpolation (with limiters) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3aa6a3ddddeb4ffdda877719e545eaef" name="a3aa6a3ddddeb4ffdda877719e545eaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa6a3ddddeb4ffdda877719e545eaef">&#9670;&#160;</a></span>interpGhostPwl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpGhostPwl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm and phase. This uses piecewise linear interpolation (with limiters) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa07d5998e160d5430c49bc238e819e77" name="aa07d5998e160d5430c49bc238e819e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07d5998e160d5430c49bc238e819e77">&#9670;&#160;</a></span>interpolateParticles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">RealVect</a> &amp;(P::*)() particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpolateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshScalarField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_interpType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code><a class="el" href="classTracerParticleSolver.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a scalar field onto the particle position. </p>
<p>This is just like regular particle-mesh interpolation. The input field should have exactly one component and the the field will be interpolated onto the template parameter's input field. The template parameter 'particleScalarField' should be a pointer to a member function which will set the particle field. <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">E.g</a>. the function must have a signature Real&amp; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">P::particleScalarField()</a>. A valid expression is <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">e.g</a>. </p><pre class="fragment">interpolate&lt;P, &amp;P::mass&gt; (...)
</pre><p> To interpolate onto a different field, replace ::mass by the other scalar field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be interpolated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_meshScalarField</td><td>Scalar field on the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpType</td><td>Interpolation type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP interpolation in cut-cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac073bb1b20ac52395c1a2403af462996" name="ac073bb1b20ac52395c1a2403af462996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac073bb1b20ac52395c1a2403af462996">&#9670;&#160;</a></span>interpolateParticles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> , <a class="el" href="classTracerParticleSolver.html">RealVect</a> &amp;(P::*)() particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpolateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshVectorField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_interpType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code><a class="el" href="classTracerParticleSolver.html">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector field onto the particle position. </p>
<p>This is just like regular particle-mesh interpolation. The input field should have exactly SpaceDim components and the the field will be interpolated onto the template parameter's input field. The template parameter 'particleVectorField' should be a pointer to a member function which will set the particle field. <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">E.g</a>. the function must have a signature RealVect&amp; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">P::particleVectorField()</a>. A valid expression is <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">e.g</a>. </p><pre class="fragment">interpolate&lt;P, &amp;P::velocity&gt; (...)
</pre><p> To interpolate onto a different field, replace ::velocity by another vector field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be interpolated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_meshScalarField</td><td>Scalar field on the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpType</td><td>Interpolation type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP interpolation in cut-cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58008f166bc2d7de06c4c24d879513fe" name="a58008f166bc2d7de06c4c24d879513fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58008f166bc2d7de06c4c24d879513fe">&#9670;&#160;</a></span>interpToCentroids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpToCentroids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to centroids on realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid)</td></tr>
  </table>
  </dd>
</dl>
<p>This leaves regular data intact, while the values in irregular are replaced by the corresponding interpolation to centroids. </p>

</div>
</div>
<a id="a69e42a6fb2e20aae67933c15a2b5e604" name="a69e42a6fb2e20aae67933c15a2b5e604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e42a6fb2e20aae67933c15a2b5e604">&#9670;&#160;</a></span>interpToCentroids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpToCentroids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">LevelData</a>&lt; <a class="el" href="classTracerParticleSolver.html">EBCellFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to centroids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a195914bb2a8bace5985d1960d6074100" name="a195914bb2a8bace5985d1960d6074100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195914bb2a8bace5985d1960d6074100">&#9670;&#160;</a></span>interpToNewGrids() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpToNewGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBCoarseToFineInterp.html#a7da81d645a467200cc6ad9b2667c1c08">EBCoarseToFineInterp::Type</a>&#160;</td>
          <td class="paramname"><em>a_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to new grids. </p>
<p>This is called when requiring data to be interpolated to new grids. Takes old data as argument and fills the new grid data with an interpolation of the old grid data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_newData</td><td>New grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldData</td><td>Old grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which we regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that did not change (but distribution may have changed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Previous finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>New finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_type</td><td>Interpolation type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb81553cf7712d97c54615f69634f03" name="a6fb81553cf7712d97c54615f69634f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb81553cf7712d97c54615f69634f03">&#9670;&#160;</a></span>interpToNewGrids() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpToNewGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBCoarseToFineInterp.html#a7da81d645a467200cc6ad9b2667c1c08">EBCoarseToFineInterp::Type</a>&#160;</td>
          <td class="paramname"><em>a_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to new grids. </p>
<p>This is called when requiring data to be interpolated to new grids. Takes old data as argument and fills the new grid data with an interpolation of the old grid data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_newData</td><td>New grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldData</td><td>Old grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which we regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that did not change (but distribution may have changed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Previous finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>New finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_type</td><td>Interpolation type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb8c62ee3fbc0bac33784f1abf312816" name="adb8c62ee3fbc0bac33784f1abf312816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8c62ee3fbc0bac33784f1abf312816">&#9670;&#160;</a></span>interpToNewGrids() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::interpToNewGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBCoarseToFineInterp.html#a7da81d645a467200cc6ad9b2667c1c08">EBCoarseToFineInterp::Type</a>&#160;</td>
          <td class="paramname"><em>a_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to new grids. </p>
<p>This is called when requiring data to be interpolated to new grids. Takes old data as argument and fills the new grid data with an interpolation of the old grid data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_newData</td><td>New grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldData</td><td>Old grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that did not change (but distribution may have changed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Previous finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>New finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_type</td><td>Interpolation type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a785050ce35bae77bac1d1bfa3358a7cb" name="a785050ce35bae77bac1d1bfa3358a7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785050ce35bae77bac1d1bfa3358a7cb">&#9670;&#160;</a></span>intersectParticlesBisectIF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::intersectParticlesBisectIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_activeParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domainParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a>&#160;</td>
          <td class="paramname"><em>a_bisectionStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::function</a>&lt; <a class="el" href="classTracerParticleSolver.html">void</a>(<a class="el" href="classTracerParticleSolver.html">P</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>a_nonDeletionModifier</em> = <code>[](<a class="el" href="classTracerParticleSolver.html">P</a>&amp;)&#160;-&gt;&#160;<a class="el" href="classTracerParticleSolver.html">void</a>&#160;{&#160;<a class="el" href="classTracerParticleSolver.html">return</a>;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Particle intersection algorithm based on bisection. </p>
<p>This routine will iterate through all the particles and check if they intersect the geometry. The template parameter indicates the particle type &ndash; it MUST have const RealVec&amp; position() const and const RealVect&amp; oldPosition() const  functions that determine the start and stop position of the particle trajectory. This routine uses a bisection method to check for intersections with the EB (the domain side is much easier). Their position are updated and they are placed in the a_ebParticles argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_activeParticles</td><td>Particles to be intersected with geometry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_ebParticles</td><td>Particles that intersected with the EB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_domainParticles</td><td>Particles that intersected with the domain faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the input particles live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_bisectionStep</td><td>Length of the bisection step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, particles will be removed from a_activeParticles if they intersect the geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nonDeletionModifier</td><td>Optional input argument for letting the user manipulate particles that were intersected but not deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60a68b7e8b0a7d9062db13f1b002cc39" name="a60a68b7e8b0a7d9062db13f1b002cc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a68b7e8b0a7d9062db13f1b002cc39">&#9670;&#160;</a></span>intersectParticlesRaycastIF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::intersectParticlesRaycastIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_activeParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domainParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a>&#160;</td>
          <td class="paramname"><em>a_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">bool</a>&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::function</a>&lt; <a class="el" href="classTracerParticleSolver.html">void</a>(<a class="el" href="classTracerParticleSolver.html">P</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>a_nonDeletionModifier</em> = <code>[](<a class="el" href="classTracerParticleSolver.html">P</a>&amp;)&#160;-&gt;&#160;<a class="el" href="classTracerParticleSolver.html">void</a>&#160;{&#160;<a class="el" href="classTracerParticleSolver.html">return</a>;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Particle intersection algorithm based on ray-casting. </p>
<p>This routine will iterate through all the particles and check if they intersect the geometry. The template parameter indicates the particle type &ndash; it MUST have const RealVec&amp; position() const and const RealVect&amp; oldPosition() const  functions that determine the start and stop position of the particle trajectory. This routine uses a ray-casting method to check for intersections with the EB (the domain side is much easier). If the particles are closer to the EB than a_tolerance, they are absorbed and placed on the EB. Their position are updated and they are placed in the a_ebParticles argument. This routine uses a ray-casting method where it computes the distance from the EB (assuming that the implicit function is a signed distance function). Particles are then moved that distance along their trajectory and we then update the new distance to the EB. This is done recursively until the particles have either moved the entire length or been absorbed by the EB or domain side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_activeParticles</td><td>Particles to be intersected with geometry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_ebParticles</td><td>Particles that intersected with the EB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_domainParticles</td><td>Particles that intersected with the domain faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the input particles live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_bisectionStep</td><td>Length of the bisection step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, particles will be removed from a_activeParticles if they intersect the geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nonDeletionModifier</td><td>Optional input argument for letting the user manipulate particles that were intersected but not deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aab4befd4adb40e39afa6713db794ab" name="a9aab4befd4adb40e39afa6713db794ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aab4befd4adb40e39afa6713db794ab">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAmrMesh.html">AmrMesh</a> &amp; AmrMesh::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed move assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00a1f146cdda3a4b47a0a3b78d583f64" name="a00a1f146cdda3a4b47a0a3b78d583f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a1f146cdda3a4b47a0a3b78d583f64">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAmrMesh.html">AmrMesh</a> &amp; AmrMesh::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab02dccfc4e434c6ee612908413498d50" name="ab02dccfc4e434c6ee612908413498d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02dccfc4e434c6ee612908413498d50">&#9670;&#160;</a></span>parseEbGhostCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::parseEbGhostCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse number of ghost cells for eb stuff. </p>
<p>Only matters for the grid generation step. </p>

</div>
</div>
<a id="add290a067d272d1e544cdedd2c54a896" name="add290a067d272d1e544cdedd2c54a896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add290a067d272d1e544cdedd2c54a896">&#9670;&#160;</a></span>parseMaxEbisBoxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::parseMaxEbisBoxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the maximum permitted box size. </p>
<p>Only relevant for the grid generation step. </p>

</div>
</div>
<a id="a0d6d9f11ede790783a919c1cd20870ba" name="a0d6d9f11ede790783a919c1cd20870ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6d9f11ede790783a919c1cd20870ba">&#9670;&#160;</a></span>parseRuntimeOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::parseRuntimeOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse runtime options. </p>
<dl class="section note"><dt>Note</dt><dd>Called by <a class="el" href="classDriver.html" title="Main class for time/space advancement of streamer equations.">Driver</a> as simulations progress. </dd></dl>

</div>
</div>
<a id="a3f7105b45dc3d5db23e1029f9fa95ef2" name="a3f7105b45dc3d5db23e1029f9fa95ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7105b45dc3d5db23e1029f9fa95ef2">&#9670;&#160;</a></span>queryRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">bool</a> AmrMesh::queryRealm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if a realm exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the realm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the realm exists and false otherwise. </dd></dl>

</div>
</div>
<a id="a5074cd4a99c5c29bf499cd20688d5ca2" name="a5074cd4a99c5c29bf499cd20688d5ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5074cd4a99c5c29bf499cd20688d5ca2">&#9670;&#160;</a></span>reallocate() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRBool</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="a87a0c3e11d835a5bd9e3ab8c5950e2ca" name="a87a0c3e11d835a5bd9e3ab8c5950e2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a0c3e11d835a5bd9e3ab8c5950e2ca">&#9670;&#160;</a></span>reallocate() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase over the reallocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="a612f5b753bfe06523d77d8ffe49d9459" name="a612f5b753bfe06523d77d8ffe49d9459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612f5b753bfe06523d77d8ffe49d9459">&#9670;&#160;</a></span>reallocate() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase over the reallocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="a991ec9fb80cd2579acf88acb51738403" name="a991ec9fb80cd2579acf88acb51738403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991ec9fb80cd2579acf88acb51738403">&#9670;&#160;</a></span>reallocate() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase over the reallocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="aad120065536a58ff9f0c4662c03a8449" name="aad120065536a58ff9f0c4662c03a8449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad120065536a58ff9f0c4662c03a8449">&#9670;&#160;</a></span>reallocate() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase over the reallocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="acc9a31a2a37e7d804a6aa80ca3e7fc7d" name="acc9a31a2a37e7d804a6aa80ca3e7fc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9a31a2a37e7d804a6aa80ca3e7fc7d">&#9670;&#160;</a></span>reallocate() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="ac523d5d24140c8f8e84e118ff8c4123e" name="ac523d5d24140c8f8e84e118ff8c4123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac523d5d24140c8f8e84e118ff8c4123e">&#9670;&#160;</a></span>reallocate() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="a14e98284a18faae8ac933f5cbe469f74" name="a14e98284a18faae8ac933f5cbe469f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e98284a18faae8ac933f5cbe469f74">&#9670;&#160;</a></span>reallocate() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="acf9b6818c634e2585a628f30362af1b0" name="acf9b6818c634e2585a628f30362af1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9b6818c634e2585a628f30362af1b0">&#9670;&#160;</a></span>registerMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::registerMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a boolean mask over a realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mask</td><td>Mask name to be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_buffer</td><td>Relevant buffer for the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The meaning of a_buffer differs for different masks. </dd>
<dd>
Run-time errors will occur if the mask or realm do not exist. </dd></dl>

</div>
</div>
<a id="a2bb365cb3691098693eb0bba6b552fe6" name="a2bb365cb3691098693eb0bba6b552fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb365cb3691098693eb0bba6b552fe6">&#9670;&#160;</a></span>registerOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::registerOperator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an operator over a realm and a phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_operator</td><td>Operator to be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Run-time errors will occur if the operator or realm do not exist. </dd></dl>

</div>
</div>
<a id="a6dd2b0e8c918e6057647103c8193fa17" name="a6dd2b0e8c918e6057647103c8193fa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd2b0e8c918e6057647103c8193fa17">&#9670;&#160;</a></span>registerRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::registerRealm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a new realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is safe to re-register a realm. </dd></dl>

</div>
</div>
<a id="a9a8897dc00f6ac738080aba2ec29ad7a" name="a9a8897dc00f6ac738080aba2ec29ad7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8897dc00f6ac738080aba2ec29ad7a">&#9670;&#160;</a></span>regridAmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::regridAmr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">IntVectSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_hardcap</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regrid AMR. This versions generates the grids and Realms, but not the operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tags</td><td>Cell tags which will generate the grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest grid level allowed to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hardcap</td><td>Grid generation hardcap. If &lt; 0 there are no limitations to grid depth. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee8e3a7de269ef9be0121c22eed428d5" name="aee8e3a7de269ef9be0121c22eed428d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8e3a7de269ef9be0121c22eed428d5">&#9670;&#160;</a></span>regridOperators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::regridOperators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regrid AMR operators. This is done for all realms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest grid level that changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa3ac55867e7dc229ccbadf737dcd5c6" name="aaa3ac55867e7dc229ccbadf737dcd5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3ac55867e7dc229ccbadf737dcd5c6">&#9670;&#160;</a></span>regridOperators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::regridOperators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regrid AMR operators. This is done for a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest grid level that changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8162ae90fb308b1fb84e8c8986f8b61" name="af8162ae90fb308b1fb84e8c8986f8b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8162ae90fb308b1fb84e8c8986f8b61">&#9670;&#160;</a></span>regridRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::regridRealm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">int</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Box</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regrid a realm. This generates the grids for the realm, but does not do the operators on the realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_procs</td><td>Processor IDs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_boxes</td><td>Grid boxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33518b8e6bc4daf6ce94d33d5905c357" name="a33518b8e6bc4daf6ce94d33d5905c357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33518b8e6bc4daf6ce94d33d5905c357">&#9670;&#160;</a></span>remapToNewGrids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::remapToNewGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regrid particle to new grids. </p>
<dl class="section note"><dt>Note</dt><dd>User needs to call <a class="el" href="classParticleContainer.html#a56f20f8dc3405f672d0bd218710630e2" title="Cache particles before calling regrid.">ParticleContainer&lt;P&gt;::preRegrid</a> prior to this. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that did not change (but distribution may have changed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>New finest level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb1b3008526e53b38e09e96e0e88487" name="a6fb1b3008526e53b38e09e96e0e88487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb1b3008526e53b38e09e96e0e88487">&#9670;&#160;</a></span>removeCoveredParticlesDiscrete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::removeCoveredParticlesDiscrete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a>&#160;</td>
          <td class="paramname"><em>a_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which removes particles from the domain if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version uses the discrete information to evaluate whether or not the particles are inside the EB. The particles will be removed from the container if they lie within a covered cell OR if they lie in an irregular cell but on the "wrong" side of the EB face (to within precision tolerance*dx) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance when to remove particles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work if the particles are mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="a412d58b270f56e04aa17127c0fcf5f46" name="a412d58b270f56e04aa17127c0fcf5f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412d58b270f56e04aa17127c0fcf5f46">&#9670;&#160;</a></span>removeCoveredParticlesIF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::removeCoveredParticlesIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a>&#160;</td>
          <td class="paramname"><em>a_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which removes particles from the domain if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version uses the implicit function to evaluate whether or not the particles are inside the EB. The particles will be removed from the container if f(x) &gt; a_tolerance*dx. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Because the implicit functions are global, this function will work even if the particles aren't mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="a036c315af1e9c46ba5320a3de0017927" name="a036c315af1e9c46ba5320a3de0017927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036c315af1e9c46ba5320a3de0017927">&#9670;&#160;</a></span>removeCoveredParticlesVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::removeCoveredParticlesVoxels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which removes particles from the domain if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it must have a const RealVect&amp; P::position() function.</p>
<p>This version removes all particles that live in covered cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work if the particles are mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="afc74d0037dc972aea59860feeb54a6e3" name="afc74d0037dc972aea59860feeb54a6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc74d0037dc972aea59860feeb54a6e3">&#9670;&#160;</a></span>setBaseImplicitFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::setBaseImplicitFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; BaseIF &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_baseIF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set implicit function for a specific phase. Need <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">e.g</a>. for level-sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_baseIF</td><td>The level-set function describing the phase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dcbb2334af9b06815262abc2ceda9e2" name="a3dcbb2334af9b06815262abc2ceda9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcbb2334af9b06815262abc2ceda9e2">&#9670;&#160;</a></span>setFinestLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::setFinestLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">int</a>&#160;</td>
          <td class="paramname"><em>a_finestLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the finest level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is dangerous routine, but it's needed because <a class="el" href="classDriver.html" title="Main class for time/space advancement of streamer equations.">Driver</a> reads checkpoint files and needs to set the finest level from those. </dd></dl>

</div>
</div>
<a id="aa38a00d59a1a0fecbf0f453e2ce77a48" name="aa38a00d59a1a0fecbf0f453e2ce77a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38a00d59a1a0fecbf0f453e2ce77a48">&#9670;&#160;</a></span>setGrids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::setGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Box</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt; <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt; <a class="el" href="classTracerParticleSolver.html">long</a> <a class="el" href="classTracerParticleSolver.html">int</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_realmsAndLoads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set grids from boxes and computational loads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_boxes</td><td>Grid boxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realmsAndLoads</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> names and computational loads for realms</td></tr>
  </table>
  </dd>
</dl>
<p>This will set the grids for <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> and realms, load balancing the various realms with the provided loads. </p>

</div>
</div>
<a id="a80a0ed99e2d6e6edf3fb65ad4b79d9a0" name="a80a0ed99e2d6e6edf3fb65ad4b79d9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a0ed99e2d6e6edf3fb65ad4b79d9a0">&#9670;&#160;</a></span>setMultifluidIndexSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::setMultifluidIndexSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">RefCountedPtr</a>&lt; <a class="el" href="classMultiFluidIndexSpace.html">MultiFluidIndexSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_multiFluidIndexSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets multifluid index space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_multiFluidIndexSpace</td><td>Multifluid index space wrapper. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bdab30ee7155984c3e75bcf25e50dc3" name="a8bdab30ee7155984c3e75bcf25e50dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdab30ee7155984c3e75bcf25e50dc3">&#9670;&#160;</a></span>slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> AmrMesh::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a>&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slice cell-centered data in order to fetch a subset of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Original data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Subset of variables. The first component in the returned data holder corresponds to <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">a_variables.begin()</a>, the last to <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">a_variables.end()</a> </dd></dl>

</div>
</div>
<a id="ab607b773c624e394f178e7f09446a656" name="ab607b773c624e394f178e7f09446a656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab607b773c624e394f178e7f09446a656">&#9670;&#160;</a></span>slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> AmrMesh::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Interval</a>&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slice cell-centered data in order to fetch a subset of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Original data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Subset of variables. The first component in the returned data holder corresponds to <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">a_variables.begin()</a>, the last to <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d" title="Default constructor.">a_variables.end()</a> </dd></dl>

</div>
</div>
<a id="a06b91aa63e558054ea913b05e797ec50" name="a06b91aa63e558054ea913b05e797ec50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b91aa63e558054ea913b05e797ec50">&#9670;&#160;</a></span>transferCoveredParticlesDiscrete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::transferCoveredParticlesDiscrete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a>&#160;</td>
          <td class="paramname"><em>a_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which transferse particles from one particle container to another if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version uses the discrete information to evaluate whether or not the particles are inside the EB. The particles will be transferred from the container if they lie within a covered cell OR if they lie in an irregular cell but on the "wrong" side of the EB face (to within precision tolerance*dx) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesFrom</td><td>Container to transfer from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesTo</td><td>Container to transfer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work if the particles are mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="a25c75449e9996805572bc01bd43042b2" name="a25c75449e9996805572bc01bd43042b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c75449e9996805572bc01bd43042b2">&#9670;&#160;</a></span>transferCoveredParticlesIF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::transferCoveredParticlesIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html">Real</a>&#160;</td>
          <td class="paramname"><em>a_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which transferse particles from one particle container to another if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version uses the implicit function to evaluate whether or not the particles are inside the EB. The particles will be transferred from the container if f(x) &gt; a_tolerance*dx. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesFrom</td><td>Container to transfer from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesTo</td><td>Container to transfer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance (Note: relative to grid resolution) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Because the implicit functions are global, this function will work even if the particles aren't mapped to the correct boxes (but remapping will be necessary) </dd></dl>

</div>
</div>
<a id="adccc54b19b8398a8c48c4ef8b2ea026c" name="adccc54b19b8398a8c48c4ef8b2ea026c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccc54b19b8398a8c48c4ef8b2ea026c">&#9670;&#160;</a></span>transferCoveredParticlesVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::transferCoveredParticlesVoxels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which transferse particles from one particle container to another if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version transfers all particles that live in covered cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesFrom</td><td>Container to transfer from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesTo</td><td>Container to transfer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work if the particles are mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="a3ef231600b61769b61c6fb4e07db725c" name="a3ef231600b61769b61c6fb4e07db725c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef231600b61769b61c6fb4e07db725c">&#9670;&#160;</a></span>transferIrregularParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classTracerParticleSolver.html">class</a> <a class="el" href="classTracerParticleSolver.html">P</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html">void</a> AmrMesh::transferIrregularParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dstParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classTracerParticleSolver.html">P</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_srcParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTracerParticleSolver.html">const</a> <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::function</a>&lt; <a class="el" href="classTracerParticleSolver.html">void</a>(<a class="el" href="classTracerParticleSolver.html">P</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>a_transferModifier</em> = <code>[](<a class="el" href="classTracerParticleSolver.html">P</a>&amp;)&#160;-&gt;&#160;<a class="el" href="classTracerParticleSolver.html">void</a>&#160;{&#160;<a class="el" href="classTracerParticleSolver.html">return</a>;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer particles that are on the wrong side of the EB to a different container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_dstParticles</td><td>Destination particle container </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_srcParticles</td><td>Source particle container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles should live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_transferModifier</td><td>Optional input argument for letting the user manipulate particles that were transferred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0e2169012fe5dc50728c7e9053483362" name="a0e2169012fe5dc50728c7e9053483362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2169012fe5dc50728c7e9053483362">&#9670;&#160;</a></span>m_oldToNewCellCopiers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt;<a class="el" href="classTracerParticleSolver.html">Copier</a>&gt; &gt; AmrMesh::m_oldToNewCellCopiers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage for copiers from the old grids to the new ones. </p>
<dl class="section note"><dt>Note</dt><dd>Defined in the realm regrid routine. Cleared in the postRegrid routine. </dd></dl>

</div>
</div>
<a id="a8c3919497262c0bbae39e0ca65ec1aa4" name="a8c3919497262c0bbae39e0ca65ec1aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3919497262c0bbae39e0ca65ec1aa4">&#9670;&#160;</a></span>m_oldToNewEBCopiers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt;<a class="el" href="classTracerParticleSolver.html">Copier</a>&gt; &gt; AmrMesh::m_oldToNewEBCopiers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage for copiers from the old grids to the new ones. </p>
<dl class="section note"><dt>Note</dt><dd>Defined in the realm regrid routine. Cleared in the postRegrid routine. </dd></dl>

</div>
</div>
<a id="a6ce4c98a9de19649eafaa1abd68e2866" name="a6ce4c98a9de19649eafaa1abd68e2866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce4c98a9de19649eafaa1abd68e2866">&#9670;&#160;</a></span>m_validGhostToValidGhostRealmCopiers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::pair</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&gt;, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt;<a class="el" href="classTracerParticleSolver.html">Copier</a>&gt; &gt; AmrMesh::m_validGhostToValidGhostRealmCopiers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map for copying between various Realms. First index is the "from" realm and second index is the "to" realm. </p>
<dl class="section note"><dt>Note</dt><dd>This is important at scale when you have &gt; 1M boxes since Copier definitions become costly. </dd></dl>

</div>
</div>
<a id="a5e8d11b276504693095d4336c2b77c72" name="a5e8d11b276504693095d4336c2b77c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8d11b276504693095d4336c2b77c72">&#9670;&#160;</a></span>m_validGhostToValidRealmCopiers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::pair</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&gt;, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt;<a class="el" href="classTracerParticleSolver.html">Copier</a>&gt; &gt; AmrMesh::m_validGhostToValidRealmCopiers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map for copying between various Realms. First index is the "from" realm and second index is the "to" realm. </p>
<dl class="section note"><dt>Note</dt><dd>This is important at scale when you have &gt; 1M boxes since Copier definitions become costly. </dd></dl>

</div>
</div>
<a id="aa74f5894b9a4eeebaa3cbb12ac2d0ab2" name="aa74f5894b9a4eeebaa3cbb12ac2d0ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74f5894b9a4eeebaa3cbb12ac2d0ab2">&#9670;&#160;</a></span>m_validToValidGhostRealmCopiers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::pair</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&gt;, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt;<a class="el" href="classTracerParticleSolver.html">Copier</a>&gt; &gt; AmrMesh::m_validToValidGhostRealmCopiers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map for copying between various Realms. First index is the "from" realm and second index is the "to" realm. </p>
<dl class="section note"><dt>Note</dt><dd>This is important at scale when you have &gt; 1M boxes since Copier definitions become costly. </dd></dl>

</div>
</div>
<a id="a5e4c06b25de01bb1be380e84dc93dbc8" name="a5e4c06b25de01bb1be380e84dc93dbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4c06b25de01bb1be380e84dc93dbc8">&#9670;&#160;</a></span>m_validToValidRealmCopiers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::map</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::pair</a>&lt;<a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>, <a class="el" href="classTracerParticleSolver.html#a4fa2ba84feb2e79304ef1d8c0aafd77d">std::string</a>&gt;, <a class="el" href="classTracerParticleSolver.html">Vector</a>&lt;<a class="el" href="classTracerParticleSolver.html">Copier</a>&gt; &gt; AmrMesh::m_validToValidRealmCopiers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map for copying between various Realms. First index is the "from" realm and second index is the "to" realm. </p>
<dl class="section note"><dt>Note</dt><dd>This is important at scale when you have &gt; 1M boxes since Copier definitions become costly. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/AmrMesh/<a class="el" href="CD__AmrMesh_8H_source.html">CD_AmrMesh.H</a></li>
<li>Source/AmrMesh/<a class="el" href="CD__AmrMesh_8cpp.html">CD_AmrMesh.cpp</a></li>
<li>Source/AmrMesh/<a class="el" href="CD__AmrMeshImplem_8H_source.html">CD_AmrMeshImplem.H</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
