<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: AmrMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classAmrMesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AmrMesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for handling spatial operations.  
 <a href="classAmrMesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__AmrMesh_8H_source.html">CD_AmrMesh.H</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaf2154348b6e3f8c7691e4aed716961b"><td class="memItemLeft" align="right" valign="top"><a id="aaf2154348b6e3f8c7691e4aed716961b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aaf2154348b6e3f8c7691e4aed716961b">AmrMesh</a> ()</td></tr>
<tr class="memdesc:aaf2154348b6e3f8c7691e4aed716961b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aaf2154348b6e3f8c7691e4aed716961b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dbdbd76308b0f823ac99ba8c96b030"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad3dbdbd76308b0f823ac99ba8c96b030">AmrMesh</a> (const <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;a_other)=delete</td></tr>
<tr class="memdesc:ad3dbdbd76308b0f823ac99ba8c96b030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed copy constructor.  <a href="classAmrMesh.html#ad3dbdbd76308b0f823ac99ba8c96b030">More...</a><br /></td></tr>
<tr class="separator:ad3dbdbd76308b0f823ac99ba8c96b030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169cb0dcdb19e5bf08061ac7fd6b5780"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a169cb0dcdb19e5bf08061ac7fd6b5780">AmrMesh</a> (const <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&amp;a_other)=delete</td></tr>
<tr class="memdesc:a169cb0dcdb19e5bf08061ac7fd6b5780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed move constructor.  <a href="classAmrMesh.html#a169cb0dcdb19e5bf08061ac7fd6b5780">More...</a><br /></td></tr>
<tr class="separator:a169cb0dcdb19e5bf08061ac7fd6b5780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcc6b58e9fc585510258ae7c3c9332a"><td class="memItemLeft" align="right" valign="top"><a id="a3fcc6b58e9fc585510258ae7c3c9332a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3fcc6b58e9fc585510258ae7c3c9332a">~AmrMesh</a> ()</td></tr>
<tr class="memdesc:a3fcc6b58e9fc585510258ae7c3c9332a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a3fcc6b58e9fc585510258ae7c3c9332a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7cd5f8fa15a16eebfe28f2547ef685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8c7cd5f8fa15a16eebfe28f2547ef685">operator=</a> (const <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;a_other)=delete</td></tr>
<tr class="memdesc:a8c7cd5f8fa15a16eebfe28f2547ef685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed copy assignment.  <a href="classAmrMesh.html#a8c7cd5f8fa15a16eebfe28f2547ef685">More...</a><br /></td></tr>
<tr class="separator:a8c7cd5f8fa15a16eebfe28f2547ef685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62abb1c10ff8d78a358316db0288b140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a62abb1c10ff8d78a358316db0288b140">operator=</a> (const <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&amp;a_other)=delete</td></tr>
<tr class="memdesc:a62abb1c10ff8d78a358316db0288b140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed move assignment.  <a href="classAmrMesh.html#a62abb1c10ff8d78a358316db0288b140">More...</a><br /></td></tr>
<tr class="separator:a62abb1c10ff8d78a358316db0288b140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ab65c2e423aaa581d3adb4fd883b92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5ab65c2e423aaa581d3adb4fd883b92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae5ab65c2e423aaa581d3adb4fd883b92">deallocate</a> (Vector&lt; T * &gt; &amp;a_data) const</td></tr>
<tr class="memdesc:ae5ab65c2e423aaa581d3adb4fd883b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate data.  <a href="classAmrMesh.html#ae5ab65c2e423aaa581d3adb4fd883b92">More...</a><br /></td></tr>
<tr class="separator:ae5ab65c2e423aaa581d3adb4fd883b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4106e7ad20ffcbc318620738f6cec766"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4106e7ad20ffcbc318620738f6cec766"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4106e7ad20ffcbc318620738f6cec766">deallocate</a> (Vector&lt; RefCountedPtr&lt; T &gt;&gt; &amp;a_data) const</td></tr>
<tr class="memdesc:a4106e7ad20ffcbc318620738f6cec766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate smart pointer data.  <a href="classAmrMesh.html#a4106e7ad20ffcbc318620738f6cec766">More...</a><br /></td></tr>
<tr class="separator:a4106e7ad20ffcbc318620738f6cec766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe76068a86db2799fc9e6e96d6a2ccf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebe76068a86db2799fc9e6e96d6a2ccf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aebe76068a86db2799fc9e6e96d6a2ccf">deallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;a_data) const</td></tr>
<tr class="memdesc:aebe76068a86db2799fc9e6e96d6a2ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate data.  <a href="classAmrMesh.html#aebe76068a86db2799fc9e6e96d6a2ccf">More...</a><br /></td></tr>
<tr class="separator:aebe76068a86db2799fc9e6e96d6a2ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1420f5b9c853b5e09334f15966a36f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1420f5b9c853b5e09334f15966a36f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae1420f5b9c853b5e09334f15966a36f6">alias</a> (Vector&lt; T * &gt; &amp;a_alias, const Vector&lt; RefCountedPtr&lt; T &gt;&gt; &amp;a_data) const</td></tr>
<tr class="memdesc:ae1420f5b9c853b5e09334f15966a36f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn smart-pointer data structure into regular-pointer data structure.  <a href="classAmrMesh.html#ae1420f5b9c853b5e09334f15966a36f6">More...</a><br /></td></tr>
<tr class="separator:ae1420f5b9c853b5e09334f15966a36f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7129b60d83999a8e9ebb473987a8f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:add7129b60d83999a8e9ebb473987a8f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#add7129b60d83999a8e9ebb473987a8f4">alias</a> (Vector&lt; T * &gt; &amp;a_alias, const <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; S &gt; &amp;a_data) const</td></tr>
<tr class="memdesc:add7129b60d83999a8e9ebb473987a8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn smart-pointer data structure into regular-pointer data structure.  <a href="classAmrMesh.html#add7129b60d83999a8e9ebb473987a8f4">More...</a><br /></td></tr>
<tr class="separator:add7129b60d83999a8e9ebb473987a8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fffb758e5b66b09bed3d194d99d94c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7fffb758e5b66b09bed3d194d99d94c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad7fffb758e5b66b09bed3d194d99d94c">allocate</a> (Vector&lt; RefCountedPtr&lt; ParticleData&lt; T &gt;&gt;&gt; &amp;a_particles, const std::string a_realm) const</td></tr>
<tr class="memdesc:ad7fffb758e5b66b09bed3d194d99d94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for generic allocation of particle data.  <a href="classAmrMesh.html#ad7fffb758e5b66b09bed3d194d99d94c">More...</a><br /></td></tr>
<tr class="separator:ad7fffb758e5b66b09bed3d194d99d94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f77ca80a54f034ec88ad6451677757"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14f77ca80a54f034ec88ad6451677757"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a14f77ca80a54f034ec88ad6451677757">allocate</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; T &gt; &amp;a_container, const std::string a_realm) const</td></tr>
<tr class="memdesc:a14f77ca80a54f034ec88ad6451677757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for generic allocation of particle containers.  <a href="classAmrMesh.html#a14f77ca80a54f034ec88ad6451677757">More...</a><br /></td></tr>
<tr class="separator:a14f77ca80a54f034ec88ad6451677757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c266b32bccaf75389e17bb093f35e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4c266b32bccaf75389e17bb093f35e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac4c266b32bccaf75389e17bb093f35e0">allocatePointer</a> (Vector&lt; RefCountedPtr&lt; T &gt;&gt; &amp;a_data) const</td></tr>
<tr class="memdesc:ac4c266b32bccaf75389e17bb093f35e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate pointer but not any memory blocks.  <a href="classAmrMesh.html#ac4c266b32bccaf75389e17bb093f35e0">More...</a><br /></td></tr>
<tr class="separator:ac4c266b32bccaf75389e17bb093f35e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43de955ea9fed613ae6514fdc06ccbaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43de955ea9fed613ae6514fdc06ccbaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a43de955ea9fed613ae6514fdc06ccbaf">allocatePointer</a> (Vector&lt; RefCountedPtr&lt; T &gt;&gt; &amp;a_data, const int a_finestLevel) const</td></tr>
<tr class="memdesc:a43de955ea9fed613ae6514fdc06ccbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate pointer but not any memory blocks.  <a href="classAmrMesh.html#a43de955ea9fed613ae6514fdc06ccbaf">More...</a><br /></td></tr>
<tr class="separator:a43de955ea9fed613ae6514fdc06ccbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0624a6f806dc2ee7790916f7d178aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd0624a6f806dc2ee7790916f7d178aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#abd0624a6f806dc2ee7790916f7d178aa">allocatePointer</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;a_data) const</td></tr>
<tr class="memdesc:abd0624a6f806dc2ee7790916f7d178aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate pointer but not any memory blocks.  <a href="classAmrMesh.html#abd0624a6f806dc2ee7790916f7d178aa">More...</a><br /></td></tr>
<tr class="separator:abd0624a6f806dc2ee7790916f7d178aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6b0764f2aa6080931401e3749045ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a6b0764f2aa6080931401e3749045ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8a6b0764f2aa6080931401e3749045ff">allocatePointer</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;a_data, const int a_finestLevel) const</td></tr>
<tr class="memdesc:a8a6b0764f2aa6080931401e3749045ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate pointer but not any memory.  <a href="classAmrMesh.html#a8a6b0764f2aa6080931401e3749045ff">More...</a><br /></td></tr>
<tr class="separator:a8a6b0764f2aa6080931401e3749045ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63a0de47e3bbe424ae5231cab2a963"><td class="memItemLeft" align="right" valign="top"><a id="a7c63a0de47e3bbe424ae5231cab2a963"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a7c63a0de47e3bbe424ae5231cab2a963">parseOptions</a> ()</td></tr>
<tr class="memdesc:a7c63a0de47e3bbe424ae5231cab2a963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse options. Called during the constructor. <br /></td></tr>
<tr class="separator:a7c63a0de47e3bbe424ae5231cab2a963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6d9f11ede790783a919c1cd20870ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0d6d9f11ede790783a919c1cd20870ba">parseRuntimeOptions</a> ()</td></tr>
<tr class="memdesc:a0d6d9f11ede790783a919c1cd20870ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse runtime options.  <a href="classAmrMesh.html#a0d6d9f11ede790783a919c1cd20870ba">More...</a><br /></td></tr>
<tr class="separator:a0d6d9f11ede790783a919c1cd20870ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb365cb3691098693eb0bba6b552fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2bb365cb3691098693eb0bba6b552fe6">registerOperator</a> (const std::string a_operator, const std::string a_realm, const phase::which_phase a_phase)</td></tr>
<tr class="memdesc:a2bb365cb3691098693eb0bba6b552fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an operator over a realm and a phase.  <a href="classAmrMesh.html#a2bb365cb3691098693eb0bba6b552fe6">More...</a><br /></td></tr>
<tr class="separator:a2bb365cb3691098693eb0bba6b552fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9b6818c634e2585a628f30362af1b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#acf9b6818c634e2585a628f30362af1b0">registerMask</a> (const std::string a_mask, const int a_buffer, const std::string a_realm)</td></tr>
<tr class="memdesc:acf9b6818c634e2585a628f30362af1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a boolean mask over a realm.  <a href="classAmrMesh.html#acf9b6818c634e2585a628f30362af1b0">More...</a><br /></td></tr>
<tr class="separator:acf9b6818c634e2585a628f30362af1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429a94d3c17f51f138121c95b8bfe2bf"><td class="memItemLeft" align="right" valign="top"><a id="a429a94d3c17f51f138121c95b8bfe2bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a429a94d3c17f51f138121c95b8bfe2bf">buildDomains</a> ()</td></tr>
<tr class="memdesc:a429a94d3c17f51f138121c95b8bfe2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build domains. <br /></td></tr>
<tr class="separator:a429a94d3c17f51f138121c95b8bfe2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcbb2334af9b06815262abc2ceda9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3dcbb2334af9b06815262abc2ceda9e2">setFinestLevel</a> (const int a_finestLevel)</td></tr>
<tr class="memdesc:a3dcbb2334af9b06815262abc2ceda9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the finest level.  <a href="classAmrMesh.html#a3dcbb2334af9b06815262abc2ceda9e2">More...</a><br /></td></tr>
<tr class="separator:a3dcbb2334af9b06815262abc2ceda9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e8f0c7d2300cba44150fff100efb4"><td class="memItemLeft" align="right" valign="top"><a id="a362e8f0c7d2300cba44150fff100efb4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a362e8f0c7d2300cba44150fff100efb4">setCoarsestGrid</a> (const IntVect &amp;a_nCells)</td></tr>
<tr class="memdesc:a362e8f0c7d2300cba44150fff100efb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coarsest grid cells. <br /></td></tr>
<tr class="separator:a362e8f0c7d2300cba44150fff100efb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7105b45dc3d5db23e1029f9fa95ef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3f7105b45dc3d5db23e1029f9fa95ef2">queryRealm</a> (const std::string a_realm) const</td></tr>
<tr class="memdesc:a3f7105b45dc3d5db23e1029f9fa95ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a realm exists.  <a href="classAmrMesh.html#a3f7105b45dc3d5db23e1029f9fa95ef2">More...</a><br /></td></tr>
<tr class="separator:a3f7105b45dc3d5db23e1029f9fa95ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f0c7045c11ff7348a421675cf5ff6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a70f0c7045c11ff7348a421675cf5ff6b">getEbCf</a> () const</td></tr>
<tr class="memdesc:a70f0c7045c11ff7348a421675cf5ff6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if mesh has an EBCF.  <a href="classAmrMesh.html#a70f0c7045c11ff7348a421675cf5ff6b">More...</a><br /></td></tr>
<tr class="separator:a70f0c7045c11ff7348a421675cf5ff6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd2b0e8c918e6057647103c8193fa17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6dd2b0e8c918e6057647103c8193fa17">registerRealm</a> (const std::string a_realm)</td></tr>
<tr class="memdesc:a6dd2b0e8c918e6057647103c8193fa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new realm.  <a href="classAmrMesh.html#a6dd2b0e8c918e6057647103c8193fa17">More...</a><br /></td></tr>
<tr class="separator:a6dd2b0e8c918e6057647103c8193fa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0c09b67c82352fe4ebd4f9f6ae5fbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5e0c09b67c82352fe4ebd4f9f6ae5fbc">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const phase::which_phase a_phase, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_mfdata, const int a_finestLevel) const</td></tr>
<tr class="memdesc:a5e0c09b67c82352fe4ebd4f9f6ae5fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias multifluid data up to a specified level.  <a href="classAmrMesh.html#a5e0c09b67c82352fe4ebd4f9f6ae5fbc">More...</a><br /></td></tr>
<tr class="separator:a5e0c09b67c82352fe4ebd4f9f6ae5fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e201260012be3d1709f86689af5abf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3e201260012be3d1709f86689af5abf0">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data, const phase::which_phase a_phase, const <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_mfdata, const int a_finestLevel) const</td></tr>
<tr class="memdesc:a3e201260012be3d1709f86689af5abf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias multifluid data up to a specified level.  <a href="classAmrMesh.html#a3e201260012be3d1709f86689af5abf0">More...</a><br /></td></tr>
<tr class="separator:a3e201260012be3d1709f86689af5abf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd8f12c2f367eaed5f168dfc54bd275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9bd8f12c2f367eaed5f168dfc54bd275">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const phase::which_phase a_phase, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_mfdata) const</td></tr>
<tr class="memdesc:a9bd8f12c2f367eaed5f168dfc54bd275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <a href="classAmrMesh.html#a9bd8f12c2f367eaed5f168dfc54bd275">More...</a><br /></td></tr>
<tr class="separator:a9bd8f12c2f367eaed5f168dfc54bd275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c7a7cb2e3783a26312d3533f4cb0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a648c7a7cb2e3783a26312d3533f4cb0f">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data, const phase::which_phase a_phase, const <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_mfdata) const</td></tr>
<tr class="memdesc:a648c7a7cb2e3783a26312d3533f4cb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <a href="classAmrMesh.html#a648c7a7cb2e3783a26312d3533f4cb0f">More...</a><br /></td></tr>
<tr class="separator:a648c7a7cb2e3783a26312d3533f4cb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567e5bc873abc63dc52aee60efa1ba44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a567e5bc873abc63dc52aee60efa1ba44">alias</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_data, const phase::which_phase a_phase, const <a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;a_mfdata) const</td></tr>
<tr class="memdesc:a567e5bc873abc63dc52aee60efa1ba44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <a href="classAmrMesh.html#a567e5bc873abc63dc52aee60efa1ba44">More...</a><br /></td></tr>
<tr class="separator:a567e5bc873abc63dc52aee60efa1ba44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fe5b8146a945e4fe8911fbb57494e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a82fe5b8146a945e4fe8911fbb57494e7">alias</a> (const phase::which_phase a_phase, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_mfdata) const</td></tr>
<tr class="memdesc:a82fe5b8146a945e4fe8911fbb57494e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <a href="classAmrMesh.html#a82fe5b8146a945e4fe8911fbb57494e7">More...</a><br /></td></tr>
<tr class="separator:a82fe5b8146a945e4fe8911fbb57494e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0d11dbe8ad04d37008c260df025374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5f0d11dbe8ad04d37008c260df025374">alias</a> (const phase::which_phase a_phase, const <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_mfdata) const</td></tr>
<tr class="memdesc:a5f0d11dbe8ad04d37008c260df025374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <a href="classAmrMesh.html#a5f0d11dbe8ad04d37008c260df025374">More...</a><br /></td></tr>
<tr class="separator:a5f0d11dbe8ad04d37008c260df025374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8da582e3c2910ba6c168e6a24d5679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#abd8da582e3c2910ba6c168e6a24d5679">alias</a> (const phase::which_phase a_phase, const <a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;a_mfdata) const</td></tr>
<tr class="memdesc:abd8da582e3c2910ba6c168e6a24d5679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias an entire hiearchy of multifluid data.  <a href="classAmrMesh.html#abd8da582e3c2910ba6c168e6a24d5679">More...</a><br /></td></tr>
<tr class="separator:abd8da582e3c2910ba6c168e6a24d5679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03736c8164011068783b32d6c0342caf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a03736c8164011068783b32d6c0342caf">computeGradient</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_gradient, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a03736c8164011068783b32d6c0342caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell-centered gradient over an AMR hierarchy.  <a href="classAmrMesh.html#a03736c8164011068783b32d6c0342caf">More...</a><br /></td></tr>
<tr class="separator:a03736c8164011068783b32d6c0342caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5468ec45f9d206c1d2d99fd74cf42521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5468ec45f9d206c1d2d99fd74cf42521">computeGradient</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_gradient, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a5468ec45f9d206c1d2d99fd74cf42521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face-centered gradient over an AMR hierarchy.  <a href="classAmrMesh.html#a5468ec45f9d206c1d2d99fd74cf42521">More...</a><br /></td></tr>
<tr class="separator:a5468ec45f9d206c1d2d99fd74cf42521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc77b754e28f3212863848aaba964db5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#adc77b754e28f3212863848aaba964db5">computeGradient</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_gradient, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_phi, const std::string a_realm) const</td></tr>
<tr class="memdesc:adc77b754e28f3212863848aaba964db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell-centered gradient over an AMR hierarchy.  <a href="classAmrMesh.html#adc77b754e28f3212863848aaba964db5">More...</a><br /></td></tr>
<tr class="separator:adc77b754e28f3212863848aaba964db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4b4cd76b62eaaca138fbdcd5ec3090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9e4b4cd76b62eaaca138fbdcd5ec3090">computeGradient</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_gradient, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_phi, const std::string a_realm) const</td></tr>
<tr class="memdesc:a9e4b4cd76b62eaaca138fbdcd5ec3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face-centered gradient over an AMR hierarchy.  <a href="classAmrMesh.html#a9e4b4cd76b62eaaca138fbdcd5ec3090">More...</a><br /></td></tr>
<tr class="separator:a9e4b4cd76b62eaaca138fbdcd5ec3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a408d2381f605f562b01a7de04ef2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a97a408d2381f605f562b01a7de04ef2c">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const int a_nComp, const int a_nGhost=-1) const</td></tr>
<tr class="memdesc:a97a408d2381f605f562b01a7de04ef2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <a href="classAmrMesh.html#a97a408d2381f605f562b01a7de04ef2c">More...</a><br /></td></tr>
<tr class="separator:a97a408d2381f605f562b01a7de04ef2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8000cf94e2d87a651cf49c7e853ce6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8000cf94e2d87a651cf49c7e853ce6f4">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const int a_nComp, const int a_nGhost=-1) const</td></tr>
<tr class="memdesc:a8000cf94e2d87a651cf49c7e853ce6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <a href="classAmrMesh.html#a8000cf94e2d87a651cf49c7e853ce6f4">More...</a><br /></td></tr>
<tr class="separator:a8000cf94e2d87a651cf49c7e853ce6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e05b28f775f47845a231661f708c963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4e05b28f775f47845a231661f708c963">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const int a_nComp, const int a_nGhost=-1) const</td></tr>
<tr class="memdesc:a4e05b28f775f47845a231661f708c963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <a href="classAmrMesh.html#a4e05b28f775f47845a231661f708c963">More...</a><br /></td></tr>
<tr class="separator:a4e05b28f775f47845a231661f708c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ebef713ce593b19fe2ffbbba9ce2ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a74ebef713ce593b19fe2ffbbba9ce2ea">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const int a_nComp, const int a_nGhost=-1) const</td></tr>
<tr class="memdesc:a74ebef713ce593b19fe2ffbbba9ce2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <a href="classAmrMesh.html#a74ebef713ce593b19fe2ffbbba9ce2ea">More...</a><br /></td></tr>
<tr class="separator:a74ebef713ce593b19fe2ffbbba9ce2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c89795f369b846f251f1fec56c48a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af5c89795f369b846f251f1fec56c48a5">allocate</a> (<a class="el" href="classEBAMRData.html">EBAMRBool</a> &amp;a_data, const std::string a_realm, const int a_nComp, const int a_nGhost=-1) const</td></tr>
<tr class="memdesc:af5c89795f369b846f251f1fec56c48a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate Boolean data over a specific realm.  <a href="classAmrMesh.html#af5c89795f369b846f251f1fec56c48a5">More...</a><br /></td></tr>
<tr class="separator:af5c89795f369b846f251f1fec56c48a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02342a1d423fc64ed7bd1d3f08fafae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a02342a1d423fc64ed7bd1d3f08fafae6">allocate</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const std::string a_realm, const int a_nComp, const int a_nGhost=-1) const</td></tr>
<tr class="memdesc:a02342a1d423fc64ed7bd1d3f08fafae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <a href="classAmrMesh.html#a02342a1d423fc64ed7bd1d3f08fafae6">More...</a><br /></td></tr>
<tr class="separator:a02342a1d423fc64ed7bd1d3f08fafae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a666605ffc876316d34fe42318a13bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6a666605ffc876316d34fe42318a13bb">allocate</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_data, const std::string a_realm, const int a_nComp, const int a_ghost=-1) const</td></tr>
<tr class="memdesc:a6a666605ffc876316d34fe42318a13bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <a href="classAmrMesh.html#a6a666605ffc876316d34fe42318a13bb">More...</a><br /></td></tr>
<tr class="separator:a6a666605ffc876316d34fe42318a13bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5010f466f55bebc90afc212bd78e494c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5010f466f55bebc90afc212bd78e494c">allocate</a> (<a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;a_data, const std::string a_realm, const int a_nComp, const int a_ghost=0) const</td></tr>
<tr class="memdesc:a5010f466f55bebc90afc212bd78e494c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data holder over a specific realm.  <a href="classAmrMesh.html#a5010f466f55bebc90afc212bd78e494c">More...</a><br /></td></tr>
<tr class="separator:a5010f466f55bebc90afc212bd78e494c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a0c3e11d835a5bd9e3ab8c5950e2ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a87a0c3e11d835a5bd9e3ab8c5950e2ca">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const phase::which_phase a_phase, const int a_lmin) const</td></tr>
<tr class="memdesc:a87a0c3e11d835a5bd9e3ab8c5950e2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <a href="classAmrMesh.html#a87a0c3e11d835a5bd9e3ab8c5950e2ca">More...</a><br /></td></tr>
<tr class="separator:a87a0c3e11d835a5bd9e3ab8c5950e2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612f5b753bfe06523d77d8ffe49d9459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a612f5b753bfe06523d77d8ffe49d9459">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data, const phase::which_phase a_phase, const int a_lmin) const</td></tr>
<tr class="memdesc:a612f5b753bfe06523d77d8ffe49d9459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <a href="classAmrMesh.html#a612f5b753bfe06523d77d8ffe49d9459">More...</a><br /></td></tr>
<tr class="separator:a612f5b753bfe06523d77d8ffe49d9459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad120065536a58ff9f0c4662c03a8449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aad120065536a58ff9f0c4662c03a8449">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_data, const phase::which_phase a_phase, const int a_lmin) const</td></tr>
<tr class="memdesc:aad120065536a58ff9f0c4662c03a8449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <a href="classAmrMesh.html#aad120065536a58ff9f0c4662c03a8449">More...</a><br /></td></tr>
<tr class="separator:aad120065536a58ff9f0c4662c03a8449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ec9fb80cd2579acf88acb51738403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a991ec9fb80cd2579acf88acb51738403">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;a_data, const phase::which_phase a_phase, const int a_lmin) const</td></tr>
<tr class="memdesc:a991ec9fb80cd2579acf88acb51738403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <a href="classAmrMesh.html#a991ec9fb80cd2579acf88acb51738403">More...</a><br /></td></tr>
<tr class="separator:a991ec9fb80cd2579acf88acb51738403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074cd4a99c5c29bf499cd20688d5ca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5074cd4a99c5c29bf499cd20688d5ca2">reallocate</a> (<a class="el" href="classEBAMRData.html">EBAMRBool</a> &amp;a_data, const int a_lmin) const</td></tr>
<tr class="memdesc:a5074cd4a99c5c29bf499cd20688d5ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <a href="classAmrMesh.html#a5074cd4a99c5c29bf499cd20688d5ca2">More...</a><br /></td></tr>
<tr class="separator:a5074cd4a99c5c29bf499cd20688d5ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9a31a2a37e7d804a6aa80ca3e7fc7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#acc9a31a2a37e7d804a6aa80ca3e7fc7d">reallocate</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const int a_lmin) const</td></tr>
<tr class="memdesc:acc9a31a2a37e7d804a6aa80ca3e7fc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <a href="classAmrMesh.html#acc9a31a2a37e7d804a6aa80ca3e7fc7d">More...</a><br /></td></tr>
<tr class="separator:acc9a31a2a37e7d804a6aa80ca3e7fc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac523d5d24140c8f8e84e118ff8c4123e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac523d5d24140c8f8e84e118ff8c4123e">reallocate</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_data, const int a_lmin) const</td></tr>
<tr class="memdesc:ac523d5d24140c8f8e84e118ff8c4123e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <a href="classAmrMesh.html#ac523d5d24140c8f8e84e118ff8c4123e">More...</a><br /></td></tr>
<tr class="separator:ac523d5d24140c8f8e84e118ff8c4123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e98284a18faae8ac933f5cbe469f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a14e98284a18faae8ac933f5cbe469f74">reallocate</a> (<a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;a_data, const int a_lmin) const</td></tr>
<tr class="memdesc:a14e98284a18faae8ac933f5cbe469f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate data.  <a href="classAmrMesh.html#a14e98284a18faae8ac933f5cbe469f74">More...</a><br /></td></tr>
<tr class="separator:a14e98284a18faae8ac933f5cbe469f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9db6f208842207e02524d7cc61d0961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac9db6f208842207e02524d7cc61d0961">average</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const std::string a_realm, const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;a_average) const</td></tr>
<tr class="memdesc:ac9db6f208842207e02524d7cc61d0961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average multifluid data over a specified realm.  <a href="classAmrMesh.html#ac9db6f208842207e02524d7cc61d0961">More...</a><br /></td></tr>
<tr class="separator:ac9db6f208842207e02524d7cc61d0961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c3e36e18a1b3feefe1bc12e0b59a8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a41c3e36e18a1b3feefe1bc12e0b59a8d">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:a41c3e36e18a1b3feefe1bc12e0b59a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic coarsening of multifluid data.  <a href="classAmrMesh.html#a41c3e36e18a1b3feefe1bc12e0b59a8d">More...</a><br /></td></tr>
<tr class="separator:a41c3e36e18a1b3feefe1bc12e0b59a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186c852306b0260ad0637599217ea035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a186c852306b0260ad0637599217ea035">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:a186c852306b0260ad0637599217ea035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonic coarsening of multifluid data.  <a href="classAmrMesh.html#a186c852306b0260ad0637599217ea035">More...</a><br /></td></tr>
<tr class="separator:a186c852306b0260ad0637599217ea035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b3f8d395e81592ba629ebc11b9141e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a53b3f8d395e81592ba629ebc11b9141e">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:a53b3f8d395e81592ba629ebc11b9141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conservative coarsening of multifluid data.  <a href="classAmrMesh.html#a53b3f8d395e81592ba629ebc11b9141e">More...</a><br /></td></tr>
<tr class="separator:a53b3f8d395e81592ba629ebc11b9141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35796165052eb306d772d0471eca391b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a35796165052eb306d772d0471eca391b">average</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_data, const std::string a_realm, const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;a_average) const</td></tr>
<tr class="memdesc:a35796165052eb306d772d0471eca391b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average multifluid data over a specified realm.  <a href="classAmrMesh.html#a35796165052eb306d772d0471eca391b">More...</a><br /></td></tr>
<tr class="separator:a35796165052eb306d772d0471eca391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64caac626d5f6846785a8ad7a855303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad64caac626d5f6846785a8ad7a855303">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:ad64caac626d5f6846785a8ad7a855303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average multifluid data over a realm.  <a href="classAmrMesh.html#ad64caac626d5f6846785a8ad7a855303">More...</a><br /></td></tr>
<tr class="separator:ad64caac626d5f6846785a8ad7a855303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e9d87d1e36b48c25847153b44b2db2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae4e9d87d1e36b48c25847153b44b2db2">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:ae4e9d87d1e36b48c25847153b44b2db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average multifluid data over a realm.  <a href="classAmrMesh.html#ae4e9d87d1e36b48c25847153b44b2db2">More...</a><br /></td></tr>
<tr class="separator:ae4e9d87d1e36b48c25847153b44b2db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe7ab07b30103513af9784864aba639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aabe7ab07b30103513af9784864aba639">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:aabe7ab07b30103513af9784864aba639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down multifluid data over a realm.  <a href="classAmrMesh.html#aabe7ab07b30103513af9784864aba639">More...</a><br /></td></tr>
<tr class="separator:aabe7ab07b30103513af9784864aba639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6540dc8db6193a32c989936f8b47da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af6540dc8db6193a32c989936f8b47da1">average</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;a_average) const</td></tr>
<tr class="memdesc:af6540dc8db6193a32c989936f8b47da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <a href="classAmrMesh.html#af6540dc8db6193a32c989936f8b47da1">More...</a><br /></td></tr>
<tr class="separator:af6540dc8db6193a32c989936f8b47da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07eed6758ee76431667b3832f36b966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa07eed6758ee76431667b3832f36b966">average</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;a_average, const Interval &amp;a_variables) const</td></tr>
<tr class="memdesc:aa07eed6758ee76431667b3832f36b966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <a href="classAmrMesh.html#aa07eed6758ee76431667b3832f36b966">More...</a><br /></td></tr>
<tr class="separator:aa07eed6758ee76431667b3832f36b966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eb5733b4a2fce7c522c37d3c1347ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af6eb5733b4a2fce7c522c37d3c1347ff">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:af6eb5733b4a2fce7c522c37d3c1347ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic average of data. Does all components.  <a href="classAmrMesh.html#af6eb5733b4a2fce7c522c37d3c1347ff">More...</a><br /></td></tr>
<tr class="separator:af6eb5733b4a2fce7c522c37d3c1347ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c8382e0e99edfdbf353d60b46d41ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a57c8382e0e99edfdbf353d60b46d41ba">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const Interval &amp;a_variables) const</td></tr>
<tr class="memdesc:a57c8382e0e99edfdbf353d60b46d41ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic average of data.  <a href="classAmrMesh.html#a57c8382e0e99edfdbf353d60b46d41ba">More...</a><br /></td></tr>
<tr class="separator:a57c8382e0e99edfdbf353d60b46d41ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b49e5fa25c6a4bb059a6c3e25b1c078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4b49e5fa25c6a4bb059a6c3e25b1c078">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a4b49e5fa25c6a4bb059a6c3e25b1c078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonic average of data. Does all components.  <a href="classAmrMesh.html#a4b49e5fa25c6a4bb059a6c3e25b1c078">More...</a><br /></td></tr>
<tr class="separator:a4b49e5fa25c6a4bb059a6c3e25b1c078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3e29a7ec2d7e88c8ba7410e1fda2ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#adb3e29a7ec2d7e88c8ba7410e1fda2ea">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const Interval &amp;a_variables) const</td></tr>
<tr class="memdesc:adb3e29a7ec2d7e88c8ba7410e1fda2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonic average of data. Does all components.  <a href="classAmrMesh.html#adb3e29a7ec2d7e88c8ba7410e1fda2ea">More...</a><br /></td></tr>
<tr class="separator:adb3e29a7ec2d7e88c8ba7410e1fda2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae69d99efb79d91bbf8ddfa33b61ab0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aae69d99efb79d91bbf8ddfa33b61ab0f">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:aae69d99efb79d91bbf8ddfa33b61ab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conseratively average data. Does all components.  <a href="classAmrMesh.html#aae69d99efb79d91bbf8ddfa33b61ab0f">More...</a><br /></td></tr>
<tr class="separator:aae69d99efb79d91bbf8ddfa33b61ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd84b6a06ba937f38448a89a3f6882b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0bd84b6a06ba937f38448a89a3f6882b">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const Interval &amp;a_variables) const</td></tr>
<tr class="memdesc:a0bd84b6a06ba937f38448a89a3f6882b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conseratively average data. Does all components.  <a href="classAmrMesh.html#a0bd84b6a06ba937f38448a89a3f6882b">More...</a><br /></td></tr>
<tr class="separator:a0bd84b6a06ba937f38448a89a3f6882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1459b80feff30769ea928f10907fcc89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1459b80feff30769ea928f10907fcc89">average</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;a_average) const</td></tr>
<tr class="memdesc:a1459b80feff30769ea928f10907fcc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <a href="classAmrMesh.html#a1459b80feff30769ea928f10907fcc89">More...</a><br /></td></tr>
<tr class="separator:a1459b80feff30769ea928f10907fcc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb661908599529bdc686d2de016a16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#abdb661908599529bdc686d2de016a16f">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:abdb661908599529bdc686d2de016a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <a href="classAmrMesh.html#abdb661908599529bdc686d2de016a16f">More...</a><br /></td></tr>
<tr class="separator:abdb661908599529bdc686d2de016a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b2fdcbb8c36d6ccd8e6b836980ab3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a00b2fdcbb8c36d6ccd8e6b836980ab3c">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a00b2fdcbb8c36d6ccd8e6b836980ab3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <a href="classAmrMesh.html#a00b2fdcbb8c36d6ccd8e6b836980ab3c">More...</a><br /></td></tr>
<tr class="separator:a00b2fdcbb8c36d6ccd8e6b836980ab3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32fe0c1d230d0a0dadee647d7d2730b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af32fe0c1d230d0a0dadee647d7d2730b">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:af32fe0c1d230d0a0dadee647d7d2730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <a href="classAmrMesh.html#af32fe0c1d230d0a0dadee647d7d2730b">More...</a><br /></td></tr>
<tr class="separator:af32fe0c1d230d0a0dadee647d7d2730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3a4063ef5b08f363743daa70496b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#acc3a4063ef5b08f363743daa70496b45">average</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase, const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;a_average) const</td></tr>
<tr class="memdesc:acc3a4063ef5b08f363743daa70496b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average down on specific realm and phase.  <a href="classAmrMesh.html#acc3a4063ef5b08f363743daa70496b45">More...</a><br /></td></tr>
<tr class="separator:acc3a4063ef5b08f363743daa70496b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbddcd21848988ec71d1525f80076bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2bbddcd21848988ec71d1525f80076bc">arithmeticAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a2bbddcd21848988ec71d1525f80076bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic average on specific realm and phase.  <a href="classAmrMesh.html#a2bbddcd21848988ec71d1525f80076bc">More...</a><br /></td></tr>
<tr class="separator:a2bbddcd21848988ec71d1525f80076bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259cb2f2336f091eeb1955b7c525a040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a259cb2f2336f091eeb1955b7c525a040">harmonicAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a259cb2f2336f091eeb1955b7c525a040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harmonic average on specific realm and phase.  <a href="classAmrMesh.html#a259cb2f2336f091eeb1955b7c525a040">More...</a><br /></td></tr>
<tr class="separator:a259cb2f2336f091eeb1955b7c525a040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ebca4c73310fecee761a9f74b8fe01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae9ebca4c73310fecee761a9f74b8fe01">conservativeAverage</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:ae9ebca4c73310fecee761a9f74b8fe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conservative averaging on specific realm and phase.  <a href="classAmrMesh.html#ae9ebca4c73310fecee761a9f74b8fe01">More...</a><br /></td></tr>
<tr class="separator:ae9ebca4c73310fecee761a9f74b8fe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const std::string &amp;a_realm, const phase::which_phase &amp;a_phase, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit scalar particle quantities on the mesh.  <a href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">More...</a><br /></td></tr>
<tr class="separator:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const std::string &amp;a_realm, const phase::which_phase &amp;a_phase, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit scalar particle quantities on the mesh.  <a href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">More...</a><br /></td></tr>
<tr class="separator:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplParams" colspan="2">template&lt;class P , const RealVect &amp;(P::*)() const particleVectorField&gt; </td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const std::string &amp;a_realm, const phase::which_phase &amp;a_phase, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit vector particle quantities on the mesh.  <a href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">More...</a><br /></td></tr>
<tr class="separator:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplParams" colspan="2">template&lt;class P , RealVect(P::*)() const particleVectorField&gt; </td></tr>
<tr class="memitem:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const std::string &amp;a_realm, const phase::which_phase &amp;a_phase, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit vector particle quantities on the mesh.  <a href="classAmrMesh.html#a5032e0accfccfbc5c77cd8d4e6bbe578">More...</a><br /></td></tr>
<tr class="separator:a5032e0accfccfbc5c77cd8d4e6bbe578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07d5998e160d5430c49bc238e819e77"><td class="memTemplParams" colspan="2">template&lt;class P , Real &amp;(P::*)() particleScalarField&gt; </td></tr>
<tr class="memitem:aa07d5998e160d5430c49bc238e819e77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa07d5998e160d5430c49bc238e819e77">interpolateParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const std::string &amp;a_realm, const phase::which_phase &amp;a_phase, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshScalarField, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_interpType, const bool a_forceIrregNGP=false) const</td></tr>
<tr class="memdesc:aa07d5998e160d5430c49bc238e819e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a scalar field onto the particle position.  <a href="classAmrMesh.html#aa07d5998e160d5430c49bc238e819e77">More...</a><br /></td></tr>
<tr class="separator:aa07d5998e160d5430c49bc238e819e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac073bb1b20ac52395c1a2403af462996"><td class="memTemplParams" colspan="2">template&lt;class P , RealVect &amp;(P::*)() particleVectorField&gt; </td></tr>
<tr class="memitem:ac073bb1b20ac52395c1a2403af462996"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac073bb1b20ac52395c1a2403af462996">interpolateParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const std::string &amp;a_realm, const phase::which_phase &amp;a_phase, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshVectorField, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_interpType, const bool a_forceIrregNGP=false) const</td></tr>
<tr class="memdesc:ac073bb1b20ac52395c1a2403af462996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector field onto the particle position.  <a href="classAmrMesh.html#ac073bb1b20ac52395c1a2403af462996">More...</a><br /></td></tr>
<tr class="separator:ac073bb1b20ac52395c1a2403af462996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412d58b270f56e04aa17127c0fcf5f46"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a412d58b270f56e04aa17127c0fcf5f46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a412d58b270f56e04aa17127c0fcf5f46">removeCoveredParticlesIF</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const phase::which_phase &amp;a_phase, const Real a_tolerance=0.0) const</td></tr>
<tr class="memdesc:a412d58b270f56e04aa17127c0fcf5f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which removes particles from the domain if they fall inside the EB.  <a href="classAmrMesh.html#a412d58b270f56e04aa17127c0fcf5f46">More...</a><br /></td></tr>
<tr class="separator:a412d58b270f56e04aa17127c0fcf5f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb1b3008526e53b38e09e96e0e88487"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a6fb1b3008526e53b38e09e96e0e88487"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6fb1b3008526e53b38e09e96e0e88487">removeCoveredParticlesDiscrete</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const phase::which_phase &amp;a_phase, const Real a_tolerance=0.0) const</td></tr>
<tr class="memdesc:a6fb1b3008526e53b38e09e96e0e88487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which removes particles from the domain if they fall inside the EB.  <a href="classAmrMesh.html#a6fb1b3008526e53b38e09e96e0e88487">More...</a><br /></td></tr>
<tr class="separator:a6fb1b3008526e53b38e09e96e0e88487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036c315af1e9c46ba5320a3de0017927"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a036c315af1e9c46ba5320a3de0017927"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a036c315af1e9c46ba5320a3de0017927">removeCoveredParticlesVoxels</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const phase::which_phase &amp;a_phase) const</td></tr>
<tr class="memdesc:a036c315af1e9c46ba5320a3de0017927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which removes particles from the domain if they fall inside the EB.  <a href="classAmrMesh.html#a036c315af1e9c46ba5320a3de0017927">More...</a><br /></td></tr>
<tr class="separator:a036c315af1e9c46ba5320a3de0017927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c75449e9996805572bc01bd43042b2"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a25c75449e9996805572bc01bd43042b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a25c75449e9996805572bc01bd43042b2">transferCoveredParticlesIF</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particlesFrom, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particlesTo, const phase::which_phase &amp;a_phase, const Real a_tolerance=0.0) const</td></tr>
<tr class="memdesc:a25c75449e9996805572bc01bd43042b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which transferse particles from one particle container to another if they fall inside the EB.  <a href="classAmrMesh.html#a25c75449e9996805572bc01bd43042b2">More...</a><br /></td></tr>
<tr class="separator:a25c75449e9996805572bc01bd43042b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b91aa63e558054ea913b05e797ec50"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a06b91aa63e558054ea913b05e797ec50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a06b91aa63e558054ea913b05e797ec50">transferCoveredParticlesDiscrete</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particlesFrom, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particlesTo, const phase::which_phase &amp;a_phase, const Real a_tolerance=0.0) const</td></tr>
<tr class="memdesc:a06b91aa63e558054ea913b05e797ec50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which transferse particles from one particle container to another if they fall inside the EB.  <a href="classAmrMesh.html#a06b91aa63e558054ea913b05e797ec50">More...</a><br /></td></tr>
<tr class="separator:a06b91aa63e558054ea913b05e797ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccc54b19b8398a8c48c4ef8b2ea026c"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:adccc54b19b8398a8c48c4ef8b2ea026c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#adccc54b19b8398a8c48c4ef8b2ea026c">transferCoveredParticlesVoxels</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particlesFrom, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particlesTo, const phase::which_phase &amp;a_phase) const</td></tr>
<tr class="memdesc:adccc54b19b8398a8c48c4ef8b2ea026c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which transferse particles from one particle container to another if they fall inside the EB.  <a href="classAmrMesh.html#adccc54b19b8398a8c48c4ef8b2ea026c">More...</a><br /></td></tr>
<tr class="separator:adccc54b19b8398a8c48c4ef8b2ea026c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ada016124b15d40ea5c6661c8f60f4"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:aa5ada016124b15d40ea5c6661c8f60f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa5ada016124b15d40ea5c6661c8f60f4">intersectParticlesRaycastIF</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_activeParticles, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_ebParticles, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_domainParticles, const phase::which_phase a_phase, const Real a_tolerance, const bool a_deleteParticles) const</td></tr>
<tr class="memdesc:aa5ada016124b15d40ea5c6661c8f60f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle intersection algorithm based on ray-casting.  <a href="classAmrMesh.html#aa5ada016124b15d40ea5c6661c8f60f4">More...</a><br /></td></tr>
<tr class="separator:aa5ada016124b15d40ea5c6661c8f60f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f00c083961d5921ba325b971838db"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:aff0f00c083961d5921ba325b971838db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aff0f00c083961d5921ba325b971838db">intersectParticlesBisectIF</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_activeParticles, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_ebParticles, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_domainParticles, const phase::which_phase a_phase, const Real a_bisectionStep, const bool a_deleteParticles) const</td></tr>
<tr class="memdesc:aff0f00c083961d5921ba325b971838db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle intersection algorithm based on bisection.  <a href="classAmrMesh.html#aff0f00c083961d5921ba325b971838db">More...</a><br /></td></tr>
<tr class="separator:aff0f00c083961d5921ba325b971838db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980ef520e5d9c3a2977a6c43d432b523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a980ef520e5d9c3a2977a6c43d432b523">interpGhost</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a980ef520e5d9c3a2977a6c43d432b523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost vectors over a realm, using the default ghost cell interpolation method.  <a href="classAmrMesh.html#a980ef520e5d9c3a2977a6c43d432b523">More...</a><br /></td></tr>
<tr class="separator:a980ef520e5d9c3a2977a6c43d432b523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff48bbba8105fcfea99d8796268eaab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5ff48bbba8105fcfea99d8796268eaab">interpGhost</a> (LevelData&lt; EBCellFAB &gt; &amp;a_fineData, const LevelData&lt; EBCellFAB &gt; &amp;a_coarData, const int a_level, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a5ff48bbba8105fcfea99d8796268eaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm, using the default ghost cell interpolation method on a specific level.  <a href="classAmrMesh.html#a5ff48bbba8105fcfea99d8796268eaab">More...</a><br /></td></tr>
<tr class="separator:a5ff48bbba8105fcfea99d8796268eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f71b81c581b084edff3a03e61ce943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a03f71b81c581b084edff3a03e61ce943">interpGhost</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:a03f71b81c581b084edff3a03e61ce943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm. Calls the default ghost cell interpolation method.  <a href="classAmrMesh.html#a03f71b81c581b084edff3a03e61ce943">More...</a><br /></td></tr>
<tr class="separator:a03f71b81c581b084edff3a03e61ce943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa6a3ddddeb4ffdda877719e545eaef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3aa6a3ddddeb4ffdda877719e545eaef">interpGhostPwl</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:a3aa6a3ddddeb4ffdda877719e545eaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm and phase. This uses piecewise linear interpolation (with limiters)  <a href="classAmrMesh.html#a3aa6a3ddddeb4ffdda877719e545eaef">More...</a><br /></td></tr>
<tr class="separator:a3aa6a3ddddeb4ffdda877719e545eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b4b8c5a83b8df8a3f23c93cd81a834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a88b4b8c5a83b8df8a3f23c93cd81a834">interpGhostPwl</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a88b4b8c5a83b8df8a3f23c93cd81a834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm and phase. This uses piecewise linear interpolation (with limiters)  <a href="classAmrMesh.html#a88b4b8c5a83b8df8a3f23c93cd81a834">More...</a><br /></td></tr>
<tr class="separator:a88b4b8c5a83b8df8a3f23c93cd81a834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a019193845e8ff43c846575570b0c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4a019193845e8ff43c846575570b0c0a">interpGhostMG</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data, const std::string a_realm) const</td></tr>
<tr class="memdesc:a4a019193845e8ff43c846575570b0c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm and phase.  <a href="classAmrMesh.html#a4a019193845e8ff43c846575570b0c0a">More...</a><br /></td></tr>
<tr class="separator:a4a019193845e8ff43c846575570b0c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187f9807eae7f2c90a6b0ac1c32f8cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a187f9807eae7f2c90a6b0ac1c32f8cb1">interpGhostMG</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a187f9807eae7f2c90a6b0ac1c32f8cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate ghost cells over a realm and phase.  <a href="classAmrMesh.html#a187f9807eae7f2c90a6b0ac1c32f8cb1">More...</a><br /></td></tr>
<tr class="separator:a187f9807eae7f2c90a6b0ac1c32f8cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ced532eeaca03e97e064b0a6cf3bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a27ced532eeaca03e97e064b0a6cf3bc1">interpToNewGrids</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_newData, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_oldData, const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel, const bool a_useSlopes)</td></tr>
<tr class="memdesc:a27ced532eeaca03e97e064b0a6cf3bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to new grids.  <a href="classAmrMesh.html#a27ced532eeaca03e97e064b0a6cf3bc1">More...</a><br /></td></tr>
<tr class="separator:a27ced532eeaca03e97e064b0a6cf3bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d58d2eac35c0c39372e209dd8a1951c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8d58d2eac35c0c39372e209dd8a1951c">interpToNewGrids</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_newData, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_oldData, const phase::which_phase a_phase, const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel, const bool a_useSlopes)</td></tr>
<tr class="memdesc:a8d58d2eac35c0c39372e209dd8a1951c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to new grids.  <a href="classAmrMesh.html#a8d58d2eac35c0c39372e209dd8a1951c">More...</a><br /></td></tr>
<tr class="separator:a8d58d2eac35c0c39372e209dd8a1951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab6792375474b61a99bd36203fd3de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aeab6792375474b61a99bd36203fd3de3">interpToNewGrids</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_newData, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_oldData, const phase::which_phase a_phase, const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel, const bool a_conservative)</td></tr>
<tr class="memdesc:aeab6792375474b61a99bd36203fd3de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to new grids.  <a href="classAmrMesh.html#aeab6792375474b61a99bd36203fd3de3">More...</a><br /></td></tr>
<tr class="separator:aeab6792375474b61a99bd36203fd3de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58008f166bc2d7de06c4c24d879513fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a58008f166bc2d7de06c4c24d879513fe">interpToCentroids</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a58008f166bc2d7de06c4c24d879513fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to centroids on realm and phase.  <a href="classAmrMesh.html#a58008f166bc2d7de06c4c24d879513fe">More...</a><br /></td></tr>
<tr class="separator:a58008f166bc2d7de06c4c24d879513fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0ed99e2d6e6edf3fb65ad4b79d9a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a80a0ed99e2d6e6edf3fb65ad4b79d9a0">setMultifluidIndexSpace</a> (const RefCountedPtr&lt; <a class="el" href="classMultiFluidIndexSpace.html">MultiFluidIndexSpace</a> &gt; &amp;a_multiFluidIndexSpace)</td></tr>
<tr class="memdesc:a80a0ed99e2d6e6edf3fb65ad4b79d9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets multifluid index space.  <a href="classAmrMesh.html#a80a0ed99e2d6e6edf3fb65ad4b79d9a0">More...</a><br /></td></tr>
<tr class="separator:a80a0ed99e2d6e6edf3fb65ad4b79d9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc74d0037dc972aea59860feeb54a6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#afc74d0037dc972aea59860feeb54a6e3">setBaseImplicitFunction</a> (const phase::which_phase a_phase, const RefCountedPtr&lt; BaseIF &gt; &amp;a_baseIF)</td></tr>
<tr class="memdesc:afc74d0037dc972aea59860feeb54a6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set implicit function for a specific phase. Need e.g. for level-sets.  <a href="classAmrMesh.html#afc74d0037dc972aea59860feeb54a6e3">More...</a><br /></td></tr>
<tr class="separator:afc74d0037dc972aea59860feeb54a6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8897dc00f6ac738080aba2ec29ad7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9a8897dc00f6ac738080aba2ec29ad7a">regridAmr</a> (const Vector&lt; IntVectSet &gt; &amp;a_tags, const int a_lmin, const int a_hardcap=-1)</td></tr>
<tr class="memdesc:a9a8897dc00f6ac738080aba2ec29ad7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid AMR. This versions generates the grids and Realms, but not the operator.  <a href="classAmrMesh.html#a9a8897dc00f6ac738080aba2ec29ad7a">More...</a><br /></td></tr>
<tr class="separator:a9a8897dc00f6ac738080aba2ec29ad7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3183dc6d7db9eae4ed1af8c80ea0c893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3183dc6d7db9eae4ed1af8c80ea0c893">regridRealm</a> (const std::string a_realm, const Vector&lt; Vector&lt; int &gt;&gt; &amp;a_procs, const Vector&lt; Vector&lt; Box &gt;&gt; &amp;a_boxes, const int a_lmin)</td></tr>
<tr class="memdesc:a3183dc6d7db9eae4ed1af8c80ea0c893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid a realm. This generates the grids for the realm, but does not do the operators on the realm.  <a href="classAmrMesh.html#a3183dc6d7db9eae4ed1af8c80ea0c893">More...</a><br /></td></tr>
<tr class="separator:a3183dc6d7db9eae4ed1af8c80ea0c893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1dedaf7d55ced2c775b32d401a08fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4a1dedaf7d55ced2c775b32d401a08fd">setGrids</a> (const Vector&lt; Vector&lt; Box &gt;&gt; &amp;a_boxes, const std::map&lt; std::string, Vector&lt; Vector&lt; long int &gt;&gt;&gt; &amp;a_realmsAndLoads)</td></tr>
<tr class="memdesc:a4a1dedaf7d55ced2c775b32d401a08fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set grids from boxes and computational loads.  <a href="classAmrMesh.html#a4a1dedaf7d55ced2c775b32d401a08fd">More...</a><br /></td></tr>
<tr class="separator:a4a1dedaf7d55ced2c775b32d401a08fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8e3a7de269ef9be0121c22eed428d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aee8e3a7de269ef9be0121c22eed428d5">regridOperators</a> (const int a_lmin)</td></tr>
<tr class="memdesc:aee8e3a7de269ef9be0121c22eed428d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid AMR operators. This is done for all realms.  <a href="classAmrMesh.html#aee8e3a7de269ef9be0121c22eed428d5">More...</a><br /></td></tr>
<tr class="separator:aee8e3a7de269ef9be0121c22eed428d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673a01e951aa1b355b60416c3ea3f55f"><td class="memItemLeft" align="right" valign="top"><a id="a673a01e951aa1b355b60416c3ea3f55f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a673a01e951aa1b355b60416c3ea3f55f">sanityCheck</a> () const</td></tr>
<tr class="memdesc:a673a01e951aa1b355b60416c3ea3f55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a sanity check to make sure everything is set up correctly. <br /></td></tr>
<tr class="separator:a673a01e951aa1b355b60416c3ea3f55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff00899eeda16c714410146ecc2c8af7"><td class="memItemLeft" align="right" valign="top"><a id="aff00899eeda16c714410146ecc2c8af7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aff00899eeda16c714410146ecc2c8af7">getFinestLevel</a> () const</td></tr>
<tr class="memdesc:aff00899eeda16c714410146ecc2c8af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get finest grid level. <br /></td></tr>
<tr class="separator:aff00899eeda16c714410146ecc2c8af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65edfcba2c19e22298dce39d524cfc5"><td class="memItemLeft" align="right" valign="top"><a id="ae65edfcba2c19e22298dce39d524cfc5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae65edfcba2c19e22298dce39d524cfc5">getMaxAmrDepth</a> () const</td></tr>
<tr class="memdesc:ae65edfcba2c19e22298dce39d524cfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum permitted amr depth. <br /></td></tr>
<tr class="separator:ae65edfcba2c19e22298dce39d524cfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22db83d03132b22c64dbe04918d6c0"><td class="memItemLeft" align="right" valign="top"><a id="a3a22db83d03132b22c64dbe04918d6c0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3a22db83d03132b22c64dbe04918d6c0">getMaxSimulationDepth</a> () const</td></tr>
<tr class="memdesc:a3a22db83d03132b22c64dbe04918d6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum permitted simulation depth. <br /></td></tr>
<tr class="separator:a3a22db83d03132b22c64dbe04918d6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41d05854bb69a10ac374a1c785a8142"><td class="memItemLeft" align="right" valign="top"><a id="ac41d05854bb69a10ac374a1c785a8142"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac41d05854bb69a10ac374a1c785a8142">getBlockingFactor</a> () const</td></tr>
<tr class="memdesc:ac41d05854bb69a10ac374a1c785a8142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get blocking factor (i.e. the smallest possible box). <br /></td></tr>
<tr class="separator:ac41d05854bb69a10ac374a1c785a8142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf47a8b74e8fe8527ac9e97779c5e1e"><td class="memItemLeft" align="right" valign="top"><a id="aabf47a8b74e8fe8527ac9e97779c5e1e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aabf47a8b74e8fe8527ac9e97779c5e1e">getMaxBoxSize</a> () const</td></tr>
<tr class="memdesc:aabf47a8b74e8fe8527ac9e97779c5e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum permitted box size. <br /></td></tr>
<tr class="separator:aabf47a8b74e8fe8527ac9e97779c5e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa14b4ba44f64a8bc5164ae97591032d"><td class="memItemLeft" align="right" valign="top"><a id="aaa14b4ba44f64a8bc5164ae97591032d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aaa14b4ba44f64a8bc5164ae97591032d">getBrBuffer</a> () const</td></tr>
<tr class="memdesc:aaa14b4ba44f64a8bc5164ae97591032d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return buffer for B-R mesh refinement algorithm. <br /></td></tr>
<tr class="separator:aaa14b4ba44f64a8bc5164ae97591032d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee371b14070e14d0a7624b943ff2441"><td class="memItemLeft" align="right" valign="top"><a id="aaee371b14070e14d0a7624b943ff2441"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aaee371b14070e14d0a7624b943ff2441">getMaxEbisBoxSize</a> () const</td></tr>
<tr class="memdesc:aaee371b14070e14d0a7624b943ff2441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum box size for EBIS generation. <br /></td></tr>
<tr class="separator:aaee371b14070e14d0a7624b943ff2441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9644428ada5f48e3fcdb512898cc1e62"><td class="memItemLeft" align="right" valign="top"><a id="a9644428ada5f48e3fcdb512898cc1e62"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9644428ada5f48e3fcdb512898cc1e62">getNumberOfGhostCells</a> () const</td></tr>
<tr class="memdesc:a9644428ada5f48e3fcdb512898cc1e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default number of ghost cells. <br /></td></tr>
<tr class="separator:a9644428ada5f48e3fcdb512898cc1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a363c78f0c85f9c8d0a66da2b40d37"><td class="memItemLeft" align="right" valign="top"><a id="af6a363c78f0c85f9c8d0a66da2b40d37"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af6a363c78f0c85f9c8d0a66da2b40d37">getNumberOfEbGhostCells</a> () const</td></tr>
<tr class="memdesc:af6a363c78f0c85f9c8d0a66da2b40d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of ghost cells used for EB grid generation. <br /></td></tr>
<tr class="separator:af6a363c78f0c85f9c8d0a66da2b40d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0797ec9054cf1b463a3202f99409651"><td class="memItemLeft" align="right" valign="top"><a id="af0797ec9054cf1b463a3202f99409651"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af0797ec9054cf1b463a3202f99409651">getRedistributionRadius</a> () const</td></tr>
<tr class="memdesc:af0797ec9054cf1b463a3202f99409651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default redistribution radius. <br /></td></tr>
<tr class="separator:af0797ec9054cf1b463a3202f99409651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dad5645ed0341ada0681607da1d600"><td class="memItemLeft" align="right" valign="top"><a id="a13dad5645ed0341ada0681607da1d600"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a13dad5645ed0341ada0681607da1d600">getFinestDx</a> () const</td></tr>
<tr class="memdesc:a13dad5645ed0341ada0681607da1d600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get resolution on the finest grid level. <br /></td></tr>
<tr class="separator:a13dad5645ed0341ada0681607da1d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e22af33b0bc2737eb911562b2796ee4"><td class="memItemLeft" align="right" valign="top"><a id="a7e22af33b0bc2737eb911562b2796ee4"></a>
RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a7e22af33b0bc2737eb911562b2796ee4">getProbLo</a> () const</td></tr>
<tr class="memdesc:a7e22af33b0bc2737eb911562b2796ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lower-left corner of computational domain. <br /></td></tr>
<tr class="separator:a7e22af33b0bc2737eb911562b2796ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e8e100d4851aa4088ac38c857a6882"><td class="memItemLeft" align="right" valign="top"><a id="a10e8e100d4851aa4088ac38c857a6882"></a>
RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a10e8e100d4851aa4088ac38c857a6882">getProbHi</a> () const</td></tr>
<tr class="memdesc:a10e8e100d4851aa4088ac38c857a6882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get upper-left corner of computational domain. <br /></td></tr>
<tr class="separator:a10e8e100d4851aa4088ac38c857a6882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dec51dbb9d0a3aa8023d63d538a8dc7"><td class="memItemLeft" align="right" valign="top"><a id="a1dec51dbb9d0a3aa8023d63d538a8dc7"></a>
ProblemDomain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1dec51dbb9d0a3aa8023d63d538a8dc7">getFinestDomain</a> () const</td></tr>
<tr class="memdesc:a1dec51dbb9d0a3aa8023d63d538a8dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get finest domain. <br /></td></tr>
<tr class="separator:a1dec51dbb9d0a3aa8023d63d538a8dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dc8db2ef220a83ac5dc391d1a1ce79"><td class="memItemLeft" align="right" valign="top"><a id="aa8dc8db2ef220a83ac5dc391d1a1ce79"></a>
const Vector&lt; Real &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa8dc8db2ef220a83ac5dc391d1a1ce79">getDx</a> () const</td></tr>
<tr class="memdesc:aa8dc8db2ef220a83ac5dc391d1a1ce79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get spatial resolutions. <br /></td></tr>
<tr class="separator:aa8dc8db2ef220a83ac5dc391d1a1ce79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9e442e363ef5f63143d438619cd334"><td class="memItemLeft" align="right" valign="top"><a id="aea9e442e363ef5f63143d438619cd334"></a>
const Vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aea9e442e363ef5f63143d438619cd334">getRefinementRatios</a> () const</td></tr>
<tr class="memdesc:aea9e442e363ef5f63143d438619cd334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get refinement ratios. <br /></td></tr>
<tr class="separator:aea9e442e363ef5f63143d438619cd334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a316dd3977e3f60c27c0e2f71cf4fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab7a316dd3977e3f60c27c0e2f71cf4fc">getRefinementRatio</a> (const int a_level1, const int a_level2) const</td></tr>
<tr class="memdesc:ab7a316dd3977e3f60c27c0e2f71cf4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get refinement factor between two levels.  <a href="classAmrMesh.html#ab7a316dd3977e3f60c27c0e2f71cf4fc">More...</a><br /></td></tr>
<tr class="separator:ab7a316dd3977e3f60c27c0e2f71cf4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1662c260b08bddf92838f6061040619b"><td class="memItemLeft" align="right" valign="top">const RefCountedPtr&lt; BaseIF &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1662c260b08bddf92838f6061040619b">getBaseImplicitFunction</a> (const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a1662c260b08bddf92838f6061040619b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get implicit function for a specific phase.  <a href="classAmrMesh.html#a1662c260b08bddf92838f6061040619b">More...</a><br /></td></tr>
<tr class="separator:a1662c260b08bddf92838f6061040619b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23821170fc1949807a3896dcc9f33b1a"><td class="memItemLeft" align="right" valign="top">const Vector&lt; DisjointBoxLayout &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a23821170fc1949807a3896dcc9f33b1a">getProxyGrids</a> () const</td></tr>
<tr class="memdesc:a23821170fc1949807a3896dcc9f33b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "proxy" grids in <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a>.  <a href="classAmrMesh.html#a23821170fc1949807a3896dcc9f33b1a">More...</a><br /></td></tr>
<tr class="separator:a23821170fc1949807a3896dcc9f33b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758abcbca57d397805fcc6ad4b6fa632"><td class="memItemLeft" align="right" valign="top"><a id="a758abcbca57d397805fcc6ad4b6fa632"></a>
const Vector&lt; DisjointBoxLayout &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a758abcbca57d397805fcc6ad4b6fa632">getGrids</a> (const std::string a_realm) const</td></tr>
<tr class="memdesc:a758abcbca57d397805fcc6ad4b6fa632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the grids. <br /></td></tr>
<tr class="separator:a758abcbca57d397805fcc6ad4b6fa632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6bd8d2bc234f35a6f54d86ce485f05"><td class="memItemLeft" align="right" valign="top"><a id="aff6bd8d2bc234f35a6f54d86ce485f05"></a>
const Vector&lt; ProblemDomain &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aff6bd8d2bc234f35a6f54d86ce485f05">getDomains</a> () const</td></tr>
<tr class="memdesc:aff6bd8d2bc234f35a6f54d86ce485f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get domains. <br /></td></tr>
<tr class="separator:aff6bd8d2bc234f35a6f54d86ce485f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94bae000d35d8820cfef27bd9c1c890"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="CD__Realm_8H.html#a906b67939aa45e674c3a94d40c0e5e34">AMRMask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac94bae000d35d8820cfef27bd9c1c890">getMask</a> (const std::string a_mask, const int a_buffer, const std::string a_realm) const</td></tr>
<tr class="memdesc:ac94bae000d35d8820cfef27bd9c1c890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a registered mask.  <a href="classAmrMesh.html#ac94bae000d35d8820cfef27bd9c1c890">More...</a><br /></td></tr>
<tr class="separator:ac94bae000d35d8820cfef27bd9c1c890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1492043709c933fca6e7c51a42aebf40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="CD__Realm_8H.html#a906b67939aa45e674c3a94d40c0e5e34">AMRMask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1492043709c933fca6e7c51a42aebf40">getValidCells</a> (const std::string a_realm) const</td></tr>
<tr class="memdesc:a1492043709c933fca6e7c51a42aebf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a map of all valid cells on a specified realm.  <a href="classAmrMesh.html#a1492043709c933fca6e7c51a42aebf40">More...</a><br /></td></tr>
<tr class="separator:a1492043709c933fca6e7c51a42aebf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1071a09cfc3ff93bd467ae8c63da08"><td class="memItemLeft" align="right" valign="top">const Vector&lt; RefCountedPtr&lt; EBLevelGrid &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6b1071a09cfc3ff93bd467ae8c63da08">getEBLevelGrid</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a6b1071a09cfc3ff93bd467ae8c63da08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the EBLevelGrid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase.  <a href="classAmrMesh.html#a6b1071a09cfc3ff93bd467ae8c63da08">More...</a><br /></td></tr>
<tr class="separator:a6b1071a09cfc3ff93bd467ae8c63da08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db2254121059379e82f6569b2c6641a"><td class="memItemLeft" align="right" valign="top">const Vector&lt; EBISLayout &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a8db2254121059379e82f6569b2c6641a">getEBISLayout</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a8db2254121059379e82f6569b2c6641a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get EBISLayouts for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase.  <a href="classAmrMesh.html#a8db2254121059379e82f6569b2c6641a">More...</a><br /></td></tr>
<tr class="separator:a8db2254121059379e82f6569b2c6641a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a7c78576d46ae8ced617b78ab0ae30"><td class="memItemLeft" align="right" valign="top">const Vector&lt; RefCountedPtr&lt; <a class="el" href="classMFLevelGrid.html">MFLevelGrid</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a99a7c78576d46ae8ced617b78ab0ae30">getMFLevelGrid</a> (const std::string a_realm) const</td></tr>
<tr class="memdesc:a99a7c78576d46ae8ced617b78ab0ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get EBISLayouts for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a>.  <a href="classAmrMesh.html#a99a7c78576d46ae8ced617b78ab0ae30">More...</a><br /></td></tr>
<tr class="separator:a99a7c78576d46ae8ced617b78ab0ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a0d0f998de1a920a638a7b23c8056a"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; LayoutData&lt; VoFIterator &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae3a0d0f998de1a920a638a7b23c8056a">getVofIterator</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:ae3a0d0f998de1a920a638a7b23c8056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vof iterators for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. This has the capability of iterating through cut-cells.  <a href="classAmrMesh.html#ae3a0d0f998de1a920a638a7b23c8056a">More...</a><br /></td></tr>
<tr class="separator:ae3a0d0f998de1a920a638a7b23c8056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abbe61fb38994322f510515d9ea3849"><td class="memItemLeft" align="right" valign="top">const Vector&lt; RefCountedPtr&lt; LayoutData&lt; Vector&lt; LayoutIndex &gt; &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4abbe61fb38994322f510515d9ea3849">getNeighbors</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a4abbe61fb38994322f510515d9ea3849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get neighboring boxes.  <a href="classAmrMesh.html#a4abbe61fb38994322f510515d9ea3849">More...</a><br /></td></tr>
<tr class="separator:a4abbe61fb38994322f510515d9ea3849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ae0a0c9ceba11621bc8f1ba1682824"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEBAMRData.html">EBAMRFAB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af6ae0a0c9ceba11621bc8f1ba1682824">getLevelset</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:af6ae0a0c9ceba11621bc8f1ba1682824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get levelset function, allocated over a grid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase.  <a href="classAmrMesh.html#af6ae0a0c9ceba11621bc8f1ba1682824">More...</a><br /></td></tr>
<tr class="separator:af6ae0a0c9ceba11621bc8f1ba1682824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01ad6d63e8fed8c1615a06a9ccb534a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEBAMRParticleMesh.html">EBAMRParticleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae01ad6d63e8fed8c1615a06a9ccb534a">getParticleMesh</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:ae01ad6d63e8fed8c1615a06a9ccb534a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classEBAMRParticleMesh.html" title="Class for handling particle-mesh operations with AMR.">EBAMRParticleMesh</a> operator.  <a href="classAmrMesh.html#ae01ad6d63e8fed8c1615a06a9ccb534a">More...</a><br /></td></tr>
<tr class="separator:ae01ad6d63e8fed8c1615a06a9ccb534a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04c32d16bc55edc5fe1147eb32bda67"><td class="memItemLeft" align="right" valign="top"><a id="ab04c32d16bc55edc5fe1147eb32bda67"></a>
Vector&lt; RefCountedPtr&lt; <a class="el" href="classEBCoarAve.html">EBCoarAve</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab04c32d16bc55edc5fe1147eb32bda67">getCoarseAverage</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:ab04c32d16bc55edc5fe1147eb32bda67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the coarsening utility. <br /></td></tr>
<tr class="separator:ab04c32d16bc55edc5fe1147eb32bda67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d1aa576ea1b98c23378f127212844e"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; <a class="el" href="classEBMultigridInterpolator.html">EBMultigridInterpolator</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a28d1aa576ea1b98c23378f127212844e">getMultigridInterpolator</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a28d1aa576ea1b98c23378f127212844e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multigrid interpolation utility.  <a href="classAmrMesh.html#a28d1aa576ea1b98c23378f127212844e">More...</a><br /></td></tr>
<tr class="separator:a28d1aa576ea1b98c23378f127212844e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2947e26ae104dd0bf1476ac94638100a"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; AggEBPWLFillPatch &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2947e26ae104dd0bf1476ac94638100a">getFillPatch</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a2947e26ae104dd0bf1476ac94638100a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get piecewise linear ghost cell interpolator.  <a href="classAmrMesh.html#a2947e26ae104dd0bf1476ac94638100a">More...</a><br /></td></tr>
<tr class="separator:a2947e26ae104dd0bf1476ac94638100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbe95dc353cef3fe72aea2f83927e98"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; <a class="el" href="classEBFineInterp.html">EBFineInterp</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4cbe95dc353cef3fe72aea2f83927e98">getFineInterp</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a4cbe95dc353cef3fe72aea2f83927e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolator.  <a href="classAmrMesh.html#a4cbe95dc353cef3fe72aea2f83927e98">More...</a><br /></td></tr>
<tr class="separator:a4cbe95dc353cef3fe72aea2f83927e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04896ca8511ca4f17a1558d89683085d"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; EBFluxRegister &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a04896ca8511ca4f17a1558d89683085d">getFluxRegister</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a04896ca8511ca4f17a1558d89683085d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flux register.  <a href="classAmrMesh.html#a04896ca8511ca4f17a1558d89683085d">More...</a><br /></td></tr>
<tr class="separator:a04896ca8511ca4f17a1558d89683085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a15d1ab20a04a86618e7c45d001c6c5"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; EBLevelRedist &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0a15d1ab20a04a86618e7c45d001c6c5">getLevelRedist</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a0a15d1ab20a04a86618e7c45d001c6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get redistribution.  <a href="classAmrMesh.html#a0a15d1ab20a04a86618e7c45d001c6c5">More...</a><br /></td></tr>
<tr class="separator:a0a15d1ab20a04a86618e7c45d001c6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe8f027bf253db4627512e378ef0a95"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; EBCoarToFineRedist &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a7fe8f027bf253db4627512e378ef0a95">getCoarToFineRedist</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a7fe8f027bf253db4627512e378ef0a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coar-to-fine redistribution for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase.  <a href="classAmrMesh.html#a7fe8f027bf253db4627512e378ef0a95">More...</a><br /></td></tr>
<tr class="separator:a7fe8f027bf253db4627512e378ef0a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f69225d0b1c2b84e8f69bd0dd5c4d5"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; EBCoarToCoarRedist &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab2f69225d0b1c2b84e8f69bd0dd5c4d5">getCoarToCoarRedist</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:ab2f69225d0b1c2b84e8f69bd0dd5c4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coar-to-coar redistribution objects.  <a href="classAmrMesh.html#ab2f69225d0b1c2b84e8f69bd0dd5c4d5">More...</a><br /></td></tr>
<tr class="separator:ab2f69225d0b1c2b84e8f69bd0dd5c4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4352f3a572ffe95357934042c5409ec5"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; EBFineToCoarRedist &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4352f3a572ffe95357934042c5409ec5">getFineToCoarRedist</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a4352f3a572ffe95357934042c5409ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coar-to-coar redistribution redistribution objects.  <a href="classAmrMesh.html#a4352f3a572ffe95357934042c5409ec5">More...</a><br /></td></tr>
<tr class="separator:a4352f3a572ffe95357934042c5409ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a85437e92d6b8493258d04c05d30db"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classCentroidInterpolationStencil.html">CentroidInterpolationStencil</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab8a85437e92d6b8493258d04c05d30db">getCentroidInterpolationStencils</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:ab8a85437e92d6b8493258d04c05d30db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolation stencils for going from cell center to cell centroid.  <a href="classAmrMesh.html#ab8a85437e92d6b8493258d04c05d30db">More...</a><br /></td></tr>
<tr class="separator:ab8a85437e92d6b8493258d04c05d30db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8721574be5dce546f43bc88f9ca9cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classEbCentroidInterpolationStencil.html">EbCentroidInterpolationStencil</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9e8721574be5dce546f43bc88f9ca9cd">getEbCentroidInterpolationStencils</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:a9e8721574be5dce546f43bc88f9ca9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interpolation stencils for going from cell center to cell boundary centroid.  <a href="classAmrMesh.html#a9e8721574be5dce546f43bc88f9ca9cd">More...</a><br /></td></tr>
<tr class="separator:a9e8721574be5dce546f43bc88f9ca9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71d4093fe3c996f104348eec16cf0bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classNonConservativeDivergenceStencil.html">NonConservativeDivergenceStencil</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa71d4093fe3c996f104348eec16cf0bd">getNonConservativeDivergenceStencils</a> (const std::string a_realm, const phase::which_phase a_phase) const</td></tr>
<tr class="memdesc:aa71d4093fe3c996f104348eec16cf0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nonconservative divergence stencils.  <a href="classAmrMesh.html#aa71d4093fe3c996f104348eec16cf0bd">More...</a><br /></td></tr>
<tr class="separator:aa71d4093fe3c996f104348eec16cf0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa1580b30fe66ec3e313435c44d1f1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a10aa1580b30fe66ec3e313435c44d1f1">getRealms</a> () const</td></tr>
<tr class="memdesc:a10aa1580b30fe66ec3e313435c44d1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of all Realms.  <a href="classAmrMesh.html#a10aa1580b30fe66ec3e313435c44d1f1">More...</a><br /></td></tr>
<tr class="separator:a10aa1580b30fe66ec3e313435c44d1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18f3ce3d1d5310f7f18518a84fdf1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CD__BoxSorting_8H.html#ab5db8b3a96e3a04473aaa898f7eb2128">BoxSorting</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af18f3ce3d1d5310f7f18518a84fdf1dc">getBoxSorting</a> () const</td></tr>
<tr class="memdesc:af18f3ce3d1d5310f7f18518a84fdf1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get box sorting method.  <a href="classAmrMesh.html#af18f3ce3d1d5310f7f18518a84fdf1dc">More...</a><br /></td></tr>
<tr class="separator:af18f3ce3d1d5310f7f18518a84fdf1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e42c503eb88132db381576c0289f5ab"><td class="memItemLeft" align="right" valign="top">RefCountedPtr&lt; EBIndexSpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3e42c503eb88132db381576c0289f5ab">getEBIndexSpace</a> (const phase::which_phase a_phase)</td></tr>
<tr class="memdesc:a3e42c503eb88132db381576c0289f5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get EBIndexSpace corresponding to a particular phase.  <a href="classAmrMesh.html#a3e42c503eb88132db381576c0289f5ab">More...</a><br /></td></tr>
<tr class="separator:a3e42c503eb88132db381576c0289f5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a6b1adbb06620c67d0b168f649c796289"><td class="memItemLeft" align="right" valign="top"><a id="a6b1adbb06620c67d0b168f649c796289"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6b1adbb06620c67d0b168f649c796289">GridGenerationMethod</a> { <b>BergerRigoutsous</b>, 
<b>Tiled</b>
 }</td></tr>
<tr class="memdesc:a6b1adbb06620c67d0b168f649c796289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for having understandable notation for grid generation. <br /></td></tr>
<tr class="separator:a6b1adbb06620c67d0b168f649c796289"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a82b28bf393e8ff6ed5cc544a48ea75ea"><td class="memItemLeft" align="right" valign="top"><a id="a82b28bf393e8ff6ed5cc544a48ea75ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a82b28bf393e8ff6ed5cc544a48ea75ea">defineRealms</a> ()</td></tr>
<tr class="memdesc:a82b28bf393e8ff6ed5cc544a48ea75ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define Realms. <br /></td></tr>
<tr class="separator:a82b28bf393e8ff6ed5cc544a48ea75ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338e3c1c4ba567f145e898a6c66a0ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a338e3c1c4ba567f145e898a6c66a0ede">buildGrids</a> (Vector&lt; IntVectSet &gt; &amp;a_tags, const int a_lmin, const int a_hardcap=-1)</td></tr>
<tr class="memdesc:a338e3c1c4ba567f145e898a6c66a0ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build new internal AMR grids.  <a href="classAmrMesh.html#a338e3c1c4ba567f145e898a6c66a0ede">More...</a><br /></td></tr>
<tr class="separator:a338e3c1c4ba567f145e898a6c66a0ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64b6dda8135d3f53ec299c945ad5b4b"><td class="memItemLeft" align="right" valign="top"><a id="ad64b6dda8135d3f53ec299c945ad5b4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad64b6dda8135d3f53ec299c945ad5b4b">parseProbLoHiCorners</a> ()</td></tr>
<tr class="memdesc:ad64b6dda8135d3f53ec299c945ad5b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the low/high corners of the computational domain. <br /></td></tr>
<tr class="separator:ad64b6dda8135d3f53ec299c945ad5b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67cab9a8a5cf3d884a07df809ca72ba"><td class="memItemLeft" align="right" valign="top"><a id="ad67cab9a8a5cf3d884a07df809ca72ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad67cab9a8a5cf3d884a07df809ca72ba">parseGridGeneration</a> ()</td></tr>
<tr class="memdesc:ad67cab9a8a5cf3d884a07df809ca72ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the grid generation algorithm. <br /></td></tr>
<tr class="separator:ad67cab9a8a5cf3d884a07df809ca72ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fc82644d6c1aff9aa67931d3eceb44"><td class="memItemLeft" align="right" valign="top"><a id="a69fc82644d6c1aff9aa67931d3eceb44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a69fc82644d6c1aff9aa67931d3eceb44">parseVerbosity</a> ()</td></tr>
<tr class="memdesc:a69fc82644d6c1aff9aa67931d3eceb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the verbosity for <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a>. <br /></td></tr>
<tr class="separator:a69fc82644d6c1aff9aa67931d3eceb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e128ab04f54e27a3372f1296de58252"><td class="memItemLeft" align="right" valign="top"><a id="a9e128ab04f54e27a3372f1296de58252"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9e128ab04f54e27a3372f1296de58252">parseCoarsestLevelNumCells</a> ()</td></tr>
<tr class="memdesc:a9e128ab04f54e27a3372f1296de58252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the coarsest domain grid. <br /></td></tr>
<tr class="separator:a9e128ab04f54e27a3372f1296de58252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2862782a7c22f1f38543d7d21cf9b65c"><td class="memItemLeft" align="right" valign="top"><a id="a2862782a7c22f1f38543d7d21cf9b65c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2862782a7c22f1f38543d7d21cf9b65c">parseMaxAmrDepth</a> ()</td></tr>
<tr class="memdesc:a2862782a7c22f1f38543d7d21cf9b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the maximum permitted AMR depth. <br /></td></tr>
<tr class="separator:a2862782a7c22f1f38543d7d21cf9b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37af95890a678148aee6107045c7d43b"><td class="memItemLeft" align="right" valign="top"><a id="a37af95890a678148aee6107045c7d43b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a37af95890a678148aee6107045c7d43b">parseMaxSimulationDepth</a> ()</td></tr>
<tr class="memdesc:a37af95890a678148aee6107045c7d43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum simulation depth. <br /></td></tr>
<tr class="separator:a37af95890a678148aee6107045c7d43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a233392deb63bc7f5ee8eb1739e8f28"><td class="memItemLeft" align="right" valign="top"><a id="a4a233392deb63bc7f5ee8eb1739e8f28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4a233392deb63bc7f5ee8eb1739e8f28">parseRefinementRatios</a> ()</td></tr>
<tr class="memdesc:a4a233392deb63bc7f5ee8eb1739e8f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse refinement ratios. <br /></td></tr>
<tr class="separator:a4a233392deb63bc7f5ee8eb1739e8f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1395b197e29ccb700e412f112cfa2fbb"><td class="memItemLeft" align="right" valign="top"><a id="a1395b197e29ccb700e412f112cfa2fbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1395b197e29ccb700e412f112cfa2fbb">parseBrBufferSize</a> ()</td></tr>
<tr class="memdesc:a1395b197e29ccb700e412f112cfa2fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse buffer size for Berger-Rigoutsous grid algorithm. <br /></td></tr>
<tr class="separator:a1395b197e29ccb700e412f112cfa2fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e48f42538637c9afc04975cfc192e"><td class="memItemLeft" align="right" valign="top"><a id="ad40e48f42538637c9afc04975cfc192e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad40e48f42538637c9afc04975cfc192e">parseBrFillRatio</a> ()</td></tr>
<tr class="memdesc:ad40e48f42538637c9afc04975cfc192e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the Berger-Rigoutsos fill ratio. <br /></td></tr>
<tr class="separator:ad40e48f42538637c9afc04975cfc192e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f012242b01a0b252a8a513d3d2f6a4"><td class="memItemLeft" align="right" valign="top"><a id="a57f012242b01a0b252a8a513d3d2f6a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a57f012242b01a0b252a8a513d3d2f6a4">parseMaxBoxSize</a> ()</td></tr>
<tr class="memdesc:a57f012242b01a0b252a8a513d3d2f6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the maximum permitted box size. <br /></td></tr>
<tr class="separator:a57f012242b01a0b252a8a513d3d2f6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add290a067d272d1e544cdedd2c54a896"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#add290a067d272d1e544cdedd2c54a896">parseMaxEbisBoxSize</a> ()</td></tr>
<tr class="memdesc:add290a067d272d1e544cdedd2c54a896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the maximum permitted box size.  <a href="classAmrMesh.html#add290a067d272d1e544cdedd2c54a896">More...</a><br /></td></tr>
<tr class="separator:add290a067d272d1e544cdedd2c54a896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe173b70b8b8c15cfb7fd9caaadd77c4"><td class="memItemLeft" align="right" valign="top"><a id="abe173b70b8b8c15cfb7fd9caaadd77c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#abe173b70b8b8c15cfb7fd9caaadd77c4">parseBlockingFactor</a> ()</td></tr>
<tr class="memdesc:abe173b70b8b8c15cfb7fd9caaadd77c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the B-R blocking factor. For tiled mesh refinement this parses the tile size. <br /></td></tr>
<tr class="separator:abe173b70b8b8c15cfb7fd9caaadd77c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02dccfc4e434c6ee612908413498d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab02dccfc4e434c6ee612908413498d50">parseEbGhostCells</a> ()</td></tr>
<tr class="memdesc:ab02dccfc4e434c6ee612908413498d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse number of ghost cells for eb stuff.  <a href="classAmrMesh.html#ab02dccfc4e434c6ee612908413498d50">More...</a><br /></td></tr>
<tr class="separator:ab02dccfc4e434c6ee612908413498d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ec2b203e0b6b4c0b22ac3d3e126277"><td class="memItemLeft" align="right" valign="top"><a id="a60ec2b203e0b6b4c0b22ac3d3e126277"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a60ec2b203e0b6b4c0b22ac3d3e126277">parseNumGhostCells</a> ()</td></tr>
<tr class="memdesc:a60ec2b203e0b6b4c0b22ac3d3e126277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the number of ghost cells. <br /></td></tr>
<tr class="separator:a60ec2b203e0b6b4c0b22ac3d3e126277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab035e11d56e0978fc386769706f5f40b"><td class="memItemLeft" align="right" valign="top"><a id="ab035e11d56e0978fc386769706f5f40b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab035e11d56e0978fc386769706f5f40b">parseMultigridInterpolator</a> ()</td></tr>
<tr class="memdesc:ab035e11d56e0978fc386769706f5f40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse settings for the multigrid interpolator. <br /></td></tr>
<tr class="separator:ab035e11d56e0978fc386769706f5f40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e931207fee7ef2897c99de6d8c5e819"><td class="memItemLeft" align="right" valign="top"><a id="a9e931207fee7ef2897c99de6d8c5e819"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a9e931207fee7ef2897c99de6d8c5e819">parseRedistributionRadius</a> ()</td></tr>
<tr class="memdesc:a9e931207fee7ef2897c99de6d8c5e819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the default redistribution radius. <br /></td></tr>
<tr class="separator:a9e931207fee7ef2897c99de6d8c5e819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fb548d469776e55ee3194bfb6a90d9"><td class="memItemLeft" align="right" valign="top"><a id="af1fb548d469776e55ee3194bfb6a90d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af1fb548d469776e55ee3194bfb6a90d9">parseCentroidStencils</a> ()</td></tr>
<tr class="memdesc:af1fb548d469776e55ee3194bfb6a90d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse centroid interpolation stencils. <br /></td></tr>
<tr class="separator:af1fb548d469776e55ee3194bfb6a90d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d87299e60f6cda07e9c4d00e7bbe8d"><td class="memItemLeft" align="right" valign="top"><a id="a40d87299e60f6cda07e9c4d00e7bbe8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a40d87299e60f6cda07e9c4d00e7bbe8d">parseEbCentroidStencils</a> ()</td></tr>
<tr class="memdesc:a40d87299e60f6cda07e9c4d00e7bbe8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse EB interpolation (or extrapolation) stencils. <br /></td></tr>
<tr class="separator:a40d87299e60f6cda07e9c4d00e7bbe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8748090e8b37b8b2f678ce4002ebeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a0a8748090e8b37b8b2f678ce4002ebeb">computeGradient</a> (LevelData&lt; EBCellFAB &gt; &amp;a_gradient, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const std::string a_realm, const phase::which_phase a_phase, const int a_lvl) const</td></tr>
<tr class="memdesc:a0a8748090e8b37b8b2f678ce4002ebeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell-centered gradient for a grid level.  <a href="classAmrMesh.html#a0a8748090e8b37b8b2f678ce4002ebeb">More...</a><br /></td></tr>
<tr class="separator:a0a8748090e8b37b8b2f678ce4002ebeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aacde379809f5856a15d71f6d5c0056d6"><td class="memItemLeft" align="right" valign="top"><a id="aacde379809f5856a15d71f6d5c0056d6"></a>
std::map&lt; std::string, RefCountedPtr&lt; <a class="el" href="classRealm.html">Realm</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aacde379809f5856a15d71f6d5c0056d6">m_realms</a></td></tr>
<tr class="memdesc:aacde379809f5856a15d71f6d5c0056d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are all the Realms. <br /></td></tr>
<tr class="separator:aacde379809f5856a15d71f6d5c0056d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c109ce8345145d8d5373abf9c6280b"><td class="memItemLeft" align="right" valign="top"><a id="a93c109ce8345145d8d5373abf9c6280b"></a>
std::map&lt; phase::which_phase, RefCountedPtr&lt; BaseIF &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a93c109ce8345145d8d5373abf9c6280b">m_baseif</a></td></tr>
<tr class="memdesc:a93c109ce8345145d8d5373abf9c6280b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit functions. <br /></td></tr>
<tr class="separator:a93c109ce8345145d8d5373abf9c6280b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb87ee604d972a4afabc46eb48e2c4"><td class="memItemLeft" align="right" valign="top"><a id="a45cb87ee604d972a4afabc46eb48e2c4"></a>
<a class="el" href="classAmrMesh.html#a6b1adbb06620c67d0b168f649c796289">GridGenerationMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a45cb87ee604d972a4afabc46eb48e2c4">m_gridGenerationMethod</a></td></tr>
<tr class="memdesc:a45cb87ee604d972a4afabc46eb48e2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid generation method. <br /></td></tr>
<tr class="separator:a45cb87ee604d972a4afabc46eb48e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4167481a292dba71d5d6a4a70f5d90"><td class="memItemLeft" align="right" valign="top"><a id="a7e4167481a292dba71d5d6a4a70f5d90"></a>
<a class="el" href="CD__BoxSorting_8H.html#ab5db8b3a96e3a04473aaa898f7eb2128">BoxSorting</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a7e4167481a292dba71d5d6a4a70f5d90">m_boxSort</a></td></tr>
<tr class="memdesc:a7e4167481a292dba71d5d6a4a70f5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Box sorting. <br /></td></tr>
<tr class="separator:a7e4167481a292dba71d5d6a4a70f5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3102844226abdcb46fa75c97c33ae42b"><td class="memItemLeft" align="right" valign="top"><a id="a3102844226abdcb46fa75c97c33ae42b"></a>
RefCountedPtr&lt; <a class="el" href="classMultiFluidIndexSpace.html">MultiFluidIndexSpace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3102844226abdcb46fa75c97c33ae42b">m_multifluidIndexSpace</a></td></tr>
<tr class="memdesc:a3102844226abdcb46fa75c97c33ae42b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMultiFluidIndexSpace.html" title="Two-fluid index space.">MultiFluidIndexSpace</a>. <br /></td></tr>
<tr class="separator:a3102844226abdcb46fa75c97c33ae42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddedc6810af3dc75b50cb6c66f44978"><td class="memItemLeft" align="right" valign="top"><a id="a7ddedc6810af3dc75b50cb6c66f44978"></a>
<a class="el" href="classIrregStencil.html#ac2a71148a30087346575360af4cacd6f">IrregStencil::StencilType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a7ddedc6810af3dc75b50cb6c66f44978">m_stencilType</a></td></tr>
<tr class="memdesc:a7ddedc6810af3dc75b50cb6c66f44978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil type. <br /></td></tr>
<tr class="separator:a7ddedc6810af3dc75b50cb6c66f44978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2b00f54754547efee1e6ba8c5235bc"><td class="memItemLeft" align="right" valign="top"><a id="afb2b00f54754547efee1e6ba8c5235bc"></a>
<a class="el" href="classIrregStencil.html#ac2a71148a30087346575360af4cacd6f">IrregStencil::StencilType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#afb2b00f54754547efee1e6ba8c5235bc">m_centroidStencilType</a></td></tr>
<tr class="memdesc:afb2b00f54754547efee1e6ba8c5235bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil type for centroid interpolation. <br /></td></tr>
<tr class="separator:afb2b00f54754547efee1e6ba8c5235bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae492d45eb81aa01d7d2e7a8921158508"><td class="memItemLeft" align="right" valign="top"><a id="ae492d45eb81aa01d7d2e7a8921158508"></a>
<a class="el" href="classIrregStencil.html#ac2a71148a30087346575360af4cacd6f">IrregStencil::StencilType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae492d45eb81aa01d7d2e7a8921158508">m_ebCentroidStencilType</a></td></tr>
<tr class="memdesc:ae492d45eb81aa01d7d2e7a8921158508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil type for EB interpolation. <br /></td></tr>
<tr class="separator:ae492d45eb81aa01d7d2e7a8921158508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26419b21e9239407e5108f4ba7f1d773"><td class="memItemLeft" align="right" valign="top"><a id="a26419b21e9239407e5108f4ba7f1d773"></a>
IntVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a26419b21e9239407e5108f4ba7f1d773">m_numCells</a></td></tr>
<tr class="memdesc:a26419b21e9239407e5108f4ba7f1d773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsest box where we compute. <br /></td></tr>
<tr class="separator:a26419b21e9239407e5108f4ba7f1d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b974f78b58899e25a439e47cdb15161"><td class="memItemLeft" align="right" valign="top"><a id="a1b974f78b58899e25a439e47cdb15161"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a1b974f78b58899e25a439e47cdb15161">m_fillRatioBR</a></td></tr>
<tr class="memdesc:a1b974f78b58899e25a439e47cdb15161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill ratio. <br /></td></tr>
<tr class="separator:a1b974f78b58899e25a439e47cdb15161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c4af19deea668e528e1539492ba6a7"><td class="memItemLeft" align="right" valign="top"><a id="a32c4af19deea668e528e1539492ba6a7"></a>
RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a32c4af19deea668e528e1539492ba6a7">m_probLo</a></td></tr>
<tr class="memdesc:a32c4af19deea668e528e1539492ba6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain simulation corner. <br /></td></tr>
<tr class="separator:a32c4af19deea668e528e1539492ba6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29140588beef4314843c96c03a5e700f"><td class="memItemLeft" align="right" valign="top"><a id="a29140588beef4314843c96c03a5e700f"></a>
RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a29140588beef4314843c96c03a5e700f">m_probHi</a></td></tr>
<tr class="memdesc:a29140588beef4314843c96c03a5e700f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain simulation corner. <br /></td></tr>
<tr class="separator:a29140588beef4314843c96c03a5e700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cf1b204e7125308d078061d54ef2c7"><td class="memItemLeft" align="right" valign="top"><a id="a07cf1b204e7125308d078061d54ef2c7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a07cf1b204e7125308d078061d54ef2c7">m_refRatio</a></td></tr>
<tr class="memdesc:a07cf1b204e7125308d078061d54ef2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement ratio. <br /></td></tr>
<tr class="separator:a07cf1b204e7125308d078061d54ef2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50336ab4f43dc66bf6f5ee8fde4a9acd"><td class="memItemLeft" align="right" valign="top"><a id="a50336ab4f43dc66bf6f5ee8fde4a9acd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a50336ab4f43dc66bf6f5ee8fde4a9acd">m_verbosity</a></td></tr>
<tr class="memdesc:a50336ab4f43dc66bf6f5ee8fde4a9acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verbosity. <br /></td></tr>
<tr class="separator:a50336ab4f43dc66bf6f5ee8fde4a9acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836d00237da8ce294102747a9ad27439"><td class="memItemLeft" align="right" valign="top"><a id="a836d00237da8ce294102747a9ad27439"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a836d00237da8ce294102747a9ad27439">m_finestLevel</a></td></tr>
<tr class="memdesc:a836d00237da8ce294102747a9ad27439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finest level. <br /></td></tr>
<tr class="separator:a836d00237da8ce294102747a9ad27439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82395aa042ef543322cbfee5b05be1d3"><td class="memItemLeft" align="right" valign="top"><a id="a82395aa042ef543322cbfee5b05be1d3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a82395aa042ef543322cbfee5b05be1d3">m_maxAmrDepth</a></td></tr>
<tr class="memdesc:a82395aa042ef543322cbfee5b05be1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum amr depth. <br /></td></tr>
<tr class="separator:a82395aa042ef543322cbfee5b05be1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd7ea7c8886171bd2533b6ec39c7f3"><td class="memItemLeft" align="right" valign="top"><a id="a3cdd7ea7c8886171bd2533b6ec39c7f3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3cdd7ea7c8886171bd2533b6ec39c7f3">m_maxSimulationDepth</a></td></tr>
<tr class="memdesc:a3cdd7ea7c8886171bd2533b6ec39c7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed depth for simulation. <br /></td></tr>
<tr class="separator:a3cdd7ea7c8886171bd2533b6ec39c7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b355417f9a9dca3aaabdc0c3aae47f3"><td class="memItemLeft" align="right" valign="top"><a id="a2b355417f9a9dca3aaabdc0c3aae47f3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2b355417f9a9dca3aaabdc0c3aae47f3">m_maxBoxSize</a></td></tr>
<tr class="memdesc:a2b355417f9a9dca3aaabdc0c3aae47f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max box size. <br /></td></tr>
<tr class="separator:a2b355417f9a9dca3aaabdc0c3aae47f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68cd81210ec67a38e8c85dfe24c594f"><td class="memItemLeft" align="right" valign="top"><a id="af68cd81210ec67a38e8c85dfe24c594f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#af68cd81210ec67a38e8c85dfe24c594f">m_maxEbisBoxSize</a></td></tr>
<tr class="memdesc:af68cd81210ec67a38e8c85dfe24c594f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum box size for EBIS generation. <br /></td></tr>
<tr class="separator:af68cd81210ec67a38e8c85dfe24c594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3496bd4e53289c5636ea90b97b837545"><td class="memItemLeft" align="right" valign="top"><a id="a3496bd4e53289c5636ea90b97b837545"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a3496bd4e53289c5636ea90b97b837545">m_bufferSizeBR</a></td></tr>
<tr class="memdesc:a3496bd4e53289c5636ea90b97b837545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer size. <br /></td></tr>
<tr class="separator:a3496bd4e53289c5636ea90b97b837545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b28d2dedb85c12c6f4cd7ec0fc7325"><td class="memItemLeft" align="right" valign="top"><a id="ab6b28d2dedb85c12c6f4cd7ec0fc7325"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ab6b28d2dedb85c12c6f4cd7ec0fc7325">m_blockingFactor</a></td></tr>
<tr class="memdesc:ab6b28d2dedb85c12c6f4cd7ec0fc7325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking factor. <br /></td></tr>
<tr class="separator:ab6b28d2dedb85c12c6f4cd7ec0fc7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d5cb0ef5642c27c6c485b81652eaa1"><td class="memItemLeft" align="right" valign="top"><a id="a78d5cb0ef5642c27c6c485b81652eaa1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a78d5cb0ef5642c27c6c485b81652eaa1">m_numEbGhostsCells</a></td></tr>
<tr class="memdesc:a78d5cb0ef5642c27c6c485b81652eaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost cells to use for eb stuff. <br /></td></tr>
<tr class="separator:a78d5cb0ef5642c27c6c485b81652eaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6859cfe9346388b089a4bdb324d2d019"><td class="memItemLeft" align="right" valign="top"><a id="a6859cfe9346388b089a4bdb324d2d019"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a6859cfe9346388b089a4bdb324d2d019">m_numGhostCells</a></td></tr>
<tr class="memdesc:a6859cfe9346388b089a4bdb324d2d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost cells. <br /></td></tr>
<tr class="separator:a6859cfe9346388b089a4bdb324d2d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb0c9bbc493aa6d83ca0a97cf919c70"><td class="memItemLeft" align="right" valign="top"><a id="affb0c9bbc493aa6d83ca0a97cf919c70"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#affb0c9bbc493aa6d83ca0a97cf919c70">m_numLsfGhostCells</a></td></tr>
<tr class="memdesc:affb0c9bbc493aa6d83ca0a97cf919c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost cells to use when writing level-set to grid. <br /></td></tr>
<tr class="separator:affb0c9bbc493aa6d83ca0a97cf919c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb291dba0cc74ada1f95640077ea494"><td class="memItemLeft" align="right" valign="top"><a id="a5bb291dba0cc74ada1f95640077ea494"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5bb291dba0cc74ada1f95640077ea494">m_multigridInterpOrder</a></td></tr>
<tr class="memdesc:a5bb291dba0cc74ada1f95640077ea494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid interpolation order. <br /></td></tr>
<tr class="separator:a5bb291dba0cc74ada1f95640077ea494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419a9ee9c2d3b16a2466dafff0c5c0f2"><td class="memItemLeft" align="right" valign="top"><a id="a419a9ee9c2d3b16a2466dafff0c5c0f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a419a9ee9c2d3b16a2466dafff0c5c0f2">m_multigridInterpRadius</a></td></tr>
<tr class="memdesc:a419a9ee9c2d3b16a2466dafff0c5c0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid interpolation radius. <br /></td></tr>
<tr class="separator:a419a9ee9c2d3b16a2466dafff0c5c0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d601f57b4a712db238cd5301636ff3"><td class="memItemLeft" align="right" valign="top"><a id="ac7d601f57b4a712db238cd5301636ff3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac7d601f57b4a712db238cd5301636ff3">m_multigridInterpWeight</a></td></tr>
<tr class="memdesc:ac7d601f57b4a712db238cd5301636ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid interpolation weights. <br /></td></tr>
<tr class="separator:ac7d601f57b4a712db238cd5301636ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4be2723b347e649654ab7cb8f84b6f"><td class="memItemLeft" align="right" valign="top"><a id="aff4be2723b347e649654ab7cb8f84b6f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aff4be2723b347e649654ab7cb8f84b6f">m_redistributionRadius</a></td></tr>
<tr class="memdesc:aff4be2723b347e649654ab7cb8f84b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribution radius. <br /></td></tr>
<tr class="separator:aff4be2723b347e649654ab7cb8f84b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6e06b89404fbb52f7e4886c6aed004"><td class="memItemLeft" align="right" valign="top"><a id="a2d6e06b89404fbb52f7e4886c6aed004"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a2d6e06b89404fbb52f7e4886c6aed004">m_centroidStencilOrder</a></td></tr>
<tr class="memdesc:a2d6e06b89404fbb52f7e4886c6aed004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order for interpolation stencils to centroids. <br /></td></tr>
<tr class="separator:a2d6e06b89404fbb52f7e4886c6aed004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8713127781f8c965ccd1c98b63dac5"><td class="memItemLeft" align="right" valign="top"><a id="a5d8713127781f8c965ccd1c98b63dac5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a5d8713127781f8c965ccd1c98b63dac5">m_centroidStencilRadius</a></td></tr>
<tr class="memdesc:a5d8713127781f8c965ccd1c98b63dac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius for centroid interpolation stencil. <br /></td></tr>
<tr class="separator:a5d8713127781f8c965ccd1c98b63dac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa459d5ca131c5f8c97c61ae7830437bb"><td class="memItemLeft" align="right" valign="top"><a id="aa459d5ca131c5f8c97c61ae7830437bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#aa459d5ca131c5f8c97c61ae7830437bb">m_ebCentroidStencilOrder</a></td></tr>
<tr class="memdesc:aa459d5ca131c5f8c97c61ae7830437bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order for interpolation stencilst to EB. <br /></td></tr>
<tr class="separator:aa459d5ca131c5f8c97c61ae7830437bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d85fcac14583ec31cebae2c77da39"><td class="memItemLeft" align="right" valign="top"><a id="a433d85fcac14583ec31cebae2c77da39"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a433d85fcac14583ec31cebae2c77da39">m_ebCentroidStencilRadius</a></td></tr>
<tr class="memdesc:a433d85fcac14583ec31cebae2c77da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius for EB interpolation stencil. <br /></td></tr>
<tr class="separator:a433d85fcac14583ec31cebae2c77da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dc909ecfabbc7eaeb976ca587ad75c"><td class="memItemLeft" align="right" valign="top"><a id="ac0dc909ecfabbc7eaeb976ca587ad75c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac0dc909ecfabbc7eaeb976ca587ad75c">m_irregStenOrder</a></td></tr>
<tr class="memdesc:ac0dc909ecfabbc7eaeb976ca587ad75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil order for irregular stencils. <br /></td></tr>
<tr class="separator:ac0dc909ecfabbc7eaeb976ca587ad75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d51f9deb305d018b7886b63e5ea130"><td class="memItemLeft" align="right" valign="top"><a id="ac1d51f9deb305d018b7886b63e5ea130"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ac1d51f9deb305d018b7886b63e5ea130">m_irregStenRadius</a></td></tr>
<tr class="memdesc:ac1d51f9deb305d018b7886b63e5ea130"><td class="mdescLeft">&#160;</td><td class="mdescRight">radius for irregular stencils <br /></td></tr>
<tr class="separator:ac1d51f9deb305d018b7886b63e5ea130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fb5e315cfc9e853def28d39c4259f1"><td class="memItemLeft" align="right" valign="top"><a id="ae2fb5e315cfc9e853def28d39c4259f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ae2fb5e315cfc9e853def28d39c4259f1">m_hasGrids</a></td></tr>
<tr class="memdesc:ae2fb5e315cfc9e853def28d39c4259f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has grids or not. <br /></td></tr>
<tr class="separator:ae2fb5e315cfc9e853def28d39c4259f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b7f70026f6bcf705bcfc9770730417"><td class="memItemLeft" align="right" valign="top"><a id="a30b7f70026f6bcf705bcfc9770730417"></a>
Vector&lt; DisjointBoxLayout &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a30b7f70026f6bcf705bcfc9770730417">m_grids</a></td></tr>
<tr class="memdesc:a30b7f70026f6bcf705bcfc9770730417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grids. <br /></td></tr>
<tr class="separator:a30b7f70026f6bcf705bcfc9770730417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6264ea87b2d6fc5803f7ac01ba9219e"><td class="memItemLeft" align="right" valign="top"><a id="ad6264ea87b2d6fc5803f7ac01ba9219e"></a>
Vector&lt; ProblemDomain &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#ad6264ea87b2d6fc5803f7ac01ba9219e">m_domains</a></td></tr>
<tr class="memdesc:ad6264ea87b2d6fc5803f7ac01ba9219e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem domains. <br /></td></tr>
<tr class="separator:ad6264ea87b2d6fc5803f7ac01ba9219e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a46b00edbd08fb6f3851035d7d2520a"><td class="memItemLeft" align="right" valign="top"><a id="a4a46b00edbd08fb6f3851035d7d2520a"></a>
Vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a4a46b00edbd08fb6f3851035d7d2520a">m_refinementRatios</a></td></tr>
<tr class="memdesc:a4a46b00edbd08fb6f3851035d7d2520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMR resolutions. <br /></td></tr>
<tr class="separator:a4a46b00edbd08fb6f3851035d7d2520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496a7ae2b97d7e6b609c82a22586433"><td class="memItemLeft" align="right" valign="top"><a id="a7496a7ae2b97d7e6b609c82a22586433"></a>
Vector&lt; Real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAmrMesh.html#a7496a7ae2b97d7e6b609c82a22586433">m_dx</a></td></tr>
<tr class="memdesc:a7496a7ae2b97d7e6b609c82a22586433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level resolutions. <br /></td></tr>
<tr class="separator:a7496a7ae2b97d7e6b609c82a22586433"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for handling spatial operations. </p>
<p>This class handles most (if not all) spatial operations. Examples are grid generation, coarsening of data, interpolation of data, memory allocations etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad3dbdbd76308b0f823ac99ba8c96b030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dbdbd76308b0f823ac99ba8c96b030">&#9670;&nbsp;</a></span>AmrMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AmrMesh::AmrMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169cb0dcdb19e5bf08061ac7fd6b5780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169cb0dcdb19e5bf08061ac7fd6b5780">&#9670;&nbsp;</a></span>AmrMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AmrMesh::AmrMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a82fe5b8146a945e4fe8911fbb57494e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fe5b8146a945e4fe8911fbb57494e7">&#9670;&nbsp;</a></span>alias() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single-phase alias of the multifluid data, having the same size as the input data. </dd></dl>

</div>
</div>
<a id="a5f0d11dbe8ad04d37008c260df025374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0d11dbe8ad04d37008c260df025374">&#9670;&nbsp;</a></span>alias() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single-phase alias of the multifluid data, having the same size as the input data. </dd></dl>

</div>
</div>
<a id="abd8da582e3c2910ba6c168e6a24d5679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8da582e3c2910ba6c168e6a24d5679">&#9670;&nbsp;</a></span>alias() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single-phase alias of the multifluid data, having the same size as the input data. </dd></dl>

</div>
</div>
<a id="a9bd8f12c2f367eaed5f168dfc54bd275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd8f12c2f367eaed5f168dfc54bd275">&#9670;&nbsp;</a></span>alias() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e0c09b67c82352fe4ebd4f9f6ae5fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0c09b67c82352fe4ebd4f9f6ae5fbc">&#9670;&nbsp;</a></span>alias() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias multifluid data up to a specified level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Maximum grid level for aliasing operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a648c7a7cb2e3783a26312d3533f4cb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c7a7cb2e3783a26312d3533f4cb0f">&#9670;&nbsp;</a></span>alias() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e201260012be3d1709f86689af5abf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e201260012be3d1709f86689af5abf0">&#9670;&nbsp;</a></span>alias() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias multifluid data up to a specified level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Maximum grid level for aliasing operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a567e5bc873abc63dc52aee60efa1ba44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567e5bc873abc63dc52aee60efa1ba44">&#9670;&nbsp;</a></span>alias() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_mfdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias an entire hiearchy of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Single-phased data on specific phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mfdata</td><td>Multifluid data to be aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add7129b60d83999a8e9ebb473987a8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7129b60d83999a8e9ebb473987a8f4">&#9670;&nbsp;</a></span>alias() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn smart-pointer data structure into regular-pointer data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_alias</td><td>Raw pointer aliased </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Smart-pointer data</td></tr>
  </table>
  </dd>
</dl>
<p>This fetches the bare pointer from a_data and sets it in a_alias. </p>

</div>
</div>
<a id="ae1420f5b9c853b5e09334f15966a36f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1420f5b9c853b5e09334f15966a36f6">&#9670;&nbsp;</a></span>alias() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::alias </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; RefCountedPtr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn smart-pointer data structure into regular-pointer data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_alias</td><td>Raw pointer aliased </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Smart-pointer data</td></tr>
  </table>
  </dd>
</dl>
<p>This fetches the bare pointer from a_data and sets it in a_alias. </p>

</div>
</div>
<a id="af5c89795f369b846f251f1fec56c48a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c89795f369b846f251f1fec56c48a5">&#9670;&nbsp;</a></span>allocate() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRBool</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate Boolean data over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a97a408d2381f605f562b01a7de04ef2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a408d2381f605f562b01a7de04ef2c">&#9670;&nbsp;</a></span>allocate() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a8000cf94e2d87a651cf49c7e853ce6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8000cf94e2d87a651cf49c7e853ce6f4">&#9670;&nbsp;</a></span>allocate() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a74ebef713ce593b19fe2ffbbba9ce2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ebef713ce593b19fe2ffbbba9ce2ea">&#9670;&nbsp;</a></span>allocate() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a4e05b28f775f47845a231661f708c963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e05b28f775f47845a231661f708c963">&#9670;&nbsp;</a></span>allocate() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a02342a1d423fc64ed7bd1d3f08fafae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02342a1d423fc64ed7bd1d3f08fafae6">&#9670;&nbsp;</a></span>allocate() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nGhost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a6a666605ffc876316d34fe42318a13bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a666605ffc876316d34fe42318a13bb">&#9670;&nbsp;</a></span>allocate() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_ghost</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a5010f466f55bebc90afc212bd78e494c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5010f466f55bebc90afc212bd78e494c">&#9670;&nbsp;</a></span>allocate() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_nComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_ghost</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data holder over a specific realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data holder to be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> of the name where the data will be allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nComp</td><td>Number of components in a_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nGhost</td><td>Number of ghost cells for a_data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a_nGhost &lt; 0, this routine will use the default number of ghost cells. </dd></dl>

</div>
</div>
<a id="a14f77ca80a54f034ec88ad6451677757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f77ca80a54f034ec88ad6451677757">&#9670;&nbsp;</a></span>allocate() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template class for generic allocation of particle containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_container</td><td>Particle container to be allocated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> on which the particles will be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7fffb758e5b66b09bed3d194d99d94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fffb758e5b66b09bed3d194d99d94c">&#9670;&nbsp;</a></span>allocate() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocate </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RefCountedPtr&lt; ParticleData&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template class for generic allocation of particle data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_particles</td><td>Particle data holder. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> on which the particles will be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd0624a6f806dc2ee7790916f7d178aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0624a6f806dc2ee7790916f7d178aa">&#9670;&nbsp;</a></span>allocatePointer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocatePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate pointer but not any memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data structure for which pointers will be constructed.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets all the elements in a_data to be RefCountedPtr&lt;T&gt;(nullptr) </p>

</div>
</div>
<a id="a8a6b0764f2aa6080931401e3749045ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6b0764f2aa6080931401e3749045ff">&#9670;&nbsp;</a></span>allocatePointer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocatePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate pointer but not any memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data structure for which pointers will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Finest grid level on which a_data will be defined.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets all the elements in the vector to be RefCountedPtr&lt;T&gt;(nullptr) </p>

</div>
</div>
<a id="ac4c266b32bccaf75389e17bb093f35e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c266b32bccaf75389e17bb093f35e0">&#9670;&nbsp;</a></span>allocatePointer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocatePointer </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RefCountedPtr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate pointer but not any memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data structure for which pointers will be constructed.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets all the elements in the vector to be RefCountedPtr&lt;T&gt;(nullptr) </p>

</div>
</div>
<a id="a43de955ea9fed613ae6514fdc06ccbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43de955ea9fed613ae6514fdc06ccbaf">&#9670;&nbsp;</a></span>allocatePointer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::allocatePointer </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RefCountedPtr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate pointer but not any memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data structure for which pointers will be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Finest grid level on which a_data will be defined.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets all the elements in the vector to be RefCountedPtr&lt;T&gt;(nullptr) </p>

</div>
</div>
<a id="af6eb5733b4a2fce7c522c37d3c1347ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6eb5733b4a2fce7c522c37d3c1347ff">&#9670;&nbsp;</a></span>arithmeticAverage() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic average of data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57c8382e0e99edfdbf353d60b46d41ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c8382e0e99edfdbf353d60b46d41ba">&#9670;&nbsp;</a></span>arithmeticAverage() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval &amp;&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic average of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdb661908599529bdc686d2de016a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb661908599529bdc686d2de016a16f">&#9670;&nbsp;</a></span>arithmeticAverage() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<p>This computes an arithmetic average of the face data. Data on coarse faces is replaced by the arithmetic average of the fine face data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be average. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bbddcd21848988ec71d1525f80076bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbddcd21848988ec71d1525f80076bc">&#9670;&nbsp;</a></span>arithmeticAverage() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic average on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41c3e36e18a1b3feefe1bc12e0b59a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c3e36e18a1b3feefe1bc12e0b59a8d">&#9670;&nbsp;</a></span>arithmeticAverage() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic coarsening of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad64caac626d5f6846785a8ad7a855303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64caac626d5f6846785a8ad7a855303">&#9670;&nbsp;</a></span>arithmeticAverage() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::arithmeticAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average multifluid data over a realm. </p>
<p>This computes an arithmetic average of the face data. Data on coarse faces is replaced by the arithmetic average of the fine face data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6540dc8db6193a32c989936f8b47da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6540dc8db6193a32c989936f8b47da1">&#9670;&nbsp;</a></span>average() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa07eed6758ee76431667b3832f36b966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07eed6758ee76431667b3832f36b966">&#9670;&nbsp;</a></span>average() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval &amp;&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables to average </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1459b80feff30769ea928f10907fcc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1459b80feff30769ea928f10907fcc89">&#9670;&nbsp;</a></span>average() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc3a4063ef5b08f363743daa70496b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3a4063ef5b08f363743daa70496b45">&#9670;&nbsp;</a></span>average() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9db6f208842207e02524d7cc61d0961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9db6f208842207e02524d7cc61d0961">&#9670;&nbsp;</a></span>average() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average multifluid data over a specified realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35796165052eb306d772d0471eca391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35796165052eb306d772d0471eca391b">&#9670;&nbsp;</a></span>average() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average multifluid data over a specified realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a338e3c1c4ba567f145e898a6c66a0ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338e3c1c4ba567f145e898a6c66a0ede">&#9670;&nbsp;</a></span>buildGrids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::buildGrids </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; IntVectSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_hardcap</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build new internal AMR grids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_tags</td><td>Sets of cell tags used for the grid generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The finest grid level which changes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hardcap</td><td>Hardcap for the maximum grid level which can be generated. If a_hardcap &lt; 0 there is no restriction beyond the <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> restrictions.</td></tr>
  </table>
  </dd>
</dl>
<p>This will call the specified grid generation method and fill m_grids with the new grids. </p>

</div>
</div>
<a id="a03736c8164011068783b32d6c0342caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03736c8164011068783b32d6c0342caf">&#9670;&nbsp;</a></span>computeGradient() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute cell-centered gradient over an AMR hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Cell centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the realm where the data lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells are updated before using this routine. </dd></dl>

</div>
</div>
<a id="a5468ec45f9d206c1d2d99fd74cf42521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5468ec45f9d206c1d2d99fd74cf42521">&#9670;&nbsp;</a></span>computeGradient() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute face-centered gradient over an AMR hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Face centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the realm where the data lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells are updated before using this routine. </dd></dl>

</div>
</div>
<a id="a0a8748090e8b37b8b2f678ce4002ebeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8748090e8b37b8b2f678ce4002ebeb">&#9670;&nbsp;</a></span>computeGradient() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell-centered gradient for a grid level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Cell centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the realm where the data lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which the data lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level where the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells updated before using this routine. </dd></dl>

</div>
</div>
<a id="adc77b754e28f3212863848aaba964db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc77b754e28f3212863848aaba964db5">&#9670;&nbsp;</a></span>computeGradient() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute cell-centered gradient over an AMR hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Cell centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells are updated before using this routine. </dd></dl>

</div>
</div>
<a id="a9e4b4cd76b62eaaca138fbdcd5ec3090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4b4cd76b62eaaca138fbdcd5ec3090">&#9670;&nbsp;</a></span>computeGradient() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::computeGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute face-centered gradient over an AMR hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_gradient</td><td>Face centered gradient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>The scalar for which the gradient is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where the data lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will reach into ghost cells and across refinement boundaries. The user must make sure that ghost cells are updated before using this routine. </dd></dl>

</div>
</div>
<a id="aae69d99efb79d91bbf8ddfa33b61ab0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae69d99efb79d91bbf8ddfa33b61ab0f">&#9670;&nbsp;</a></span>conservativeAverage() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conseratively average data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bd84b6a06ba937f38448a89a3f6882b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd84b6a06ba937f38448a89a3f6882b">&#9670;&nbsp;</a></span>conservativeAverage() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval &amp;&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conseratively average data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af32fe0c1d230d0a0dadee647d7d2730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32fe0c1d230d0a0dadee647d7d2730b">&#9670;&nbsp;</a></span>conservativeAverage() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ebca4c73310fecee761a9f74b8fe01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ebca4c73310fecee761a9f74b8fe01">&#9670;&nbsp;</a></span>conservativeAverage() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conservative averaging on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53b3f8d395e81592ba629ebc11b9141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b3f8d395e81592ba629ebc11b9141e">&#9670;&nbsp;</a></span>conservativeAverage() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conservative coarsening of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabe7ab07b30103513af9784864aba639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe7ab07b30103513af9784864aba639">&#9670;&nbsp;</a></span>conservativeAverage() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::conservativeAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down multifluid data over a realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebe76068a86db2799fc9e6e96d6a2ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe76068a86db2799fc9e6e96d6a2ccf">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4106e7ad20ffcbc318620738f6cec766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4106e7ad20ffcbc318620738f6cec766">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::deallocate </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RefCountedPtr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate smart pointer data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ab65c2e423aaa581d3adb4fd883b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ab65c2e423aaa581d3adb4fd883b92">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::deallocate </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5032e0accfccfbc5c77cd8d4e6bbe578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032e0accfccfbc5c77cd8d4e6bbe578">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , const RealVect &amp;(P::*)() const particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deposit scalar particle quantities on the mesh. </p>
<p>This routine will switch between various algorithms depending on the user input. If the user chooses to deposit with "halos" near the refinement boundaries then this function requires the "halo" particles to be filled before entering this routine. Thus, if depositing with halos (which requires kernels with 2x or 4x the particle width), the user must first call ParticleContainer::copyMaskParticles(AMRMask). If the user does not do this, he will lose mass near the refinement boundaries. Other than that, this function is just like regular particle-mesh deposition. The mesh field should have exactly one component and the quantity to be deposited is fetched from the specified template parameter 'a_particleScalarField'. This should be a pointer to a member function with signature const Real&amp; P::function() const. E.g. if we are depositing mass through a function const Real&amp; P::mass() const we will specifiy</p>
<p>interpolate&lt;P, &amp;P::mass&gt; (...)</p>
<p>To deposit a different quantity, simply change the function pointer in the input parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5032e0accfccfbc5c77cd8d4e6bbe578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032e0accfccfbc5c77cd8d4e6bbe578">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deposit scalar particle quantities on the mesh. </p>
<p>Precisely like the above function, except that the function signature is Real P::particleScalarField() const (C++ is not too smart about these things) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5032e0accfccfbc5c77cd8d4e6bbe578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032e0accfccfbc5c77cd8d4e6bbe578">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , const RealVect &amp;(P::*)() const particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deposit vector particle quantities on the mesh. </p>
<p>This routine will switch between various algorithms depending on the user input. If the user chooses to deposit with "halos" near the refinement boundaries then this function requires the "halo" particles to be filled before entering this routine. Thus, if depositing with halos (which requires kernels with 2x or 4x the particle width), the user must first call ParticleContainer::copyMaskParticles(AMRMask). If the user does not do this, he will lose mass near the refinement boundaries. Other than that, this function is just like regular particle-mesh deposition. The mesh field should have exactly SpaceDim components and the quantity to be deposited is fetched from the specified template parameter 'a_particleVectorField'. This should be a pointer to a member function with signature const RealVect&amp; P::function() const. E.g. if we are depositing current through a function const RealVect&amp; P::current() const we will specifiy</p>
<p>interpolate&lt;P, &amp;P::current&gt; (...)</p>
<p>To deposit a different quantity, simply change the function pointer in the input parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5032e0accfccfbc5c77cd8d4e6bbe578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5032e0accfccfbc5c77cd8d4e6bbe578">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deposit vector particle quantities on the mesh. </p>
<p>Precisely like the above function, except that the function signature is RealVect P::particleVectorField() const (C++ is not too smart about these things) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1662c260b08bddf92838f6061040619b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1662c260b08bddf92838f6061040619b">&#9670;&nbsp;</a></span>getBaseImplicitFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const RefCountedPtr&lt; BaseIF &gt; &amp; AmrMesh::getBaseImplicitFunction </td>
          <td>(</td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get implicit function for a specific phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase 8gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af18f3ce3d1d5310f7f18518a84fdf1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18f3ce3d1d5310f7f18518a84fdf1dc">&#9670;&nbsp;</a></span>getBoxSorting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CD__BoxSorting_8H.html#ab5db8b3a96e3a04473aaa898f7eb2128">BoxSorting</a> AmrMesh::getBoxSorting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get box sorting method. </p>
<dl class="section return"><dt>Returns</dt><dd>Box sorting method. </dd></dl>

</div>
</div>
<a id="ab8a85437e92d6b8493258d04c05d30db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a85437e92d6b8493258d04c05d30db">&#9670;&nbsp;</a></span>getCentroidInterpolationStencils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classCentroidInterpolationStencil.html">CentroidInterpolationStencil</a> &gt; &amp; AmrMesh::getCentroidInterpolationStencils </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interpolation stencils for going from cell center to cell centroid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2f69225d0b1c2b84e8f69bd0dd5c4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f69225d0b1c2b84e8f69bd0dd5c4d5">&#9670;&nbsp;</a></span>getCoarToCoarRedist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; EBCoarToCoarRedist &gt; &gt; &amp; AmrMesh::getCoarToCoarRedist </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get coar-to-coar redistribution objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fe8f027bf253db4627512e378ef0a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe8f027bf253db4627512e378ef0a95">&#9670;&nbsp;</a></span>getCoarToFineRedist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; EBCoarToFineRedist &gt; &gt; &amp; AmrMesh::getCoarToFineRedist </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get coar-to-fine redistribution for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e8721574be5dce546f43bc88f9ca9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8721574be5dce546f43bc88f9ca9cd">&#9670;&nbsp;</a></span>getEbCentroidInterpolationStencils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classEbCentroidInterpolationStencil.html">EbCentroidInterpolationStencil</a> &gt; &amp; AmrMesh::getEbCentroidInterpolationStencils </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interpolation stencils for going from cell center to cell boundary centroid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f0c7045c11ff7348a421675cf5ff6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f0c7045c11ff7348a421675cf5ff6b">&#9670;&nbsp;</a></span>getEbCf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AmrMesh::getEbCf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if mesh has an EBCF. </p>
<dl class="section note"><dt>Note</dt><dd>Always returns true, non-EBCF cases are a thing of the past. </dd></dl>

</div>
</div>
<a id="a3e42c503eb88132db381576c0289f5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e42c503eb88132db381576c0289f5ab">&#9670;&nbsp;</a></span>getEBIndexSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RefCountedPtr&lt;EBIndexSpace&gt;&amp; AmrMesh::getEBIndexSpace </td>
          <td>(</td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get EBIndexSpace corresponding to a particular phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas/solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db2254121059379e82f6569b2c6641a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db2254121059379e82f6569b2c6641a">&#9670;&nbsp;</a></span>getEBISLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Vector&lt; EBISLayout &gt; &amp; AmrMesh::getEBISLayout </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get EBISLayouts for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b1071a09cfc3ff93bd467ae8c63da08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1071a09cfc3ff93bd467ae8c63da08">&#9670;&nbsp;</a></span>getEBLevelGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Vector&lt; RefCountedPtr&lt; EBLevelGrid &gt; &gt; &amp; AmrMesh::getEBLevelGrid </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the EBLevelGrid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2947e26ae104dd0bf1476ac94638100a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2947e26ae104dd0bf1476ac94638100a">&#9670;&nbsp;</a></span>getFillPatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; AggEBPWLFillPatch &gt; &gt; &amp; AmrMesh::getFillPatch </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get piecewise linear ghost cell interpolator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cbe95dc353cef3fe72aea2f83927e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbe95dc353cef3fe72aea2f83927e98">&#9670;&nbsp;</a></span>getFineInterp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; <a class="el" href="classEBFineInterp.html">EBFineInterp</a> &gt; &gt; &amp; AmrMesh::getFineInterp </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interpolator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4352f3a572ffe95357934042c5409ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4352f3a572ffe95357934042c5409ec5">&#9670;&nbsp;</a></span>getFineToCoarRedist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; EBFineToCoarRedist &gt; &gt; &amp; AmrMesh::getFineToCoarRedist </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get coar-to-coar redistribution redistribution objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04896ca8511ca4f17a1558d89683085d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04896ca8511ca4f17a1558d89683085d">&#9670;&nbsp;</a></span>getFluxRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; EBFluxRegister &gt; &gt; &amp; AmrMesh::getFluxRegister </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flux register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a15d1ab20a04a86618e7c45d001c6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a15d1ab20a04a86618e7c45d001c6c5">&#9670;&nbsp;</a></span>getLevelRedist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; EBLevelRedist &gt; &gt; &amp; AmrMesh::getLevelRedist </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get redistribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6ae0a0c9ceba11621bc8f1ba1682824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ae0a0c9ceba11621bc8f1ba1682824">&#9670;&nbsp;</a></span>getLevelset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBAMRData.html">EBAMRFAB</a> &amp; AmrMesh::getLevelset </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get levelset function, allocated over a grid for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac94bae000d35d8820cfef27bd9c1c890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94bae000d35d8820cfef27bd9c1c890">&#9670;&nbsp;</a></span>getMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="CD__Realm_8H.html#a906b67939aa45e674c3a94d40c0e5e34">AMRMask</a> &amp; AmrMesh::getMask </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a registered mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mask</td><td>Mask name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_buffer</td><td>Buffer (used when registering mask) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99a7c78576d46ae8ced617b78ab0ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a7c78576d46ae8ced617b78ab0ae30">&#9670;&nbsp;</a></span>getMFLevelGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Vector&lt; RefCountedPtr&lt; <a class="el" href="classMFLevelGrid.html">MFLevelGrid</a> &gt; &gt; &amp; AmrMesh::getMFLevelGrid </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get EBISLayouts for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28d1aa576ea1b98c23378f127212844e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d1aa576ea1b98c23378f127212844e">&#9670;&nbsp;</a></span>getMultigridInterpolator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; <a class="el" href="classEBMultigridInterpolator.html">EBMultigridInterpolator</a> &gt; &gt; &amp; AmrMesh::getMultigridInterpolator </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get multigrid interpolation utility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4abbe61fb38994322f510515d9ea3849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abbe61fb38994322f510515d9ea3849">&#9670;&nbsp;</a></span>getNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Vector&lt; RefCountedPtr&lt; LayoutData&lt; Vector&lt; LayoutIndex &gt; &gt; &gt; &gt; &amp; AmrMesh::getNeighbors </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get neighboring boxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa71d4093fe3c996f104348eec16cf0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71d4093fe3c996f104348eec16cf0bd">&#9670;&nbsp;</a></span>getNonConservativeDivergenceStencils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIrregAmrStencil.html">IrregAmrStencil</a>&lt; <a class="el" href="classNonConservativeDivergenceStencil.html">NonConservativeDivergenceStencil</a> &gt; &amp; AmrMesh::getNonConservativeDivergenceStencils </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nonconservative divergence stencils. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae01ad6d63e8fed8c1615a06a9ccb534a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01ad6d63e8fed8c1615a06a9ccb534a">&#9670;&nbsp;</a></span>getParticleMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRParticleMesh.html">EBAMRParticleMesh</a> &amp; AmrMesh::getParticleMesh </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classEBAMRParticleMesh.html" title="Class for handling particle-mesh operations with AMR.">EBAMRParticleMesh</a> operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23821170fc1949807a3896dcc9f33b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23821170fc1949807a3896dcc9f33b1a">&#9670;&nbsp;</a></span>getProxyGrids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Vector&lt; DisjointBoxLayout &gt; &amp; AmrMesh::getProxyGrids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "proxy" grids in <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a>. </p>
<p>Returns m_grids </p>

</div>
</div>
<a id="a10aa1580b30fe66ec3e313435c44d1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa1580b30fe66ec3e313435c44d1f1">&#9670;&nbsp;</a></span>getRealms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; AmrMesh::getRealms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of all Realms. </p>
<dl class="section return"><dt>Returns</dt><dd>Names of all Realms </dd></dl>

</div>
</div>
<a id="ab7a316dd3977e3f60c27c0e2f71cf4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a316dd3977e3f60c27c0e2f71cf4fc">&#9670;&nbsp;</a></span>getRefinementRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AmrMesh::getRefinementRatio </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get refinement factor between two levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level1</td><td>First level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level2</td><td>Second level</td></tr>
  </table>
  </dd>
</dl>
<p>This will work correctly in reverse as well. </p>

</div>
</div>
<a id="a1492043709c933fca6e7c51a42aebf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1492043709c933fca6e7c51a42aebf40">&#9670;&nbsp;</a></span>getValidCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="CD__Realm_8H.html#a906b67939aa45e674c3a94d40c0e5e34">AMRMask</a> &amp; AmrMesh::getValidCells </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a map of all valid cells on a specified realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3a0d0f998de1a920a638a7b23c8056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a0d0f998de1a920a638a7b23c8056a">&#9670;&nbsp;</a></span>getVofIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; RefCountedPtr&lt; LayoutData&lt; VoFIterator &gt; &gt; &gt; &amp; AmrMesh::getVofIterator </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get vof iterators for a <a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> and phase. This has the capability of iterating through cut-cells. </p>
<p>Not const because we need to reset the vofiterator </p>

</div>
</div>
<a id="a4b49e5fa25c6a4bb059a6c3e25b1c078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b49e5fa25c6a4bb059a6c3e25b1c078">&#9670;&nbsp;</a></span>harmonicAverage() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonic average of data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb3e29a7ec2d7e88c8ba7410e1fda2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3e29a7ec2d7e88c8ba7410e1fda2ea">&#9670;&nbsp;</a></span>harmonicAverage() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval &amp;&#160;</td>
          <td class="paramname"><em>a_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonic average of data. Does all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_variables</td><td>Variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00b2fdcbb8c36d6ccd8e6b836980ab3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b2fdcbb8c36d6ccd8e6b836980ab3c">&#9670;&nbsp;</a></span>harmonicAverage() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average down on specific realm and phase. </p>
<p>This computes an arithmetic average of the face data. Data on coarse faces is replaced by the arithmetic average of the fine face data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be average. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a259cb2f2336f091eeb1955b7c525a040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb2f2336f091eeb1955b7c525a040">&#9670;&nbsp;</a></span>harmonicAverage() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonic average on specific realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a186c852306b0260ad0637599217ea035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186c852306b0260ad0637599217ea035">&#9670;&nbsp;</a></span>harmonicAverage() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harmonic coarsening of multifluid data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4e9d87d1e36b48c25847153b44b2db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e9d87d1e36b48c25847153b44b2db2">&#9670;&nbsp;</a></span>harmonicAverage() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::harmonicAverage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average multifluid data over a realm. </p>
<p>This computes an arithmetic average of the face data. Data on coarse faces is replaced by the arithmetic average of the fine face data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a980ef520e5d9c3a2977a6c43d432b523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980ef520e5d9c3a2977a6c43d432b523">&#9670;&nbsp;</a></span>interpGhost() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpGhost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost vectors over a realm, using the default ghost cell interpolation method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff48bbba8105fcfea99d8796268eaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff48bbba8105fcfea99d8796268eaab">&#9670;&nbsp;</a></span>interpGhost() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpGhost </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_fineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_coarData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm, using the default ghost cell interpolation method on a specific level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_fineData</td><td>Fine grid data </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_coarData</td><td>Coarse grid data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>The grid level corresponding to a_fineData </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03f71b81c581b084edff3a03e61ce943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f71b81c581b084edff3a03e61ce943">&#9670;&nbsp;</a></span>interpGhost() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpGhost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm. Calls the default ghost cell interpolation method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187f9807eae7f2c90a6b0ac1c32f8cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187f9807eae7f2c90a6b0ac1c32f8cb1">&#9670;&nbsp;</a></span>interpGhostMG() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpGhostMG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm and phase. </p>
<p>This routine uses the multigrid interpolator, which does not reach into invalid regions. I.e., all ghost cells are interpolated using valid data only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a019193845e8ff43c846575570b0c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a019193845e8ff43c846575570b0c0a">&#9670;&nbsp;</a></span>interpGhostMG() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpGhostMG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm and phase. </p>
<p>This routine uses the multigrid interpolator, which does not reach into invalid regions. I.e., all ghost cells are interpolated using valid data only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b4b8c5a83b8df8a3f23c93cd81a834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b4b8c5a83b8df8a3f23c93cd81a834">&#9670;&nbsp;</a></span>interpGhostPwl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpGhostPwl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm and phase. This uses piecewise linear interpolation (with limiters) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3aa6a3ddddeb4ffdda877719e545eaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa6a3ddddeb4ffdda877719e545eaef">&#9670;&nbsp;</a></span>interpGhostPwl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpGhostPwl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate ghost cells over a realm and phase. This uses piecewise linear interpolation (with limiters) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa07d5998e160d5430c49bc238e819e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07d5998e160d5430c49bc238e819e77">&#9670;&nbsp;</a></span>interpolateParticles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect &amp;(P::*)() particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpolateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshScalarField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_interpType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a scalar field onto the particle position. </p>
<p>This is just like regular particle-mesh interpolation. The input field should have exactly one component and the the field will be interpolated onto the template parameter's input field. The template parameter 'particleScalarField' should be a pointer to a member function which will set the particle field. E.g. the function must have a signature Real&amp; P::particleScalarField(). A valid expression is e.g. </p><pre class="fragment">interpolate&lt;P, &amp;P::mass&gt; (...)
</pre><p>To interpolate onto a different field, replace ::mass by the other scalar field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be interpolated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_meshScalarField</td><td>Scalar field on the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpType</td><td>Interpolation type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP interpolation in cut-cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac073bb1b20ac52395c1a2403af462996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac073bb1b20ac52395c1a2403af462996">&#9670;&nbsp;</a></span>interpolateParticles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect &amp;(P::*)() particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpolateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshVectorField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_interpType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector field onto the particle position. </p>
<p>This is just like regular particle-mesh interpolation. The input field should have exactly SpaceDim components and the the field will be interpolated onto the template parameter's input field. The template parameter 'particleVectorField' should be a pointer to a member function which will set the particle field. E.g. the function must have a signature RealVect&amp; P::particleVectorField(). A valid expression is e.g. </p><pre class="fragment">interpolate&lt;P, &amp;P::velocity&gt; (...)
</pre><p>To interpolate onto a different field, replace ::velocity by another vector field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be interpolated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where data is registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_meshScalarField</td><td>Scalar field on the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpType</td><td>Interpolation type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP interpolation in cut-cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58008f166bc2d7de06c4c24d879513fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58008f166bc2d7de06c4c24d879513fe">&#9670;&nbsp;</a></span>interpToCentroids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpToCentroids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to centroids on realm and phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be interpolated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid)</td></tr>
  </table>
  </dd>
</dl>
<p>This leaves regular data intact, while the values in irregular are replaced by the corresponding interpolation to centroids. </p>

</div>
</div>
<a id="a8d58d2eac35c0c39372e209dd8a1951c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d58d2eac35c0c39372e209dd8a1951c">&#9670;&nbsp;</a></span>interpToNewGrids() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpToNewGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_useSlopes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to new grids. </p>
<p>This is called when requiring data to be interpolated to new grids. Takes old data as argument and fills the new grid data with an interpolation of the old grid data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_newData</td><td>New grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldData</td><td>Old grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which we regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that did not change (but distribution may have changed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Previous finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>New finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_useSlopes</td><td>If true, use slopes when regridding the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeab6792375474b61a99bd36203fd3de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab6792375474b61a99bd36203fd3de3">&#9670;&nbsp;</a></span>interpToNewGrids() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpToNewGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_conservative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to new grids. </p>
<p>This is called when requiring data to be interpolated to new grids. Takes old data as argument and fills the new grid data with an interpolation of the old grid data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_newData</td><td>New grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldData</td><td>Old grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase on which we regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that did not change (but distribution may have changed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Previous finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>New finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_conservative</td><td>If true, do conservative regridding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27ced532eeaca03e97e064b0a6cf3bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ced532eeaca03e97e064b0a6cf3bc1">&#9670;&nbsp;</a></span>interpToNewGrids() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::interpToNewGrids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_useSlopes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to new grids. </p>
<p>This is called when requiring data to be interpolated to new grids. Takes old data as argument and fills the new grid data with an interpolation of the old grid data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_newData</td><td>New grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldData</td><td>Old grid data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that did not change (but distribution may have changed). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Previous finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>New finest level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_useSlopes</td><td>If true, use slopes when regridding the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0f00c083961d5921ba325b971838db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f00c083961d5921ba325b971838db">&#9670;&nbsp;</a></span>intersectParticlesBisectIF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::intersectParticlesBisectIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_activeParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domainParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_bisectionStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Particle intersection algorithm based on bisection. </p>
<p>This routine will iterate through all the particles and check if they intersect the geometry. The template parameter indicates the particle type &ndash; it MUST have const RealVec&amp; position() const and const RealVect&amp; oldPosition() const  functions that determine the start and stop position of the particle trajectory. This routine uses a bisection method to check for intersections with the EB (the domain side is much easier). Their position are updated and they are placed in the a_ebParticles argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_activeParticles</td><td>Particles to be intersected with geometry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_ebParticles</td><td>Particles that intersected with the EB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_domainParticles</td><td>Particles that intersected with the domain faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the input particles live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_bisectionStep</td><td>Length of the bisection step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, particles will be removed from a_activeParticles if they intersect the geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5ada016124b15d40ea5c6661c8f60f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ada016124b15d40ea5c6661c8f60f4">&#9670;&nbsp;</a></span>intersectParticlesRaycastIF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::intersectParticlesRaycastIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_activeParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domainParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Particle intersection algorithm based on ray-casting. </p>
<p>This routine will iterate through all the particles and check if they intersect the geometry. The template parameter indicates the particle type &ndash; it MUST have const RealVec&amp; position() const and const RealVect&amp; oldPosition() const  functions that determine the start and stop position of the particle trajectory. This routine uses a ray-casting method to check for intersections with the EB (the domain side is much easier). If the particles are closer to the EB than a_tolerance, they are absorbed and placed on the EB. Their position are updated and they are placed in the a_ebParticles argument. This routine uses a ray-casting method where it computes the distance from the EB (assuming that the implicit function is a signed distance function). Particles are then moved that distance along their trajectory and we then update the new distance to the EB. This is done recursively until the particles have either moved the entire length or been absorbed by the EB or domain side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_activeParticles</td><td>Particles to be intersected with geometry </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_ebParticles</td><td>Particles that intersected with the EB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_domainParticles</td><td>Particles that intersected with the domain faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the input particles live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, particles will be removed from a_activeParticles if they intersect the geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62abb1c10ff8d78a358316db0288b140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62abb1c10ff8d78a358316db0288b140">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAmrMesh.html">AmrMesh</a>&amp; AmrMesh::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed move assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c7cd5f8fa15a16eebfe28f2547ef685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7cd5f8fa15a16eebfe28f2547ef685">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAmrMesh.html">AmrMesh</a>&amp; AmrMesh::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAmrMesh.html">AmrMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab02dccfc4e434c6ee612908413498d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02dccfc4e434c6ee612908413498d50">&#9670;&nbsp;</a></span>parseEbGhostCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::parseEbGhostCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse number of ghost cells for eb stuff. </p>
<p>Only matters for the grid generation step. </p>

</div>
</div>
<a id="add290a067d272d1e544cdedd2c54a896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add290a067d272d1e544cdedd2c54a896">&#9670;&nbsp;</a></span>parseMaxEbisBoxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::parseMaxEbisBoxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the maximum permitted box size. </p>
<p>Only relevant for the grid generation step. </p>

</div>
</div>
<a id="a0d6d9f11ede790783a919c1cd20870ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6d9f11ede790783a919c1cd20870ba">&#9670;&nbsp;</a></span>parseRuntimeOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::parseRuntimeOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse runtime options. </p>
<dl class="section note"><dt>Note</dt><dd>Called by <a class="el" href="classDriver.html" title="Main class for time/space advancement of streamer equations.">Driver</a> as simulations progress. </dd></dl>

</div>
</div>
<a id="a3f7105b45dc3d5db23e1029f9fa95ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7105b45dc3d5db23e1029f9fa95ef2">&#9670;&nbsp;</a></span>queryRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AmrMesh::queryRealm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if a realm exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td>Name of the realm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the realm exists and false otherwise. </dd></dl>

</div>
</div>
<a id="a5074cd4a99c5c29bf499cd20688d5ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5074cd4a99c5c29bf499cd20688d5ca2">&#9670;&nbsp;</a></span>reallocate() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRBool</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="a87a0c3e11d835a5bd9e3ab8c5950e2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a0c3e11d835a5bd9e3ab8c5950e2ca">&#9670;&nbsp;</a></span>reallocate() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase over the reallocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="a612f5b753bfe06523d77d8ffe49d9459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612f5b753bfe06523d77d8ffe49d9459">&#9670;&nbsp;</a></span>reallocate() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase over the reallocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="a991ec9fb80cd2579acf88acb51738403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991ec9fb80cd2579acf88acb51738403">&#9670;&nbsp;</a></span>reallocate() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase over the reallocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="aad120065536a58ff9f0c4662c03a8449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad120065536a58ff9f0c4662c03a8449">&#9670;&nbsp;</a></span>reallocate() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase over the reallocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="acc9a31a2a37e7d804a6aa80ca3e7fc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9a31a2a37e7d804a6aa80ca3e7fc7d">&#9670;&nbsp;</a></span>reallocate() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="ac523d5d24140c8f8e84e118ff8c4123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac523d5d24140c8f8e84e118ff8c4123e">&#9670;&nbsp;</a></span>reallocate() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="a14e98284a18faae8ac933f5cbe469f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e98284a18faae8ac933f5cbe469f74">&#9670;&nbsp;</a></span>reallocate() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Data to be reallocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>The lowest grid level that will be reallocated.</td></tr>
  </table>
  </dd>
</dl>
<p>This will reallocate data for all grid levels lvl &gt;= a_lmin. </p>

</div>
</div>
<a id="acf9b6818c634e2585a628f30362af1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9b6818c634e2585a628f30362af1b0">&#9670;&nbsp;</a></span>registerMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::registerMask </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a boolean mask over a realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mask</td><td>Mask name to be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_buffer</td><td>Relevant buffer for the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The meaning of a_buffer differs for different masks. </dd>
<dd>
Run-time errors will occur if the mask or realm do not exist. </dd></dl>

</div>
</div>
<a id="a2bb365cb3691098693eb0bba6b552fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb365cb3691098693eb0bba6b552fe6">&#9670;&nbsp;</a></span>registerOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::registerOperator </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an operator over a realm and a phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_operator</td><td>Operator to be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase (gas or solid). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Run-time errors will occur if the operator or realm do not exist. </dd></dl>

</div>
</div>
<a id="a6dd2b0e8c918e6057647103c8193fa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd2b0e8c918e6057647103c8193fa17">&#9670;&nbsp;</a></span>registerRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::registerRealm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a new realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is safe to re-register a realm. </dd></dl>

</div>
</div>
<a id="a9a8897dc00f6ac738080aba2ec29ad7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8897dc00f6ac738080aba2ec29ad7a">&#9670;&nbsp;</a></span>regridAmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::regridAmr </td>
          <td>(</td>
          <td class="paramtype">const Vector&lt; IntVectSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_hardcap</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regrid AMR. This versions generates the grids and Realms, but not the operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tags</td><td>Cell tags which will generate the grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest grid level allowed to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hardcap</td><td>Grid generation hardcap. If &lt; 0 there are no limitations to grid depth. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee8e3a7de269ef9be0121c22eed428d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8e3a7de269ef9be0121c22eed428d5">&#9670;&nbsp;</a></span>regridOperators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::regridOperators </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regrid AMR operators. This is done for all realms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest grid level that changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3183dc6d7db9eae4ed1af8c80ea0c893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3183dc6d7db9eae4ed1af8c80ea0c893">&#9670;&nbsp;</a></span>regridRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::regridRealm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Vector&lt; Box &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regrid a realm. This generates the grids for the realm, but does not do the operators on the realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_procs</td><td>Processor IDs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_boxes</td><td>Grid boxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level that changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb1b3008526e53b38e09e96e0e88487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb1b3008526e53b38e09e96e0e88487">&#9670;&nbsp;</a></span>removeCoveredParticlesDiscrete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::removeCoveredParticlesDiscrete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which removes particles from the domain if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version uses the discrete information to evaluate whether or not the particles are inside the EB. The particles will be removed from the container if they lie within a covered cell OR if they lie in an irregular cell but on the "wrong" side of the EB face (to within precision tolerance*dx) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance when to remove particles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work if the particles are mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="a412d58b270f56e04aa17127c0fcf5f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412d58b270f56e04aa17127c0fcf5f46">&#9670;&nbsp;</a></span>removeCoveredParticlesIF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::removeCoveredParticlesIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which removes particles from the domain if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version uses the implicit function to evaluate whether or not the particles are inside the EB. The particles will be removed from the container if f(x) &gt; a_tolerance*dx. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Because the implicit functions are global, this function will work even if the particles aren't mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="a036c315af1e9c46ba5320a3de0017927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036c315af1e9c46ba5320a3de0017927">&#9670;&nbsp;</a></span>removeCoveredParticlesVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::removeCoveredParticlesVoxels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which removes particles from the domain if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it must have a const RealVect&amp; <a class="el" href="namespaceLocation.html#a303c39a31d7afb2dd5650a9117a7d710" title="Compute the position (ignoring the &quot;origin) of a Vof.">P::position()</a> function.</p>
<p>This version removes all particles that live in covered cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work if the particles are mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="afc74d0037dc972aea59860feeb54a6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc74d0037dc972aea59860feeb54a6e3">&#9670;&nbsp;</a></span>setBaseImplicitFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::setBaseImplicitFunction </td>
          <td>(</td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RefCountedPtr&lt; BaseIF &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_baseIF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set implicit function for a specific phase. Need e.g. for level-sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_baseIF</td><td>The level-set function describing the phase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dcbb2334af9b06815262abc2ceda9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcbb2334af9b06815262abc2ceda9e2">&#9670;&nbsp;</a></span>setFinestLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::setFinestLevel </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_finestLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the finest level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is dangerous routine, but it's needed because <a class="el" href="classDriver.html" title="Main class for time/space advancement of streamer equations.">Driver</a> reads checkpoint files and needs to set the finest level from those. </dd></dl>

</div>
</div>
<a id="a4a1dedaf7d55ced2c775b32d401a08fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1dedaf7d55ced2c775b32d401a08fd">&#9670;&nbsp;</a></span>setGrids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::setGrids </td>
          <td>(</td>
          <td class="paramtype">const Vector&lt; Vector&lt; Box &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Vector&lt; Vector&lt; long int &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_realmsAndLoads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set grids from boxes and computational loads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_boxes</td><td>Grid boxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realmsAndLoads</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> names and computational loads for realms</td></tr>
  </table>
  </dd>
</dl>
<p>This will set the grids for <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> and realms, load balancing the various realms with the provided loads. </p>

</div>
</div>
<a id="a80a0ed99e2d6e6edf3fb65ad4b79d9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a0ed99e2d6e6edf3fb65ad4b79d9a0">&#9670;&nbsp;</a></span>setMultifluidIndexSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::setMultifluidIndexSpace </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classMultiFluidIndexSpace.html">MultiFluidIndexSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_multiFluidIndexSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets multifluid index space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_multiFluidIndexSpace</td><td>Multifluid index space wrapper. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06b91aa63e558054ea913b05e797ec50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b91aa63e558054ea913b05e797ec50">&#9670;&nbsp;</a></span>transferCoveredParticlesDiscrete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::transferCoveredParticlesDiscrete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which transferse particles from one particle container to another if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version uses the discrete information to evaluate whether or not the particles are inside the EB. The particles will be transferred from the container if they lie within a covered cell OR if they lie in an irregular cell but on the "wrong" side of the EB face (to within precision tolerance*dx) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesFrom</td><td>Container to transfer from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesTo</td><td>Container to transfer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work if the particles are mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<a id="a25c75449e9996805572bc01bd43042b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c75449e9996805572bc01bd43042b2">&#9670;&nbsp;</a></span>transferCoveredParticlesIF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::transferCoveredParticlesIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which transferse particles from one particle container to another if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version uses the implicit function to evaluate whether or not the particles are inside the EB. The particles will be transferred from the container if f(x) &gt; a_tolerance*dx. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesFrom</td><td>Container to transfer from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesTo</td><td>Container to transfer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance (Note: relative to grid resolution) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Because the implicit functions are global, this function will work even if the particles aren't mapped to the correct boxes (but remapping will be necessary) </dd></dl>

</div>
</div>
<a id="adccc54b19b8398a8c48c4ef8b2ea026c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccc54b19b8398a8c48c4ef8b2ea026c">&#9670;&nbsp;</a></span>transferCoveredParticlesVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AmrMesh::transferCoveredParticlesVoxels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const phase::which_phase &amp;&#160;</td>
          <td class="paramname"><em>a_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which transferse particles from one particle container to another if they fall inside the EB. </p>
<p>The template parameter indicate the particle type &ndash; it MUST have a const RealVect&amp; P::position() const function.</p>
<p>This version transfers all particles that live in covered cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesFrom</td><td>Container to transfer from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particlesTo</td><td>Container to transfer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase where the particles live. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work if the particles are mapped to the correct EBISBox. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/AmrMesh/<a class="el" href="CD__AmrMesh_8H_source.html">CD_AmrMesh.H</a></li>
<li>Source/AmrMesh/<a class="el" href="CD__AmrMesh_8cpp.html">CD_AmrMesh.cpp</a></li>
<li>Source/AmrMesh/<a class="el" href="CD__AmrMeshImplem_8H_source.html">CD_AmrMeshImplem.H</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
