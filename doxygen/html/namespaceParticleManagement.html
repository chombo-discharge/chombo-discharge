<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: ParticleManagement Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ParticleManagement Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for various particle management tools.  
<a href="namespaceParticleManagement.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abb4cc237cfca463592686cabeb3a6f75"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:abb4cc237cfca463592686cabeb3a6f75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#abb4cc237cfca463592686cabeb3a6f75">ParticleMerger</a> = std::function&lt; void(List&lt; P &gt; &amp;a_particles, const <a class="el" href="classCellInfo.html">CellInfo</a> &amp;a_cellInfo, const int a_numTargetParticles)&gt;</td></tr>
<tr class="memdesc:abb4cc237cfca463592686cabeb3a6f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for splitting/merging particles.  <a href="namespaceParticleManagement.html#abb4cc237cfca463592686cabeb3a6f75">More...</a><br /></td></tr>
<tr class="separator:abb4cc237cfca463592686cabeb3a6f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355c356fabec1650406a887b59c2068f"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a355c356fabec1650406a887b59c2068f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#a355c356fabec1650406a887b59c2068f">BinaryParticleReconcile</a> = std::function&lt; void(P &amp;p1, P &amp;p2, const P &amp;p0)&gt;</td></tr>
<tr class="memdesc:a355c356fabec1650406a887b59c2068f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of a reconciliation function when splitting particles.  <a href="namespaceParticleManagement.html#a355c356fabec1650406a887b59c2068f">More...</a><br /></td></tr>
<tr class="separator:a355c356fabec1650406a887b59c2068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a682da4913c7f97a112bca7a51c83aada"><td class="memTemplParams" colspan="2">template&lt;class P , Real &amp;(P::*)() weight, const RealVect &amp;(P::*)() const position&gt; </td></tr>
<tr class="memitem:a682da4913c7f97a112bca7a51c83aada"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classKDNode.html">KDNode</a>&lt; P &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#a682da4913c7f97a112bca7a51c83aada">recursivePartitionAndSplitEqualWeightKD</a> (typename <a class="el" href="classKDNode.html">KDNode</a>&lt; P &gt;::ParticleList &amp;a_inputParticles, const int a_maxLeaves, const <a class="el" href="namespaceParticleManagement.html#a355c356fabec1650406a887b59c2068f">BinaryParticleReconcile</a>&lt; P &gt; a_particleReconcile) noexcept</td></tr>
<tr class="memdesc:a682da4913c7f97a112bca7a51c83aada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively build a KD-tree following the "equal weight" principle when partitioning nodes.  <a href="namespaceParticleManagement.html#a682da4913c7f97a112bca7a51c83aada">More...</a><br /></td></tr>
<tr class="separator:a682da4913c7f97a112bca7a51c83aada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21623f295aec259e5624cf60287f7fed"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T , typename &gt; </td></tr>
<tr class="memitem:a21623f295aec259e5624cf60287f7fed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#a21623f295aec259e5624cf60287f7fed">removePhysicalParticles</a> (List&lt; P &gt; &amp;a_particles, const T a_numPhysPartToRemove) noexcept</td></tr>
<tr class="memdesc:a21623f295aec259e5624cf60287f7fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove physical particles from the input particles.  <a href="namespaceParticleManagement.html#a21623f295aec259e5624cf60287f7fed">More...</a><br /></td></tr>
<tr class="separator:a21623f295aec259e5624cf60287f7fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03181d038c45abb4e5ba0d78be9d830c"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a03181d038c45abb4e5ba0d78be9d830c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#a03181d038c45abb4e5ba0d78be9d830c">deleteParticles</a> (List&lt; P &gt; &amp;a_particles, const Real a_weightThresh) noexcept</td></tr>
<tr class="memdesc:a03181d038c45abb4e5ba0d78be9d830c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove particles if their weight is below the input weight.  <a href="namespaceParticleManagement.html#a03181d038c45abb4e5ba0d78be9d830c">More...</a><br /></td></tr>
<tr class="separator:a03181d038c45abb4e5ba0d78be9d830c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f6b1e86c8bf2b35f97f8965aca4d61"><td class="memTemplParams" colspan="2">template&lt;typename T , typename &gt; </td></tr>
<tr class="memitem:a81f6b1e86c8bf2b35f97f8965aca4d61"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#a81f6b1e86c8bf2b35f97f8965aca4d61">partitionParticleWeights</a> (const T a_numPhysicalParticles, const T a_maxCompParticles) noexcept</td></tr>
<tr class="memdesc:a81f6b1e86c8bf2b35f97f8965aca4d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition particle weights among a number of computational particles.  <a href="namespaceParticleManagement.html#a81f6b1e86c8bf2b35f97f8965aca4d61">More...</a><br /></td></tr>
<tr class="separator:a81f6b1e86c8bf2b35f97f8965aca4d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2e3437fa68515105d33f9a5b30b6aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename &gt; </td></tr>
<tr class="memitem:adb2e3437fa68515105d33f9a5b30b6aa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#adb2e3437fa68515105d33f9a5b30b6aa">partitionParticles</a> (const T a_numParticles)</td></tr>
<tr class="memdesc:adb2e3437fa68515105d33f9a5b30b6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition particles so that all MPI rank draw a cumulative number of particles equal to a_numParticles.  <a href="namespaceParticleManagement.html#adb2e3437fa68515105d33f9a5b30b6aa">More...</a><br /></td></tr>
<tr class="separator:adb2e3437fa68515105d33f9a5b30b6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75f56fb901f696511a835668c2f0aed"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T , typename &gt; </td></tr>
<tr class="memitem:af75f56fb901f696511a835668c2f0aed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#af75f56fb901f696511a835668c2f0aed">drawRandomParticles</a> (List&lt; P &gt; &amp;a_particles, const T a_numParticles, const std::function&lt; RealVect()&gt; &amp;a_distribution)</td></tr>
<tr class="memdesc:af75f56fb901f696511a835668c2f0aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a specified number of random particles distributed according to a predefined distribution.  <a href="namespaceParticleManagement.html#af75f56fb901f696511a835668c2f0aed">More...</a><br /></td></tr>
<tr class="separator:af75f56fb901f696511a835668c2f0aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab801d1419a184bb1a0beaa8acede5be0"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T , typename &gt; </td></tr>
<tr class="memitem:ab801d1419a184bb1a0beaa8acede5be0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#ab801d1419a184bb1a0beaa8acede5be0">drawSphereParticles</a> (List&lt; P &gt; &amp;a_particles, const T a_numParticles, const RealVect a_center, const Real a_radius) noexcept</td></tr>
<tr class="memdesc:ab801d1419a184bb1a0beaa8acede5be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw particles in a sphere.  <a href="namespaceParticleManagement.html#ab801d1419a184bb1a0beaa8acede5be0">More...</a><br /></td></tr>
<tr class="separator:ab801d1419a184bb1a0beaa8acede5be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b10c8404d6da6e59042fd4f7ff8312"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T , typename &gt; </td></tr>
<tr class="memitem:af0b10c8404d6da6e59042fd4f7ff8312"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#af0b10c8404d6da6e59042fd4f7ff8312">drawBoxParticles</a> (List&lt; P &gt; &amp;a_particles, const T a_numParticles, const RealVect a_loCorner, const RealVect a_hiCorner) noexcept</td></tr>
<tr class="memdesc:af0b10c8404d6da6e59042fd4f7ff8312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw particles in a box.  <a href="namespaceParticleManagement.html#af0b10c8404d6da6e59042fd4f7ff8312">More...</a><br /></td></tr>
<tr class="separator:af0b10c8404d6da6e59042fd4f7ff8312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788d6de7f87c7d0126d8a8a8fadc4b8b"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T , typename &gt; </td></tr>
<tr class="memitem:a788d6de7f87c7d0126d8a8a8fadc4b8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceParticleManagement.html#a788d6de7f87c7d0126d8a8a8fadc4b8b">drawGaussianParticles</a> (List&lt; P &gt; &amp;a_particles, const T a_numParticles, const RealVect a_center, const Real a_radius) noexcept</td></tr>
<tr class="memdesc:a788d6de7f87c7d0126d8a8a8fadc4b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw particles from a Gaussian distribution.  <a href="namespaceParticleManagement.html#a788d6de7f87c7d0126d8a8a8fadc4b8b">More...</a><br /></td></tr>
<tr class="separator:a788d6de7f87c7d0126d8a8a8fadc4b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for various particle management tools. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a355c356fabec1650406a887b59c2068f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355c356fabec1650406a887b59c2068f">&#9670;&nbsp;</a></span>BinaryParticleReconcile</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceParticleManagement.html#a355c356fabec1650406a887b59c2068f">ParticleManagement::BinaryParticleReconcile</a> = typedef std::function&lt;void(P&amp; p1, P&amp; p2, const P&amp; p0)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declaration of a reconciliation function when splitting particles. </p>
<p>This is, for example, passed into the KD-tree equal-weight partioning structure, which may split a particle such that the weight of the two nodes differ by at most one physical particle. By default, that method will call the particle copy constructor, but this function permits the user to input a reconciliation function that manipulates other class members in the split particles. </p>

</div>
</div>
<a id="abb4cc237cfca463592686cabeb3a6f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4cc237cfca463592686cabeb3a6f75">&#9670;&nbsp;</a></span>ParticleMerger</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceParticleManagement.html#abb4cc237cfca463592686cabeb3a6f75">ParticleManagement::ParticleMerger</a> = typedef std::function&lt; void(List&lt;P&gt;&amp; a_particles, const <a class="el" href="classCellInfo.html">CellInfo</a>&amp; a_cellInfo, const int a_numTargetParticles)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept for splitting/merging particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be merged/split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numTargetParticles</td><td>Number of target particles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a03181d038c45abb4e5ba0d78be9d830c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03181d038c45abb4e5ba0d78be9d830c">&#9670;&nbsp;</a></span>deleteParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParticleManagement::deleteParticles </td>
          <td>(</td>
          <td class="paramtype">List&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_weightThresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove particles if their weight is below the input weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Input list of particles. Must have a weight function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_weightThresh</td><td>Weight threshold for removal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0b10c8404d6da6e59042fd4f7ff8312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b10c8404d6da6e59042fd4f7ff8312">&#9670;&nbsp;</a></span>drawBoxParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParticleManagement::drawBoxParticles </td>
          <td>(</td>
          <td class="paramtype">List&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_loCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_hiCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw particles in a box. </p>
<p>The implementation will partition a_numParticles among the ranks so the total number of particles drawn is a_numParticles. P is the particle type (must have a RealVect&amp; <a class="el" href="namespaceLocation.html#a303c39a31d7afb2dd5650a9117a7d710" title="Compute the position (ignoring the &quot;origin) of a Vof.">position()</a> function) and T is an integer type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_particles</td><td>Output particles (different for each rank) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numParticles</td><td>Number of particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_loCorner</td><td>Low corner of box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hiCorner</td><td>High corner of box </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a788d6de7f87c7d0126d8a8a8fadc4b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788d6de7f87c7d0126d8a8a8fadc4b8b">&#9670;&nbsp;</a></span>drawGaussianParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParticleManagement::drawGaussianParticles </td>
          <td>(</td>
          <td class="paramtype">List&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw particles from a Gaussian distribution. </p>
<p>The implementation will partition a_numParticles among the ranks so the total number of particles drawn is a_numParticles. P is the particle type (must have a RealVect&amp; <a class="el" href="namespaceLocation.html#a303c39a31d7afb2dd5650a9117a7d710" title="Compute the position (ignoring the &quot;origin) of a Vof.">position()</a> function) and T is an integer type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_particles</td><td>Output particles (different for each rank) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numParticles</td><td>Number of particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_center</td><td>Gaussian blob Center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_radius</td><td>Gaussian blob radius </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af75f56fb901f696511a835668c2f0aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75f56fb901f696511a835668c2f0aed">&#9670;&nbsp;</a></span>drawRandomParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParticleManagement::drawRandomParticles </td>
          <td>(</td>
          <td class="paramtype">List&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; RealVect()&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_distribution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a specified number of random particles distributed according to a predefined distribution. </p>
<p>The implementation will partition a_numParticles among the ranks so the total number of particles drawn is a_numParticles. P is the particle type (must derived from BinItem) and T is an integer type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_particles</td><td>Output particles (different for each rank) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numParticles</td><td>Number of particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_distribution</td><td>Particle distribution. Must return a random position when calling the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab801d1419a184bb1a0beaa8acede5be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab801d1419a184bb1a0beaa8acede5be0">&#9670;&nbsp;</a></span>drawSphereParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParticleManagement::drawSphereParticles </td>
          <td>(</td>
          <td class="paramtype">List&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw particles in a sphere. </p>
<p>The implementation will partition a_numParticles among the ranks so the total number of particles drawn is a_numParticles. P is the particle type (must have a RealVect&amp; <a class="el" href="namespaceLocation.html#a303c39a31d7afb2dd5650a9117a7d710" title="Compute the position (ignoring the &quot;origin) of a Vof.">position()</a> function) and T is an integer type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_particles</td><td>Output particles (different for each rank) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numParticles</td><td>Number of particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_center</td><td>Sphere center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_radius</td><td>Sphere radius </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb2e3437fa68515105d33f9a5b30b6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2e3437fa68515105d33f9a5b30b6aa">&#9670;&nbsp;</a></span>partitionParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T ParticleManagement::partitionParticles </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_numParticles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition particles so that all MPI rank draw a cumulative number of particles equal to a_numParticles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numParticles</td><td>Total number of particles to be drawn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of particles drawn by each rank. </dd></dl>

</div>
</div>
<a id="a81f6b1e86c8bf2b35f97f8965aca4d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f6b1e86c8bf2b35f97f8965aca4d61">&#9670;&nbsp;</a></span>partitionParticleWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; ParticleManagement::partitionParticleWeights </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_numPhysicalParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_maxCompParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition particle weights among a number of computational particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numPhysicalParticles</td><td>Number of physical particles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxCompParticles</td><td>Maximum number of computational particles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a682da4913c7f97a112bca7a51c83aada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682da4913c7f97a112bca7a51c83aada">&#9670;&nbsp;</a></span>recursivePartitionAndSplitEqualWeightKD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real &amp;(P::*)() weight, const RealVect &amp;(P::*)() const position&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classKDNode.html">KDNode</a>&lt;P&gt; &gt; &gt; ParticleManagement::recursivePartitionAndSplitEqualWeightKD </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classKDNode.html">KDNode</a>&lt; P &gt;::ParticleList &amp;&#160;</td>
          <td class="paramname"><em>a_inputParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_maxLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceParticleManagement.html#a355c356fabec1650406a887b59c2068f">BinaryParticleReconcile</a>&lt; P &gt;&#160;</td>
          <td class="paramname"><em>a_particleReconcile</em> = <code>[](P&#160;&amp;p1,&#160;P&#160;&amp;p2,&#160;const&#160;P&#160;&amp;p0)&#160;-&gt;&#160;void&#160;{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively build a KD-tree following the "equal weight" principle when partitioning nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_inputParticles</td><td>Input particles. These are destroyed on output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxLeaves</td><td>Maximum number of leaves in the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns leaf nodes containing the particles</dd></dl>
<p>If the number of leaves is a factor of two, leaves exist on the same level and the weight in each node will differ by at most one physical particle. The template parameters are</p>
<p>P -&gt; Particle type P::*weight -&gt; Function pointer to particle weight P::*position -&gt; Function pointer to particle position.</p>
<p>A possible call signature is e.g. recursivePartitionAndSplitEqualWeightKD&lt;P, &amp;P::weight, &amp;P::position&gt;.</p>
<p>The user can input a particle reconciliation function that manipulates the particle properties of the split particles. By default, the split particles will use the copy constructor and thus inherit class members from p0, with the exception of the particle weights. The reconcile function lets the user manipulate other particle properties, e.g. ones that are not properly captured by the particle copy constructor, or that need some other form of reconciliation. </p>

</div>
</div>
<a id="a21623f295aec259e5624cf60287f7fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21623f295aec259e5624cf60287f7fed">&#9670;&nbsp;</a></span>removePhysicalParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParticleManagement::removePhysicalParticles </td>
          <td>(</td>
          <td class="paramtype">List&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_numPhysPartToRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove physical particles from the input particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Input list of particles. Must have a weight function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numPhysPartToRemove</td><td>Number of physical particles to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May fail if particle weights are not (close to) integers. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
