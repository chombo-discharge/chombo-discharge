<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: EBAMRParticleMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classEBAMRParticleMesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EBAMRParticleMesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for handling particle-mesh operations with AMR.  
 <a href="classEBAMRParticleMesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__EBAMRParticleMesh_8H_source.html">CD_EBAMRParticleMesh.H</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf041cd52fc9431850b9f174ca7f1855"><td class="memItemLeft" align="right" valign="top"><a id="abf041cd52fc9431850b9f174ca7f1855"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#abf041cd52fc9431850b9f174ca7f1855">EBAMRParticleMesh</a> ()</td></tr>
<tr class="memdesc:abf041cd52fc9431850b9f174ca7f1855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Leaves object in undefined state and thus requires the user to call define. <br /></td></tr>
<tr class="separator:abf041cd52fc9431850b9f174ca7f1855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9957cef3b50ab9a3f7801c61bcdf32c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a9957cef3b50ab9a3f7801c61bcdf32c4">EBAMRParticleMesh</a> (const Vector&lt; RefCountedPtr&lt; EBLevelGrid &gt;&gt; &amp;a_eblgs, const Vector&lt; int &gt; &amp;a_refRat, const Vector&lt; Real &gt; &amp;a_dx, const RealVect &amp;a_probLo, const IntVect &amp;a_ghost, const int a_maxParticleWidth, const int a_finestLevel)</td></tr>
<tr class="memdesc:a9957cef3b50ab9a3f7801c61bcdf32c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full constructor. Calls the define function.  <a href="classEBAMRParticleMesh.html#a9957cef3b50ab9a3f7801c61bcdf32c4">More...</a><br /></td></tr>
<tr class="separator:a9957cef3b50ab9a3f7801c61bcdf32c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5064ae1fd724d491775a76992737c9e3"><td class="memItemLeft" align="right" valign="top"><a id="a5064ae1fd724d491775a76992737c9e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a5064ae1fd724d491775a76992737c9e3">~EBAMRParticleMesh</a> ()</td></tr>
<tr class="memdesc:a5064ae1fd724d491775a76992737c9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (does nothing) <br /></td></tr>
<tr class="separator:a5064ae1fd724d491775a76992737c9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69540e8dafd1fa7e62e4caa0a79fbd09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a69540e8dafd1fa7e62e4caa0a79fbd09">define</a> (const Vector&lt; RefCountedPtr&lt; EBLevelGrid &gt;&gt; &amp;a_eblgs, const Vector&lt; int &gt; &amp;a_refRat, const Vector&lt; Real &gt; &amp;a_dx, const RealVect &amp;a_probLo, const IntVect &amp;a_ghost, const int a_maxParticleWidth, const int a_finestLevel)</td></tr>
<tr class="memdesc:a69540e8dafd1fa7e62e4caa0a79fbd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define function.  <a href="classEBAMRParticleMesh.html#a69540e8dafd1fa7e62e4caa0a79fbd09">More...</a><br /></td></tr>
<tr class="separator:a69540e8dafd1fa7e62e4caa0a79fbd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843">deposit</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for deposition of particles of a type P to the mesh. This does scalar quantities.  <a href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843">More...</a><br /></td></tr>
<tr class="separator:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843">deposit</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for deposition of particles of a type P to the mesh. This does scalar quantities.  <a href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843">More...</a><br /></td></tr>
<tr class="separator:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memTemplParams" colspan="2">template&lt;class P , const RealVect &amp;(P::*)() const particleVectorField&gt; </td></tr>
<tr class="memitem:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843">deposit</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for deposition of particles of a type P to the mesh. This does vector quantities.  <a href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843">More...</a><br /></td></tr>
<tr class="separator:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memTemplParams" colspan="2">template&lt;class P , RealVect(P::*)() const particleVectorField&gt; </td></tr>
<tr class="memitem:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843">deposit</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for deposition of particles of a type P to the mesh. This does vector quantities.  <a href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843">More...</a><br /></td></tr>
<tr class="separator:ac4ff2ad7b21f0131730b17c93a6f5843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d83d6fd441d62ca8068a122cbc5fd"><td class="memTemplParams" colspan="2">template&lt;class P , Real &amp;(P::*)() particleScalarField&gt; </td></tr>
<tr class="memitem:a972d83d6fd441d62ca8068a122cbc5fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a972d83d6fd441d62ca8068a122cbc5fd">interpolate</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshVectorField, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_interpType, const bool a_forceIrregNGP=false) const</td></tr>
<tr class="memdesc:a972d83d6fd441d62ca8068a122cbc5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a scalar field onto the particle position.  <a href="classEBAMRParticleMesh.html#a972d83d6fd441d62ca8068a122cbc5fd">More...</a><br /></td></tr>
<tr class="separator:a972d83d6fd441d62ca8068a122cbc5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d83d6fd441d62ca8068a122cbc5fd"><td class="memTemplParams" colspan="2">template&lt;class P , RealVect &amp;(P::*)() particleVectorField&gt; </td></tr>
<tr class="memitem:a972d83d6fd441d62ca8068a122cbc5fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a972d83d6fd441d62ca8068a122cbc5fd">interpolate</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshVectorField, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_interpType, const bool a_forceIrregNGP=false) const</td></tr>
<tr class="memdesc:a972d83d6fd441d62ca8068a122cbc5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector field onto the particle position.  <a href="classEBAMRParticleMesh.html#a972d83d6fd441d62ca8068a122cbc5fd">More...</a><br /></td></tr>
<tr class="separator:a972d83d6fd441d62ca8068a122cbc5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3405865d0f7ef07a3664e170568e3af5"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; <a class="el" href="classEBCoarseFineParticleMesh.html">EBCoarseFineParticleMesh</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a3405865d0f7ef07a3664e170568e3af5">getEBCoarseFineParticleMesh</a> () const</td></tr>
<tr class="memdesc:a3405865d0f7ef07a3664e170568e3af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffers for handling deposition over refinement boundaries.  <a href="classEBAMRParticleMesh.html#a3405865d0f7ef07a3664e170568e3af5">More...</a><br /></td></tr>
<tr class="separator:a3405865d0f7ef07a3664e170568e3af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfca3dfa7af4c8c38cb1f77af66e5015"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEBParticleMesh.html">EBParticleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#acfca3dfa7af4c8c38cb1f77af66e5015">getEBParticleMesh</a> (const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:acfca3dfa7af4c8c38cb1f77af66e5015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classEBParticleMesh.html" title="A class for depositing and interpolating particles. Contains various useful routines for interpolatio...">EBParticleMesh</a> deposition/interpolation object for specified grid patch.  <a href="classEBAMRParticleMesh.html#acfca3dfa7af4c8c38cb1f77af66e5015">More...</a><br /></td></tr>
<tr class="separator:acfca3dfa7af4c8c38cb1f77af66e5015"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af7078bfe1729f10b1739edd264749101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#af7078bfe1729f10b1739edd264749101">defineLevelMotion</a> ()</td></tr>
<tr class="memdesc:af7078bfe1729f10b1739edd264749101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define level copiers.  <a href="classEBAMRParticleMesh.html#af7078bfe1729f10b1739edd264749101">More...</a><br /></td></tr>
<tr class="separator:af7078bfe1729f10b1739edd264749101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42bd65a697b9fe12d4637b13df2cd24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#af42bd65a697b9fe12d4637b13df2cd24">defineCoarseFineMotion</a> ()</td></tr>
<tr class="memdesc:af42bd65a697b9fe12d4637b13df2cd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define coarse-fine data motion operators.  <a href="classEBAMRParticleMesh.html#af42bd65a697b9fe12d4637b13df2cd24">More...</a><br /></td></tr>
<tr class="separator:af42bd65a697b9fe12d4637b13df2cd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1da335a1ae9076481b3365f0d35ae9"><td class="memItemLeft" align="right" valign="top"><a id="a6d1da335a1ae9076481b3365f0d35ae9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a6d1da335a1ae9076481b3365f0d35ae9">defineEBParticleMesh</a> ()</td></tr>
<tr class="memdesc:a6d1da335a1ae9076481b3365f0d35ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define <a class="el" href="classEBParticleMesh.html" title="A class for depositing and interpolating particles. Contains various useful routines for interpolatio...">EBParticleMesh</a> objects. <br /></td></tr>
<tr class="separator:a6d1da335a1ae9076481b3365f0d35ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb58633a2caafccf5783980435f9a7cc"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:acb58633a2caafccf5783980435f9a7cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#acb58633a2caafccf5783980435f9a7cc">depositPVR</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:acb58633a2caafccf5783980435f9a7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "PVR" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#acb58633a2caafccf5783980435f9a7cc">More...</a><br /></td></tr>
<tr class="separator:acb58633a2caafccf5783980435f9a7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb58633a2caafccf5783980435f9a7cc"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:acb58633a2caafccf5783980435f9a7cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#acb58633a2caafccf5783980435f9a7cc">depositPVR</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:acb58633a2caafccf5783980435f9a7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "PVR" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#acb58633a2caafccf5783980435f9a7cc">More...</a><br /></td></tr>
<tr class="separator:acb58633a2caafccf5783980435f9a7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bf08ea08cb444054dfc09417f113c7"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:ad4bf08ea08cb444054dfc09417f113c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ad4bf08ea08cb444054dfc09417f113c7">depositHalo</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:ad4bf08ea08cb444054dfc09417f113c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "Halo" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#ad4bf08ea08cb444054dfc09417f113c7">More...</a><br /></td></tr>
<tr class="separator:ad4bf08ea08cb444054dfc09417f113c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bf08ea08cb444054dfc09417f113c7"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:ad4bf08ea08cb444054dfc09417f113c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ad4bf08ea08cb444054dfc09417f113c7">depositHalo</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:ad4bf08ea08cb444054dfc09417f113c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "Halo" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#ad4bf08ea08cb444054dfc09417f113c7">More...</a><br /></td></tr>
<tr class="separator:ad4bf08ea08cb444054dfc09417f113c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a61924fd4ff7dad8f19cb1dc2757717ff">depositHaloNGP</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "HaloNGP" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#a61924fd4ff7dad8f19cb1dc2757717ff">More...</a><br /></td></tr>
<tr class="separator:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a61924fd4ff7dad8f19cb1dc2757717ff">depositHaloNGP</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "HaloNGP" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#a61924fd4ff7dad8f19cb1dc2757717ff">More...</a><br /></td></tr>
<tr class="separator:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb58633a2caafccf5783980435f9a7cc"><td class="memTemplParams" colspan="2">template&lt;class P , const RealVect &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:acb58633a2caafccf5783980435f9a7cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#acb58633a2caafccf5783980435f9a7cc">depositPVR</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:acb58633a2caafccf5783980435f9a7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "PVR" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#acb58633a2caafccf5783980435f9a7cc">More...</a><br /></td></tr>
<tr class="separator:acb58633a2caafccf5783980435f9a7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb58633a2caafccf5783980435f9a7cc"><td class="memTemplParams" colspan="2">template&lt;class P , RealVect(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:acb58633a2caafccf5783980435f9a7cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#acb58633a2caafccf5783980435f9a7cc">depositPVR</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:acb58633a2caafccf5783980435f9a7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "PVR" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#acb58633a2caafccf5783980435f9a7cc">More...</a><br /></td></tr>
<tr class="separator:acb58633a2caafccf5783980435f9a7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bf08ea08cb444054dfc09417f113c7"><td class="memTemplParams" colspan="2">template&lt;class P , const RealVect &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:ad4bf08ea08cb444054dfc09417f113c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ad4bf08ea08cb444054dfc09417f113c7">depositHalo</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:ad4bf08ea08cb444054dfc09417f113c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "Halo" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#ad4bf08ea08cb444054dfc09417f113c7">More...</a><br /></td></tr>
<tr class="separator:ad4bf08ea08cb444054dfc09417f113c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bf08ea08cb444054dfc09417f113c7"><td class="memTemplParams" colspan="2">template&lt;class P , RealVect(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:ad4bf08ea08cb444054dfc09417f113c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ad4bf08ea08cb444054dfc09417f113c7">depositHalo</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:ad4bf08ea08cb444054dfc09417f113c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "Halo" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#ad4bf08ea08cb444054dfc09417f113c7">More...</a><br /></td></tr>
<tr class="separator:ad4bf08ea08cb444054dfc09417f113c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memTemplParams" colspan="2">template&lt;class P , const RealVect &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a61924fd4ff7dad8f19cb1dc2757717ff">depositHaloNGP</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "HaloNGP" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#a61924fd4ff7dad8f19cb1dc2757717ff">More...</a><br /></td></tr>
<tr class="separator:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memTemplParams" colspan="2">template&lt;class P , RealVect(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a61924fd4ff7dad8f19cb1dc2757717ff">depositHaloNGP</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_meshData, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_depositionType, const bool a_forceIrregNGP=false)</td></tr>
<tr class="memdesc:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the deposit function, but forced to use the "HaloNGP" algorithm for handling refinement boundaries.  <a href="classEBAMRParticleMesh.html#a61924fd4ff7dad8f19cb1dc2757717ff">More...</a><br /></td></tr>
<tr class="separator:a61924fd4ff7dad8f19cb1dc2757717ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9ae94c60cd4c3695ed3e9ee3677be9c3"><td class="memItemLeft" align="right" valign="top"><a id="a9ae94c60cd4c3695ed3e9ee3677be9c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a9ae94c60cd4c3695ed3e9ee3677be9c3">m_isDefined</a></td></tr>
<tr class="memdesc:a9ae94c60cd4c3695ed3e9ee3677be9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is defined or not. <br /></td></tr>
<tr class="separator:a9ae94c60cd4c3695ed3e9ee3677be9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3c4e172d2c9af84f4c928a870d409c"><td class="memItemLeft" align="right" valign="top"><a id="a7d3c4e172d2c9af84f4c928a870d409c"></a>
RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a7d3c4e172d2c9af84f4c928a870d409c">m_probLo</a></td></tr>
<tr class="memdesc:a7d3c4e172d2c9af84f4c928a870d409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower-left corner of physical domain. <br /></td></tr>
<tr class="separator:a7d3c4e172d2c9af84f4c928a870d409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204a5e140b49229c09a6117191072cd0"><td class="memItemLeft" align="right" valign="top"><a id="a204a5e140b49229c09a6117191072cd0"></a>
IntVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a204a5e140b49229c09a6117191072cd0">m_ghost</a></td></tr>
<tr class="memdesc:a204a5e140b49229c09a6117191072cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ghost cells. <br /></td></tr>
<tr class="separator:a204a5e140b49229c09a6117191072cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103990d2c971877e3db80991bcd00cab"><td class="memItemLeft" align="right" valign="top"><a id="a103990d2c971877e3db80991bcd00cab"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a103990d2c971877e3db80991bcd00cab">m_maxParticleWidth</a></td></tr>
<tr class="memdesc:a103990d2c971877e3db80991bcd00cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum particle width that will ever be used. <br /></td></tr>
<tr class="separator:a103990d2c971877e3db80991bcd00cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f76849f380fb119794cfd7553ba1bdf"><td class="memItemLeft" align="right" valign="top"><a id="a6f76849f380fb119794cfd7553ba1bdf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a6f76849f380fb119794cfd7553ba1bdf">m_finestLevel</a></td></tr>
<tr class="memdesc:a6f76849f380fb119794cfd7553ba1bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finest AMR level. <br /></td></tr>
<tr class="separator:a6f76849f380fb119794cfd7553ba1bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada81b44c0d6c6fe72043f5e58aff8e2"><td class="memItemLeft" align="right" valign="top"><a id="aada81b44c0d6c6fe72043f5e58aff8e2"></a>
Vector&lt; RefCountedPtr&lt; EBLevelGrid &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#aada81b44c0d6c6fe72043f5e58aff8e2">m_eblgs</a></td></tr>
<tr class="memdesc:aada81b44c0d6c6fe72043f5e58aff8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grids on each level. <br /></td></tr>
<tr class="separator:aada81b44c0d6c6fe72043f5e58aff8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7563d64c64ed92f4fdcf1eae9e1cddc"><td class="memItemLeft" align="right" valign="top"><a id="af7563d64c64ed92f4fdcf1eae9e1cddc"></a>
Vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#af7563d64c64ed92f4fdcf1eae9e1cddc">m_refRat</a></td></tr>
<tr class="memdesc:af7563d64c64ed92f4fdcf1eae9e1cddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinement ratios between levels. <br /></td></tr>
<tr class="separator:af7563d64c64ed92f4fdcf1eae9e1cddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfa422111fdd0bab4cf9bd63c4bcb04"><td class="memItemLeft" align="right" valign="top"><a id="a5dfa422111fdd0bab4cf9bd63c4bcb04"></a>
Vector&lt; Real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a5dfa422111fdd0bab4cf9bd63c4bcb04">m_dx</a></td></tr>
<tr class="memdesc:a5dfa422111fdd0bab4cf9bd63c4bcb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid resolutions. <br /></td></tr>
<tr class="separator:a5dfa422111fdd0bab4cf9bd63c4bcb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1199b02a9b4bbf52d883148877ff427"><td class="memItemLeft" align="right" valign="top"><a id="aa1199b02a9b4bbf52d883148877ff427"></a>
Vector&lt; RefCountedPtr&lt; LayoutData&lt; <a class="el" href="classEBParticleMesh.html">EBParticleMesh</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#aa1199b02a9b4bbf52d883148877ff427">m_ebParticleMesh</a></td></tr>
<tr class="memdesc:aa1199b02a9b4bbf52d883148877ff427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular particle-mesh object on each grid level. <br /></td></tr>
<tr class="separator:aa1199b02a9b4bbf52d883148877ff427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1ac124f7d261d7d87132d14ec231bb"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; LayoutData&lt; <a class="el" href="classEBParticleMesh.html">EBParticleMesh</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#aef1ac124f7d261d7d87132d14ec231bb">m_ebParticleMeshFiCo</a></td></tr>
<tr class="memdesc:aef1ac124f7d261d7d87132d14ec231bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special particle-mesh objects for depositing on the coarsened fine grid.  <a href="classEBAMRParticleMesh.html#aef1ac124f7d261d7d87132d14ec231bb">More...</a><br /></td></tr>
<tr class="separator:aef1ac124f7d261d7d87132d14ec231bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5b9dff0fa365dbd0b5727b2c7388fb"><td class="memItemLeft" align="right" valign="top">Vector&lt; RefCountedPtr&lt; <a class="el" href="classEBCoarseFineParticleMesh.html">EBCoarseFineParticleMesh</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#a5c5b9dff0fa365dbd0b5727b2c7388fb">m_coarseFinePM</a></td></tr>
<tr class="memdesc:a5c5b9dff0fa365dbd0b5727b2c7388fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers for handling arithmetic for mass moving from coarse to fine level and vice versa.  <a href="classEBAMRParticleMesh.html#a5c5b9dff0fa365dbd0b5727b2c7388fb">More...</a><br /></td></tr>
<tr class="separator:a5c5b9dff0fa365dbd0b5727b2c7388fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72c43fc182e9c5fb6c0b15a607706f8"><td class="memItemLeft" align="right" valign="top">Vector&lt; Copier &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEBAMRParticleMesh.html#ab72c43fc182e9c5fb6c0b15a607706f8">m_levelCopiers</a></td></tr>
<tr class="memdesc:ab72c43fc182e9c5fb6c0b15a607706f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copier for moving data from valid+ghost to valid on each AMR level.  <a href="classEBAMRParticleMesh.html#ab72c43fc182e9c5fb6c0b15a607706f8">More...</a><br /></td></tr>
<tr class="separator:ab72c43fc182e9c5fb6c0b15a607706f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for handling particle-mesh operations with AMR. </p>
<p>This class contains templated functions for depositing particles with AMR. When depositing, the user must specify the deposition type (e.g., CIC) as well as how to handle coarse-fine boundary conditions and cut-cell deposition. Because of the many degrees of freedom in depositing particles with AMR (and EB), the user must expect to preprocess his particle data before solving. There are thus two "main" ways of handling deposition near refinement boundaries.</p>
<p>When specifying CoarseFineDeposition::PVR, the deposition is done by first depositing the data as usual on both levels. On the fine level, there may be mass that hangs over the refinement boundaries; that mass is added to the coarse level. On the coarse level some of the particles will deposit mass into cells that are covered by a finer level; that mass is interpolated with piece-wise constant interpolation and added to the fine level.</p>
<p>When specyfing CoarseFineDeposition::Halo, only the handling of the coarse-side deposition is different. As with PVR, the mass from the fine-level particles that hangs over refinement boundaries is put on the coarse mesh. However, the coarse-level particles are deposited in two separate steps so that the coarse-level particles have the same physical widths on the coarse and fine levels. We first deposit ALL the coarse-level particles on the coarse level. Some of these particles (halo particles) will have clouds that overlap with the fine level. We take the set of these particles and deposit them directly onto the fine level (via buffers) with 2x or 4x the original particle width (depending on the refinement ratios between the levels). Essentially, this differs CoarseFineDeposition::PVR in the sense that the original particle width is maintained on the fine level. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9957cef3b50ab9a3f7801c61bcdf32c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9957cef3b50ab9a3f7801c61bcdf32c4">&#9670;&nbsp;</a></span>EBAMRParticleMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EBAMRParticleMesh::EBAMRParticleMesh </td>
          <td>(</td>
          <td class="paramtype">const Vector&lt; RefCountedPtr&lt; EBLevelGrid &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_eblgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_refRat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect &amp;&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVect &amp;&#160;</td>
          <td class="paramname"><em>a_ghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_maxParticleWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full constructor. Calls the define function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_eblgs</td><td>Grids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_refRat</td><td>Refinement factory between levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions. @πaram[in] a_probLo Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ghost</td><td>Ghost cells in data holders. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxParticleWidth</td><td>Maximum particle width that will be encountered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Finest grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a69540e8dafd1fa7e62e4caa0a79fbd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69540e8dafd1fa7e62e4caa0a79fbd09">&#9670;&nbsp;</a></span>define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::define </td>
          <td>(</td>
          <td class="paramtype">const Vector&lt; RefCountedPtr&lt; EBLevelGrid &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_eblgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_refRat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect &amp;&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntVect &amp;&#160;</td>
          <td class="paramname"><em>a_ghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_maxParticleWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_finestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_eblgs</td><td>Grids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_refRat</td><td>Refinement factory between levels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions. @πaram[in] a_probLo Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ghost</td><td>Ghost cells in data holders. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxParticleWidth</td><td>Maximum particle width that will be encountered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_finestLevel</td><td>Finest grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af42bd65a697b9fe12d4637b13df2cd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42bd65a697b9fe12d4637b13df2cd24">&#9670;&nbsp;</a></span>defineCoarseFineMotion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::defineCoarseFineMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define coarse-fine data motion operators. </p>
<p>This defines the necessary constructors for </p>

</div>
</div>
<a id="af7078bfe1729f10b1739edd264749101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7078bfe1729f10b1739edd264749101">&#9670;&nbsp;</a></span>defineLevelMotion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::defineLevelMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define level copiers. </p>
<dl class="section note"><dt>Note</dt><dd>This defines the Copiers we need to move data from valid+ghost to valid on each level. </dd></dl>

</div>
</div>
<a id="ac4ff2ad7b21f0131730b17c93a6f5843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ff2ad7b21f0131730b17c93a6f5843">&#9670;&nbsp;</a></span>deposit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::deposit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class for deposition of particles of a type P to the mesh. This does scalar quantities. </p>
<p>This routine will switch between various algorithms depending on the user input. If the user chooses to deposit with "halos" near the refinement boundaries then this function requires the "halo" particles to be filled before entering this routine. Thus, if depositing with halos (which requires kernels with 2x or 4x the particle width), the user must first call ParticleContainer::copyMaskParticles(AMRMask). If the user does not do this, he will lose mass near the refinement boundaries. Other than that, this function is just like regular particle-mesh deposition. The mesh field should have exactly one component and the quantity to be deposited is fetched from the specified template parameter 'a_particleScalarField'. This should be a pointer to a member function with signature const Real&amp; P::function() const. E.g. if we are depositing mass through a function const Real&amp; P::mass() const we will specifiy</p>
<p><a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit&lt;P, &amp;P::mass&gt;</a> (...)</p>
<p>To deposit a different quantity, simply change the function pointer in the input parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. @πaram[in] a_particles Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When using certain types of coarseFineDeposition methods &ndash; the user may need to fill the mask particles before calling this routine. </dd></dl>

</div>
</div>
<a id="ac4ff2ad7b21f0131730b17c93a6f5843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ff2ad7b21f0131730b17c93a6f5843">&#9670;&nbsp;</a></span>deposit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::deposit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class for deposition of particles of a type P to the mesh. This does scalar quantities. </p>
<p>Just like the version above, except that the function signature is Real P::particleScalarField() const (C++ is not too smart about these things) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. @πaram[in] a_particles Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When using certain types of coarseFineDeposition methods &ndash; the user may need to fill the mask particles before calling this routine. </dd></dl>

</div>
</div>
<a id="ac4ff2ad7b21f0131730b17c93a6f5843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ff2ad7b21f0131730b17c93a6f5843">&#9670;&nbsp;</a></span>deposit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , const RealVect &amp;(P::*)() const particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::deposit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class for deposition of particles of a type P to the mesh. This does vector quantities. </p>
<p>This routine will switch between various algorithms depending on the user input. If the user chooses to deposit with "halos" near the refinement boundaries then this function requires the "halo" particles to be filled before entering this routine. Thus, if depositing with halos (which requires kernels with 2x or 4x the particle width), the user must first call ParticleContainer::copyMaskParticles(AMRMask). If the user does not do this, he will lose mass near the refinement boundaries. Other than that, this function is just like regular particle-mesh deposition. The mesh field should have exactly SpaceDim components and the quantity to be deposited is fetched from the specified template parameter 'a_particleVectorField'. This should be a pointer to a member function with signature const RealVect&amp; P::function() const. E.g. if we are depositing current through a function const RealVect&amp; P::current() const we will specifiy</p>
<p><a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit&lt;P, &amp;P::current&gt;</a> (...)</p>
<p>To deposit a different quantity, simply change the function pointer in the input parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly SpaceDim components. @πaram[in] a_particles Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4ff2ad7b21f0131730b17c93a6f5843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ff2ad7b21f0131730b17c93a6f5843">&#9670;&nbsp;</a></span>deposit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::deposit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class for deposition of particles of a type P to the mesh. This does vector quantities. </p>
<p>Just like the version above, except that the function signature is RealVect P::particleVectorField() const </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly SpaceDim components. @πaram[in] a_particles Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4bf08ea08cb444054dfc09417f113c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bf08ea08cb444054dfc09417f113c7">&#9670;&nbsp;</a></span>depositHalo() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleVectorField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositHalo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "Halo" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user must have filled the "halo" particles for this routine to make any sense. This function will run special deposition routines with 2x or 4x the particle width near the refinement boundaries. </p><dl class="section note"><dt>Note</dt><dd>This routine is currently limited to NGP and CIC. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4bf08ea08cb444054dfc09417f113c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bf08ea08cb444054dfc09417f113c7">&#9670;&nbsp;</a></span>depositHalo() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositHalo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "Halo" algorithm for handling refinement boundaries. </p>
<p>Just like the above version, but with a different function signature. </p><dl class="section note"><dt>Note</dt><dd>This routine is currently limited to NGP and CIC. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4bf08ea08cb444054dfc09417f113c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bf08ea08cb444054dfc09417f113c7">&#9670;&nbsp;</a></span>depositHalo() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , const RealVect &amp;(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositHalo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "Halo" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user must have filled the "halo" particles for this routine to make any sense. This function will run special deposition routines with 2x or 4x the particle width near the refinement boundaries. </p><dl class="section note"><dt>Note</dt><dd>This routine is currently limited to NGP and CIC. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4bf08ea08cb444054dfc09417f113c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bf08ea08cb444054dfc09417f113c7">&#9670;&nbsp;</a></span>depositHalo() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositHalo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "Halo" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user must have filled the "halo" particles for this routine to make any sense. This function will run special deposition routines with 2x or 4x the particle width near the refinement boundaries. </p><dl class="section note"><dt>Note</dt><dd>This routine is currently limited to NGP and CIC. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61924fd4ff7dad8f19cb1dc2757717ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61924fd4ff7dad8f19cb1dc2757717ff">&#9670;&nbsp;</a></span>depositHaloNGP() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleVectorField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositHaloNGP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "HaloNGP" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user must have filled the "halo" particles for this routine to make any sense. This function will deposit as usual, but force the particles on the refinement boundary to be deposited with an NGP scheme. Essentially, this means that the fine grid particles will deposit mass into the coarse grid but the coarse grid particles will NOT deposit mass into the fine grid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61924fd4ff7dad8f19cb1dc2757717ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61924fd4ff7dad8f19cb1dc2757717ff">&#9670;&nbsp;</a></span>depositHaloNGP() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositHaloNGP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "HaloNGP" algorithm for handling refinement boundaries. </p>
<p>Just like the above version, but with a different function signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61924fd4ff7dad8f19cb1dc2757717ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61924fd4ff7dad8f19cb1dc2757717ff">&#9670;&nbsp;</a></span>depositHaloNGP() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , const RealVect &amp;(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositHaloNGP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "HaloNGP" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user must have filled the "halo" particles for this routine to make any sense. This function will deposit as usual, but force the particles on the refinement boundary to be deposited with an NGP scheme. Essentially, this means that the fine grid particles will deposit mass into the coarse grid but the coarse grid particles will NOT deposit mass into the fine grid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61924fd4ff7dad8f19cb1dc2757717ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61924fd4ff7dad8f19cb1dc2757717ff">&#9670;&nbsp;</a></span>depositHaloNGP() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositHaloNGP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "HaloNGP" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user must have filled the "halo" particles for this routine to make any sense. This function will deposit as usual, but force the particles on the refinement boundary to be deposited with an NGP scheme. Essentially, this means that the fine grid particles will deposit mass into the coarse grid but the coarse grid particles will NOT deposit mass into the fine grid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb58633a2caafccf5783980435f9a7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb58633a2caafccf5783980435f9a7cc">&#9670;&nbsp;</a></span>depositPVR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleVectorField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositPVR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "PVR" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user does NOT need to fill the "halo" particles. Rather, the mass that is deposited on the part of the coarse grid that lies underneath the fine grid (i.e., the invalid region) is interpolated to the fine level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb58633a2caafccf5783980435f9a7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb58633a2caafccf5783980435f9a7cc">&#9670;&nbsp;</a></span>depositPVR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositPVR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "PVR" algorithm for handling refinement boundaries. </p>
<p>Just like the above version, but with a different function signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb58633a2caafccf5783980435f9a7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb58633a2caafccf5783980435f9a7cc">&#9670;&nbsp;</a></span>depositPVR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , const RealVect &amp;(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositPVR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "PVR" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user does NOT need to fill the "halo" particles. Rather, the mass that is deposited on the part of the coarse grid that lies underneath the fine grid (i.e., the invalid region) is interpolated to the fine level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb58633a2caafccf5783980435f9a7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb58633a2caafccf5783980435f9a7cc">&#9670;&nbsp;</a></span>depositPVR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::depositPVR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_depositionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the deposit function, but forced to use the "PVR" algorithm for handling refinement boundaries. </p>
<p>See <a class="el" href="classEBAMRParticleMesh.html#ac4ff2ad7b21f0131730b17c93a6f5843" title="Class for deposition of particles of a type P to the mesh. This does scalar quantities.">deposit()</a> for details regarding the template arguments. When calling this routine the user does NOT need to fill the "halo" particles. Rather, the mass that is deposited on the part of the coarse grid that lies underneath the fine grid (i.e., the invalid region) is interpolated to the fine level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_meshData</td><td>Mesh data. Must have exactly one compnent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container. Must be in "usable state" for deposition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionType</td><td>Specification of deposition kernel (e.g., CIC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP deposition in irregular cells or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3405865d0f7ef07a3664e170568e3af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3405865d0f7ef07a3664e170568e3af5">&#9670;&nbsp;</a></span>getEBCoarseFineParticleMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;RefCountedPtr&lt;<a class="el" href="classEBCoarseFineParticleMesh.html">EBCoarseFineParticleMesh</a>&gt; &gt;&amp; EBAMRParticleMesh::getEBCoarseFineParticleMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get buffers for handling deposition over refinement boundaries. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer for handling mass transfer between level lvl and level lvl+1 lives on lvl+1. </dd></dl>

</div>
</div>
<a id="acfca3dfa7af4c8c38cb1f77af66e5015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfca3dfa7af4c8c38cb1f77af66e5015">&#9670;&nbsp;</a></span>getEBParticleMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBParticleMesh.html">EBParticleMesh</a> &amp; EBAMRParticleMesh::getEBParticleMesh </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classEBParticleMesh.html" title="A class for depositing and interpolating particles. Contains various useful routines for interpolatio...">EBParticleMesh</a> deposition/interpolation object for specified grid patch. </p>
<p>This routine is used for when users want to interpolate on a per-patch basis. This is useful when the user has written his interpolation functions on a per-patch basis. I fail to see any other reason where this routine is useful. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a972d83d6fd441d62ca8068a122cbc5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972d83d6fd441d62ca8068a122cbc5fd">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect &amp;(P::*)() particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshVectorField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_interpType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a scalar field onto the particle position. </p>
<p>This is just like regular particle-mesh interpolation. The input field should have exactly one component and the the field will be interpolated onto the template parameter's input field. The template parameter 'particleScalarField' should be a pointer to a member function which will set the particle field. E.g. the function must have a signature Real&amp; P::particleScalarField(). A valid expression is e.g.</p>
<p><a class="el" href="classEBAMRParticleMesh.html#a972d83d6fd441d62ca8068a122cbc5fd" title="Interpolate a scalar field onto the particle position.">interpolate&lt;P, &amp;P::mass&gt;</a> (...)</p>
<p>To interpolate onto a different field, replace ::mass by the other scalar field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be interpolated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_meshScalarField</td><td>Scalar field on the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpType</td><td>Interpolation type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP interpolation in cut-cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a972d83d6fd441d62ca8068a122cbc5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972d83d6fd441d62ca8068a122cbc5fd">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , RealVect &amp;(P::*)() particleVectorField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EBAMRParticleMesh::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_meshVectorField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_interpType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_forceIrregNGP</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector field onto the particle position. </p>
<p>This is just like regular particle-mesh interpolation. The input field should have exactly SpaceDim components and the the field will be interpolated onto the template parameter's input field. The template parameter 'particleVectorField' should be a pointer to a member function which will set the particle field. E.g. the function must have a signature RealVect&amp; P::particleVectorField(). A valid expression is e.g.</p>
<p><a class="el" href="classEBAMRParticleMesh.html#a972d83d6fd441d62ca8068a122cbc5fd" title="Interpolate a scalar field onto the particle position.">interpolate&lt;P, &amp;P::velocity&gt;</a> (...)</p>
<p>To interpolate onto a different field, replace ::velocity by another vector field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be interpolated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_meshScalarField</td><td>Scalar field on the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpType</td><td>Interpolation type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Specification of handling of coarse-fine boundaries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_forceIrregNGP</td><td>Force NGP interpolation in cut-cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5c5b9dff0fa365dbd0b5727b2c7388fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5b9dff0fa365dbd0b5727b2c7388fb">&#9670;&nbsp;</a></span>m_coarseFinePM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;RefCountedPtr&lt;<a class="el" href="classEBCoarseFineParticleMesh.html">EBCoarseFineParticleMesh</a>&gt; &gt; EBAMRParticleMesh::m_coarseFinePM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffers for handling arithmetic for mass moving from coarse to fine level and vice versa. </p>
<dl class="section note"><dt>Note</dt><dd>The buffer for handling mass transfer between level lvl and level lvl+1 lives on lvl+1. </dd></dl>

</div>
</div>
<a id="aef1ac124f7d261d7d87132d14ec231bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1ac124f7d261d7d87132d14ec231bb">&#9670;&nbsp;</a></span>m_ebParticleMeshFiCo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;RefCountedPtr&lt;LayoutData&lt;<a class="el" href="classEBParticleMesh.html">EBParticleMesh</a>&gt; &gt; &gt; EBAMRParticleMesh::m_ebParticleMeshFiCo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Special particle-mesh objects for depositing on the coarsened fine grid. </p>
<p>These are deposition/interpolation objects defined on the refined coarse grid. They are used when we need to deposit coarse-grid particles on the fine grid. </p>

</div>
</div>
<a id="ab72c43fc182e9c5fb6c0b15a607706f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72c43fc182e9c5fb6c0b15a607706f8">&#9670;&nbsp;</a></span>m_levelCopiers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;Copier&gt; EBAMRParticleMesh::m_levelCopiers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copier for moving data from valid+ghost to valid on each AMR level. </p>
<dl class="section note"><dt>Note</dt><dd>After depositing on a level, this is used in order to add data from the ghost cells to the valid region. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/Particle/<a class="el" href="CD__EBAMRParticleMesh_8H_source.html">CD_EBAMRParticleMesh.H</a></li>
<li>Source/Particle/<a class="el" href="CD__EBAMRParticleMesh_8cpp.html">CD_EBAMRParticleMesh.cpp</a></li>
<li>Source/Particle/<a class="el" href="CD__EBAMRParticleMeshImplem_8H_source.html">CD_EBAMRParticleMeshImplem.H</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
