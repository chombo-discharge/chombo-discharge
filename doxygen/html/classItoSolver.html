<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: ItoSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classItoSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ItoSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for Ito diffusion particle models.  
 <a href="classItoSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__ItoSolver_8H_source.html">CD_ItoSolver.H</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ItoSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classItoSolver__coll__graph.png" border="0" usemap="#ItoSolver_coll__map" alt="Collaboration graph"/></div>
<map name="ItoSolver_coll__map" id="ItoSolver_coll__map">
<area shape="rect" title="Base class for Ito diffusion particle models." alt="" coords="294,168,374,195"/>
<area shape="rect" href="classItoMerge_1_1Tree.html" title=" " alt="" coords="5,13,217,39"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="242,5,426,47"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="451,13,647,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a070d75d0d3ac16e04013d25574c1ffa5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> { <br />
&#160;&#160;<b>Bulk</b>, 
<b>EB</b>, 
<b>Domain</b>, 
<b>Source</b>, 
<br />
&#160;&#160;<b>Covered</b>, 
<b>Scratch</b>
<br />
 }</td></tr>
<tr class="memdesc:a070d75d0d3ac16e04013d25574c1ffa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum class for distinguishing various types of particle containers.  <a href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">More...</a><br /></td></tr>
<tr class="separator:a070d75d0d3ac16e04013d25574c1ffa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69dd704c975e14f67548ccb2433e7c46"><td class="memItemLeft" align="right" valign="top"><a id="a69dd704c975e14f67548ccb2433e7c46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a69dd704c975e14f67548ccb2433e7c46">ItoSolver</a> ()</td></tr>
<tr class="memdesc:a69dd704c975e14f67548ccb2433e7c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor &ndash; user must subsequently set the realm and, parse class options, set the species etc. <br /></td></tr>
<tr class="separator:a69dd704c975e14f67548ccb2433e7c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d05094e1614798857464ab8bc7f728"><td class="memItemLeft" align="right" valign="top"><a id="a73d05094e1614798857464ab8bc7f728"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a73d05094e1614798857464ab8bc7f728">~ItoSolver</a> ()</td></tr>
<tr class="memdesc:a73d05094e1614798857464ab8bc7f728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (does nothing). <br /></td></tr>
<tr class="separator:a73d05094e1614798857464ab8bc7f728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6fcdccd99f9369d87b8e74646f0296"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6e6fcdccd99f9369d87b8e74646f0296">getName</a> () const</td></tr>
<tr class="memdesc:a6e6fcdccd99f9369d87b8e74646f0296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this solver's name.  <a href="classItoSolver.html#a6e6fcdccd99f9369d87b8e74646f0296">More...</a><br /></td></tr>
<tr class="separator:a6e6fcdccd99f9369d87b8e74646f0296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa314653552338b3a526f5241bf874f0d"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa314653552338b3a526f5241bf874f0d">getRealm</a> () const</td></tr>
<tr class="memdesc:aa314653552338b3a526f5241bf874f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the realm where this solver is registered.  <a href="classItoSolver.html#aa314653552338b3a526f5241bf874f0d">More...</a><br /></td></tr>
<tr class="separator:aa314653552338b3a526f5241bf874f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953bd44ffab98bb2b7e408194339aeca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a953bd44ffab98bb2b7e408194339aeca">setRealm</a> (const std::string a_realm)</td></tr>
<tr class="memdesc:a953bd44ffab98bb2b7e408194339aeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the realm where this solver will live.  <a href="classItoSolver.html#a953bd44ffab98bb2b7e408194339aeca">More...</a><br /></td></tr>
<tr class="separator:a953bd44ffab98bb2b7e408194339aeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b96f5194246f130a4612b027884a020"><td class="memItemLeft" align="right" valign="top"><a id="a5b96f5194246f130a4612b027884a020"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5b96f5194246f130a4612b027884a020">parseOptions</a> ()</td></tr>
<tr class="memdesc:a5b96f5194246f130a4612b027884a020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse class options. <br /></td></tr>
<tr class="separator:a5b96f5194246f130a4612b027884a020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd193ec875bfd612861cd833cd28fce4"><td class="memItemLeft" align="right" valign="top"><a id="abd193ec875bfd612861cd833cd28fce4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abd193ec875bfd612861cd833cd28fce4">parseRuntimeOptions</a> ()</td></tr>
<tr class="memdesc:abd193ec875bfd612861cd833cd28fce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse class runtime configurable options. <br /></td></tr>
<tr class="separator:abd193ec875bfd612861cd833cd28fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113c01d977f92e8048729f259cf32b81"><td class="memItemLeft" align="right" valign="top">virtual Vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a113c01d977f92e8048729f259cf32b81">getPlotVariableNames</a> () const</td></tr>
<tr class="memdesc:a113c01d977f92e8048729f259cf32b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output plot names.  <a href="classItoSolver.html#a113c01d977f92e8048729f259cf32b81">More...</a><br /></td></tr>
<tr class="separator:a113c01d977f92e8048729f259cf32b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc86cb62b622c8ddfd0b7fb1601afda7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abc86cb62b622c8ddfd0b7fb1601afda7">initialData</a> ()</td></tr>
<tr class="memdesc:abc86cb62b622c8ddfd0b7fb1601afda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial data.  <a href="classItoSolver.html#abc86cb62b622c8ddfd0b7fb1601afda7">More...</a><br /></td></tr>
<tr class="separator:abc86cb62b622c8ddfd0b7fb1601afda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec90d5f802b40a624d7aa0be36a6f6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2ec90d5f802b40a624d7aa0be36a6f6d">regrid</a> (const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel)</td></tr>
<tr class="memdesc:a2ec90d5f802b40a624d7aa0be36a6f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid this solver.  <a href="classItoSolver.html#a2ec90d5f802b40a624d7aa0be36a6f6d">More...</a><br /></td></tr>
<tr class="separator:a2ec90d5f802b40a624d7aa0be36a6f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53e954337a6c4fdb8a84ce9f71760c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad53e954337a6c4fdb8a84ce9f71760c0">allocateInternals</a> ()</td></tr>
<tr class="memdesc:ad53e954337a6c4fdb8a84ce9f71760c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate internal storage.  <a href="classItoSolver.html#ad53e954337a6c4fdb8a84ce9f71760c0">More...</a><br /></td></tr>
<tr class="separator:ad53e954337a6c4fdb8a84ce9f71760c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10a4355f45e56bd7b5a971b1173db1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad10a4355f45e56bd7b5a971b1173db1d">clear</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:ad10a4355f45e56bd7b5a971b1173db1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a particle container &ndash; this will delete all the particles in the input container.  <a href="classItoSolver.html#ad10a4355f45e56bd7b5a971b1173db1d">More...</a><br /></td></tr>
<tr class="separator:ad10a4355f45e56bd7b5a971b1173db1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5766b96846e5e5f1b152e42aa752dd53"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5766b96846e5e5f1b152e42aa752dd53">clear</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a5766b96846e5e5f1b152e42aa752dd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a particle container &ndash; this will delete all the particles in the input container.  <a href="classItoSolver.html#a5766b96846e5e5f1b152e42aa752dd53">More...</a><br /></td></tr>
<tr class="separator:a5766b96846e5e5f1b152e42aa752dd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fee60a86508b6ce121dea757f6a3144"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6fee60a86508b6ce121dea757f6a3144">clear</a> (<a class="el" href="CD__ParticleContainer_8H.html#a1c6735e2399c488ebf37f5e96aea95c3">AMRParticles</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a6fee60a86508b6ce121dea757f6a3144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear particles &ndash; this will deleted all the particles in the input container.  <a href="classItoSolver.html#a6fee60a86508b6ce121dea757f6a3144">More...</a><br /></td></tr>
<tr class="separator:a6fee60a86508b6ce121dea757f6a3144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfc0f7ef17ef6e11187ea8bee622fdf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2cfc0f7ef17ef6e11187ea8bee622fdf">depositConductivity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a2cfc0f7ef17ef6e11187ea8bee622fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit conductivities (i.e. mass*mobility / volume)  <a href="classItoSolver.html#a2cfc0f7ef17ef6e11187ea8bee622fdf">More...</a><br /></td></tr>
<tr class="separator:a2cfc0f7ef17ef6e11187ea8bee622fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87309b80ec7dec1b74b1626ca2f4d700"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a87309b80ec7dec1b74b1626ca2f4d700">depositConductivity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition) const</td></tr>
<tr class="memdesc:a87309b80ec7dec1b74b1626ca2f4d700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit conductivities (i.e. mass*mobility / volume)  <a href="classItoSolver.html#a87309b80ec7dec1b74b1626ca2f4d700">More...</a><br /></td></tr>
<tr class="separator:a87309b80ec7dec1b74b1626ca2f4d700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce12aab2e784f8ccaf8c316513c7623"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0ce12aab2e784f8ccaf8c316513c7623">depositDiffusivity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a0ce12aab2e784f8ccaf8c316513c7623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit diffusivity (i.e. mass*D/volume)  <a href="classItoSolver.html#a0ce12aab2e784f8ccaf8c316513c7623">More...</a><br /></td></tr>
<tr class="separator:a0ce12aab2e784f8ccaf8c316513c7623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d1a25cbe12b84279f9a86911ab1019"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a13d1a25cbe12b84279f9a86911ab1019">depositDiffusivity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition) const</td></tr>
<tr class="memdesc:a13d1a25cbe12b84279f9a86911ab1019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit diffusivity (i.e. mass*D/volume)  <a href="classItoSolver.html#a13d1a25cbe12b84279f9a86911ab1019">More...</a><br /></td></tr>
<tr class="separator:a13d1a25cbe12b84279f9a86911ab1019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cfd08a3c53d5c4104665d8e1646ce3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a33cfd08a3c53d5c4104665d8e1646ce3">depositEnergyDensity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a33cfd08a3c53d5c4104665d8e1646ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit energy densities (i.e. mass*energy/volume =&gt; total energy per unit volume)  <a href="classItoSolver.html#a33cfd08a3c53d5c4104665d8e1646ce3">More...</a><br /></td></tr>
<tr class="separator:a33cfd08a3c53d5c4104665d8e1646ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30867cb13ca546b8729ee29db273ac9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa30867cb13ca546b8729ee29db273ac9">depositEnergyDensity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition) const</td></tr>
<tr class="memdesc:aa30867cb13ca546b8729ee29db273ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit energy densities (i.e. mass*energy/volume =&gt; total energy per unit volume)  <a href="classItoSolver.html#aa30867cb13ca546b8729ee29db273ac9">More...</a><br /></td></tr>
<tr class="separator:aa30867cb13ca546b8729ee29db273ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822e0c67d9f19c88a1959d07e8c8b4f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a822e0c67d9f19c88a1959d07e8c8b4f2">computeAverageMobility</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a822e0c67d9f19c88a1959d07e8c8b4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute average mobility.  <a href="classItoSolver.html#a822e0c67d9f19c88a1959d07e8c8b4f2">More...</a><br /></td></tr>
<tr class="separator:a822e0c67d9f19c88a1959d07e8c8b4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2d8c9dd1664655f32cf424f5519316"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aac2d8c9dd1664655f32cf424f5519316">computeAverageDiffusion</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:aac2d8c9dd1664655f32cf424f5519316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute average diffusion coefficient.  <a href="classItoSolver.html#aac2d8c9dd1664655f32cf424f5519316">More...</a><br /></td></tr>
<tr class="separator:aac2d8c9dd1664655f32cf424f5519316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4ccc50baf7d8feff3912509de45dff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2e4ccc50baf7d8feff3912509de45dff">computeAverageEnergy</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a2e4ccc50baf7d8feff3912509de45dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute average particle energy..  <a href="classItoSolver.html#a2e4ccc50baf7d8feff3912509de45dff">More...</a><br /></td></tr>
<tr class="separator:a2e4ccc50baf7d8feff3912509de45dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a43e827b7b8e1776cf9e4572ccf6a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a18a43e827b7b8e1776cf9e4572ccf6a0">depositParticles</a> ()</td></tr>
<tr class="memdesc:a18a43e827b7b8e1776cf9e4572ccf6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit particles onto mesh.  <a href="classItoSolver.html#a18a43e827b7b8e1776cf9e4572ccf6a0">More...</a><br /></td></tr>
<tr class="separator:a18a43e827b7b8e1776cf9e4572ccf6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fa3e39b93d9f4abf3c8ca352c61d02"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a83fa3e39b93d9f4abf3c8ca352c61d02">depositParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a83fa3e39b93d9f4abf3c8ca352c61d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit particles on to mesh.  <a href="classItoSolver.html#a83fa3e39b93d9f4abf3c8ca352c61d02">More...</a><br /></td></tr>
<tr class="separator:a83fa3e39b93d9f4abf3c8ca352c61d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f62e0f408437165ecd79bd061d6612"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a28f62e0f408437165ecd79bd061d6612"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a28f62e0f408437165ecd79bd061d6612">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition) const</td></tr>
<tr class="memdesc:a28f62e0f408437165ecd79bd061d6612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic deposition function which deposits a particle field onto the mesh using a specified deposition method.  <a href="classItoSolver.html#a28f62e0f408437165ecd79bd061d6612">More...</a><br /></td></tr>
<tr class="separator:a28f62e0f408437165ecd79bd061d6612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f62e0f408437165ecd79bd061d6612"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a28f62e0f408437165ecd79bd061d6612"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a28f62e0f408437165ecd79bd061d6612">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition) const</td></tr>
<tr class="memdesc:a28f62e0f408437165ecd79bd061d6612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic deposition function which deposits a particle field onto the mesh using a specified deposition method.  <a href="classItoSolver.html#a28f62e0f408437165ecd79bd061d6612">More...</a><br /></td></tr>
<tr class="separator:a28f62e0f408437165ecd79bd061d6612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1478e53aa80da3b4ef0e4e6c779accf3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1478e53aa80da3b4ef0e4e6c779accf3">removeCoveredParticles</a> (const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a> a_representation, const Real a_tol)</td></tr>
<tr class="memdesc:a1478e53aa80da3b4ef0e4e6c779accf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove particles that are inside the EB.  <a href="classItoSolver.html#a1478e53aa80da3b4ef0e4e6c779accf3">More...</a><br /></td></tr>
<tr class="separator:a1478e53aa80da3b4ef0e4e6c779accf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0cfd8c327d593f16ee71d546cccdf8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acf0cfd8c327d593f16ee71d546cccdf8">removeCoveredParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a> a_representation, const Real a_tol)</td></tr>
<tr class="memdesc:acf0cfd8c327d593f16ee71d546cccdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove particles that are inside the EB.  <a href="classItoSolver.html#acf0cfd8c327d593f16ee71d546cccdf8">More...</a><br /></td></tr>
<tr class="separator:acf0cfd8c327d593f16ee71d546cccdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972f24cc11dc2d60cbfc83f86be683dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a972f24cc11dc2d60cbfc83f86be683dc">removeCoveredParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a> a_representation, const Real a_tol) const</td></tr>
<tr class="memdesc:a972f24cc11dc2d60cbfc83f86be683dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove particles that are inside the EB.  <a href="classItoSolver.html#a972f24cc11dc2d60cbfc83f86be683dc">More...</a><br /></td></tr>
<tr class="separator:a972f24cc11dc2d60cbfc83f86be683dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eea2667b22bfdcb91c27e3349932cce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0eea2667b22bfdcb91c27e3349932cce">transferCoveredParticles</a> (const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a> a_representation, const Real a_tol)</td></tr>
<tr class="memdesc:a0eea2667b22bfdcb91c27e3349932cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer particles that are covered (within a_tol distance from EB) to another container.  <a href="classItoSolver.html#a0eea2667b22bfdcb91c27e3349932cce">More...</a><br /></td></tr>
<tr class="separator:a0eea2667b22bfdcb91c27e3349932cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13019b6687845c7e626313b9dc51b59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#af13019b6687845c7e626313b9dc51b59">transferCoveredParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_containerFrom, const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_containerTo, const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a> a_representation, const Real a_tol)</td></tr>
<tr class="memdesc:af13019b6687845c7e626313b9dc51b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer particles that are covered (within a_tol distance from EB) to another container.  <a href="classItoSolver.html#af13019b6687845c7e626313b9dc51b59">More...</a><br /></td></tr>
<tr class="separator:af13019b6687845c7e626313b9dc51b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17e9facf86e62b4693736a31efeedb2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac17e9facf86e62b4693736a31efeedb2">transferCoveredParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particlesFrom, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particlesTo, const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a> a_representation, const Real a_tol) const</td></tr>
<tr class="memdesc:ac17e9facf86e62b4693736a31efeedb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer particles that are inside the EB to another container.  <a href="classItoSolver.html#ac17e9facf86e62b4693736a31efeedb2">More...</a><br /></td></tr>
<tr class="separator:ac17e9facf86e62b4693736a31efeedb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71390b209f25e33c1a8286f846f215ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a71390b209f25e33c1a8286f846f215ab">intersectParticles</a> (const <a class="el" href="CD__EbIntersection_8H.html#a187992258b18205389b013d6dd06e804">EbIntersection</a> a_ebIntersection, const bool a_deleteParticles)</td></tr>
<tr class="memdesc:a71390b209f25e33c1a8286f846f215ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do boundary intersection tests.  <a href="classItoSolver.html#a71390b209f25e33c1a8286f846f215ab">More...</a><br /></td></tr>
<tr class="separator:a71390b209f25e33c1a8286f846f215ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474240bfb7066826513828984aff09ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a474240bfb7066826513828984aff09ae">intersectParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_particles, const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_ebParticles, const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_domainParticles, const <a class="el" href="CD__EbIntersection_8H.html#a187992258b18205389b013d6dd06e804">EbIntersection</a> a_ebIntersection, const bool a_deleteParticles)</td></tr>
<tr class="memdesc:a474240bfb7066826513828984aff09ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do boundary intersection tests.  <a href="classItoSolver.html#a474240bfb7066826513828984aff09ae">More...</a><br /></td></tr>
<tr class="separator:a474240bfb7066826513828984aff09ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507e376a5b3a88d281a6144952b6b2f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a507e376a5b3a88d281a6144952b6b2f9">intersectParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_ebParticles, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_domainParticles, const <a class="el" href="CD__EbIntersection_8H.html#a187992258b18205389b013d6dd06e804">EbIntersection</a> a_ebIntersection, const bool a_deleteParticles)</td></tr>
<tr class="memdesc:a507e376a5b3a88d281a6144952b6b2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do boundary intersection tests.  <a href="classItoSolver.html#a507e376a5b3a88d281a6144952b6b2f9">More...</a><br /></td></tr>
<tr class="separator:a507e376a5b3a88d281a6144952b6b2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dd656605d24d6171dd291bb20ab7d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac4dd656605d24d6171dd291bb20ab7d4">computeLoads</a> (Vector&lt; long int &gt; &amp;a_loads, const DisjointBoxLayout &amp;a_dbl, const int a_level)</td></tr>
<tr class="memdesc:ac4dd656605d24d6171dd291bb20ab7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute particle load on a specific grid level &ndash; this will compute the number of particles in each box in the input grids.  <a href="classItoSolver.html#ac4dd656605d24d6171dd291bb20ab7d4">More...</a><br /></td></tr>
<tr class="separator:ac4dd656605d24d6171dd291bb20ab7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0938b394aa25ddeac394ecce5d2b474"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad0938b394aa25ddeac394ecce5d2b474">getNumberOfPlotVariables</a> () const</td></tr>
<tr class="memdesc:ad0938b394aa25ddeac394ecce5d2b474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of plot variables.  <a href="classItoSolver.html#ad0938b394aa25ddeac394ecce5d2b474">More...</a><br /></td></tr>
<tr class="separator:ad0938b394aa25ddeac394ecce5d2b474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815471c6b6c7e1aeb636aab2ea0e3877"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a815471c6b6c7e1aeb636aab2ea0e3877">getPVRBuffer</a> () const</td></tr>
<tr class="memdesc:a815471c6b6c7e1aeb636aab2ea0e3877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PVR buffer.  <a href="classItoSolver.html#a815471c6b6c7e1aeb636aab2ea0e3877">More...</a><br /></td></tr>
<tr class="separator:a815471c6b6c7e1aeb636aab2ea0e3877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6982f82df0a04d2f325f1e84899a37"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1f6982f82df0a04d2f325f1e84899a37">getHaloBuffer</a> () const</td></tr>
<tr class="memdesc:a1f6982f82df0a04d2f325f1e84899a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the halo buffer.  <a href="classItoSolver.html#a1f6982f82df0a04d2f325f1e84899a37">More...</a><br /></td></tr>
<tr class="separator:a1f6982f82df0a04d2f325f1e84899a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6369581fd075bc1688c1a3838328b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afd6369581fd075bc1688c1a3838328b6">setPVRBuffer</a> (const int a_pvrBuffer)</td></tr>
<tr class="memdesc:afd6369581fd075bc1688c1a3838328b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PVR buffer.  <a href="classItoSolver.html#afd6369581fd075bc1688c1a3838328b6">More...</a><br /></td></tr>
<tr class="separator:afd6369581fd075bc1688c1a3838328b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b64ad1b376afd86ef2e3a1f8c7d02f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5b64ad1b376afd86ef2e3a1f8c7d02f0">setHaloBuffer</a> (const int a_haloBuffer)</td></tr>
<tr class="memdesc:a5b64ad1b376afd86ef2e3a1f8c7d02f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the halo buffer.  <a href="classItoSolver.html#a5b64ad1b376afd86ef2e3a1f8c7d02f0">More...</a><br /></td></tr>
<tr class="separator:a5b64ad1b376afd86ef2e3a1f8c7d02f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cdb1b9e287c948e6b1c6ad1c0e0709"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#af0cdb1b9e287c948e6b1c6ad1c0e0709">getNumParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const bool a_localOnly) const</td></tr>
<tr class="memdesc:af0cdb1b9e287c948e6b1c6ad1c0e0709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of particles in a specified particle container.  <a href="classItoSolver.html#af0cdb1b9e287c948e6b1c6ad1c0e0709">More...</a><br /></td></tr>
<tr class="separator:af0cdb1b9e287c948e6b1c6ad1c0e0709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174efc0134a7417f1afa737b8f328d16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a174efc0134a7417f1afa737b8f328d16">registerOperators</a> () const</td></tr>
<tr class="memdesc:a174efc0134a7417f1afa737b8f328d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register operators.  <a href="classItoSolver.html#a174efc0134a7417f1afa737b8f328d16">More...</a><br /></td></tr>
<tr class="separator:a174efc0134a7417f1afa737b8f328d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3174bdfc77666ce0d0a7a46876389365"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a3174bdfc77666ce0d0a7a46876389365">setComputationalGeometry</a> (const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; &amp;a_computationalGeometry)</td></tr>
<tr class="memdesc:a3174bdfc77666ce0d0a7a46876389365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set computational geometry.  <a href="classItoSolver.html#a3174bdfc77666ce0d0a7a46876389365">More...</a><br /></td></tr>
<tr class="separator:a3174bdfc77666ce0d0a7a46876389365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351676445e519924a3054b8433c30001"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a351676445e519924a3054b8433c30001">setAmr</a> (const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;a_amr)</td></tr>
<tr class="memdesc:a351676445e519924a3054b8433c30001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations for streamer equations.">AmrMesh</a> object.  <a href="classItoSolver.html#a351676445e519924a3054b8433c30001">More...</a><br /></td></tr>
<tr class="separator:a351676445e519924a3054b8433c30001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6b0c77343a02439242f7b9a84949bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8b6b0c77343a02439242f7b9a84949bf">setPhase</a> (const phase::which_phase a_phase)</td></tr>
<tr class="memdesc:a8b6b0c77343a02439242f7b9a84949bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set phase where the particles will live.  <a href="classItoSolver.html#a8b6b0c77343a02439242f7b9a84949bf">More...</a><br /></td></tr>
<tr class="separator:a8b6b0c77343a02439242f7b9a84949bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa01f68543f9b94f9d083ce3e3ed0339"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aaa01f68543f9b94f9d083ce3e3ed0339">setVerbosity</a> (const int a_verbosity)</td></tr>
<tr class="memdesc:aaa01f68543f9b94f9d083ce3e3ed0339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set verbosity level for this solver.  <a href="classItoSolver.html#aaa01f68543f9b94f9d083ce3e3ed0339">More...</a><br /></td></tr>
<tr class="separator:aaa01f68543f9b94f9d083ce3e3ed0339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2293d2a6db7b36a451100e2e8400698f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2293d2a6db7b36a451100e2e8400698f">setTime</a> (const int a_step, const Real a_time, const Real a_dt)</td></tr>
<tr class="memdesc:a2293d2a6db7b36a451100e2e8400698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time for this solver.  <a href="classItoSolver.html#a2293d2a6db7b36a451100e2e8400698f">More...</a><br /></td></tr>
<tr class="separator:a2293d2a6db7b36a451100e2e8400698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a5eb61b52bbec09e4bf33427855484"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab3a5eb61b52bbec09e4bf33427855484">writePlotData</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_output, int &amp;a_comp) const</td></tr>
<tr class="memdesc:ab3a5eb61b52bbec09e4bf33427855484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write plot data.  <a href="classItoSolver.html#ab3a5eb61b52bbec09e4bf33427855484">More...</a><br /></td></tr>
<tr class="separator:ab3a5eb61b52bbec09e4bf33427855484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134feb52bf6e0fdb4b0b25cd76b4ef91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a134feb52bf6e0fdb4b0b25cd76b4ef91">setSpecies</a> (const RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt; &amp;a_species)</td></tr>
<tr class="memdesc:a134feb52bf6e0fdb4b0b25cd76b4ef91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the species.  <a href="classItoSolver.html#a134feb52bf6e0fdb4b0b25cd76b4ef91">More...</a><br /></td></tr>
<tr class="separator:a134feb52bf6e0fdb4b0b25cd76b4ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eb3e95dfee2010652368ce894bda9d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a30eb3e95dfee2010652368ce894bda9d">preRegrid</a> (const int a_lbase, const int a_oldFinestLevel)</td></tr>
<tr class="memdesc:a30eb3e95dfee2010652368ce894bda9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pre-regrid operations.  <a href="classItoSolver.html#a30eb3e95dfee2010652368ce894bda9d">More...</a><br /></td></tr>
<tr class="separator:a30eb3e95dfee2010652368ce894bda9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630057bd092fce7fb72044a628459af"><td class="memTemplParams" colspan="2">template&lt;ItoSolver::WhichContainer C = WhichContainer::Bulk&gt; </td></tr>
<tr class="memitem:a9630057bd092fce7fb72044a628459af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a9630057bd092fce7fb72044a628459af">addParticles</a> (ListBox&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_inputParticles, const int a_lvl, const DataIndex a_dit, const bool a_destructive)</td></tr>
<tr class="memdesc:a9630057bd092fce7fb72044a628459af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add particles to a contain. This adds into a specific grid level and patch. The user can delete the input particles.  <a href="classItoSolver.html#a9630057bd092fce7fb72044a628459af">More...</a><br /></td></tr>
<tr class="separator:a9630057bd092fce7fb72044a628459af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8967ce2dec5194a8d54e0dd7e4acec08"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8967ce2dec5194a8d54e0dd7e4acec08">isMobile</a> () const</td></tr>
<tr class="memdesc:a8967ce2dec5194a8d54e0dd7e4acec08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if solver is mobile.  <a href="classItoSolver.html#a8967ce2dec5194a8d54e0dd7e4acec08">More...</a><br /></td></tr>
<tr class="separator:a8967ce2dec5194a8d54e0dd7e4acec08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1db74cb60c15142ce2729deb9179a31"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae1db74cb60c15142ce2729deb9179a31">isDiffusive</a> () const</td></tr>
<tr class="memdesc:ae1db74cb60c15142ce2729deb9179a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if solver is diffusive.  <a href="classItoSolver.html#ae1db74cb60c15142ce2729deb9179a31">More...</a><br /></td></tr>
<tr class="separator:ae1db74cb60c15142ce2729deb9179a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754df1d59ab75675768b1fdba4ce759a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a754df1d59ab75675768b1fdba4ce759a">getParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a754df1d59ab75675768b1fdba4ce759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a general particle container.  <a href="classItoSolver.html#a754df1d59ab75675768b1fdba4ce759a">More...</a><br /></td></tr>
<tr class="separator:a754df1d59ab75675768b1fdba4ce759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b5921e65afb1442dc9a71ef2c83d55"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a83b5921e65afb1442dc9a71ef2c83d55">getParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container) const</td></tr>
<tr class="memdesc:a83b5921e65afb1442dc9a71ef2c83d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a general particle container.  <a href="classItoSolver.html#a83b5921e65afb1442dc9a71ef2c83d55">More...</a><br /></td></tr>
<tr class="separator:a83b5921e65afb1442dc9a71ef2c83d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab7ee2c7496bdad4c5331b4ccf84952"><td class="memItemLeft" align="right" valign="top">virtual const RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acab7ee2c7496bdad4c5331b4ccf84952">getSpecies</a> () const</td></tr>
<tr class="memdesc:acab7ee2c7496bdad4c5331b4ccf84952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the species.  <a href="classItoSolver.html#acab7ee2c7496bdad4c5331b4ccf84952">More...</a><br /></td></tr>
<tr class="separator:acab7ee2c7496bdad4c5331b4ccf84952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa426b09943223c61f0a9a5c51ddb8822"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa426b09943223c61f0a9a5c51ddb8822">getPhi</a> ()</td></tr>
<tr class="memdesc:aa426b09943223c61f0a9a5c51ddb8822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mesh data.  <a href="classItoSolver.html#aa426b09943223c61f0a9a5c51ddb8822">More...</a><br /></td></tr>
<tr class="separator:aa426b09943223c61f0a9a5c51ddb8822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5321417dad2ee4db572060f86421a7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae5321417dad2ee4db572060f86421a7a">getVelocityFunction</a> ()</td></tr>
<tr class="memdesc:ae5321417dad2ee4db572060f86421a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cell-centered velocity mesh data.  <a href="classItoSolver.html#ae5321417dad2ee4db572060f86421a7a">More...</a><br /></td></tr>
<tr class="separator:ae5321417dad2ee4db572060f86421a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe09b54f8bbf8db61b86e8be2e3d1508"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abe09b54f8bbf8db61b86e8be2e3d1508">getVelocityFunction</a> () const</td></tr>
<tr class="memdesc:abe09b54f8bbf8db61b86e8be2e3d1508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cell-centered velocity mesh data.  <a href="classItoSolver.html#abe09b54f8bbf8db61b86e8be2e3d1508">More...</a><br /></td></tr>
<tr class="separator:abe09b54f8bbf8db61b86e8be2e3d1508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb760819f334c0b3af7535108b7366d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#adb760819f334c0b3af7535108b7366d0">getDiffusionFunction</a> ()</td></tr>
<tr class="memdesc:adb760819f334c0b3af7535108b7366d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diffusion function.  <a href="classItoSolver.html#adb760819f334c0b3af7535108b7366d0">More...</a><br /></td></tr>
<tr class="separator:adb760819f334c0b3af7535108b7366d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c71c977fb7130e83a8d557817dea6b"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad9c71c977fb7130e83a8d557817dea6b">getDiffusionFunction</a> () const</td></tr>
<tr class="memdesc:ad9c71c977fb7130e83a8d557817dea6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diffusion function.  <a href="classItoSolver.html#ad9c71c977fb7130e83a8d557817dea6b">More...</a><br /></td></tr>
<tr class="separator:ad9c71c977fb7130e83a8d557817dea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca0e379935bc11a7bf6bd2be06f8b05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1ca0e379935bc11a7bf6bd2be06f8b05">getScratch</a> ()</td></tr>
<tr class="memdesc:a1ca0e379935bc11a7bf6bd2be06f8b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scratch storage.  <a href="classItoSolver.html#a1ca0e379935bc11a7bf6bd2be06f8b05">More...</a><br /></td></tr>
<tr class="separator:a1ca0e379935bc11a7bf6bd2be06f8b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa4cde66efccaa860a1c1fe4bf3db78"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acaa4cde66efccaa860a1c1fe4bf3db78">getScratch</a> () const</td></tr>
<tr class="memdesc:acaa4cde66efccaa860a1c1fe4bf3db78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scratch storage.  <a href="classItoSolver.html#acaa4cde66efccaa860a1c1fe4bf3db78">More...</a><br /></td></tr>
<tr class="separator:acaa4cde66efccaa860a1c1fe4bf3db78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5ad3bcb9a19cd08ae6c3172cfa43d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aef5ad3bcb9a19cd08ae6c3172cfa43d0">getMobilityFunction</a> ()</td></tr>
<tr class="memdesc:aef5ad3bcb9a19cd08ae6c3172cfa43d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mobility function.  <a href="classItoSolver.html#aef5ad3bcb9a19cd08ae6c3172cfa43d0">More...</a><br /></td></tr>
<tr class="separator:aef5ad3bcb9a19cd08ae6c3172cfa43d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a6184b2efe0c515f0782438f1ce874"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a67a6184b2efe0c515f0782438f1ce874">getMobilityFunction</a> () const</td></tr>
<tr class="memdesc:a67a6184b2efe0c515f0782438f1ce874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mobility function.  <a href="classItoSolver.html#a67a6184b2efe0c515f0782438f1ce874">More...</a><br /></td></tr>
<tr class="separator:a67a6184b2efe0c515f0782438f1ce874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4426b5a48a8530afb511bec40f6b718"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab4426b5a48a8530afb511bec40f6b718">setDiffusionFunction</a> (const Real a_diffusionCoefficient)</td></tr>
<tr class="memdesc:ab4426b5a48a8530afb511bec40f6b718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function &ndash; set a constant diffusion coefficient.  <a href="classItoSolver.html#ab4426b5a48a8530afb511bec40f6b718">More...</a><br /></td></tr>
<tr class="separator:ab4426b5a48a8530afb511bec40f6b718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f6cbb8805b459df5a6bcbcb0ff06ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae8f6cbb8805b459df5a6bcbcb0ff06ea">setVelocityFunction</a> (const RealVect a_velocity)</td></tr>
<tr class="memdesc:ae8f6cbb8805b459df5a6bcbcb0ff06ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function &ndash; set a constant velocity.  <a href="classItoSolver.html#ae8f6cbb8805b459df5a6bcbcb0ff06ea">More...</a><br /></td></tr>
<tr class="separator:ae8f6cbb8805b459df5a6bcbcb0ff06ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429895a5e10f6830cc6160654684f6e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a429895a5e10f6830cc6160654684f6e2">setParticleMobility</a> (const Real a_mobility)</td></tr>
<tr class="memdesc:a429895a5e10f6830cc6160654684f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets mobility coefficient for all particles.  <a href="classItoSolver.html#a429895a5e10f6830cc6160654684f6e2">More...</a><br /></td></tr>
<tr class="separator:a429895a5e10f6830cc6160654684f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b76fa27520cfcf6b20bc2115cd2c18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a79b76fa27520cfcf6b20bc2115cd2c18">setParticleDiffusion</a> (const Real a_diffusion)</td></tr>
<tr class="memdesc:a79b76fa27520cfcf6b20bc2115cd2c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets diffusion coefficient for all particles.  <a href="classItoSolver.html#a79b76fa27520cfcf6b20bc2115cd2c18">More...</a><br /></td></tr>
<tr class="separator:a79b76fa27520cfcf6b20bc2115cd2c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a6d5963c8a82dca1aa2868e0988b75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a58a6d5963c8a82dca1aa2868e0988b75">interpolateVelocities</a> ()</td></tr>
<tr class="memdesc:a58a6d5963c8a82dca1aa2868e0988b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the particle velocities.  <a href="classItoSolver.html#a58a6d5963c8a82dca1aa2868e0988b75">More...</a><br /></td></tr>
<tr class="separator:a58a6d5963c8a82dca1aa2868e0988b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f927ad3700a86bb8eaabb11912f81a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4f927ad3700a86bb8eaabb11912f81a9">interpolateVelocities</a> (const int a_level, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:a4f927ad3700a86bb8eaabb11912f81a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the particle velocities.  <a href="classItoSolver.html#a4f927ad3700a86bb8eaabb11912f81a9">More...</a><br /></td></tr>
<tr class="separator:a4f927ad3700a86bb8eaabb11912f81a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df3eb32ebb71b1858298b2b0d7dd0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a06df3eb32ebb71b1858298b2b0d7dd0b">interpolateMobilities</a> ()</td></tr>
<tr class="memdesc:a06df3eb32ebb71b1858298b2b0d7dd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate mobilities.  <a href="classItoSolver.html#a06df3eb32ebb71b1858298b2b0d7dd0b">More...</a><br /></td></tr>
<tr class="separator:a06df3eb32ebb71b1858298b2b0d7dd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6615c33886b26c602e0908b6069a1e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afe6615c33886b26c602e0908b6069a1e">interpolateMobilities</a> (const int a_level, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:afe6615c33886b26c602e0908b6069a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate mobilities &ndash; this will switch between the two ways of computing the particle mobility.  <a href="classItoSolver.html#afe6615c33886b26c602e0908b6069a1e">More...</a><br /></td></tr>
<tr class="separator:afe6615c33886b26c602e0908b6069a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877960fbdde4e57f9ce3061fc0bb703f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a877960fbdde4e57f9ce3061fc0bb703f">updateMobilities</a> ()</td></tr>
<tr class="memdesc:a877960fbdde4e57f9ce3061fc0bb703f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update mobilities parametrically from the particle energy.  <a href="classItoSolver.html#a877960fbdde4e57f9ce3061fc0bb703f">More...</a><br /></td></tr>
<tr class="separator:a877960fbdde4e57f9ce3061fc0bb703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a9256055022575daeceafe643972f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac7a9256055022575daeceafe643972f2">updateMobilities</a> (const int a_level, const DataIndex a_dit)</td></tr>
<tr class="memdesc:ac7a9256055022575daeceafe643972f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update mobilities parametrically from the particle energy.  <a href="classItoSolver.html#ac7a9256055022575daeceafe643972f2">More...</a><br /></td></tr>
<tr class="separator:ac7a9256055022575daeceafe643972f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b5e34d86ab0286807678c7f753f57e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a64b5e34d86ab0286807678c7f753f57e">interpolateDiffusion</a> ()</td></tr>
<tr class="memdesc:a64b5e34d86ab0286807678c7f753f57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the diffusion field to the particle positions.  <a href="classItoSolver.html#a64b5e34d86ab0286807678c7f753f57e">More...</a><br /></td></tr>
<tr class="separator:a64b5e34d86ab0286807678c7f753f57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3ef423300841c7a94bdb2ccd248189"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aef3ef423300841c7a94bdb2ccd248189">interpolateDiffusion</a> (const int a_level, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:aef3ef423300841c7a94bdb2ccd248189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the diffusion field to the particle positions.  <a href="classItoSolver.html#aef3ef423300841c7a94bdb2ccd248189">More...</a><br /></td></tr>
<tr class="separator:aef3ef423300841c7a94bdb2ccd248189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8246f963aa976e49c808a9d963b464"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4d8246f963aa976e49c808a9d963b464">updateDiffusion</a> ()</td></tr>
<tr class="memdesc:a4d8246f963aa976e49c808a9d963b464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update mobilities parametrically from the particle energy.  <a href="classItoSolver.html#a4d8246f963aa976e49c808a9d963b464">More...</a><br /></td></tr>
<tr class="separator:a4d8246f963aa976e49c808a9d963b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad686ec03d1b90c1f9b2e2bb2e45126bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad686ec03d1b90c1f9b2e2bb2e45126bf">updateDiffusion</a> (const int a_level, const DataIndex a_dit)</td></tr>
<tr class="memdesc:ad686ec03d1b90c1f9b2e2bb2e45126bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update mobilities parametrically from the particle energy.  <a href="classItoSolver.html#ad686ec03d1b90c1f9b2e2bb2e45126bf">More...</a><br /></td></tr>
<tr class="separator:ad686ec03d1b90c1f9b2e2bb2e45126bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201369931b6d5e171c836857203b0d3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a201369931b6d5e171c836857203b0d3f">sortParticlesByCell</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a201369931b6d5e171c836857203b0d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the input particle container by cell.  <a href="classItoSolver.html#a201369931b6d5e171c836857203b0d3f">More...</a><br /></td></tr>
<tr class="separator:a201369931b6d5e171c836857203b0d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998ca9c97dd35a41b9d3de0b9c522115"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a998ca9c97dd35a41b9d3de0b9c522115">sortParticlesByPatch</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a998ca9c97dd35a41b9d3de0b9c522115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the input particle container by patch.  <a href="classItoSolver.html#a998ca9c97dd35a41b9d3de0b9c522115">More...</a><br /></td></tr>
<tr class="separator:a998ca9c97dd35a41b9d3de0b9c522115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e0d074046485949984c3c074d1fe58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a90e0d074046485949984c3c074d1fe58">makeSuperparticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const int a_particlesPerCell)</td></tr>
<tr class="memdesc:a90e0d074046485949984c3c074d1fe58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make superparticles for a full container &ndash; this is the AMR version that users will usually call.  <a href="classItoSolver.html#a90e0d074046485949984c3c074d1fe58">More...</a><br /></td></tr>
<tr class="separator:a90e0d074046485949984c3c074d1fe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc59aabefa256470657b9c0087725c20"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acc59aabefa256470657b9c0087725c20">makeSuperparticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const int a_particlesPerCell, const int a_level)</td></tr>
<tr class="memdesc:acc59aabefa256470657b9c0087725c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make superparticles for a particle container &ndash; this is used for a specified grid level.  <a href="classItoSolver.html#acc59aabefa256470657b9c0087725c20">More...</a><br /></td></tr>
<tr class="separator:acc59aabefa256470657b9c0087725c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb1432cb164650e8b71c4c5657fb36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae0cb1432cb164650e8b71c4c5657fb36">makeSuperparticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const int a_particlesPerPatch, const int a_level, const DataIndex a_dit)</td></tr>
<tr class="memdesc:ae0cb1432cb164650e8b71c4c5657fb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make superparticles for a particle container &ndash; this is used for a specified grid level and patch.  <a href="classItoSolver.html#ae0cb1432cb164650e8b71c4c5657fb36">More...</a><br /></td></tr>
<tr class="separator:ae0cb1432cb164650e8b71c4c5657fb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802e12734bd28664a925cf946f485350"><td class="memItemLeft" align="right" valign="top"><a id="a802e12734bd28664a925cf946f485350"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a802e12734bd28664a925cf946f485350">remap</a> ()</td></tr>
<tr class="memdesc:a802e12734bd28664a925cf946f485350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap the bulk particle container. <br /></td></tr>
<tr class="separator:a802e12734bd28664a925cf946f485350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2ffd6f216e2fe3fc1b7d69134cd941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2b2ffd6f216e2fe3fc1b7d69134cd941">remap</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a2b2ffd6f216e2fe3fc1b7d69134cd941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap all particles in the input container.  <a href="classItoSolver.html#a2b2ffd6f216e2fe3fc1b7d69134cd941">More...</a><br /></td></tr>
<tr class="separator:a2b2ffd6f216e2fe3fc1b7d69134cd941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59ef79304936f346170bb00bef1d484"><td class="memItemLeft" align="right" valign="top"><a id="ac59ef79304936f346170bb00bef1d484"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac59ef79304936f346170bb00bef1d484">remapAll</a> ()</td></tr>
<tr class="memdesc:ac59ef79304936f346170bb00bef1d484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap all particle containers. <br /></td></tr>
<tr class="separator:ac59ef79304936f346170bb00bef1d484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cbe509c51f4fce01400a105760b1e9"><td class="memItemLeft" align="right" valign="top">RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a77cbe509c51f4fce01400a105760b1e9">randomGaussian</a> () const</td></tr>
<tr class="memdesc:a77cbe509c51f4fce01400a105760b1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a random N-dimensional Gaussian number from a normal distribution with zero with and unit standard deviation.  <a href="classItoSolver.html#a77cbe509c51f4fce01400a105760b1e9">More...</a><br /></td></tr>
<tr class="separator:a77cbe509c51f4fce01400a105760b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019fa52c90f664f338441ae58ee891cf"><td class="memItemLeft" align="right" valign="top">RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a019fa52c90f664f338441ae58ee891cf">randomDirection</a> () const</td></tr>
<tr class="memdesc:a019fa52c90f664f338441ae58ee891cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a random direction in N-dimensional space.  <a href="classItoSolver.html#a019fa52c90f664f338441ae58ee891cf">More...</a><br /></td></tr>
<tr class="separator:a019fa52c90f664f338441ae58ee891cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad5fa4823fa70c9722b863ab3e35f5"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5fad5fa4823fa70c9722b863ab3e35f5">computeDt</a> () const</td></tr>
<tr class="memdesc:a5fad5fa4823fa70c9722b863ab3e35f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a time step for the advance &ndash; this calls the level function.  <a href="classItoSolver.html#a5fad5fa4823fa70c9722b863ab3e35f5">More...</a><br /></td></tr>
<tr class="separator:a5fad5fa4823fa70c9722b863ab3e35f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe18ba36b867d4ddc70f686dd977ab7"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0fe18ba36b867d4ddc70f686dd977ab7">computeDt</a> (const int a_lvl) const</td></tr>
<tr class="memdesc:a0fe18ba36b867d4ddc70f686dd977ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a time step for the advance &ndash; this returns the maximum permitted time step on the input grid level.  <a href="classItoSolver.html#a0fe18ba36b867d4ddc70f686dd977ab7">More...</a><br /></td></tr>
<tr class="separator:a0fe18ba36b867d4ddc70f686dd977ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41787bfa9dd5767989a63e7782e50e9"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac41787bfa9dd5767989a63e7782e50e9">computeDt</a> (const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:ac41787bfa9dd5767989a63e7782e50e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a time step for the advance &ndash; this returns the maximum permitted time step on the input grid patch.  <a href="classItoSolver.html#ac41787bfa9dd5767989a63e7782e50e9">More...</a><br /></td></tr>
<tr class="separator:ac41787bfa9dd5767989a63e7782e50e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f48f81560c8a7d1c3952303187e519"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a40f48f81560c8a7d1c3952303187e519">computeHopDt</a> (const Real a_maxCellsToMove) const</td></tr>
<tr class="memdesc:a40f48f81560c8a7d1c3952303187e519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on any grid level.  <a href="classItoSolver.html#a40f48f81560c8a7d1c3952303187e519">More...</a><br /></td></tr>
<tr class="separator:a40f48f81560c8a7d1c3952303187e519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ea187e51e51e3623459068cc281b14"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a17ea187e51e51e3623459068cc281b14">computeHopDt</a> (const Real a_maxCellsToMove, const int a_lvl) const</td></tr>
<tr class="memdesc:a17ea187e51e51e3623459068cc281b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on the input grid level.  <a href="classItoSolver.html#a17ea187e51e51e3623459068cc281b14">More...</a><br /></td></tr>
<tr class="separator:a17ea187e51e51e3623459068cc281b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab053c9b08666c62e4527258f7762793c"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab053c9b08666c62e4527258f7762793c">computeHopDt</a> (const Real a_maxCellsToMove, const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:ab053c9b08666c62e4527258f7762793c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on the input grid level.  <a href="classItoSolver.html#ab053c9b08666c62e4527258f7762793c">More...</a><br /></td></tr>
<tr class="separator:ab053c9b08666c62e4527258f7762793c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43a7879eb8c98d18b23ea3accf38c65"><td class="memItemLeft" align="right" valign="top"><a id="af43a7879eb8c98d18b23ea3accf38c65"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#af43a7879eb8c98d18b23ea3accf38c65">computeAdvectiveDt</a> () const</td></tr>
<tr class="memdesc:af43a7879eb8c98d18b23ea3accf38c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute advection time step dt = dx/vMax where vMax is the largest velocity component of the particle. <br /></td></tr>
<tr class="separator:af43a7879eb8c98d18b23ea3accf38c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafa5edfbb02fcab67e2e2e7da5a1ce0"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abafa5edfbb02fcab67e2e2e7da5a1ce0">computeAdvectiveDt</a> (const int a_lvl) const</td></tr>
<tr class="memdesc:abafa5edfbb02fcab67e2e2e7da5a1ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the drift dt. This computes the minimum dt = dx/vMax on the input level.  <a href="classItoSolver.html#abafa5edfbb02fcab67e2e2e7da5a1ce0">More...</a><br /></td></tr>
<tr class="separator:abafa5edfbb02fcab67e2e2e7da5a1ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42432c4f69f66dfca9a5c74784664167"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a42432c4f69f66dfca9a5c74784664167">computeAdvectiveDt</a> (const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:a42432c4f69f66dfca9a5c74784664167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the drift dt. This computes the minimum dt = dx/vMax on one level and one box.  <a href="classItoSolver.html#a42432c4f69f66dfca9a5c74784664167">More...</a><br /></td></tr>
<tr class="separator:a42432c4f69f66dfca9a5c74784664167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b93acc51df2b5bf6f6d69309027c646"><td class="memItemLeft" align="right" valign="top"><a id="a4b93acc51df2b5bf6f6d69309027c646"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4b93acc51df2b5bf6f6d69309027c646">computeDiffusiveDt</a> () const</td></tr>
<tr class="memdesc:a4b93acc51df2b5bf6f6d69309027c646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles. <br /></td></tr>
<tr class="separator:a4b93acc51df2b5bf6f6d69309027c646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb099bd8a10e78857d024d26f7b6570"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1bb099bd8a10e78857d024d26f7b6570">computeDiffusiveDt</a> (const int a_lvl) const</td></tr>
<tr class="memdesc:a1bb099bd8a10e78857d024d26f7b6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles on the input level.  <a href="classItoSolver.html#a1bb099bd8a10e78857d024d26f7b6570">More...</a><br /></td></tr>
<tr class="separator:a1bb099bd8a10e78857d024d26f7b6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040479280a818cbe4947529d7651ce1c"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a040479280a818cbe4947529d7651ce1c">computeDiffusiveDt</a> (const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:a040479280a818cbe4947529d7651ce1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles on the input grid patch.  <a href="classItoSolver.html#a040479280a818cbe4947529d7651ce1c">More...</a><br /></td></tr>
<tr class="separator:a040479280a818cbe4947529d7651ce1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6205a79851e8e13fee2fd0edc2b48c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab6205a79851e8e13fee2fd0edc2b48c9">getDeposition</a> () const</td></tr>
<tr class="memdesc:ab6205a79851e8e13fee2fd0edc2b48c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get deposition method.  <a href="classItoSolver.html#ab6205a79851e8e13fee2fd0edc2b48c9">More...</a><br /></td></tr>
<tr class="separator:ab6205a79851e8e13fee2fd0edc2b48c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0728c740c0a9ced2691f193057b384fa"><td class="memItemLeft" align="right" valign="top">phase::which_phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0728c740c0a9ced2691f193057b384fa">getPhase</a> () const</td></tr>
<tr class="memdesc:a0728c740c0a9ced2691f193057b384fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return phase.  <a href="classItoSolver.html#a0728c740c0a9ced2691f193057b384fa">More...</a><br /></td></tr>
<tr class="separator:a0728c740c0a9ced2691f193057b384fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a93be4b5f935a4ba80472db227c9d75cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a93be4b5f935a4ba80472db227c9d75cd">WhichCheckpoint</a> { <b>Particles</b>, 
<b>Numbers</b>
 }</td></tr>
<tr class="memdesc:a93be4b5f935a4ba80472db227c9d75cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to checkpoint files.  <a href="classItoSolver.html#a93be4b5f935a4ba80472db227c9d75cd">More...</a><br /></td></tr>
<tr class="separator:a93be4b5f935a4ba80472db227c9d75cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ea13986249a06a5185c8315e4548bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac7ea13986249a06a5185c8315e4548bc">WhichMobilityInterpolation</a> { <b>Direct</b>, 
<b>Velocity</b>
 }</td></tr>
<tr class="memdesc:ac7ea13986249a06a5185c8315e4548bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for deciding how to interpolate particle mobilities.  <a href="classItoSolver.html#ac7ea13986249a06a5185c8315e4548bc">More...</a><br /></td></tr>
<tr class="separator:ac7ea13986249a06a5185c8315e4548bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aceb07ec1c7f2a91d7c26224aee84073f"><td class="memItemLeft" align="right" valign="top"><a id="aceb07ec1c7f2a91d7c26224aee84073f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aceb07ec1c7f2a91d7c26224aee84073f">parseSuperParticles</a> ()</td></tr>
<tr class="memdesc:aceb07ec1c7f2a91d7c26224aee84073f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse superparticle settings &ndash; this just sets the default direction in which we build the BVH. <br /></td></tr>
<tr class="separator:aceb07ec1c7f2a91d7c26224aee84073f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e8e4881e32bd4b99ad8f272ee9236f"><td class="memItemLeft" align="right" valign="top"><a id="ab1e8e4881e32bd4b99ad8f272ee9236f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab1e8e4881e32bd4b99ad8f272ee9236f">parseRNG</a> ()</td></tr>
<tr class="memdesc:ab1e8e4881e32bd4b99ad8f272ee9236f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse RNG options &ndash; this parses the RNG seed and instantiates the distributions. <br /></td></tr>
<tr class="separator:ab1e8e4881e32bd4b99ad8f272ee9236f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b7f123b742ce59ff8ed203fa96d326"><td class="memItemLeft" align="right" valign="top"><a id="ab6b7f123b742ce59ff8ed203fa96d326"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab6b7f123b742ce59ff8ed203fa96d326">parseTruncation</a> ()</td></tr>
<tr class="memdesc:ab6b7f123b742ce59ff8ed203fa96d326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the normal distribution truncation level. <br /></td></tr>
<tr class="separator:ab6b7f123b742ce59ff8ed203fa96d326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99beba4bb3d6b11b26c1a031225c038"><td class="memItemLeft" align="right" valign="top"><a id="ae99beba4bb3d6b11b26c1a031225c038"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae99beba4bb3d6b11b26c1a031225c038">parseDeposition</a> ()</td></tr>
<tr class="memdesc:ae99beba4bb3d6b11b26c1a031225c038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse particle deposition methods. <br /></td></tr>
<tr class="separator:ae99beba4bb3d6b11b26c1a031225c038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49b1c278811933412ea0c6480ab26da"><td class="memItemLeft" align="right" valign="top"><a id="ac49b1c278811933412ea0c6480ab26da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac49b1c278811933412ea0c6480ab26da">parseBisectStep</a> ()</td></tr>
<tr class="memdesc:ac49b1c278811933412ea0c6480ab26da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse bisection step. <br /></td></tr>
<tr class="separator:ac49b1c278811933412ea0c6480ab26da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0816fef9d4ea05e412f66422add9226a"><td class="memItemLeft" align="right" valign="top"><a id="a0816fef9d4ea05e412f66422add9226a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0816fef9d4ea05e412f66422add9226a">parsePvrBuffer</a> ()</td></tr>
<tr class="memdesc:a0816fef9d4ea05e412f66422add9226a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse PVR buffer. <br /></td></tr>
<tr class="separator:a0816fef9d4ea05e412f66422add9226a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf6f91c6ad86c19f26c56962ac7cdcf"><td class="memItemLeft" align="right" valign="top"><a id="afaf6f91c6ad86c19f26c56962ac7cdcf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afaf6f91c6ad86c19f26c56962ac7cdcf">parsePlotVariables</a> ()</td></tr>
<tr class="memdesc:afaf6f91c6ad86c19f26c56962ac7cdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse plot variables. <br /></td></tr>
<tr class="separator:afaf6f91c6ad86c19f26c56962ac7cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077daa0e8d08f13bc81a9a7f19d079df"><td class="memItemLeft" align="right" valign="top"><a id="a077daa0e8d08f13bc81a9a7f19d079df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a077daa0e8d08f13bc81a9a7f19d079df">parseDiffusionHop</a> ()</td></tr>
<tr class="memdesc:a077daa0e8d08f13bc81a9a7f19d079df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse diffusion hop. <br /></td></tr>
<tr class="separator:a077daa0e8d08f13bc81a9a7f19d079df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ac1cf61d9ad50ba0f959088e4e083b"><td class="memItemLeft" align="right" valign="top"><a id="a40ac1cf61d9ad50ba0f959088e4e083b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a40ac1cf61d9ad50ba0f959088e4e083b">parseRedistribution</a> ()</td></tr>
<tr class="memdesc:a40ac1cf61d9ad50ba0f959088e4e083b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse whether or not to use redistribution. <br /></td></tr>
<tr class="separator:a40ac1cf61d9ad50ba0f959088e4e083b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4be69b978f264e422bcdf75498a81e"><td class="memItemLeft" align="right" valign="top"><a id="aac4be69b978f264e422bcdf75498a81e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aac4be69b978f264e422bcdf75498a81e">parseDivergenceComputation</a> ()</td></tr>
<tr class="memdesc:aac4be69b978f264e422bcdf75498a81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse whether or not to compute a "non-conservative" divergence when redistributing mass. <br /></td></tr>
<tr class="separator:aac4be69b978f264e422bcdf75498a81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74657cea12e9660c0e25db1b4982d647"><td class="memItemLeft" align="right" valign="top"><a id="a74657cea12e9660c0e25db1b4982d647"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a74657cea12e9660c0e25db1b4982d647">parseCheckpointing</a> ()</td></tr>
<tr class="memdesc:a74657cea12e9660c0e25db1b4982d647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse checkpointing method. <br /></td></tr>
<tr class="separator:a74657cea12e9660c0e25db1b4982d647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803e769f2adeed3b1a2f2b9d40c2422f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a803e769f2adeed3b1a2f2b9d40c2422f">drawNewParticles</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_particlesPerCell, const int a_level, const int a_newPPC)</td></tr>
<tr class="memdesc:a803e769f2adeed3b1a2f2b9d40c2422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart particles from a specified number of particles in the grid cell.  <a href="classItoSolver.html#a803e769f2adeed3b1a2f2b9d40c2422f">More...</a><br /></td></tr>
<tr class="separator:a803e769f2adeed3b1a2f2b9d40c2422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a72bc36aaac4eaff69df185bd8159a4"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a1a72bc36aaac4eaff69df185bd8159a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1a72bc36aaac4eaff69df185bd8159a4">depositKappaConservative</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition) const</td></tr>
<tr class="memdesc:a1a72bc36aaac4eaff69df185bd8159a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cell-centered deposition &ndash; this is the main deposition function.  <a href="classItoSolver.html#a1a72bc36aaac4eaff69df185bd8159a4">More...</a><br /></td></tr>
<tr class="separator:a1a72bc36aaac4eaff69df185bd8159a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a72bc36aaac4eaff69df185bd8159a4"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a1a72bc36aaac4eaff69df185bd8159a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1a72bc36aaac4eaff69df185bd8159a4">depositKappaConservative</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition) const</td></tr>
<tr class="memdesc:a1a72bc36aaac4eaff69df185bd8159a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cell-centered deposition &ndash; this is the main deposition function.  <a href="classItoSolver.html#a1a72bc36aaac4eaff69df185bd8159a4">More...</a><br /></td></tr>
<tr class="separator:a1a72bc36aaac4eaff69df185bd8159a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad599086b015754fd8dc25f94ba0b686d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad599086b015754fd8dc25f94ba0b686d">redistributeAMR</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi) const</td></tr>
<tr class="memdesc:ad599086b015754fd8dc25f94ba0b686d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribute mass in an AMR context.  <a href="classItoSolver.html#ad599086b015754fd8dc25f94ba0b686d">More...</a><br /></td></tr>
<tr class="separator:ad599086b015754fd8dc25f94ba0b686d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6778295d539cd8d0224bf2615e93bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1f6778295d539cd8d0224bf2615e93bb">depositNonConservative</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_depositionNC, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_depositionKappaC) const</td></tr>
<tr class="memdesc:a1f6778295d539cd8d0224bf2615e93bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the "non-conservative" kappa deposition &ndash; computing depositionNC = sum(kappa*depositionC)/sum(kappa) in a neighborhood around each vof.  <a href="classItoSolver.html#a1f6778295d539cd8d0224bf2615e93bb">More...</a><br /></td></tr>
<tr class="separator:a1f6778295d539cd8d0224bf2615e93bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2b82ed36f44539366b43564e352846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aac2b82ed36f44539366b43564e352846">depositHybrid</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_depositionH, <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_massDifference, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_depositionNC) const</td></tr>
<tr class="memdesc:aac2b82ed36f44539366b43564e352846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the "hybrid" deposition phiH = kappa*phiC + (1-kappa)*phiNC. On input, a_depositionH should contain phiC.  <a href="classItoSolver.html#aac2b82ed36f44539366b43564e352846">More...</a><br /></td></tr>
<tr class="separator:aac2b82ed36f44539366b43564e352846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af150e243cbc08c6359b9218338676d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#af150e243cbc08c6359b9218338676d30">incrementRedist</a> (const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_massDifference) const</td></tr>
<tr class="memdesc:af150e243cbc08c6359b9218338676d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment redistribution objects with mass to be redistributed.  <a href="classItoSolver.html#af150e243cbc08c6359b9218338676d30">More...</a><br /></td></tr>
<tr class="separator:af150e243cbc08c6359b9218338676d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad163ae5e22e548b23e2e932f05b57392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad163ae5e22e548b23e2e932f05b57392">levelRedist</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi) const</td></tr>
<tr class="memdesc:ad163ae5e22e548b23e2e932f05b57392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do redistribution on all levels, no coarse-fine stuff.  <a href="classItoSolver.html#ad163ae5e22e548b23e2e932f05b57392">More...</a><br /></td></tr>
<tr class="separator:ad163ae5e22e548b23e2e932f05b57392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8db7d60bcd16f77dd52d064b231be4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae8db7d60bcd16f77dd52d064b231be4f">coarseFineIncrement</a> (const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;m_massDifference) const</td></tr>
<tr class="memdesc:ae8db7d60bcd16f77dd52d064b231be4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the coarse-fine redist with mass difference (only for EB x CF)  <a href="classItoSolver.html#ae8db7d60bcd16f77dd52d064b231be4f">More...</a><br /></td></tr>
<tr class="separator:ae8db7d60bcd16f77dd52d064b231be4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ac7d9fa5f802806c12d667c1892a5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac3ac7d9fa5f802806c12d667c1892a5d">coarseFineRedistribution</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi) const</td></tr>
<tr class="memdesc:ac3ac7d9fa5f802806c12d667c1892a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do coarse-fine mass redistribution.  <a href="classItoSolver.html#ac3ac7d9fa5f802806c12d667c1892a5d">More...</a><br /></td></tr>
<tr class="separator:ac3ac7d9fa5f802806c12d667c1892a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53064ecb380ff57c7fc6f666daef30a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a53064ecb380ff57c7fc6f666daef30a3">mergeBVH</a> (List&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const int a_particlesPerCell)</td></tr>
<tr class="memdesc:a53064ecb380ff57c7fc6f666daef30a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superparticle merging with BVH trees.  <a href="classItoSolver.html#a53064ecb380ff57c7fc6f666daef30a3">More...</a><br /></td></tr>
<tr class="separator:a53064ecb380ff57c7fc6f666daef30a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04b4155dcf2543bd538e27669e47518"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac04b4155dcf2543bd538e27669e47518">writeData</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_output, int &amp;a_comp, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const bool a_interpToCentroids) const</td></tr>
<tr class="memdesc:ac04b4155dcf2543bd538e27669e47518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to output. Convenience function which just copies data from one data holder to the output data holder.  <a href="classItoSolver.html#ac04b4155dcf2543bd538e27669e47518">More...</a><br /></td></tr>
<tr class="separator:ac04b4155dcf2543bd538e27669e47518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f7f9fdcaf5fcca2917480d9896b621"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a23f7f9fdcaf5fcca2917480d9896b621">interpolateMobilitiesDirect</a> (const int a_level, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:a23f7f9fdcaf5fcca2917480d9896b621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly interpolate mobilities. Interpolates for all particles in the specified grid patch.  <a href="classItoSolver.html#a23f7f9fdcaf5fcca2917480d9896b621">More...</a><br /></td></tr>
<tr class="separator:a23f7f9fdcaf5fcca2917480d9896b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11980419f7695d872a83885be0f20494"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a11980419f7695d872a83885be0f20494">interpolateMobilitiesVelocity</a> (const int a_level, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:a11980419f7695d872a83885be0f20494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate mobilities through the velocity. Interpolates for all particles in the specified grid patch.  <a href="classItoSolver.html#a11980419f7695d872a83885be0f20494">More...</a><br /></td></tr>
<tr class="separator:a11980419f7695d872a83885be0f20494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0edd943066ee2e871ce6d5962a5b38"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1e0edd943066ee2e871ce6d5962a5b38">sign</a> (const Real &amp;a) const</td></tr>
<tr class="memdesc:a1e0edd943066ee2e871ce6d5962a5b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign function.  <a href="classItoSolver.html#a1e0edd943066ee2e871ce6d5962a5b38">More...</a><br /></td></tr>
<tr class="separator:a1e0edd943066ee2e871ce6d5962a5b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1685c620081632e849d9dd2bc87ffe"><td class="memItemLeft" align="right" valign="top">RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8d1685c620081632e849d9dd2bc87ffe">randomPosition</a> (const RealVect a_cellPos, const RealVect a_lo, const RealVect a_hi, const RealVect a_bndryCentroid, const RealVect a_normal, const Real a_dx, const Real a_kappa) const</td></tr>
<tr class="memdesc:a8d1685c620081632e849d9dd2bc87ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a random position physical somewhere in a grid cell.  <a href="classItoSolver.html#a8d1685c620081632e849d9dd2bc87ffe">More...</a><br /></td></tr>
<tr class="separator:a8d1685c620081632e849d9dd2bc87ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686244537fc296dcaf1ae3cf30563a16"><td class="memItemLeft" align="right" valign="top">RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a686244537fc296dcaf1ae3cf30563a16">randomPosition</a> (const RealVect a_lo, const RealVect a_hi, const RealVect a_bndryCentroid, const RealVect a_normal) const</td></tr>
<tr class="memdesc:a686244537fc296dcaf1ae3cf30563a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a random position somewhere in a cut-cell.  <a href="classItoSolver.html#a686244537fc296dcaf1ae3cf30563a16">More...</a><br /></td></tr>
<tr class="separator:a686244537fc296dcaf1ae3cf30563a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2c856e17b3820aafb09a4ee1737390"><td class="memItemLeft" align="right" valign="top">RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5f2c856e17b3820aafb09a4ee1737390">randomPosition</a> (const RealVect a_lo, const RealVect a_hi) const</td></tr>
<tr class="memdesc:a5f2c856e17b3820aafb09a4ee1737390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random position in the cube (a_lo, a_hi);.  <a href="classItoSolver.html#a5f2c856e17b3820aafb09a4ee1737390">More...</a><br /></td></tr>
<tr class="separator:a5f2c856e17b3820aafb09a4ee1737390"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a73a4bb5ebcec9cd208eb2328a1cc3840"><td class="memItemLeft" align="right" valign="top"><a id="a73a4bb5ebcec9cd208eb2328a1cc3840"></a>
<a class="el" href="classItoSolver.html#a93be4b5f935a4ba80472db227c9d75cd">WhichCheckpoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a73a4bb5ebcec9cd208eb2328a1cc3840">m_checkpointing</a></td></tr>
<tr class="memdesc:a73a4bb5ebcec9cd208eb2328a1cc3840"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to checkpoint files. particles =&gt; write particles to HDF5. numbers =&gt; write numbers to HDF5. <br /></td></tr>
<tr class="separator:a73a4bb5ebcec9cd208eb2328a1cc3840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a28b6a171ed4a0aa2093e39c42cebe"><td class="memItemLeft" align="right" valign="top"><a id="aa8a28b6a171ed4a0aa2093e39c42cebe"></a>
<a class="el" href="classItoSolver.html#ac7ea13986249a06a5185c8315e4548bc">WhichMobilityInterpolation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa8a28b6a171ed4a0aa2093e39c42cebe">m_mobilityInterp</a></td></tr>
<tr class="memdesc:aa8a28b6a171ed4a0aa2093e39c42cebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch for deciding how to interpolate mobilities, i.e. interpolating either mu*E or just mu (to the particle position) <br /></td></tr>
<tr class="separator:aa8a28b6a171ed4a0aa2093e39c42cebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdbaf1fcff7620202eef2892684dcc"><td class="memItemLeft" align="right" valign="top"><a id="a2ecdbaf1fcff7620202eef2892684dcc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2ecdbaf1fcff7620202eef2892684dcc">m_restartPPC</a></td></tr>
<tr class="memdesc:a2ecdbaf1fcff7620202eef2892684dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of particles used when restarting a simulation &ndash; this is relevant only when restarting from a "fluid" checkpoint file. <br /></td></tr>
<tr class="separator:a2ecdbaf1fcff7620202eef2892684dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca315816cb8204a5164f03539cf6f20"><td class="memItemLeft" align="right" valign="top"><a id="a4ca315816cb8204a5164f03539cf6f20"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4ca315816cb8204a5164f03539cf6f20">m_directionKD</a></td></tr>
<tr class="memdesc:a4ca315816cb8204a5164f03539cf6f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splitting direction. This is used in mergeBVH to select the first direction of the BVH when merging/splitting particles. <br /></td></tr>
<tr class="separator:a4ca315816cb8204a5164f03539cf6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a9455e60b33ff6e057b561cca227af"><td class="memItemLeft" align="right" valign="top"><a id="a55a9455e60b33ff6e057b561cca227af"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a55a9455e60b33ff6e057b561cca227af">m_realm</a></td></tr>
<tr class="memdesc:a55a9455e60b33ff6e057b561cca227af"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where this solve lives. <br /></td></tr>
<tr class="separator:a55a9455e60b33ff6e057b561cca227af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedef422fac4a38e1360886d35e765c36"><td class="memItemLeft" align="right" valign="top"><a id="aedef422fac4a38e1360886d35e765c36"></a>
<a class="el" href="classItoMerge_1_1Tree.html">ItoMerge::Tree</a>&lt; <a class="el" href="classPointMass.html">PointMass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aedef422fac4a38e1360886d35e765c36">m_mergeTree</a></td></tr>
<tr class="memdesc:aedef422fac4a38e1360886d35e765c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundary volume hierarchy merging tree &ndash; used in mergeBVH. <br /></td></tr>
<tr class="separator:aedef422fac4a38e1360886d35e765c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadc148a0d39b1c381b4ef83cfe465b9"><td class="memItemLeft" align="right" valign="top"><a id="aeadc148a0d39b1c381b4ef83cfe465b9"></a>
RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aeadc148a0d39b1c381b4ef83cfe465b9">m_computationalGeometry</a></td></tr>
<tr class="memdesc:aeadc148a0d39b1c381b4ef83cfe465b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational geometry. <br /></td></tr>
<tr class="separator:aeadc148a0d39b1c381b4ef83cfe465b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3f016c77c3ce58e11f6e1e1243773a"><td class="memItemLeft" align="right" valign="top"><a id="aaf3f016c77c3ce58e11f6e1e1243773a"></a>
RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aaf3f016c77c3ce58e11f6e1e1243773a">m_amr</a></td></tr>
<tr class="memdesc:aaf3f016c77c3ce58e11f6e1e1243773a"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMR; needed for grid stuff. <br /></td></tr>
<tr class="separator:aaf3f016c77c3ce58e11f6e1e1243773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6142ed82b15d560df3f16d3921c37566"><td class="memItemLeft" align="right" valign="top"><a id="a6142ed82b15d560df3f16d3921c37566"></a>
RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6142ed82b15d560df3f16d3921c37566">m_species</a></td></tr>
<tr class="memdesc:a6142ed82b15d560df3f16d3921c37566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Species that this solver solves for. <br /></td></tr>
<tr class="separator:a6142ed82b15d560df3f16d3921c37566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1704d95090017c82c313acfdafdeeb5"><td class="memItemLeft" align="right" valign="top"><a id="ae1704d95090017c82c313acfdafdeeb5"></a>
phase::which_phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae1704d95090017c82c313acfdafdeeb5">m_phase</a></td></tr>
<tr class="memdesc:ae1704d95090017c82c313acfdafdeeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase where this solver lives. <br /></td></tr>
<tr class="separator:ae1704d95090017c82c313acfdafdeeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8cdd7bdd007bc3fb1269adf0e92125"><td class="memItemLeft" align="right" valign="top"><a id="a6b8cdd7bdd007bc3fb1269adf0e92125"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6b8cdd7bdd007bc3fb1269adf0e92125">m_name</a></td></tr>
<tr class="memdesc:a6b8cdd7bdd007bc3fb1269adf0e92125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver name. <br /></td></tr>
<tr class="separator:a6b8cdd7bdd007bc3fb1269adf0e92125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfbc656f1f16c9b664b25ff0fedd92a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4cfbc656f1f16c9b664b25ff0fedd92a">m_className</a></td></tr>
<tr class="memdesc:a4cfbc656f1f16c9b664b25ff0fedd92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class name.  <a href="classItoSolver.html#a4cfbc656f1f16c9b664b25ff0fedd92a">More...</a><br /></td></tr>
<tr class="separator:a4cfbc656f1f16c9b664b25ff0fedd92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1432b00602a2602938d0477a76b378"><td class="memItemLeft" align="right" valign="top"><a id="a1d1432b00602a2602938d0477a76b378"></a>
std::uniform_int_distribution&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1d1432b00602a2602938d0477a76b378">m_uniformDistribution0d</a></td></tr>
<tr class="memdesc:a1d1432b00602a2602938d0477a76b378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform integer distribution between [0,SpaceDim-1]. <br /></td></tr>
<tr class="separator:a1d1432b00602a2602938d0477a76b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987806a343072c9ed15231c9a371a16e"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a987806a343072c9ed15231c9a371a16e">m_normalDistributionTruncation</a></td></tr>
<tr class="memdesc:a987806a343072c9ed15231c9a371a16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncation value for normal distribution.  <a href="classItoSolver.html#a987806a343072c9ed15231c9a371a16e">More...</a><br /></td></tr>
<tr class="separator:a987806a343072c9ed15231c9a371a16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3e2e32f016978fff89f34b876d0905"><td class="memItemLeft" align="right" valign="top"><a id="a2a3e2e32f016978fff89f34b876d0905"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2a3e2e32f016978fff89f34b876d0905">m_bisectionStep</a></td></tr>
<tr class="memdesc:a2a3e2e32f016978fff89f34b876d0905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisection step size to use for particle intersection tests with EBs. <br /></td></tr>
<tr class="separator:a2a3e2e32f016978fff89f34b876d0905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddb00c8bcd19c7d23ce98738326c108"><td class="memItemLeft" align="right" valign="top"><a id="a8ddb00c8bcd19c7d23ce98738326c108"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8ddb00c8bcd19c7d23ce98738326c108">m_verbosity</a></td></tr>
<tr class="memdesc:a8ddb00c8bcd19c7d23ce98738326c108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verbosity level for this solver. <br /></td></tr>
<tr class="separator:a8ddb00c8bcd19c7d23ce98738326c108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e82d759ba2e48638ad1226c2ccca5e5"><td class="memItemLeft" align="right" valign="top"><a id="a4e82d759ba2e48638ad1226c2ccca5e5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4e82d759ba2e48638ad1226c2ccca5e5">m_timeStep</a></td></tr>
<tr class="memdesc:a4e82d759ba2e48638ad1226c2ccca5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step. <br /></td></tr>
<tr class="separator:a4e82d759ba2e48638ad1226c2ccca5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a81f132401599dd015e3e3060528705"><td class="memItemLeft" align="right" valign="top"><a id="a3a81f132401599dd015e3e3060528705"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a3a81f132401599dd015e3e3060528705">m_pvrBuffer</a></td></tr>
<tr class="memdesc:a3a81f132401599dd015e3e3060528705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer for PVR. <br /></td></tr>
<tr class="separator:a3a81f132401599dd015e3e3060528705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89480b124a54ae732a71d2be4251a1c7"><td class="memItemLeft" align="right" valign="top"><a id="a89480b124a54ae732a71d2be4251a1c7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a89480b124a54ae732a71d2be4251a1c7">m_haloBuffer</a></td></tr>
<tr class="memdesc:a89480b124a54ae732a71d2be4251a1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of refinement boundary halo. <br /></td></tr>
<tr class="separator:a89480b124a54ae732a71d2be4251a1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7302d002cffb137588c1f08fef88ffb"><td class="memItemLeft" align="right" valign="top"><a id="ad7302d002cffb137588c1f08fef88ffb"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad7302d002cffb137588c1f08fef88ffb">m_time</a></td></tr>
<tr class="memdesc:ad7302d002cffb137588c1f08fef88ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current time. <br /></td></tr>
<tr class="separator:ad7302d002cffb137588c1f08fef88ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6747e8e5e18f1617c4fb773def7e5fdd"><td class="memItemLeft" align="right" valign="top"><a id="a6747e8e5e18f1617c4fb773def7e5fdd"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6747e8e5e18f1617c4fb773def7e5fdd">m_dt</a></td></tr>
<tr class="memdesc:a6747e8e5e18f1617c4fb773def7e5fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step. <br /></td></tr>
<tr class="separator:a6747e8e5e18f1617c4fb773def7e5fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5381483b3eb70b58fda7a36a20774738"><td class="memItemLeft" align="right" valign="top"><a id="a5381483b3eb70b58fda7a36a20774738"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5381483b3eb70b58fda7a36a20774738">m_forceIrregDepositionNGP</a></td></tr>
<tr class="memdesc:a5381483b3eb70b58fda7a36a20774738"><td class="mdescLeft">&#160;</td><td class="mdescRight">NGP deposition in cut cells or not. <br /></td></tr>
<tr class="separator:a5381483b3eb70b58fda7a36a20774738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eff78633d5756c928ecfa7ade33e9b"><td class="memItemLeft" align="right" valign="top"><a id="a44eff78633d5756c928ecfa7ade33e9b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a44eff78633d5756c928ecfa7ade33e9b">m_forceIrregInterpolationNGP</a></td></tr>
<tr class="memdesc:a44eff78633d5756c928ecfa7ade33e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">NGP interpolation in cut cells or not. <br /></td></tr>
<tr class="separator:a44eff78633d5756c928ecfa7ade33e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3577bd63b657bd0e01a8fc16f36d66dc"><td class="memItemLeft" align="right" valign="top"><a id="a3577bd63b657bd0e01a8fc16f36d66dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a3577bd63b657bd0e01a8fc16f36d66dc">m_forceHaloNGP</a></td></tr>
<tr class="memdesc:a3577bd63b657bd0e01a8fc16f36d66dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force usage of NGP when depositing "halo" particles. <br /></td></tr>
<tr class="separator:a3577bd63b657bd0e01a8fc16f36d66dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c612b96f248ab1d4952f5640270158"><td class="memItemLeft" align="right" valign="top"><a id="a82c612b96f248ab1d4952f5640270158"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a82c612b96f248ab1d4952f5640270158">m_useRedistribution</a></td></tr>
<tr class="memdesc:a82c612b96f248ab1d4952f5640270158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use mass redistribution or not. <br /></td></tr>
<tr class="separator:a82c612b96f248ab1d4952f5640270158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee84b0a66255e6e5c8b798db2f32e0e"><td class="memItemLeft" align="right" valign="top"><a id="a9ee84b0a66255e6e5c8b798db2f32e0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a9ee84b0a66255e6e5c8b798db2f32e0e">m_blendConservation</a></td></tr>
<tr class="memdesc:a9ee84b0a66255e6e5c8b798db2f32e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for blending the deposition clouds with the "non-conservative" divergence. <br /></td></tr>
<tr class="separator:a9ee84b0a66255e6e5c8b798db2f32e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75440c5ecf1b1bf55e76bc13e28e80c5"><td class="memItemLeft" align="right" valign="top"><a id="a75440c5ecf1b1bf55e76bc13e28e80c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a75440c5ecf1b1bf55e76bc13e28e80c5">m_isDiffusive</a></td></tr>
<tr class="memdesc:a75440c5ecf1b1bf55e76bc13e28e80c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, solver is diffusive. <br /></td></tr>
<tr class="separator:a75440c5ecf1b1bf55e76bc13e28e80c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5525eae4b28bdd085b242d67ac5a1a"><td class="memItemLeft" align="right" valign="top"><a id="acc5525eae4b28bdd085b242d67ac5a1a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acc5525eae4b28bdd085b242d67ac5a1a">m_isMobile</a></td></tr>
<tr class="memdesc:acc5525eae4b28bdd085b242d67ac5a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, solver is mobile, i.e. advection is turned on. <br /></td></tr>
<tr class="separator:acc5525eae4b28bdd085b242d67ac5a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102e31eab3cdf58100b390afbd6bac5a"><td class="memItemLeft" align="right" valign="top"><a id="a102e31eab3cdf58100b390afbd6bac5a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a102e31eab3cdf58100b390afbd6bac5a">m_plotPhi</a></td></tr>
<tr class="memdesc:a102e31eab3cdf58100b390afbd6bac5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for outputting m_phi to plot files. <br /></td></tr>
<tr class="separator:a102e31eab3cdf58100b390afbd6bac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd69a16d2fe7a28629d5f3a0f83b1ad0"><td class="memItemLeft" align="right" valign="top"><a id="afd69a16d2fe7a28629d5f3a0f83b1ad0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afd69a16d2fe7a28629d5f3a0f83b1ad0">m_plotVelocity</a></td></tr>
<tr class="memdesc:afd69a16d2fe7a28629d5f3a0f83b1ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for outputting m_velocityFunction to plot files. <br /></td></tr>
<tr class="separator:afd69a16d2fe7a28629d5f3a0f83b1ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9e7bdf7a18548a2f13572e8e2811c7"><td class="memItemLeft" align="right" valign="top"><a id="abe9e7bdf7a18548a2f13572e8e2811c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abe9e7bdf7a18548a2f13572e8e2811c7">m_plotDiffCo</a></td></tr>
<tr class="memdesc:abe9e7bdf7a18548a2f13572e8e2811c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for outputting m_diffusionFunction to plot files. <br /></td></tr>
<tr class="separator:abe9e7bdf7a18548a2f13572e8e2811c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9a240d402d0800d2420563b308e3f3"><td class="memItemLeft" align="right" valign="top"><a id="a4d9a240d402d0800d2420563b308e3f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4d9a240d402d0800d2420563b308e3f3">m_plotParticles</a></td></tr>
<tr class="memdesc:a4d9a240d402d0800d2420563b308e3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the bulk particles on the mesh. <br /></td></tr>
<tr class="separator:a4d9a240d402d0800d2420563b308e3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf7209c5e935aed87c20cce97c09bb4"><td class="memItemLeft" align="right" valign="top"><a id="a9cf7209c5e935aed87c20cce97c09bb4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a9cf7209c5e935aed87c20cce97c09bb4">m_plotParticlesEB</a></td></tr>
<tr class="memdesc:a9cf7209c5e935aed87c20cce97c09bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the EB particles on the mesh. <br /></td></tr>
<tr class="separator:a9cf7209c5e935aed87c20cce97c09bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6a0ec3137e7d82d5c3eea897fd8de8"><td class="memItemLeft" align="right" valign="top"><a id="afc6a0ec3137e7d82d5c3eea897fd8de8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afc6a0ec3137e7d82d5c3eea897fd8de8">m_plotParticlesDomain</a></td></tr>
<tr class="memdesc:afc6a0ec3137e7d82d5c3eea897fd8de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the domain particles on the mesh. <br /></td></tr>
<tr class="separator:afc6a0ec3137e7d82d5c3eea897fd8de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb34942c2186f94f4c765b3a5528223"><td class="memItemLeft" align="right" valign="top"><a id="a5eb34942c2186f94f4c765b3a5528223"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5eb34942c2186f94f4c765b3a5528223">m_plotParticlesSource</a></td></tr>
<tr class="memdesc:a5eb34942c2186f94f4c765b3a5528223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the source particles on the mesh. <br /></td></tr>
<tr class="separator:a5eb34942c2186f94f4c765b3a5528223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6647bea673932d5ea9b09c914de6b49"><td class="memItemLeft" align="right" valign="top"><a id="ad6647bea673932d5ea9b09c914de6b49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad6647bea673932d5ea9b09c914de6b49">m_plotParticlesCovered</a></td></tr>
<tr class="memdesc:ad6647bea673932d5ea9b09c914de6b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the covered particles on the mesh. <br /></td></tr>
<tr class="separator:ad6647bea673932d5ea9b09c914de6b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b58fe18b09bce12f09dbdbcb5882825"><td class="memItemLeft" align="right" valign="top"><a id="a1b58fe18b09bce12f09dbdbcb5882825"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1b58fe18b09bce12f09dbdbcb5882825">m_plotEnergyDensity</a></td></tr>
<tr class="memdesc:a1b58fe18b09bce12f09dbdbcb5882825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for plotting the energy density on the mesh. <br /></td></tr>
<tr class="separator:a1b58fe18b09bce12f09dbdbcb5882825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757dc659ee8ad33e28fae138affb616b"><td class="memItemLeft" align="right" valign="top"><a id="a757dc659ee8ad33e28fae138affb616b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a757dc659ee8ad33e28fae138affb616b">m_plotAverageEnergy</a></td></tr>
<tr class="memdesc:a757dc659ee8ad33e28fae138affb616b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for plotting the average particle energy on the mesh. <br /></td></tr>
<tr class="separator:a757dc659ee8ad33e28fae138affb616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bc4b0940fd002ab82329890fbd3157"><td class="memItemLeft" align="right" valign="top"><a id="a61bc4b0940fd002ab82329890fbd3157"></a>
<a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a61bc4b0940fd002ab82329890fbd3157">m_deposition</a></td></tr>
<tr class="memdesc:a61bc4b0940fd002ab82329890fbd3157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposition method when depositing particles to the mesh. <br /></td></tr>
<tr class="separator:a61bc4b0940fd002ab82329890fbd3157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7796e2e15a35a118207dbf42741f3cf3"><td class="memItemLeft" align="right" valign="top"><a id="a7796e2e15a35a118207dbf42741f3cf3"></a>
<a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a7796e2e15a35a118207dbf42741f3cf3">m_plotDeposition</a></td></tr>
<tr class="memdesc:a7796e2e15a35a118207dbf42741f3cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposition method when depositing particles to mesh during plotting. <br /></td></tr>
<tr class="separator:a7796e2e15a35a118207dbf42741f3cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5cbaceb9ea706db14a6d93094e2c7e"><td class="memItemLeft" align="right" valign="top"><a id="abc5cbaceb9ea706db14a6d93094e2c7e"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abc5cbaceb9ea706db14a6d93094e2c7e">m_phi</a></td></tr>
<tr class="memdesc:abc5cbaceb9ea706db14a6d93094e2c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for particle mesh data. <br /></td></tr>
<tr class="separator:abc5cbaceb9ea706db14a6d93094e2c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842d9611dc970ba409a660600b75d922"><td class="memItemLeft" align="right" valign="top"><a id="a842d9611dc970ba409a660600b75d922"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a842d9611dc970ba409a660600b75d922">m_mobilityFunction</a></td></tr>
<tr class="memdesc:a842d9611dc970ba409a660600b75d922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mobility function &ndash; used when interpolating particle mobilities. <br /></td></tr>
<tr class="separator:a842d9611dc970ba409a660600b75d922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7358e6f0f8ba7d994b23cef61c33be69"><td class="memItemLeft" align="right" valign="top"><a id="a7358e6f0f8ba7d994b23cef61c33be69"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a7358e6f0f8ba7d994b23cef61c33be69">m_velocityFunction</a></td></tr>
<tr class="memdesc:a7358e6f0f8ba7d994b23cef61c33be69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell-centered field used for interpolating velocities. <br /></td></tr>
<tr class="separator:a7358e6f0f8ba7d994b23cef61c33be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1530feac364fec71833a2cc367538577"><td class="memItemLeft" align="right" valign="top"><a id="a1530feac364fec71833a2cc367538577"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1530feac364fec71833a2cc367538577">m_diffusionFunction</a></td></tr>
<tr class="memdesc:a1530feac364fec71833a2cc367538577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diffusion-centerer field used for interpolating diffusion coefficients. <br /></td></tr>
<tr class="separator:a1530feac364fec71833a2cc367538577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8659ea3416421f5adccbea134449f46f"><td class="memItemLeft" align="right" valign="top"><a id="a8659ea3416421f5adccbea134449f46f"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8659ea3416421f5adccbea134449f46f">m_scratch</a></td></tr>
<tr class="memdesc:a8659ea3416421f5adccbea134449f46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch data. <br /></td></tr>
<tr class="separator:a8659ea3416421f5adccbea134449f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dc43db44eb8cb98f208c66162d5e7b"><td class="memItemLeft" align="right" valign="top"><a id="a49dc43db44eb8cb98f208c66162d5e7b"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a49dc43db44eb8cb98f208c66162d5e7b">m_depositionNC</a></td></tr>
<tr class="memdesc:a49dc43db44eb8cb98f208c66162d5e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for holding the non-conservative deposition. <br /></td></tr>
<tr class="separator:a49dc43db44eb8cb98f208c66162d5e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92737393f3b0d1776c7116f65379fec"><td class="memItemLeft" align="right" valign="top"><a id="ab92737393f3b0d1776c7116f65379fec"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab92737393f3b0d1776c7116f65379fec">m_massDiff</a></td></tr>
<tr class="memdesc:ab92737393f3b0d1776c7116f65379fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for holding the mass difference when using hybrid deposition. <br /></td></tr>
<tr class="separator:ab92737393f3b0d1776c7116f65379fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a391ecb6dd2afbe949ecba8190b1aa"><td class="memItemLeft" align="right" valign="top"><a id="a87a391ecb6dd2afbe949ecba8190b1aa"></a>
std::map&lt; <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a87a391ecb6dd2afbe949ecba8190b1aa">m_particleContainers</a></td></tr>
<tr class="memdesc:a87a391ecb6dd2afbe949ecba8190b1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various particle containers with identifiers. <br /></td></tr>
<tr class="separator:a87a391ecb6dd2afbe949ecba8190b1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa9fb27c5e5045c58b9c8be966e78199b"><td class="memItemLeft" align="right" valign="top"><a id="aa9fb27c5e5045c58b9c8be966e78199b"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa9fb27c5e5045c58b9c8be966e78199b">m_comp</a> = 0</td></tr>
<tr class="memdesc:aa9fb27c5e5045c58b9c8be966e78199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default component in data holders (do not touch). <br /></td></tr>
<tr class="separator:aa9fb27c5e5045c58b9c8be966e78199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cee90b04b96ce937fc28d458ec77d96"><td class="memItemLeft" align="right" valign="top"><a id="a3cee90b04b96ce937fc28d458ec77d96"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a3cee90b04b96ce937fc28d458ec77d96">m_nComp</a> = 1</td></tr>
<tr class="memdesc:a3cee90b04b96ce937fc28d458ec77d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of component in data holders (do not touch). <br /></td></tr>
<tr class="separator:a3cee90b04b96ce937fc28d458ec77d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for Ito diffusion particle models. </p>
<p>This is a particle class for solving Ito diffusion problems dX = v*dt + sqrt(2*D)*dW_t (dW_t is a Wiener process over dt) over an AMR hierarchy. The diffusion coefficient is related to the hydrodynamic diffusion coefficient by D(fluid) = sqrt(2*D(Ito)). </p><dl class="section note"><dt>Note</dt><dd>To use this class, the user must add a species and set the realm and phase where the solver will live. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a93be4b5f935a4ba80472db227c9d75cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93be4b5f935a4ba80472db227c9d75cd">&#9670;&nbsp;</a></span>WhichCheckpoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classItoSolver.html#a93be4b5f935a4ba80472db227c9d75cd">ItoSolver::WhichCheckpoint</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How to checkpoint files. </p>
<p>Particles =&gt; Write particles to HDF5. Numbers =&gt; Write particle numbers to HDF5 (and lose information) </p>

</div>
</div>
<a id="a070d75d0d3ac16e04013d25574c1ffa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d75d0d3ac16e04013d25574c1ffa5">&#9670;&nbsp;</a></span>WhichContainer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">ItoSolver::WhichContainer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum class for distinguishing various types of particle containers. </p>
<p>This exists because the <a class="el" href="classItoSolver.html" title="Base class for Ito diffusion particle models.">ItoSolver</a> can partition particles into various containers, which is very useful when one wants to add particles from a source term, remove particles that fall inside the EB, or parse boundary conditions on the EB and domain faces. Here, Bulk = "Active" particles, EB = Particles on the EBs , Domain = Particles on the domain sides, Source = Source particles &ndash; used to e.g. add new particles to the bulk particles, Covered = Particles inside the EB, Scratch = Scratch particles </p>

</div>
</div>
<a id="ac7ea13986249a06a5185c8315e4548bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ea13986249a06a5185c8315e4548bc">&#9670;&nbsp;</a></span>WhichMobilityInterpolation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classItoSolver.html#ac7ea13986249a06a5185c8315e4548bc">ItoSolver::WhichMobilityInterpolation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum for deciding how to interpolate particle mobilities. </p>
<p>Direct =&gt; Interpolate particle mobilities from the mesh. Velocity =&gt; Set particle mobilitys by computing mu = |v|/|V| where v is the particle velocity and V is the "velocity field". </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9630057bd092fce7fb72044a628459af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9630057bd092fce7fb72044a628459af">&#9670;&nbsp;</a></span>addParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ItoSolver::WhichContainer C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::addParticles </td>
          <td>(</td>
          <td class="paramtype">ListBox&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_inputParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_destructive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add particles to a contain. This adds into a specific grid level and patch. The user can delete the input particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_inputParticles</td><td>Input particles &ndash; can be destroyed if a_destructive=true </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_destructive</td><td>If true, delete the input particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad53e954337a6c4fdb8a84ce9f71760c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53e954337a6c4fdb8a84ce9f71760c0">&#9670;&nbsp;</a></span>allocateInternals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::allocateInternals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate internal storage. </p>
<p>This will allocate the required mesh data as well as all the particle data holders. </p><dl class="section note"><dt>Note</dt><dd>Storage for diffusion and advection fields are only allocate if the species is diffusive/mobile. </dd></dl>

</div>
</div>
<a id="a6fee60a86508b6ce121dea757f6a3144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fee60a86508b6ce121dea757f6a3144">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="CD__ParticleContainer_8H.html#a1c6735e2399c488ebf37f5e96aea95c3">AMRParticles</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear particles &ndash; this will deleted all the particles in the input container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container to be emptied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad10a4355f45e56bd7b5a971b1173db1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10a4355f45e56bd7b5a971b1173db1d">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a particle container &ndash; this will delete all the particles in the input container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_whichContainer</td><td>Particle container to be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5766b96846e5e5f1b152e42aa752dd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5766b96846e5e5f1b152e42aa752dd53">&#9670;&nbsp;</a></span>clear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a particle container &ndash; this will delete all the particles in the input container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container to be emptied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8db7d60bcd16f77dd52d064b231be4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8db7d60bcd16f77dd52d064b231be4f">&#9670;&nbsp;</a></span>coarseFineIncrement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::coarseFineIncrement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>m_massDifference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the coarse-fine redist with mass difference (only for EB x CF) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_massDifference</td><td>mass to be redistributed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3ac7d9fa5f802806c12d667c1892a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ac7d9fa5f802806c12d667c1892a5d">&#9670;&nbsp;</a></span>coarseFineRedistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::coarseFineRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do coarse-fine mass redistribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>Data to be redistributed into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abafa5edfbb02fcab67e2e2e7da5a1ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafa5edfbb02fcab67e2e2e7da5a1ce0">&#9670;&nbsp;</a></span>computeAdvectiveDt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeAdvectiveDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the drift dt. This computes the minimum dt = dx/vMax on the input level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42432c4f69f66dfca9a5c74784664167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42432c4f69f66dfca9a5c74784664167">&#9670;&nbsp;</a></span>computeAdvectiveDt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeAdvectiveDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the drift dt. This computes the minimum dt = dx/vMax on one level and one box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac2d8c9dd1664655f32cf424f5519316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2d8c9dd1664655f32cf424f5519316">&#9670;&nbsp;</a></span>computeAverageDiffusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::computeAverageDiffusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute average diffusion coefficient. </p>
<p>This computes the average diffusion coefficient as D_avg = sum(mass*D)/sum(mass) by depositing on the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e4ccc50baf7d8feff3912509de45dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4ccc50baf7d8feff3912509de45dff">&#9670;&nbsp;</a></span>computeAverageEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::computeAverageEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute average particle energy.. </p>
<p>This computes the average energy as E_avg = sum(mass*energy)/sum(mass) by depositing on the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a822e0c67d9f19c88a1959d07e8c8b4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822e0c67d9f19c88a1959d07e8c8b4f2">&#9670;&nbsp;</a></span>computeAverageMobility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::computeAverageMobility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute average mobility. </p>
<p>This computes the average mobility as mu_avg = sum(mass*mu)/sum(mass) by depositing on the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb099bd8a10e78857d024d26f7b6570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb099bd8a10e78857d024d26f7b6570">&#9670;&nbsp;</a></span>computeDiffusiveDt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDiffusiveDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles on the input level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a040479280a818cbe4947529d7651ce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040479280a818cbe4947529d7651ce1c">&#9670;&nbsp;</a></span>computeDiffusiveDt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDiffusiveDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles on the input grid patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fad5fa4823fa70c9722b863ab3e35f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fad5fa4823fa70c9722b863ab3e35f5">&#9670;&nbsp;</a></span>computeDt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a time step for the advance &ndash; this calls the level function. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not have a fundamental time step limitation, so these limits "replicate" the time step selections in a 1D fluid model. If we only use advection advection the time step is computed as dt = dx/Vmax = dtA, where Vmax is the largest velocity component along any of the directions. If only diffusion is active the time step is computed as dt = (dx*dx)/(2*D) = dtD. If both advection and diffusion are active the time step is computed as dt = 1/(1/dtA + 1/dtD). </p>

</div>
</div>
<a id="a0fe18ba36b867d4ddc70f686dd977ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe18ba36b867d4ddc70f686dd977ab7">&#9670;&nbsp;</a></span>computeDt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a time step for the advance &ndash; this returns the maximum permitted time step on the input grid level. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not have a fundamental time step limitation, so these limits "replicate" the time step selections in a 1D fluid model. If we only use advection advection the time step is computed as dt = dx/Vmax = dtA, where Vmax is the largest velocity component along any of the directions. If only diffusion is active the time step is computed as dt = (dx*dx)/(2*D) = dtD. If both advection and diffusion are active the time step is computed as dt = 1/(1/dtA + 1/dtD). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41787bfa9dd5767989a63e7782e50e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41787bfa9dd5767989a63e7782e50e9">&#9670;&nbsp;</a></span>computeDt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a time step for the advance &ndash; this returns the maximum permitted time step on the input grid patch. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not have a fundamental time step limitation, so these limits "replicate" the time step selections in a 1D fluid model. If we only use advection advection the time step is computed as dt = dx/Vmax = dtA, where Vmax is the largest velocity component along any of the directions. If only diffusion is active the time step is computed as dt = (dx*dx)/(2*D) = dtD. If both advection and diffusion are active the time step is computed as dt = 1/(1/dtA + 1/dtD). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40f48f81560c8a7d1c3952303187e519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f48f81560c8a7d1c3952303187e519">&#9670;&nbsp;</a></span>computeHopDt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeHopDt </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_maxCellsToMove</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on any grid level. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not a fundamental time step limitation, so this function does its best at computing a time step such that the particles do not move more than the specified amount of grid cells. If only advection is active the time step is computed as dt = a_maxCellsToMove * dx/vMax where vMax is the largest velocity component. If only diffusion is active the usual kernel is dX = dWt which yields a "hop" of length L_d = sqrt(2*D*dt)*N0 where N0 is the diffusion hop in one of the coordinates. We do not need to worry about SpaceDim-related corrections because the hops in each direction are independent, so solving for dt we find dtD = L_d^2/(2*D*N0^2). If both advectino and diffusion are active then we can move up to L_d = v_d*dt + sqrt(2*D*dt)*N0 in any one coordinate direction (this is the usual Ito kernel). This requires a solution to a quadratic equation. Fortunately, this is easy to solve for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxCellsToMove</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17ea187e51e51e3623459068cc281b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ea187e51e51e3623459068cc281b14">&#9670;&nbsp;</a></span>computeHopDt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeHopDt </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_maxCellsToMove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on the input grid level. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not a fundamental time step limitation, so this function does its best at computing a time step such that the particles do not move more than the specified amount of grid cells. If only advection is active the time step is computed as dt = a_maxCellsToMove * dx/vMax where vMax is the largest velocity component. If only diffusion is active the usual kernel is dX = dWt which yields a "hop" of length L_d = sqrt(2*D*dt)*N0 where N0 is the diffusion hop in one of the coordinates. We do not need to worry about SpaceDim-related corrections because the hops in each direction are independent, so solving for dt we find dtD = L_d^2/(2*D*N0^2). If both advectino and diffusion are active then we can move up to L_d = v_d*dt + sqrt(2*D*dt)*N0 in any one coordinate direction (this is the usual Ito kernel). This requires a solution to a quadratic equation. Fortunately, this is easy to solve for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxCellsToMove</td><td>Maximum number of cells to move with a standard Ito kernel dX = v*dt + sqrt(2*D*dt)*N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab053c9b08666c62e4527258f7762793c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab053c9b08666c62e4527258f7762793c">&#9670;&nbsp;</a></span>computeHopDt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeHopDt </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_maxCellsToMove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on the input grid level. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not a fundamental time step limitation, so this function does its best at computing a time step such that the particles do not move more than the specified amount of grid cells. If only advection is active the time step is computed as dt = a_maxCellsToMove * dx/vMax where vMax is the largest velocity component. If only diffusion is active the usual kernel is dX = dWt which yields a "hop" of length L_d = sqrt(2*D*dt)*N0 where N0 is the diffusion hop in one of the coordinates. We do not need to worry about SpaceDim-related corrections because the hops in each direction are independent, so solving for dt we find dtD = L_d^2/(2*D*N0^2). If both advectino and diffusion are active then we can move up to L_d = v_d*dt + sqrt(2*D*dt)*N0 in any one coordinate direction (this is the usual Ito kernel). This requires a solution to a quadratic equation. Fortunately, this is easy to solve for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxCellsToMove</td><td>Maximum number of cells to move with a standard Ito kernel dX = v*dt + sqrt(2*D*dt)*N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4dd656605d24d6171dd291bb20ab7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dd656605d24d6171dd291bb20ab7d4">&#9670;&nbsp;</a></span>computeLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::computeLoads </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_loads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DisjointBoxLayout &amp;&#160;</td>
          <td class="paramname"><em>a_dbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute particle load on a specific grid level &ndash; this will compute the number of particles in each box in the input grids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_loads</td><td>Loads on each grid patch. This follows the order from a_dbl.boxArray() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dbl</td><td>Grids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cfc0f7ef17ef6e11187ea8bee622fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfc0f7ef17ef6e11187ea8bee622fdf">&#9670;&nbsp;</a></span>depositConductivity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositConductivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit conductivities (i.e. mass*mobility / volume) </p>
<p>This deposits mass*mobility (not multiplied by charge) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls the other versions with a_deposition = m_deposition </dd></dl>

</div>
</div>
<a id="a87309b80ec7dec1b74b1626ca2f4d700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87309b80ec7dec1b74b1626ca2f4d700">&#9670;&nbsp;</a></span>depositConductivity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositConductivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit conductivities (i.e. mass*mobility / volume) </p>
<p>This deposits mass*mobility (not multiplied by charge) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce12aab2e784f8ccaf8c316513c7623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce12aab2e784f8ccaf8c316513c7623">&#9670;&nbsp;</a></span>depositDiffusivity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositDiffusivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit diffusivity (i.e. mass*D/volume) </p>
<p>This deposits mass*diffusion (not multiplied by charge) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls the other versions with a_deposition = m_deposition </dd></dl>

</div>
</div>
<a id="a13d1a25cbe12b84279f9a86911ab1019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d1a25cbe12b84279f9a86911ab1019">&#9670;&nbsp;</a></span>depositDiffusivity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositDiffusivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit diffusivity (i.e. mass*D/volume) </p>
<p>This deposits mass*mobility (not multiplied by charge) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33cfd08a3c53d5c4104665d8e1646ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33cfd08a3c53d5c4104665d8e1646ce3">&#9670;&nbsp;</a></span>depositEnergyDensity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositEnergyDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit energy densities (i.e. mass*energy/volume =&gt; total energy per unit volume) </p>
<p>This deposits mass*energy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls the other versions with a_deposition = m_deposition </dd></dl>

</div>
</div>
<a id="aa30867cb13ca546b8729ee29db273ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30867cb13ca546b8729ee29db273ac9">&#9670;&nbsp;</a></span>depositEnergyDensity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositEnergyDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit energy densities (i.e. mass*energy/volume =&gt; total energy per unit volume) </p>
<p>This deposits mass*energy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac2b82ed36f44539366b43564e352846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2b82ed36f44539366b43564e352846">&#9670;&nbsp;</a></span>depositHybrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositHybrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_depositionH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_massDifference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_depositionNC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the "hybrid" deposition phiH = kappa*phiC + (1-kappa)*phiNC. On input, a_depositionH should contain phiC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_depositionH</td><td>On input, contains phiC. On output, contain phiH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_massDifference</td><td>On output, contains mass loss in each cut-cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionNC</td><td>The "non-conservative" deposited variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a72bc36aaac4eaff69df185bd8159a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a72bc36aaac4eaff69df185bd8159a4">&#9670;&nbsp;</a></span>depositKappaConservative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositKappaConservative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cell-centered deposition &ndash; this is the main deposition function. </p>
<p>The template parameters indicate the particle type and quantity to be deposited. The second template parameter must be a pointer to a member function in the particle class with signature 'const Real&amp; P::function() const'. E.g. 'const Real&amp; P::mass() const' which is the default quantity to be deposited. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Cell-centered mesh data. Must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The coarse-fine deposition is handled internally in this routine (through parameters m_pvrBuffer and m_haloBuffer) </dd></dl>

</div>
</div>
<a id="a1a72bc36aaac4eaff69df185bd8159a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a72bc36aaac4eaff69df185bd8159a4">&#9670;&nbsp;</a></span>depositKappaConservative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositKappaConservative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cell-centered deposition &ndash; this is the main deposition function. </p>
<p>Just like the version above except that the function signature is Real P::particleScalarField() const. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Cell-centered mesh data. Must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The coarse-fine deposition is handled internally in this routine (through parameters m_pvrBuffer and m_haloBuffer) </dd></dl>

</div>
</div>
<a id="a1f6778295d539cd8d0224bf2615e93bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6778295d539cd8d0224bf2615e93bb">&#9670;&nbsp;</a></span>depositNonConservative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositNonConservative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_depositionNC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_depositionKappaC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the "non-conservative" kappa deposition &ndash; computing depositionNC = sum(kappa*depositionC)/sum(kappa) in a neighborhood around each vof. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_depositionNC</td><td>Non-conservative deposition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionKappaC</td><td>Conserved deposition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18a43e827b7b8e1776cf9e4572ccf6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a43e827b7b8e1776cf9e4572ccf6a0">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit particles onto mesh. </p>
<p>This will deposit the mass (i.e., computational weight) "bulk" particles into m_phi. </p><dl class="section note"><dt>Note</dt><dd>Cells the other version with a_container = WhichContainer::Bulk </dd></dl>

</div>
</div>
<a id="a83fa3e39b93d9f4abf3c8ca352c61d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fa3e39b93d9f4abf3c8ca352c61d02">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit particles on to mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to deposit.</td></tr>
  </table>
  </dd>
</dl>
<p>This will deposit mass (i.e., computational weight) of the the input particle container particles onto the classes member 'm_phi'. </p><dl class="section note"><dt>Note</dt><dd>Calls the general version with arguments: m_phi, m_particles.at(a_container), m_deposition. </dd></dl>

</div>
</div>
<a id="a28f62e0f408437165ecd79bd061d6612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f62e0f408437165ecd79bd061d6612">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic deposition function which deposits a particle field onto the mesh using a specified deposition method. </p>
<p>The template parameters indicate the particle type and quantity to be deposited. The second template parameter must be a pointer to a member function in the particle class with signature 'const Real&amp; P::function() const'. E.g. 'const Real&amp; P::mass() const' which is the default quantity to be deposited. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data &ndash; must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The coarse-fine deposition handling is defined by the input parameters in m_pvrBuffer, m_haloBuffer, and m_forceIrregHaloNGP (see the class documentation). </dd></dl>

</div>
</div>
<a id="a28f62e0f408437165ecd79bd061d6612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f62e0f408437165ecd79bd061d6612">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic deposition function which deposits a particle field onto the mesh using a specified deposition method. </p>
<p>Just like the version above, but with a different function signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data &ndash; must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The coarse-fine deposition handling is defined by the input parameters in m_pvrBuffer, m_haloBuffer, and m_forceIrregHaloNGP (see the class documentation). </dd></dl>

</div>
</div>
<a id="a803e769f2adeed3b1a2f2b9d40c2422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803e769f2adeed3b1a2f2b9d40c2422f">&#9670;&nbsp;</a></span>drawNewParticles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::drawNewParticles </td>
          <td>(</td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newPPC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restart particles from a specified number of particles in the grid cell. </p>
<p>This will instantiate the bulk particles by randomly drawing new particles in each grid cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Mesh data showing how many particles are in each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newPPC</td><td>Desired number of computational particles per cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6205a79851e8e13fee2fd0edc2b48c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6205a79851e8e13fee2fd0edc2b48c9">&#9670;&nbsp;</a></span>getDeposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> ItoSolver::getDeposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get deposition method. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_deposition </dd></dl>

</div>
</div>
<a id="adb760819f334c0b3af7535108b7366d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb760819f334c0b3af7535108b7366d0">&#9670;&nbsp;</a></span>getDiffusionFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getDiffusionFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the diffusion function. </p>
<dl class="section return"><dt>Returns</dt><dd>m_diffusionFunction </dd></dl>

</div>
</div>
<a id="ad9c71c977fb7130e83a8d557817dea6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c71c977fb7130e83a8d557817dea6b">&#9670;&nbsp;</a></span>getDiffusionFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a>&amp; ItoSolver::getDiffusionFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the diffusion function. </p>
<dl class="section return"><dt>Returns</dt><dd>m_diffusionFunction </dd></dl>

</div>
</div>
<a id="a1f6982f82df0a04d2f325f1e84899a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6982f82df0a04d2f325f1e84899a37">&#9670;&nbsp;</a></span>getHaloBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ItoSolver::getHaloBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the halo buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_haloBuffer </dd></dl>

</div>
</div>
<a id="aef5ad3bcb9a19cd08ae6c3172cfa43d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5ad3bcb9a19cd08ae6c3172cfa43d0">&#9670;&nbsp;</a></span>getMobilityFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getMobilityFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get mobility function. </p>
<dl class="section return"><dt>Returns</dt><dd>m_mobilityFunction </dd></dl>

</div>
</div>
<a id="a67a6184b2efe0c515f0782438f1ce874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a6184b2efe0c515f0782438f1ce874">&#9670;&nbsp;</a></span>getMobilityFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a>&amp; ItoSolver::getMobilityFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get mobility function. </p>
<dl class="section return"><dt>Returns</dt><dd>m_mobilityFunction </dd></dl>

</div>
</div>
<a id="a6e6fcdccd99f9369d87b8e74646f0296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6fcdccd99f9369d87b8e74646f0296">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ItoSolver::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this solver's name. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_name </dd></dl>

</div>
</div>
<a id="ad0938b394aa25ddeac394ecce5d2b474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0938b394aa25ddeac394ecce5d2b474">&#9670;&nbsp;</a></span>getNumberOfPlotVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ItoSolver::getNumberOfPlotVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of plot variables. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of plot variables (Note: Scalars-&gt; one variable and vectors -&gt; SpaceDim variables). </dd></dl>

</div>
</div>
<a id="af0cdb1b9e287c948e6b1c6ad1c0e0709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cdb1b9e287c948e6b1c6ad1c0e0709">&#9670;&nbsp;</a></span>getNumParticles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ItoSolver::getNumParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_localOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of particles in a specified particle container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_whichContainer</td><td>Which container to count particles in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_localOnly</td><td>Only report local particles (i.e. not reduced over MPI ranks) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a754df1d59ab75675768b1fdba4ce759a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754df1d59ab75675768b1fdba4ce759a">&#9670;&nbsp;</a></span>getParticles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp; ItoSolver::getParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a general particle container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to fetch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83b5921e65afb1442dc9a71ef2c83d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b5921e65afb1442dc9a71ef2c83d55">&#9670;&nbsp;</a></span>getParticles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp; ItoSolver::getParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a general particle container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to fetch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0728c740c0a9ced2691f193057b384fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0728c740c0a9ced2691f193057b384fa">&#9670;&nbsp;</a></span>getPhase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">phase::which_phase ItoSolver::getPhase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return phase. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_phase </dd></dl>

</div>
</div>
<a id="aa426b09943223c61f0a9a5c51ddb8822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa426b09943223c61f0a9a5c51ddb8822">&#9670;&nbsp;</a></span>getPhi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getPhi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mesh data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_phi </dd></dl>

</div>
</div>
<a id="a113c01d977f92e8048729f259cf32b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113c01d977f92e8048729f259cf32b81">&#9670;&nbsp;</a></span>getPlotVariableNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; std::string &gt; ItoSolver::getPlotVariableNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get output plot names. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a string of all variables that this solver can add to plot files. </dd></dl>

</div>
</div>
<a id="a815471c6b6c7e1aeb636aab2ea0e3877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815471c6b6c7e1aeb636aab2ea0e3877">&#9670;&nbsp;</a></span>getPVRBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ItoSolver::getPVRBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get PVR buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_pvrBuffer </dd></dl>

</div>
</div>
<a id="aa314653552338b3a526f5241bf874f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa314653552338b3a526f5241bf874f0d">&#9670;&nbsp;</a></span>getRealm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string ItoSolver::getRealm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the realm where this solver is registered. </p>
<dl class="section return"><dt>Returns</dt><dd>m_realm </dd></dl>

</div>
</div>
<a id="a1ca0e379935bc11a7bf6bd2be06f8b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca0e379935bc11a7bf6bd2be06f8b05">&#9670;&nbsp;</a></span>getScratch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getScratch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get scratch storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_scratch </dd></dl>

</div>
</div>
<a id="acaa4cde66efccaa860a1c1fe4bf3db78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa4cde66efccaa860a1c1fe4bf3db78">&#9670;&nbsp;</a></span>getScratch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a>&amp; ItoSolver::getScratch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get scratch storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_scratch </dd></dl>

</div>
</div>
<a id="acab7ee2c7496bdad4c5331b4ccf84952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab7ee2c7496bdad4c5331b4ccf84952">&#9670;&nbsp;</a></span>getSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt; &amp; ItoSolver::getSpecies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the species. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_species </dd></dl>

</div>
</div>
<a id="ae5321417dad2ee4db572060f86421a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5321417dad2ee4db572060f86421a7a">&#9670;&nbsp;</a></span>getVelocityFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getVelocityFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cell-centered velocity mesh data. </p>
<dl class="section return"><dt>Returns</dt><dd>m_velocityFunction </dd></dl>

</div>
</div>
<a id="abe09b54f8bbf8db61b86e8be2e3d1508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe09b54f8bbf8db61b86e8be2e3d1508">&#9670;&nbsp;</a></span>getVelocityFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a>&amp; ItoSolver::getVelocityFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cell-centered velocity mesh data. </p>
<dl class="section return"><dt>Returns</dt><dd>m_velocityFunction </dd></dl>

</div>
</div>
<a id="af150e243cbc08c6359b9218338676d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af150e243cbc08c6359b9218338676d30">&#9670;&nbsp;</a></span>incrementRedist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::incrementRedist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_massDifference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment redistribution objects with mass to be redistributed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_massDifference</td><td>mass to be redistributed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc86cb62b622c8ddfd0b7fb1601afda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc86cb62b622c8ddfd0b7fb1601afda7">&#9670;&nbsp;</a></span>initialData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::initialData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the initial data. </p>
<p>This will add the initial particles and deposit them. </p>

</div>
</div>
<a id="a64b5e34d86ab0286807678c7f753f57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b5e34d86ab0286807678c7f753f57e">&#9670;&nbsp;</a></span>interpolateDiffusion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateDiffusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the diffusion field to the particle positions. </p>
<p>This computes D_p = Df(X_p) where Df is the diffusion field on the mesh. </p>

</div>
</div>
<a id="aef3ef423300841c7a94bdb2ccd248189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3ef423300841c7a94bdb2ccd248189">&#9670;&nbsp;</a></span>interpolateDiffusion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateDiffusion </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the diffusion field to the particle positions. </p>
<p>This computes D_p = Df(X_p) where Df is the diffusion field on the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06df3eb32ebb71b1858298b2b0d7dd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df3eb32ebb71b1858298b2b0d7dd0b">&#9670;&nbsp;</a></span>interpolateMobilities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateMobilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate mobilities. </p>
<p>This will switch between the two ways of computing the particle mobility. </p>

</div>
</div>
<a id="afe6615c33886b26c602e0908b6069a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6615c33886b26c602e0908b6069a1e">&#9670;&nbsp;</a></span>interpolateMobilities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateMobilities </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate mobilities &ndash; this will switch between the two ways of computing the particle mobility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23f7f9fdcaf5fcca2917480d9896b621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f7f9fdcaf5fcca2917480d9896b621">&#9670;&nbsp;</a></span>interpolateMobilitiesDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateMobilitiesDirect </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly interpolate mobilities. Interpolates for all particles in the specified grid patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11980419f7695d872a83885be0f20494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11980419f7695d872a83885be0f20494">&#9670;&nbsp;</a></span>interpolateMobilitiesVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateMobilitiesVelocity </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate mobilities through the velocity. Interpolates for all particles in the specified grid patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58a6d5963c8a82dca1aa2868e0988b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a6d5963c8a82dca1aa2868e0988b75">&#9670;&nbsp;</a></span>interpolateVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateVelocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the particle velocities. </p>
<p>This will compute the particle velocities as v = mu * V(Xp) where mu is the particle mobility and V(Xp) is the interpolation of m_velocityFunction to the particle position. </p>

</div>
</div>
<a id="a4f927ad3700a86bb8eaabb11912f81a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f927ad3700a86bb8eaabb11912f81a9">&#9670;&nbsp;</a></span>interpolateVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateVelocities </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the particle velocities. </p>
<p>This will compute the particle velocities as v = mu * V(Xp) where mu is the particle mobility and V(Xp) is the interpolation of m_velocityFunction to the particle position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71390b209f25e33c1a8286f846f215ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71390b209f25e33c1a8286f846f215ab">&#9670;&nbsp;</a></span>intersectParticles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::intersectParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="CD__EbIntersection_8H.html#a187992258b18205389b013d6dd06e804">EbIntersection</a>&#160;</td>
          <td class="paramname"><em>a_ebIntersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do boundary intersection tests. </p>
<p>This will intersect the particles in the "bulk" particles data holder with the domain faces and EBs. If a particle crossed the EB it will be put into the "EB" particle data holder and likewise for the particles that crossed the domain side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebIntersection</td><td>Enum for switching between various types of intersection tests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, the origin particle will also be removed from the bulk particle data holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will call the other version with WhichContainer::Bulk, WhichContainer::EB, and WhichContainer::Domain. </dd></dl>

</div>
</div>
<a id="a474240bfb7066826513828984aff09ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474240bfb7066826513828984aff09ae">&#9670;&nbsp;</a></span>intersectParticles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::intersectParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_ebParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_domainParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EbIntersection_8H.html#a187992258b18205389b013d6dd06e804">EbIntersection</a>&#160;</td>
          <td class="paramname"><em>a_ebIntersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do boundary intersection tests. </p>
<p>This will intersect the particles in the a_particles data holder with the domain faces and EBs. If a particle crossed the EB it will be put into the a_eb_particles particle data holder and likewise for the particles that crossed the domain side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Which particle container to use for the "active" particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebParticles</td><td>Which particle container to put the EB particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainParticles</td><td>Which particle container to put the domain particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebIntersection</td><td>Enum for switching between various types of intersection tests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, the origin particle will also be removed from the bulk particle data holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will look up the <a class="el" href="classParticleContainer.html" title="Templated class for holding particles on an AMR hierarchy with particle remapping.">ParticleContainer</a> and call the other version. </dd></dl>

</div>
</div>
<a id="a507e376a5b3a88d281a6144952b6b2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507e376a5b3a88d281a6144952b6b2f9">&#9670;&nbsp;</a></span>intersectParticles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::intersectParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domainParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EbIntersection_8H.html#a187992258b18205389b013d6dd06e804">EbIntersection</a>&#160;</td>
          <td class="paramname"><em>a_ebIntersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do boundary intersection tests. </p>
<p>This will intersect the particles in the a_particles data holder with the domain faces and EBs. If a particle crossed the EB it will be put into the a_eb_particles particle data holder and likewise for the particles that crossed the domain side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Which particle container to use for the "active" particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebParticles</td><td>Which particle container to put the EB particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainParticles</td><td>Which particle container to put the domain particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebIntersection</td><td>Enum for switching between various types of intersection tests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, the origin particle will also be removed from the bulk particle data holder. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1db74cb60c15142ce2729deb9179a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1db74cb60c15142ce2729deb9179a31">&#9670;&nbsp;</a></span>isDiffusive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ItoSolver::isDiffusive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if solver is diffusive. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_isDiffusive </dd></dl>

</div>
</div>
<a id="a8967ce2dec5194a8d54e0dd7e4acec08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8967ce2dec5194a8d54e0dd7e4acec08">&#9670;&nbsp;</a></span>isMobile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ItoSolver::isMobile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if solver is mobile. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_isMobile </dd></dl>

</div>
</div>
<a id="ad163ae5e22e548b23e2e932f05b57392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad163ae5e22e548b23e2e932f05b57392">&#9670;&nbsp;</a></span>levelRedist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::levelRedist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do redistribution on all levels, no coarse-fine stuff. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>Data to be redistributed into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90e0d074046485949984c3c074d1fe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e0d074046485949984c3c074d1fe58">&#9670;&nbsp;</a></span>makeSuperparticles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::makeSuperparticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make superparticles for a full container &ndash; this is the AMR version that users will usually call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to repartition into new superparticles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc59aabefa256470657b9c0087725c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc59aabefa256470657b9c0087725c20">&#9670;&nbsp;</a></span>makeSuperparticles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::makeSuperparticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make superparticles for a particle container &ndash; this is used for a specified grid level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to repartition into new superparticles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0cb1432cb164650e8b71c4c5657fb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb1432cb164650e8b71c4c5657fb36">&#9670;&nbsp;</a></span>makeSuperparticles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::makeSuperparticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerPatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make superparticles for a particle container &ndash; this is used for a specified grid level and patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to repartition into new superparticles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53064ecb380ff57c7fc6f666daef30a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53064ecb380ff57c7fc6f666daef30a3">&#9670;&nbsp;</a></span>mergeBVH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::mergeBVH </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Superparticle merging with BVH trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be merged/split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30eb3e95dfee2010652368ce894bda9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30eb3e95dfee2010652368ce894bda9d">&#9670;&nbsp;</a></span>preRegrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::preRegrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pre-regrid operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lbase</td><td>Coarsest level that changed during regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest grid level before the regrid operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This caches the bulk particles. </dd></dl>

</div>
</div>
<a id="a019fa52c90f664f338441ae58ee891cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019fa52c90f664f338441ae58ee891cf">&#9670;&nbsp;</a></span>randomDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealVect ItoSolver::randomDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a random direction in N-dimensional space. </p>
<p>We use the algorithm by Marsaglia (1972). </p>

</div>
</div>
<a id="a77cbe509c51f4fce01400a105760b1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cbe509c51f4fce01400a105760b1e9">&#9670;&nbsp;</a></span>randomGaussian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealVect ItoSolver::randomGaussian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a random N-dimensional Gaussian number from a normal distribution with zero with and unit standard deviation. </p>
<dl class="section note"><dt>Note</dt><dd>The distribution is truncated at m_normalDistributionTruncation &ndash; values above that threshold will be replaced by m_normalDistributionTruncation. </dd></dl>

</div>
</div>
<a id="a8d1685c620081632e849d9dd2bc87ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1685c620081632e849d9dd2bc87ffe">&#9670;&nbsp;</a></span>randomPosition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealVect ItoSolver::randomPosition </td>
          <td>(</td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_cellPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_bndryCentroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_kappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a random position physical somewhere in a grid cell. </p>
<p>This is the version that respects cut-cells &ndash; it will draw a position (through rejection sampling) such that the particle ends up on the correct side of the EB. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellPos</td><td>Cell-center position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lo</td><td>Lower-left corner of volume that encloses the cut-cell. This is relative to the unit cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hi</td><td>Upper-right corner of volume that encloses the cut-cell. This is relative to the unit cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_bndryCentroid</td><td>EB centroid position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_normal</td><td>EB normal (points into the fluid region) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_kappa</td><td>Cell volume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f2c856e17b3820aafb09a4ee1737390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2c856e17b3820aafb09a4ee1737390">&#9670;&nbsp;</a></span>randomPosition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealVect ItoSolver::randomPosition </td>
          <td>(</td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a random position in the cube (a_lo, a_hi);. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lo</td><td>Lower-left corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hi</td><td>Upper-right corner </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a686244537fc296dcaf1ae3cf30563a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686244537fc296dcaf1ae3cf30563a16">&#9670;&nbsp;</a></span>randomPosition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealVect ItoSolver::randomPosition </td>
          <td>(</td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_bndryCentroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a random position somewhere in a cut-cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lo</td><td>Lower-left corner of volume that encloses the cut-cell. This is relative to the unit cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_hi</td><td>Upper-right corner of volume that encloses the cut-cell. This is relative to the unit cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_bndryCentroid</td><td>EB centroid position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_normal</td><td>EB normal (points into the fluid region) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a position inside the cut-cell and on the correct side of the EB. </dd></dl>

</div>
</div>
<a id="ad599086b015754fd8dc25f94ba0b686d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad599086b015754fd8dc25f94ba0b686d">&#9670;&nbsp;</a></span>redistributeAMR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::redistributeAMR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redistribute mass in an AMR context. </p>
<p>We will have deposited particles into each cell, i.e. phi_i = m_i/dx^3. To obtain the true density in an EB context we need to divide by kappa such that phi_i = m_i/(kappa_i*dx^3). Unfortunately, this is numerically unstable because kappa_i can be arbitrarily small. We can set the density as phi_i = m_i/dx^3 but we will be missing a mass m_i*(1-kappa_i) from the cell. This mass can be smooshed into neighboring cells such as to make the total scheme conservative. As an option, we can also use a "non-conservative" divergence but the scheme is not guaranteed to be non-negative. All of this is just to say that we take the mass that fell inside the EB and put it back into the domain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>Quantity to be redistributed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a174efc0134a7417f1afa737b8f328d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174efc0134a7417f1afa737b8f328d16">&#9670;&nbsp;</a></span>registerOperators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::registerOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register operators. </p>
<p>This will register the required operators for running this class. </p>

</div>
</div>
<a id="a2ec90d5f802b40a624d7aa0be36a6f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec90d5f802b40a624d7aa0be36a6f6d">&#9670;&nbsp;</a></span>regrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::regrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regrid this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level where grids did not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest AMR level before the regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>Finest AMR level after the regrid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b2ffd6f216e2fe3fc1b7d69134cd941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2ffd6f216e2fe3fc1b7d69134cd941">&#9670;&nbsp;</a></span>remap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::remap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap all particles in the input container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Particle container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1478e53aa80da3b4ef0e4e6c779accf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1478e53aa80da3b4ef0e4e6c779accf3">&#9670;&nbsp;</a></span>removeCoveredParticles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::removeCoveredParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove particles that are inside the EB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls the other version with m_particles. </p>

</div>
</div>
<a id="acf0cfd8c327d593f16ee71d546cccdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0cfd8c327d593f16ee71d546cccdf8">&#9670;&nbsp;</a></span>removeCoveredParticles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::removeCoveredParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove particles that are inside the EB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which particle container to remove particles from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls the other version with <a class="el" href="classParticleContainer.html" title="Templated class for holding particles on an AMR hierarchy with particle remapping.">ParticleContainer</a> = m_particles.at(a_container) </dd></dl>

</div>
</div>
<a id="a972f24cc11dc2d60cbfc83f86be683dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972f24cc11dc2d60cbfc83f86be683dc">&#9670;&nbsp;</a></span>removeCoveredParticles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::removeCoveredParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove particles that are inside the EB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a351676445e519924a3054b8433c30001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351676445e519924a3054b8433c30001">&#9670;&nbsp;</a></span>setAmr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setAmr </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_amr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations for streamer equations.">AmrMesh</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_amr</td><td><a class="el" href="classAmrMesh.html" title="Class for handling spatial operations for streamer equations.">AmrMesh</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3174bdfc77666ce0d0a7a46876389365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3174bdfc77666ce0d0a7a46876389365">&#9670;&nbsp;</a></span>setComputationalGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setComputationalGeometry </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_computationalGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set computational geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_computationalGeometry</td><td>Computational geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4426b5a48a8530afb511bec40f6b718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4426b5a48a8530afb511bec40f6b718">&#9670;&nbsp;</a></span>setDiffusionFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setDiffusionFunction </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_diffusionCoefficient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function &ndash; set a constant diffusion coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_diffusionCoefficient</td><td>Diffusion coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b64ad1b376afd86ef2e3a1f8c7d02f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b64ad1b376afd86ef2e3a1f8c7d02f0">&#9670;&nbsp;</a></span>setHaloBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setHaloBuffer </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_haloBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the halo buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_haloBuffer</td><td>Halo buffer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b76fa27520cfcf6b20bc2115cd2c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b76fa27520cfcf6b20bc2115cd2c18">&#9670;&nbsp;</a></span>setParticleDiffusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setParticleDiffusion </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_diffusion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets diffusion coefficient for all particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_diffusion</td><td>Particle diffusion value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a429895a5e10f6830cc6160654684f6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429895a5e10f6830cc6160654684f6e2">&#9670;&nbsp;</a></span>setParticleMobility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setParticleMobility </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_mobility</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets mobility coefficient for all particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mobility</td><td>Particle mobility. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b6b0c77343a02439242f7b9a84949bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6b0c77343a02439242f7b9a84949bf">&#9670;&nbsp;</a></span>setPhase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setPhase </td>
          <td>(</td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set phase where the particles will live. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd6369581fd075bc1688c1a3838328b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6369581fd075bc1688c1a3838328b6">&#9670;&nbsp;</a></span>setPVRBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setPVRBuffer </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_pvrBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the PVR buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_pvrBuffer</td><td>PVR buffer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a953bd44ffab98bb2b7e408194339aeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953bd44ffab98bb2b7e408194339aeca">&#9670;&nbsp;</a></span>setRealm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setRealm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the realm where this solver will live. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a134feb52bf6e0fdb4b0b25cd76b4ef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134feb52bf6e0fdb4b0b25cd76b4ef91">&#9670;&nbsp;</a></span>setSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setSpecies </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_species</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the species. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_species</td><td>Species to be solved for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2293d2a6db7b36a451100e2e8400698f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2293d2a6db7b36a451100e2e8400698f">&#9670;&nbsp;</a></span>setTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setTime </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time for this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_step</td><td>Time step number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_time</td><td>Time (in seconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step increment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets m_step=a_step, m_time=a_time, m_dt=a_dt </dd></dl>

</div>
</div>
<a id="ae8f6cbb8805b459df5a6bcbcb0ff06ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f6cbb8805b459df5a6bcbcb0ff06ea">&#9670;&nbsp;</a></span>setVelocityFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setVelocityFunction </td>
          <td>(</td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_velocity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function &ndash; set a constant velocity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_velocity</td><td>Velocity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa01f68543f9b94f9d083ce3e3ed0339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa01f68543f9b94f9d083ce3e3ed0339">&#9670;&nbsp;</a></span>setVerbosity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setVerbosity </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set verbosity level for this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_verbosity</td><td>Verbosity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e0edd943066ee2e871ce6d5962a5b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0edd943066ee2e871ce6d5962a5b38">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::sign </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign function. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns 1.0 if a &gt; 0 and -1 if a &lt; 0. </dd></dl>

</div>
</div>
<a id="a201369931b6d5e171c836857203b0d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201369931b6d5e171c836857203b0d3f">&#9670;&nbsp;</a></span>sortParticlesByCell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::sortParticlesByCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the input particle container by cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Container to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a998ca9c97dd35a41b9d3de0b9c522115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998ca9c97dd35a41b9d3de0b9c522115">&#9670;&nbsp;</a></span>sortParticlesByPatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::sortParticlesByPatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the input particle container by patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Container to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eea2667b22bfdcb91c27e3349932cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eea2667b22bfdcb91c27e3349932cce">&#9670;&nbsp;</a></span>transferCoveredParticles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::transferCoveredParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer particles that are covered (within a_tol distance from EB) to another container. </p>
<p>Calls the other version with m_particles and m_coveredParticles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af13019b6687845c7e626313b9dc51b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13019b6687845c7e626313b9dc51b59">&#9670;&nbsp;</a></span>transferCoveredParticles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::transferCoveredParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_containerFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_containerTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer particles that are covered (within a_tol distance from EB) to another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_containerFrom</td><td>Which particle container to transfer particles from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_containerFrom</td><td>Which particle container to move particles into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17e9facf86e62b4693736a31efeedb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17e9facf86e62b4693736a31efeedb2">&#9670;&nbsp;</a></span>transferCoveredParticles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::transferCoveredParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EbRepresentation_8H.html#a07b20010dfee95e53d9c9073ca6a6c2b">EbRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer particles that are inside the EB to another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesFrom</td><td>Which particle container to transfer particles from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesTo</td><td>Which particle container to move particles into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d8246f963aa976e49c808a9d963b464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8246f963aa976e49c808a9d963b464">&#9670;&nbsp;</a></span>updateDiffusion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::updateDiffusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update mobilities parametrically from the particle energy. </p>
<p>This calls the diffusion function implemented by <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a>. The particle diffusion is set D = f(p.energy()) where f is the diffusion function in <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a> </p>

</div>
</div>
<a id="ad686ec03d1b90c1f9b2e2bb2e45126bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad686ec03d1b90c1f9b2e2bb2e45126bf">&#9670;&nbsp;</a></span>updateDiffusion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::updateDiffusion </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update mobilities parametrically from the particle energy. </p>
<p>This calls the diffusion function implemented by <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a>. The particle diffusion is set D = f(p.energy()) where f is the diffusion function in <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a877960fbdde4e57f9ce3061fc0bb703f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877960fbdde4e57f9ce3061fc0bb703f">&#9670;&nbsp;</a></span>updateMobilities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::updateMobilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update mobilities parametrically from the particle energy. </p>
<p>This calls the mobility function implemented by <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a>. The particle mobility is set mu = f(p.energy()) where f is the mobility function in <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a> </p>

</div>
</div>
<a id="ac7a9256055022575daeceafe643972f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a9256055022575daeceafe643972f2">&#9670;&nbsp;</a></span>updateMobilities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::updateMobilities </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update mobilities parametrically from the particle energy. </p>
<p>This calls the mobility function implemented by <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a>. The particle mobility is set mu = f(p.energy()) where f is the mobility function in <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04b4155dcf2543bd538e27669e47518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04b4155dcf2543bd538e27669e47518">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_interpToCentroids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to output. Convenience function which just copies data from one data holder to the output data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpToCentroids</td><td>If true, a_data will be interpolated to cell centroids before writing to a_output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3a5eb61b52bbec09e4bf33427855484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a5eb61b52bbec09e4bf33427855484">&#9670;&nbsp;</a></span>writePlotData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::writePlotData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write plot data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will write the plot data in this solver to a_output, starting on a_comp </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4cfbc656f1f16c9b664b25ff0fedd92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfbc656f1f16c9b664b25ff0fedd92a">&#9670;&nbsp;</a></span>m_className</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ItoSolver::m_className</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class name. </p>
<p><a class="el" href="classItoSolver.html" title="Base class for Ito diffusion particle models.">ItoSolver</a> for parent class &ndash; derived classes might be named something else. </p>

</div>
</div>
<a id="a987806a343072c9ed15231c9a371a16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987806a343072c9ed15231c9a371a16e">&#9670;&nbsp;</a></span>m_normalDistributionTruncation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::m_normalDistributionTruncation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncation value for normal distribution. </p>
<p>This is used when drawing numbers from the Gaussian distribution, replacing all values above m_normalDistributionTruncation by m_normalDistributionTruncation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/ItoDiffusion/<a class="el" href="CD__ItoSolver_8H_source.html">CD_ItoSolver.H</a></li>
<li>Source/ItoDiffusion/<a class="el" href="CD__ItoSolver_8cpp.html">CD_ItoSolver.cpp</a></li>
<li>Source/ItoDiffusion/<a class="el" href="CD__ItoSolverImplem_8H_source.html">CD_ItoSolverImplem.H</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
