<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: ItoSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classItoSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ItoSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for Ito diffusion particle models.  
 <a href="classItoSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__ItoSolver_8H_source.html">CD_ItoSolver.H</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ItoSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classItoSolver__coll__graph.png" border="0" usemap="#aItoSolver_coll__map" alt="Collaboration graph"/></div>
<map name="aItoSolver_coll__map" id="aItoSolver_coll__map">
<area shape="rect" title="Base class for Ito diffusion particle models." alt="" coords="164,243,244,269"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="5,95,189,136"/>
<area shape="rect" href="classEBAMRData.html" title="Default class for holding LevelData&lt;T&gt; data across an EBAMR realm." alt="" coords="135,5,273,32"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="214,102,410,129"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a070d75d0d3ac16e04013d25574c1ffa5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> { <br />
&#160;&#160;<b>Bulk</b>
, <b>EB</b>
, <b>Domain</b>
, <b>Source</b>
, <br />
&#160;&#160;<b>Covered</b>
, <b>Scratch</b>
<br />
 }</td></tr>
<tr class="memdesc:a070d75d0d3ac16e04013d25574c1ffa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum class for distinguishing various types of particle containers.  <a href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">More...</a><br /></td></tr>
<tr class="separator:a070d75d0d3ac16e04013d25574c1ffa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69dd704c975e14f67548ccb2433e7c46"><td class="memItemLeft" align="right" valign="top"><a id="a69dd704c975e14f67548ccb2433e7c46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a69dd704c975e14f67548ccb2433e7c46">ItoSolver</a> ()</td></tr>
<tr class="memdesc:a69dd704c975e14f67548ccb2433e7c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor &ndash; user must subsequently set the realm and, parse class options, set the species etc. <br /></td></tr>
<tr class="separator:a69dd704c975e14f67548ccb2433e7c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d05094e1614798857464ab8bc7f728"><td class="memItemLeft" align="right" valign="top"><a id="a73d05094e1614798857464ab8bc7f728"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a73d05094e1614798857464ab8bc7f728">~ItoSolver</a> ()</td></tr>
<tr class="memdesc:a73d05094e1614798857464ab8bc7f728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (does nothing). <br /></td></tr>
<tr class="separator:a73d05094e1614798857464ab8bc7f728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05b92be13086d225ea918350fdb006f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae05b92be13086d225ea918350fdb006f">setParticleMerger</a> (const <a class="el" href="namespaceParticleManagement.html#abb4cc237cfca463592686cabeb3a6f75">ParticleManagement::ParticleMerger</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particleMerger) noexcept</td></tr>
<tr class="memdesc:ae05b92be13086d225ea918350fdb006f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the particle merger. This will get called when merging particles using makeSuperparticles.  <a href="classItoSolver.html#ae05b92be13086d225ea918350fdb006f">More...</a><br /></td></tr>
<tr class="separator:ae05b92be13086d225ea918350fdb006f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6fcdccd99f9369d87b8e74646f0296"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6e6fcdccd99f9369d87b8e74646f0296">getName</a> () const</td></tr>
<tr class="memdesc:a6e6fcdccd99f9369d87b8e74646f0296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this solver's name.  <a href="classItoSolver.html#a6e6fcdccd99f9369d87b8e74646f0296">More...</a><br /></td></tr>
<tr class="separator:a6e6fcdccd99f9369d87b8e74646f0296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa314653552338b3a526f5241bf874f0d"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa314653552338b3a526f5241bf874f0d">getRealm</a> () const</td></tr>
<tr class="memdesc:aa314653552338b3a526f5241bf874f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the realm where this solver is registered.  <a href="classItoSolver.html#aa314653552338b3a526f5241bf874f0d">More...</a><br /></td></tr>
<tr class="separator:aa314653552338b3a526f5241bf874f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953bd44ffab98bb2b7e408194339aeca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a953bd44ffab98bb2b7e408194339aeca">setRealm</a> (const std::string a_realm)</td></tr>
<tr class="memdesc:a953bd44ffab98bb2b7e408194339aeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the realm where this solver will live.  <a href="classItoSolver.html#a953bd44ffab98bb2b7e408194339aeca">More...</a><br /></td></tr>
<tr class="separator:a953bd44ffab98bb2b7e408194339aeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b96f5194246f130a4612b027884a020"><td class="memItemLeft" align="right" valign="top"><a id="a5b96f5194246f130a4612b027884a020"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5b96f5194246f130a4612b027884a020">parseOptions</a> ()</td></tr>
<tr class="memdesc:a5b96f5194246f130a4612b027884a020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse class options. <br /></td></tr>
<tr class="separator:a5b96f5194246f130a4612b027884a020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd193ec875bfd612861cd833cd28fce4"><td class="memItemLeft" align="right" valign="top"><a id="abd193ec875bfd612861cd833cd28fce4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abd193ec875bfd612861cd833cd28fce4">parseRuntimeOptions</a> ()</td></tr>
<tr class="memdesc:abd193ec875bfd612861cd833cd28fce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse class runtime configurable options. <br /></td></tr>
<tr class="separator:abd193ec875bfd612861cd833cd28fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4db75d50c479cd8990a3711e7910c24"><td class="memItemLeft" align="right" valign="top"><a id="ae4db75d50c479cd8990a3711e7910c24"></a>
virtual <a class="el" href="CD__EBIntersection_8H.html#ad8aa543cfc22c9b4f2a6a6dab88ea1e9">EBIntersection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae4db75d50c479cd8990a3711e7910c24">getIntersectionAlgorithm</a> () const noexcept</td></tr>
<tr class="memdesc:ae4db75d50c479cd8990a3711e7910c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the EB-particle intersection algorithm. <br /></td></tr>
<tr class="separator:ae4db75d50c479cd8990a3711e7910c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc86cb62b622c8ddfd0b7fb1601afda7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abc86cb62b622c8ddfd0b7fb1601afda7">initialData</a> ()</td></tr>
<tr class="memdesc:abc86cb62b622c8ddfd0b7fb1601afda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial data.  <a href="classItoSolver.html#abc86cb62b622c8ddfd0b7fb1601afda7">More...</a><br /></td></tr>
<tr class="separator:abc86cb62b622c8ddfd0b7fb1601afda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec90d5f802b40a624d7aa0be36a6f6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2ec90d5f802b40a624d7aa0be36a6f6d">regrid</a> (const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel)</td></tr>
<tr class="memdesc:a2ec90d5f802b40a624d7aa0be36a6f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid this solver.  <a href="classItoSolver.html#a2ec90d5f802b40a624d7aa0be36a6f6d">More...</a><br /></td></tr>
<tr class="separator:a2ec90d5f802b40a624d7aa0be36a6f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f2c8ad146edca5e4d248349fda2afb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa6f2c8ad146edca5e4d248349fda2afb">allocate</a> ()</td></tr>
<tr class="memdesc:aa6f2c8ad146edca5e4d248349fda2afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate internal storage.  <a href="classItoSolver.html#aa6f2c8ad146edca5e4d248349fda2afb">More...</a><br /></td></tr>
<tr class="separator:aa6f2c8ad146edca5e4d248349fda2afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10a4355f45e56bd7b5a971b1173db1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad10a4355f45e56bd7b5a971b1173db1d">clear</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:ad10a4355f45e56bd7b5a971b1173db1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a particle container &ndash; this will delete all the particles in the input container.  <a href="classItoSolver.html#ad10a4355f45e56bd7b5a971b1173db1d">More...</a><br /></td></tr>
<tr class="separator:ad10a4355f45e56bd7b5a971b1173db1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5766b96846e5e5f1b152e42aa752dd53"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5766b96846e5e5f1b152e42aa752dd53">clear</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a5766b96846e5e5f1b152e42aa752dd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a particle container &ndash; this will delete all the particles in the input container.  <a href="classItoSolver.html#a5766b96846e5e5f1b152e42aa752dd53">More...</a><br /></td></tr>
<tr class="separator:a5766b96846e5e5f1b152e42aa752dd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fee60a86508b6ce121dea757f6a3144"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6fee60a86508b6ce121dea757f6a3144">clear</a> (<a class="el" href="CD__ParticleContainer_8H.html#ab57ee0582213ddd8962c5922528275a3">AMRParticles</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a6fee60a86508b6ce121dea757f6a3144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear particles &ndash; this will deleted all the particles in the input container.  <a href="classItoSolver.html#a6fee60a86508b6ce121dea757f6a3144">More...</a><br /></td></tr>
<tr class="separator:a6fee60a86508b6ce121dea757f6a3144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cc85c3c9a7a0327f0a3c6fff256065"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a55cc85c3c9a7a0327f0a3c6fff256065">depositConductivity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a55cc85c3c9a7a0327f0a3c6fff256065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit conductivities (i.e. mass*mobility / volume)  <a href="classItoSolver.html#a55cc85c3c9a7a0327f0a3c6fff256065">More...</a><br /></td></tr>
<tr class="separator:a55cc85c3c9a7a0327f0a3c6fff256065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b82ab687e57ec23328b9b63927ff95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a09b82ab687e57ec23328b9b63927ff95">depositConductivity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition) const</td></tr>
<tr class="memdesc:a09b82ab687e57ec23328b9b63927ff95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit conductivities (i.e. mass*mobility / volume)  <a href="classItoSolver.html#a09b82ab687e57ec23328b9b63927ff95">More...</a><br /></td></tr>
<tr class="separator:a09b82ab687e57ec23328b9b63927ff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fcaf6625351303b1b856ebc6d4c48d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a92fcaf6625351303b1b856ebc6d4c48d">depositDiffusivity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a92fcaf6625351303b1b856ebc6d4c48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit diffusivity (i.e. mass*D/volume)  <a href="classItoSolver.html#a92fcaf6625351303b1b856ebc6d4c48d">More...</a><br /></td></tr>
<tr class="separator:a92fcaf6625351303b1b856ebc6d4c48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21a6fcfd7c586497131343aa00efff5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad21a6fcfd7c586497131343aa00efff5">depositDiffusivity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition) const</td></tr>
<tr class="memdesc:ad21a6fcfd7c586497131343aa00efff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit diffusivity (i.e. mass*D/volume)  <a href="classItoSolver.html#ad21a6fcfd7c586497131343aa00efff5">More...</a><br /></td></tr>
<tr class="separator:ad21a6fcfd7c586497131343aa00efff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab173a4bede9c8cebe09fc7c2d8ec1dc6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab173a4bede9c8cebe09fc7c2d8ec1dc6">depositEnergyDensity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:ab173a4bede9c8cebe09fc7c2d8ec1dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit energy densities (i.e. mass*energy/volume =&gt; total energy per unit volume)  <a href="classItoSolver.html#ab173a4bede9c8cebe09fc7c2d8ec1dc6">More...</a><br /></td></tr>
<tr class="separator:ab173a4bede9c8cebe09fc7c2d8ec1dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d57a8de8deee382a29d713bf7331e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a00d57a8de8deee382a29d713bf7331e2">depositEnergyDensity</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition) const</td></tr>
<tr class="memdesc:a00d57a8de8deee382a29d713bf7331e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit energy densities (i.e. mass*energy/volume =&gt; total energy per unit volume)  <a href="classItoSolver.html#a00d57a8de8deee382a29d713bf7331e2">More...</a><br /></td></tr>
<tr class="separator:a00d57a8de8deee382a29d713bf7331e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65647094a4c039fd19e17dd944297eeb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a65647094a4c039fd19e17dd944297eeb">computeAverageMobility</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a65647094a4c039fd19e17dd944297eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute average mobility.  <a href="classItoSolver.html#a65647094a4c039fd19e17dd944297eeb">More...</a><br /></td></tr>
<tr class="separator:a65647094a4c039fd19e17dd944297eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd134aade2a3035692c1bd26599b157f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abd134aade2a3035692c1bd26599b157f">computeAverageDiffusion</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:abd134aade2a3035692c1bd26599b157f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute average diffusion coefficient.  <a href="classItoSolver.html#abd134aade2a3035692c1bd26599b157f">More...</a><br /></td></tr>
<tr class="separator:abd134aade2a3035692c1bd26599b157f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0140880d0a497f9c2bf6bd3cbb97f2c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0140880d0a497f9c2bf6bd3cbb97f2c0">computeAverageEnergy</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a0140880d0a497f9c2bf6bd3cbb97f2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute average particle energy..  <a href="classItoSolver.html#a0140880d0a497f9c2bf6bd3cbb97f2c0">More...</a><br /></td></tr>
<tr class="separator:a0140880d0a497f9c2bf6bd3cbb97f2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a43e827b7b8e1776cf9e4572ccf6a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a18a43e827b7b8e1776cf9e4572ccf6a0">depositParticles</a> ()</td></tr>
<tr class="memdesc:a18a43e827b7b8e1776cf9e4572ccf6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit particles onto mesh.  <a href="classItoSolver.html#a18a43e827b7b8e1776cf9e4572ccf6a0">More...</a><br /></td></tr>
<tr class="separator:a18a43e827b7b8e1776cf9e4572ccf6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fa3e39b93d9f4abf3c8ca352c61d02"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a83fa3e39b93d9f4abf3c8ca352c61d02">depositParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a83fa3e39b93d9f4abf3c8ca352c61d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposit particles on to mesh.  <a href="classItoSolver.html#a83fa3e39b93d9f4abf3c8ca352c61d02">More...</a><br /></td></tr>
<tr class="separator:a83fa3e39b93d9f4abf3c8ca352c61d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538607e6b1f3f2c9e45b8def6d264bcc"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P ::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a538607e6b1f3f2c9e45b8def6d264bcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a538607e6b1f3f2c9e45b8def6d264bcc">depositParticlesNGP</a> (LevelData&lt; EBCellFAB &gt; &amp;a_output, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const int a_level) const noexcept</td></tr>
<tr class="memdesc:a538607e6b1f3f2c9e45b8def6d264bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an NGP deposit on a specific grid level. Used for IO.  <a href="classItoSolver.html#a538607e6b1f3f2c9e45b8def6d264bcc">More...</a><br /></td></tr>
<tr class="separator:a538607e6b1f3f2c9e45b8def6d264bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538607e6b1f3f2c9e45b8def6d264bcc"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P ::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a538607e6b1f3f2c9e45b8def6d264bcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a538607e6b1f3f2c9e45b8def6d264bcc">depositParticlesNGP</a> (LevelData&lt; EBCellFAB &gt; &amp;a_output, const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const int a_level) const noexcept</td></tr>
<tr class="memdesc:a538607e6b1f3f2c9e45b8def6d264bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an NGP deposit on a specific grid level. Used for IO.  <a href="classItoSolver.html#a538607e6b1f3f2c9e45b8def6d264bcc">More...</a><br /></td></tr>
<tr class="separator:a538607e6b1f3f2c9e45b8def6d264bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6209d584e115b2ae1958409f064bb668"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a6209d584e115b2ae1958409f064bb668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6209d584e115b2ae1958409f064bb668">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles) const</td></tr>
<tr class="memdesc:a6209d584e115b2ae1958409f064bb668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic deposition function which deposits a particle field onto the mesh using a specified deposition method.  <a href="classItoSolver.html#a6209d584e115b2ae1958409f064bb668">More...</a><br /></td></tr>
<tr class="separator:a6209d584e115b2ae1958409f064bb668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b813b27a3f4058f6208d2be5e8cba35"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a0b813b27a3f4058f6208d2be5e8cba35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0b813b27a3f4058f6208d2be5e8cba35">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition) const</td></tr>
<tr class="memdesc:a0b813b27a3f4058f6208d2be5e8cba35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic deposition function which deposits a particle field onto the mesh using a specified deposition method.  <a href="classItoSolver.html#a0b813b27a3f4058f6208d2be5e8cba35">More...</a><br /></td></tr>
<tr class="separator:a0b813b27a3f4058f6208d2be5e8cba35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b813b27a3f4058f6208d2be5e8cba35"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a0b813b27a3f4058f6208d2be5e8cba35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0b813b27a3f4058f6208d2be5e8cba35">depositParticles</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition) const</td></tr>
<tr class="memdesc:a0b813b27a3f4058f6208d2be5e8cba35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic deposition function which deposits a particle field onto the mesh using a specified deposition method.  <a href="classItoSolver.html#a0b813b27a3f4058f6208d2be5e8cba35">More...</a><br /></td></tr>
<tr class="separator:a0b813b27a3f4058f6208d2be5e8cba35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f141c67d4052c5f75426e25e06c8c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae0f141c67d4052c5f75426e25e06c8c1">removeCoveredParticles</a> (const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a> a_representation, const Real a_tol)</td></tr>
<tr class="memdesc:ae0f141c67d4052c5f75426e25e06c8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove particles that are inside the EB.  <a href="classItoSolver.html#ae0f141c67d4052c5f75426e25e06c8c1">More...</a><br /></td></tr>
<tr class="separator:ae0f141c67d4052c5f75426e25e06c8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267ccadc8788c9fafe39a85c0426e1ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a267ccadc8788c9fafe39a85c0426e1ad">removeCoveredParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a> a_representation, const Real a_tol)</td></tr>
<tr class="memdesc:a267ccadc8788c9fafe39a85c0426e1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove particles that are inside the EB.  <a href="classItoSolver.html#a267ccadc8788c9fafe39a85c0426e1ad">More...</a><br /></td></tr>
<tr class="separator:a267ccadc8788c9fafe39a85c0426e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa8089edbe2b6b13cb69b7a303e9685"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aeaa8089edbe2b6b13cb69b7a303e9685">removeCoveredParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a> a_representation, const Real a_tol) const</td></tr>
<tr class="memdesc:aeaa8089edbe2b6b13cb69b7a303e9685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove particles that are inside the EB.  <a href="classItoSolver.html#aeaa8089edbe2b6b13cb69b7a303e9685">More...</a><br /></td></tr>
<tr class="separator:aeaa8089edbe2b6b13cb69b7a303e9685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123d483c4c161b135bb967f3ef65b1ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a123d483c4c161b135bb967f3ef65b1ee">transferCoveredParticles</a> (const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a> a_representation, const Real a_tol)</td></tr>
<tr class="memdesc:a123d483c4c161b135bb967f3ef65b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer particles that are covered (within a_tol distance from EB) to another container.  <a href="classItoSolver.html#a123d483c4c161b135bb967f3ef65b1ee">More...</a><br /></td></tr>
<tr class="separator:a123d483c4c161b135bb967f3ef65b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460d077c67b4d5813e5bfd40558249ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a460d077c67b4d5813e5bfd40558249ee">transferCoveredParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_containerFrom, const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_containerTo, const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a> a_representation, const Real a_tol)</td></tr>
<tr class="memdesc:a460d077c67b4d5813e5bfd40558249ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer particles that are covered (within a_tol distance from EB) to another container.  <a href="classItoSolver.html#a460d077c67b4d5813e5bfd40558249ee">More...</a><br /></td></tr>
<tr class="separator:a460d077c67b4d5813e5bfd40558249ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394a92928f87d63318249d9f42675096"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a394a92928f87d63318249d9f42675096">transferCoveredParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particlesFrom, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particlesTo, const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a> a_representation, const Real a_tol) const</td></tr>
<tr class="memdesc:a394a92928f87d63318249d9f42675096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer particles that are inside the EB to another container.  <a href="classItoSolver.html#a394a92928f87d63318249d9f42675096">More...</a><br /></td></tr>
<tr class="separator:a394a92928f87d63318249d9f42675096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288e63ce8c95c93f6a66289c4b827dbf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a288e63ce8c95c93f6a66289c4b827dbf">intersectParticles</a> (const <a class="el" href="CD__EBIntersection_8H.html#ad8aa543cfc22c9b4f2a6a6dab88ea1e9">EBIntersection</a> a_ebIntersection, const bool a_deleteParticles, const std::function&lt; void(<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;)&gt; a_nonDeletionModifier=[](<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;) -&gt; void { return;})</td></tr>
<tr class="memdesc:a288e63ce8c95c93f6a66289c4b827dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do boundary intersection tests.  <a href="classItoSolver.html#a288e63ce8c95c93f6a66289c4b827dbf">More...</a><br /></td></tr>
<tr class="separator:a288e63ce8c95c93f6a66289c4b827dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefea80730585dfd8585bc80c3cc9dbdc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aefea80730585dfd8585bc80c3cc9dbdc">intersectParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_particles, const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_ebParticles, const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_domainParticles, const <a class="el" href="CD__EBIntersection_8H.html#ad8aa543cfc22c9b4f2a6a6dab88ea1e9">EBIntersection</a> a_ebIntersection, const bool a_deleteParticles, const std::function&lt; void(<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;)&gt; a_nonDeletionModifier=[](<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;) -&gt; void { return;})</td></tr>
<tr class="memdesc:aefea80730585dfd8585bc80c3cc9dbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do boundary intersection tests.  <a href="classItoSolver.html#aefea80730585dfd8585bc80c3cc9dbdc">More...</a><br /></td></tr>
<tr class="separator:aefea80730585dfd8585bc80c3cc9dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9d257d5bbe99cc64b94fbc8eb351cf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aca9d257d5bbe99cc64b94fbc8eb351cf">intersectParticles</a> (<a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_ebParticles, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_domainParticles, const <a class="el" href="CD__EBIntersection_8H.html#ad8aa543cfc22c9b4f2a6a6dab88ea1e9">EBIntersection</a> a_ebIntersection, const bool a_deleteParticles, const std::function&lt; void(<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;)&gt; a_nonDeletionModifier=[](<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;) -&gt; void { return;})</td></tr>
<tr class="memdesc:aca9d257d5bbe99cc64b94fbc8eb351cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do boundary intersection tests.  <a href="classItoSolver.html#aca9d257d5bbe99cc64b94fbc8eb351cf">More...</a><br /></td></tr>
<tr class="separator:aca9d257d5bbe99cc64b94fbc8eb351cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dd656605d24d6171dd291bb20ab7d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac4dd656605d24d6171dd291bb20ab7d4">computeLoads</a> (Vector&lt; long int &gt; &amp;a_loads, const DisjointBoxLayout &amp;a_dbl, const int a_level)</td></tr>
<tr class="memdesc:ac4dd656605d24d6171dd291bb20ab7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute particle load on a specific grid level &ndash; this will compute the number of particles in each box in the input grids.  <a href="classItoSolver.html#ac4dd656605d24d6171dd291bb20ab7d4">More...</a><br /></td></tr>
<tr class="separator:ac4dd656605d24d6171dd291bb20ab7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0938b394aa25ddeac394ecce5d2b474"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad0938b394aa25ddeac394ecce5d2b474">getNumberOfPlotVariables</a> () const</td></tr>
<tr class="memdesc:ad0938b394aa25ddeac394ecce5d2b474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of plot variables.  <a href="classItoSolver.html#ad0938b394aa25ddeac394ecce5d2b474">More...</a><br /></td></tr>
<tr class="separator:ad0938b394aa25ddeac394ecce5d2b474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113c01d977f92e8048729f259cf32b81"><td class="memItemLeft" align="right" valign="top">virtual Vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a113c01d977f92e8048729f259cf32b81">getPlotVariableNames</a> () const</td></tr>
<tr class="memdesc:a113c01d977f92e8048729f259cf32b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output plot names.  <a href="classItoSolver.html#a113c01d977f92e8048729f259cf32b81">More...</a><br /></td></tr>
<tr class="separator:a113c01d977f92e8048729f259cf32b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe73dce206e99305dca7803e28e8e41a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afe73dce206e99305dca7803e28e8e41a">writePlotData</a> (LevelData&lt; EBCellFAB &gt; &amp;a_output, int &amp;a_comp, const std::string a_outputRealm, const int a_level) const noexcept</td></tr>
<tr class="memdesc:afe73dce206e99305dca7803e28e8e41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write plot data.  <a href="classItoSolver.html#afe73dce206e99305dca7803e28e8e41a">More...</a><br /></td></tr>
<tr class="separator:afe73dce206e99305dca7803e28e8e41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe37223efd84b9a1f174a600bd795df"><td class="memItemLeft" align="right" valign="top">virtual unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acfe37223efd84b9a1f174a600bd795df">getNumParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const bool a_localOnly) const</td></tr>
<tr class="memdesc:acfe37223efd84b9a1f174a600bd795df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of particles in a specified particle container.  <a href="classItoSolver.html#acfe37223efd84b9a1f174a600bd795df">More...</a><br /></td></tr>
<tr class="separator:acfe37223efd84b9a1f174a600bd795df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174efc0134a7417f1afa737b8f328d16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a174efc0134a7417f1afa737b8f328d16">registerOperators</a> () const</td></tr>
<tr class="memdesc:a174efc0134a7417f1afa737b8f328d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register operators.  <a href="classItoSolver.html#a174efc0134a7417f1afa737b8f328d16">More...</a><br /></td></tr>
<tr class="separator:a174efc0134a7417f1afa737b8f328d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3174bdfc77666ce0d0a7a46876389365"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a3174bdfc77666ce0d0a7a46876389365">setComputationalGeometry</a> (const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; &amp;a_computationalGeometry)</td></tr>
<tr class="memdesc:a3174bdfc77666ce0d0a7a46876389365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set computational geometry.  <a href="classItoSolver.html#a3174bdfc77666ce0d0a7a46876389365">More...</a><br /></td></tr>
<tr class="separator:a3174bdfc77666ce0d0a7a46876389365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351676445e519924a3054b8433c30001"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a351676445e519924a3054b8433c30001">setAmr</a> (const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;a_amr)</td></tr>
<tr class="memdesc:a351676445e519924a3054b8433c30001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> object.  <a href="classItoSolver.html#a351676445e519924a3054b8433c30001">More...</a><br /></td></tr>
<tr class="separator:a351676445e519924a3054b8433c30001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6b0c77343a02439242f7b9a84949bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8b6b0c77343a02439242f7b9a84949bf">setPhase</a> (const phase::which_phase a_phase)</td></tr>
<tr class="memdesc:a8b6b0c77343a02439242f7b9a84949bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set phase where the particles will live.  <a href="classItoSolver.html#a8b6b0c77343a02439242f7b9a84949bf">More...</a><br /></td></tr>
<tr class="separator:a8b6b0c77343a02439242f7b9a84949bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa01f68543f9b94f9d083ce3e3ed0339"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aaa01f68543f9b94f9d083ce3e3ed0339">setVerbosity</a> (const int a_verbosity)</td></tr>
<tr class="memdesc:aaa01f68543f9b94f9d083ce3e3ed0339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set verbosity level for this solver.  <a href="classItoSolver.html#aaa01f68543f9b94f9d083ce3e3ed0339">More...</a><br /></td></tr>
<tr class="separator:aaa01f68543f9b94f9d083ce3e3ed0339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2293d2a6db7b36a451100e2e8400698f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2293d2a6db7b36a451100e2e8400698f">setTime</a> (const int a_step, const Real a_time, const Real a_dt)</td></tr>
<tr class="memdesc:a2293d2a6db7b36a451100e2e8400698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time for this solver.  <a href="classItoSolver.html#a2293d2a6db7b36a451100e2e8400698f">More...</a><br /></td></tr>
<tr class="separator:a2293d2a6db7b36a451100e2e8400698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134feb52bf6e0fdb4b0b25cd76b4ef91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a134feb52bf6e0fdb4b0b25cd76b4ef91">setSpecies</a> (const RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt; &amp;a_species)</td></tr>
<tr class="memdesc:a134feb52bf6e0fdb4b0b25cd76b4ef91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the species.  <a href="classItoSolver.html#a134feb52bf6e0fdb4b0b25cd76b4ef91">More...</a><br /></td></tr>
<tr class="separator:a134feb52bf6e0fdb4b0b25cd76b4ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eb3e95dfee2010652368ce894bda9d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a30eb3e95dfee2010652368ce894bda9d">preRegrid</a> (const int a_lbase, const int a_oldFinestLevel)</td></tr>
<tr class="memdesc:a30eb3e95dfee2010652368ce894bda9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pre-regrid operations.  <a href="classItoSolver.html#a30eb3e95dfee2010652368ce894bda9d">More...</a><br /></td></tr>
<tr class="separator:a30eb3e95dfee2010652368ce894bda9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630057bd092fce7fb72044a628459af"><td class="memTemplParams" colspan="2">template&lt;ItoSolver::WhichContainer C = WhichContainer::Bulk&gt; </td></tr>
<tr class="memitem:a9630057bd092fce7fb72044a628459af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a9630057bd092fce7fb72044a628459af">addParticles</a> (ListBox&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_inputParticles, const int a_lvl, const DataIndex a_dit, const bool a_destructive)</td></tr>
<tr class="memdesc:a9630057bd092fce7fb72044a628459af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add particles to a contain. This adds into a specific grid level and patch. The user can delete the input particles.  <a href="classItoSolver.html#a9630057bd092fce7fb72044a628459af">More...</a><br /></td></tr>
<tr class="separator:a9630057bd092fce7fb72044a628459af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8967ce2dec5194a8d54e0dd7e4acec08"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8967ce2dec5194a8d54e0dd7e4acec08">isMobile</a> () const</td></tr>
<tr class="memdesc:a8967ce2dec5194a8d54e0dd7e4acec08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if solver is mobile.  <a href="classItoSolver.html#a8967ce2dec5194a8d54e0dd7e4acec08">More...</a><br /></td></tr>
<tr class="separator:a8967ce2dec5194a8d54e0dd7e4acec08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1db74cb60c15142ce2729deb9179a31"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae1db74cb60c15142ce2729deb9179a31">isDiffusive</a> () const</td></tr>
<tr class="memdesc:ae1db74cb60c15142ce2729deb9179a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if solver is diffusive.  <a href="classItoSolver.html#ae1db74cb60c15142ce2729deb9179a31">More...</a><br /></td></tr>
<tr class="separator:ae1db74cb60c15142ce2729deb9179a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754df1d59ab75675768b1fdba4ce759a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a754df1d59ab75675768b1fdba4ce759a">getParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a754df1d59ab75675768b1fdba4ce759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a general particle container.  <a href="classItoSolver.html#a754df1d59ab75675768b1fdba4ce759a">More...</a><br /></td></tr>
<tr class="separator:a754df1d59ab75675768b1fdba4ce759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b5921e65afb1442dc9a71ef2c83d55"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a83b5921e65afb1442dc9a71ef2c83d55">getParticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container) const</td></tr>
<tr class="memdesc:a83b5921e65afb1442dc9a71ef2c83d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a general particle container.  <a href="classItoSolver.html#a83b5921e65afb1442dc9a71ef2c83d55">More...</a><br /></td></tr>
<tr class="separator:a83b5921e65afb1442dc9a71ef2c83d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab7ee2c7496bdad4c5331b4ccf84952"><td class="memItemLeft" align="right" valign="top">virtual const RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acab7ee2c7496bdad4c5331b4ccf84952">getSpecies</a> () const</td></tr>
<tr class="memdesc:acab7ee2c7496bdad4c5331b4ccf84952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the species.  <a href="classItoSolver.html#acab7ee2c7496bdad4c5331b4ccf84952">More...</a><br /></td></tr>
<tr class="separator:acab7ee2c7496bdad4c5331b4ccf84952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa426b09943223c61f0a9a5c51ddb8822"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa426b09943223c61f0a9a5c51ddb8822">getPhi</a> ()</td></tr>
<tr class="memdesc:aa426b09943223c61f0a9a5c51ddb8822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mesh data.  <a href="classItoSolver.html#aa426b09943223c61f0a9a5c51ddb8822">More...</a><br /></td></tr>
<tr class="separator:aa426b09943223c61f0a9a5c51ddb8822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514eded13d2870997604e287111bb7a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a514eded13d2870997604e287111bb7a2">getVelocityFunction</a> ()</td></tr>
<tr class="memdesc:a514eded13d2870997604e287111bb7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cell-centered velocity mesh data.  <a href="classItoSolver.html#a514eded13d2870997604e287111bb7a2">More...</a><br /></td></tr>
<tr class="separator:a514eded13d2870997604e287111bb7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064a1b08192d33afdf02fa8d153f2a8f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a064a1b08192d33afdf02fa8d153f2a8f">getVelocityFunction</a> () const</td></tr>
<tr class="memdesc:a064a1b08192d33afdf02fa8d153f2a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cell-centered velocity mesh data.  <a href="classItoSolver.html#a064a1b08192d33afdf02fa8d153f2a8f">More...</a><br /></td></tr>
<tr class="separator:a064a1b08192d33afdf02fa8d153f2a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a953e12f23840429f1888d2e49a95b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8a953e12f23840429f1888d2e49a95b9">getDiffusionFunction</a> ()</td></tr>
<tr class="memdesc:a8a953e12f23840429f1888d2e49a95b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diffusion function.  <a href="classItoSolver.html#a8a953e12f23840429f1888d2e49a95b9">More...</a><br /></td></tr>
<tr class="separator:a8a953e12f23840429f1888d2e49a95b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcecd78eb94c06eacb8b4aaae2376dd2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afcecd78eb94c06eacb8b4aaae2376dd2">getDiffusionFunction</a> () const</td></tr>
<tr class="memdesc:afcecd78eb94c06eacb8b4aaae2376dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diffusion function.  <a href="classItoSolver.html#afcecd78eb94c06eacb8b4aaae2376dd2">More...</a><br /></td></tr>
<tr class="separator:afcecd78eb94c06eacb8b4aaae2376dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614b9a9accb81aba62bce6435e52ebf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae614b9a9accb81aba62bce6435e52ebf">getMobilityFunction</a> ()</td></tr>
<tr class="memdesc:ae614b9a9accb81aba62bce6435e52ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mobility function.  <a href="classItoSolver.html#ae614b9a9accb81aba62bce6435e52ebf">More...</a><br /></td></tr>
<tr class="separator:ae614b9a9accb81aba62bce6435e52ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436073f3af21cc58fb23b744cd4ce77e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a436073f3af21cc58fb23b744cd4ce77e">getMobilityFunction</a> () const</td></tr>
<tr class="memdesc:a436073f3af21cc58fb23b744cd4ce77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mobility function.  <a href="classItoSolver.html#a436073f3af21cc58fb23b744cd4ce77e">More...</a><br /></td></tr>
<tr class="separator:a436073f3af21cc58fb23b744cd4ce77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4426b5a48a8530afb511bec40f6b718"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab4426b5a48a8530afb511bec40f6b718">setDiffusionFunction</a> (const Real a_diffusionCoefficient)</td></tr>
<tr class="memdesc:ab4426b5a48a8530afb511bec40f6b718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function &ndash; set a constant diffusion coefficient.  <a href="classItoSolver.html#ab4426b5a48a8530afb511bec40f6b718">More...</a><br /></td></tr>
<tr class="separator:ab4426b5a48a8530afb511bec40f6b718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f6cbb8805b459df5a6bcbcb0ff06ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae8f6cbb8805b459df5a6bcbcb0ff06ea">setVelocityFunction</a> (const RealVect a_velocity)</td></tr>
<tr class="memdesc:ae8f6cbb8805b459df5a6bcbcb0ff06ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function &ndash; set a constant velocity.  <a href="classItoSolver.html#ae8f6cbb8805b459df5a6bcbcb0ff06ea">More...</a><br /></td></tr>
<tr class="separator:ae8f6cbb8805b459df5a6bcbcb0ff06ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429895a5e10f6830cc6160654684f6e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a429895a5e10f6830cc6160654684f6e2">setParticleMobility</a> (const Real a_mobility)</td></tr>
<tr class="memdesc:a429895a5e10f6830cc6160654684f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets mobility coefficient for all particles.  <a href="classItoSolver.html#a429895a5e10f6830cc6160654684f6e2">More...</a><br /></td></tr>
<tr class="separator:a429895a5e10f6830cc6160654684f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b76fa27520cfcf6b20bc2115cd2c18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a79b76fa27520cfcf6b20bc2115cd2c18">setParticleDiffusion</a> (const Real a_diffusion)</td></tr>
<tr class="memdesc:a79b76fa27520cfcf6b20bc2115cd2c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets diffusion coefficient for all particles.  <a href="classItoSolver.html#a79b76fa27520cfcf6b20bc2115cd2c18">More...</a><br /></td></tr>
<tr class="separator:a79b76fa27520cfcf6b20bc2115cd2c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a6d5963c8a82dca1aa2868e0988b75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a58a6d5963c8a82dca1aa2868e0988b75">interpolateVelocities</a> ()</td></tr>
<tr class="memdesc:a58a6d5963c8a82dca1aa2868e0988b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the particle velocities.  <a href="classItoSolver.html#a58a6d5963c8a82dca1aa2868e0988b75">More...</a><br /></td></tr>
<tr class="separator:a58a6d5963c8a82dca1aa2868e0988b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f927ad3700a86bb8eaabb11912f81a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4f927ad3700a86bb8eaabb11912f81a9">interpolateVelocities</a> (const int a_level, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:a4f927ad3700a86bb8eaabb11912f81a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the particle velocities.  <a href="classItoSolver.html#a4f927ad3700a86bb8eaabb11912f81a9">More...</a><br /></td></tr>
<tr class="separator:a4f927ad3700a86bb8eaabb11912f81a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df3eb32ebb71b1858298b2b0d7dd0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a06df3eb32ebb71b1858298b2b0d7dd0b">interpolateMobilities</a> ()</td></tr>
<tr class="memdesc:a06df3eb32ebb71b1858298b2b0d7dd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate mobilities.  <a href="classItoSolver.html#a06df3eb32ebb71b1858298b2b0d7dd0b">More...</a><br /></td></tr>
<tr class="separator:a06df3eb32ebb71b1858298b2b0d7dd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877960fbdde4e57f9ce3061fc0bb703f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a877960fbdde4e57f9ce3061fc0bb703f">updateMobilities</a> ()</td></tr>
<tr class="memdesc:a877960fbdde4e57f9ce3061fc0bb703f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update mobilities parametrically from the particle energy.  <a href="classItoSolver.html#a877960fbdde4e57f9ce3061fc0bb703f">More...</a><br /></td></tr>
<tr class="separator:a877960fbdde4e57f9ce3061fc0bb703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b5e34d86ab0286807678c7f753f57e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a64b5e34d86ab0286807678c7f753f57e">interpolateDiffusion</a> ()</td></tr>
<tr class="memdesc:a64b5e34d86ab0286807678c7f753f57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the diffusion field to the particle positions.  <a href="classItoSolver.html#a64b5e34d86ab0286807678c7f753f57e">More...</a><br /></td></tr>
<tr class="separator:a64b5e34d86ab0286807678c7f753f57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8246f963aa976e49c808a9d963b464"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4d8246f963aa976e49c808a9d963b464">updateDiffusion</a> ()</td></tr>
<tr class="memdesc:a4d8246f963aa976e49c808a9d963b464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update mobilities parametrically from the particle energy.  <a href="classItoSolver.html#a4d8246f963aa976e49c808a9d963b464">More...</a><br /></td></tr>
<tr class="separator:a4d8246f963aa976e49c808a9d963b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105469be7e9f0bda74d6e3ce523bd9bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a105469be7e9f0bda74d6e3ce523bd9bf">organizeParticlesByCell</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a105469be7e9f0bda74d6e3ce523bd9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the input particle container by cell.  <a href="classItoSolver.html#a105469be7e9f0bda74d6e3ce523bd9bf">More...</a><br /></td></tr>
<tr class="separator:a105469be7e9f0bda74d6e3ce523bd9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2cd095f6e6b42efea7cf302b676883"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a3d2cd095f6e6b42efea7cf302b676883">organizeParticlesByPatch</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a3d2cd095f6e6b42efea7cf302b676883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the input particle container by patch.  <a href="classItoSolver.html#a3d2cd095f6e6b42efea7cf302b676883">More...</a><br /></td></tr>
<tr class="separator:a3d2cd095f6e6b42efea7cf302b676883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e0d074046485949984c3c074d1fe58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a90e0d074046485949984c3c074d1fe58">makeSuperparticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const int a_particlesPerCell)</td></tr>
<tr class="memdesc:a90e0d074046485949984c3c074d1fe58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make superparticles for a full container &ndash; this is the AMR version that users will usually call.  <a href="classItoSolver.html#a90e0d074046485949984c3c074d1fe58">More...</a><br /></td></tr>
<tr class="separator:a90e0d074046485949984c3c074d1fe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea171a47b9ed6b7f3aed7c3d90ede120"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aea171a47b9ed6b7f3aed7c3d90ede120">makeSuperparticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const Vector&lt; int &gt; a_particlesPerCell)</td></tr>
<tr class="memdesc:aea171a47b9ed6b7f3aed7c3d90ede120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make superparticles for a full container &ndash; this is the AMR version that users will usually call.  <a href="classItoSolver.html#aea171a47b9ed6b7f3aed7c3d90ede120">More...</a><br /></td></tr>
<tr class="separator:aea171a47b9ed6b7f3aed7c3d90ede120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc59aabefa256470657b9c0087725c20"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acc59aabefa256470657b9c0087725c20">makeSuperparticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const int a_particlesPerCell, const int a_level)</td></tr>
<tr class="memdesc:acc59aabefa256470657b9c0087725c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make superparticles for a particle container &ndash; this is used for a specified grid level.  <a href="classItoSolver.html#acc59aabefa256470657b9c0087725c20">More...</a><br /></td></tr>
<tr class="separator:acc59aabefa256470657b9c0087725c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8859e84b563c9aa49927b39628571d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa8859e84b563c9aa49927b39628571d3">makeSuperparticles</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container, const int a_particlesPerCell, const int a_level, const DataIndex a_dit)</td></tr>
<tr class="memdesc:aa8859e84b563c9aa49927b39628571d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make superparticles for a particle container &ndash; this is used for a specified grid level and patch.  <a href="classItoSolver.html#aa8859e84b563c9aa49927b39628571d3">More...</a><br /></td></tr>
<tr class="separator:aa8859e84b563c9aa49927b39628571d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51538761f2825b0989349d640e8c061c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a51538761f2825b0989349d640e8c061c">mergeParticles</a> (List&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="classCellInfo.html">CellInfo</a> &amp;a_cellInfo, const int a_particlesPerCell) const noexcept</td></tr>
<tr class="memdesc:a51538761f2825b0989349d640e8c061c"><td class="mdescLeft">&#160;</td><td class="mdescRight">General superparticle merging with underlying algorithm through m_particleMerger.  <a href="classItoSolver.html#a51538761f2825b0989349d640e8c061c">More...</a><br /></td></tr>
<tr class="separator:a51538761f2825b0989349d640e8c061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054d02df4353cf514c5a7e84616c8b3b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a054d02df4353cf514c5a7e84616c8b3b">makeSuperparticlesEqualWeightKD</a> (List&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="classCellInfo.html">CellInfo</a> &amp;a_cellInfo, const int a_particlesPerCell) const noexcept</td></tr>
<tr class="memdesc:a054d02df4353cf514c5a7e84616c8b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superparticle merging with KD/BVH trees.  <a href="classItoSolver.html#a054d02df4353cf514c5a7e84616c8b3b">More...</a><br /></td></tr>
<tr class="separator:a054d02df4353cf514c5a7e84616c8b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96f3425ab87e0a7dfead3717f262f7b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac96f3425ab87e0a7dfead3717f262f7b">reinitializeParticles</a> (List&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;a_particles, const <a class="el" href="classCellInfo.html">CellInfo</a> &amp;a_cellInfo, const int a_particlesPerCell) const noexcept</td></tr>
<tr class="memdesc:ac96f3425ab87e0a7dfead3717f262f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle re-initialization algorithm.  <a href="classItoSolver.html#ac96f3425ab87e0a7dfead3717f262f7b">More...</a><br /></td></tr>
<tr class="separator:ac96f3425ab87e0a7dfead3717f262f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802e12734bd28664a925cf946f485350"><td class="memItemLeft" align="right" valign="top"><a id="a802e12734bd28664a925cf946f485350"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a802e12734bd28664a925cf946f485350">remap</a> ()</td></tr>
<tr class="memdesc:a802e12734bd28664a925cf946f485350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap the bulk particle container. <br /></td></tr>
<tr class="separator:a802e12734bd28664a925cf946f485350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2ffd6f216e2fe3fc1b7d69134cd941"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2b2ffd6f216e2fe3fc1b7d69134cd941">remap</a> (const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a> a_container)</td></tr>
<tr class="memdesc:a2b2ffd6f216e2fe3fc1b7d69134cd941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap all particles in the input container.  <a href="classItoSolver.html#a2b2ffd6f216e2fe3fc1b7d69134cd941">More...</a><br /></td></tr>
<tr class="separator:a2b2ffd6f216e2fe3fc1b7d69134cd941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59ef79304936f346170bb00bef1d484"><td class="memItemLeft" align="right" valign="top"><a id="ac59ef79304936f346170bb00bef1d484"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac59ef79304936f346170bb00bef1d484">remapAll</a> ()</td></tr>
<tr class="memdesc:ac59ef79304936f346170bb00bef1d484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap all particle containers. <br /></td></tr>
<tr class="separator:ac59ef79304936f346170bb00bef1d484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cbe509c51f4fce01400a105760b1e9"><td class="memItemLeft" align="right" valign="top">RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a77cbe509c51f4fce01400a105760b1e9">randomGaussian</a> () const</td></tr>
<tr class="memdesc:a77cbe509c51f4fce01400a105760b1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a random N-dimensional Gaussian number from a normal distribution with zero with and unit standard deviation.  <a href="classItoSolver.html#a77cbe509c51f4fce01400a105760b1e9">More...</a><br /></td></tr>
<tr class="separator:a77cbe509c51f4fce01400a105760b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019fa52c90f664f338441ae58ee891cf"><td class="memItemLeft" align="right" valign="top">RealVect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a019fa52c90f664f338441ae58ee891cf">randomDirection</a> () const</td></tr>
<tr class="memdesc:a019fa52c90f664f338441ae58ee891cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a random direction in N-dimensional space.  <a href="classItoSolver.html#a019fa52c90f664f338441ae58ee891cf">More...</a><br /></td></tr>
<tr class="separator:a019fa52c90f664f338441ae58ee891cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad5fa4823fa70c9722b863ab3e35f5"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5fad5fa4823fa70c9722b863ab3e35f5">computeDt</a> () const</td></tr>
<tr class="memdesc:a5fad5fa4823fa70c9722b863ab3e35f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a time step for the advance &ndash; this calls the level function.  <a href="classItoSolver.html#a5fad5fa4823fa70c9722b863ab3e35f5">More...</a><br /></td></tr>
<tr class="separator:a5fad5fa4823fa70c9722b863ab3e35f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe18ba36b867d4ddc70f686dd977ab7"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0fe18ba36b867d4ddc70f686dd977ab7">computeDt</a> (const int a_lvl) const</td></tr>
<tr class="memdesc:a0fe18ba36b867d4ddc70f686dd977ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a time step for the advance &ndash; this returns the maximum permitted time step on the input grid level.  <a href="classItoSolver.html#a0fe18ba36b867d4ddc70f686dd977ab7">More...</a><br /></td></tr>
<tr class="separator:a0fe18ba36b867d4ddc70f686dd977ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41787bfa9dd5767989a63e7782e50e9"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac41787bfa9dd5767989a63e7782e50e9">computeDt</a> (const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:ac41787bfa9dd5767989a63e7782e50e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a time step for the advance &ndash; this returns the maximum permitted time step on the input grid patch.  <a href="classItoSolver.html#ac41787bfa9dd5767989a63e7782e50e9">More...</a><br /></td></tr>
<tr class="separator:ac41787bfa9dd5767989a63e7782e50e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f48f81560c8a7d1c3952303187e519"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a40f48f81560c8a7d1c3952303187e519">computeHopDt</a> (const Real a_maxCellsToMove) const</td></tr>
<tr class="memdesc:a40f48f81560c8a7d1c3952303187e519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on any grid level.  <a href="classItoSolver.html#a40f48f81560c8a7d1c3952303187e519">More...</a><br /></td></tr>
<tr class="separator:a40f48f81560c8a7d1c3952303187e519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ea187e51e51e3623459068cc281b14"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a17ea187e51e51e3623459068cc281b14">computeHopDt</a> (const Real a_maxCellsToMove, const int a_lvl) const</td></tr>
<tr class="memdesc:a17ea187e51e51e3623459068cc281b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on the input grid level.  <a href="classItoSolver.html#a17ea187e51e51e3623459068cc281b14">More...</a><br /></td></tr>
<tr class="separator:a17ea187e51e51e3623459068cc281b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab053c9b08666c62e4527258f7762793c"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab053c9b08666c62e4527258f7762793c">computeHopDt</a> (const Real a_maxCellsToMove, const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:ab053c9b08666c62e4527258f7762793c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on the input grid level.  <a href="classItoSolver.html#ab053c9b08666c62e4527258f7762793c">More...</a><br /></td></tr>
<tr class="separator:ab053c9b08666c62e4527258f7762793c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43a7879eb8c98d18b23ea3accf38c65"><td class="memItemLeft" align="right" valign="top"><a id="af43a7879eb8c98d18b23ea3accf38c65"></a>
virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#af43a7879eb8c98d18b23ea3accf38c65">computeAdvectiveDt</a> () const</td></tr>
<tr class="memdesc:af43a7879eb8c98d18b23ea3accf38c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute advection time step dt = dx/vMax where vMax is the largest velocity component of the particle. <br /></td></tr>
<tr class="separator:af43a7879eb8c98d18b23ea3accf38c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafa5edfbb02fcab67e2e2e7da5a1ce0"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abafa5edfbb02fcab67e2e2e7da5a1ce0">computeAdvectiveDt</a> (const int a_lvl) const</td></tr>
<tr class="memdesc:abafa5edfbb02fcab67e2e2e7da5a1ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the drift dt. This computes the minimum dt = dx/vMax on the input level.  <a href="classItoSolver.html#abafa5edfbb02fcab67e2e2e7da5a1ce0">More...</a><br /></td></tr>
<tr class="separator:abafa5edfbb02fcab67e2e2e7da5a1ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42432c4f69f66dfca9a5c74784664167"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a42432c4f69f66dfca9a5c74784664167">computeAdvectiveDt</a> (const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:a42432c4f69f66dfca9a5c74784664167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the drift dt. This computes the minimum dt = dx/vMax on one level and one box.  <a href="classItoSolver.html#a42432c4f69f66dfca9a5c74784664167">More...</a><br /></td></tr>
<tr class="separator:a42432c4f69f66dfca9a5c74784664167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b93acc51df2b5bf6f6d69309027c646"><td class="memItemLeft" align="right" valign="top"><a id="a4b93acc51df2b5bf6f6d69309027c646"></a>
virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4b93acc51df2b5bf6f6d69309027c646">computeDiffusiveDt</a> () const</td></tr>
<tr class="memdesc:a4b93acc51df2b5bf6f6d69309027c646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles. <br /></td></tr>
<tr class="separator:a4b93acc51df2b5bf6f6d69309027c646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb099bd8a10e78857d024d26f7b6570"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1bb099bd8a10e78857d024d26f7b6570">computeDiffusiveDt</a> (const int a_lvl) const</td></tr>
<tr class="memdesc:a1bb099bd8a10e78857d024d26f7b6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles on the input level.  <a href="classItoSolver.html#a1bb099bd8a10e78857d024d26f7b6570">More...</a><br /></td></tr>
<tr class="separator:a1bb099bd8a10e78857d024d26f7b6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040479280a818cbe4947529d7651ce1c"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a040479280a818cbe4947529d7651ce1c">computeDiffusiveDt</a> (const int a_lvl, const DataIndex &amp;a_dit) const</td></tr>
<tr class="memdesc:a040479280a818cbe4947529d7651ce1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles on the input grid patch.  <a href="classItoSolver.html#a040479280a818cbe4947529d7651ce1c">More...</a><br /></td></tr>
<tr class="separator:a040479280a818cbe4947529d7651ce1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6205a79851e8e13fee2fd0edc2b48c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab6205a79851e8e13fee2fd0edc2b48c9">getDeposition</a> () const</td></tr>
<tr class="memdesc:ab6205a79851e8e13fee2fd0edc2b48c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get deposition method.  <a href="classItoSolver.html#ab6205a79851e8e13fee2fd0edc2b48c9">More...</a><br /></td></tr>
<tr class="separator:ab6205a79851e8e13fee2fd0edc2b48c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a624b17f9df51c9164fd5e81daa766"><td class="memItemLeft" align="right" valign="top"><a id="a19a624b17f9df51c9164fd5e81daa766"></a>
<a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a19a624b17f9df51c9164fd5e81daa766">getCoarseFineDeposition</a> () const</td></tr>
<tr class="memdesc:a19a624b17f9df51c9164fd5e81daa766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the coarse-fine deposition strategy. <br /></td></tr>
<tr class="separator:a19a624b17f9df51c9164fd5e81daa766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0728c740c0a9ced2691f193057b384fa"><td class="memItemLeft" align="right" valign="top">phase::which_phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0728c740c0a9ced2691f193057b384fa">getPhase</a> () const</td></tr>
<tr class="memdesc:a0728c740c0a9ced2691f193057b384fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return phase.  <a href="classItoSolver.html#a0728c740c0a9ced2691f193057b384fa">More...</a><br /></td></tr>
<tr class="separator:a0728c740c0a9ced2691f193057b384fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a93be4b5f935a4ba80472db227c9d75cd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a93be4b5f935a4ba80472db227c9d75cd">WhichCheckpoint</a> { <b>Particles</b>
, <b>Numbers</b>
 }</td></tr>
<tr class="memdesc:a93be4b5f935a4ba80472db227c9d75cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to checkpoint files.  <a href="classItoSolver.html#a93be4b5f935a4ba80472db227c9d75cd">More...</a><br /></td></tr>
<tr class="separator:a93be4b5f935a4ba80472db227c9d75cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ea13986249a06a5185c8315e4548bc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac7ea13986249a06a5185c8315e4548bc">WhichMobilityInterpolation</a> { <b>Direct</b>
, <b>Velocity</b>
 }</td></tr>
<tr class="memdesc:ac7ea13986249a06a5185c8315e4548bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for deciding how to interpolate particle mobilities.  <a href="classItoSolver.html#ac7ea13986249a06a5185c8315e4548bc">More...</a><br /></td></tr>
<tr class="separator:ac7ea13986249a06a5185c8315e4548bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab1e8e4881e32bd4b99ad8f272ee9236f"><td class="memItemLeft" align="right" valign="top"><a id="ab1e8e4881e32bd4b99ad8f272ee9236f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab1e8e4881e32bd4b99ad8f272ee9236f">parseRNG</a> ()</td></tr>
<tr class="memdesc:ab1e8e4881e32bd4b99ad8f272ee9236f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse RNG options &ndash; this parses the RNG seed and instantiates the distributions. <br /></td></tr>
<tr class="separator:ab1e8e4881e32bd4b99ad8f272ee9236f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b7f123b742ce59ff8ed203fa96d326"><td class="memItemLeft" align="right" valign="top"><a id="ab6b7f123b742ce59ff8ed203fa96d326"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab6b7f123b742ce59ff8ed203fa96d326">parseTruncation</a> ()</td></tr>
<tr class="memdesc:ab6b7f123b742ce59ff8ed203fa96d326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the normal distribution truncation level. <br /></td></tr>
<tr class="separator:ab6b7f123b742ce59ff8ed203fa96d326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99beba4bb3d6b11b26c1a031225c038"><td class="memItemLeft" align="right" valign="top"><a id="ae99beba4bb3d6b11b26c1a031225c038"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae99beba4bb3d6b11b26c1a031225c038">parseDeposition</a> ()</td></tr>
<tr class="memdesc:ae99beba4bb3d6b11b26c1a031225c038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse particle deposition methods. <br /></td></tr>
<tr class="separator:ae99beba4bb3d6b11b26c1a031225c038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c33ca03f4f05b4b9c69eaae228ca794"><td class="memItemLeft" align="right" valign="top"><a id="a4c33ca03f4f05b4b9c69eaae228ca794"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4c33ca03f4f05b4b9c69eaae228ca794">parseParticleMerger</a> ()</td></tr>
<tr class="memdesc:a4c33ca03f4f05b4b9c69eaae228ca794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the super-particle merger. <br /></td></tr>
<tr class="separator:a4c33ca03f4f05b4b9c69eaae228ca794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32226502e97aa02f9750ca9f19a7d088"><td class="memItemLeft" align="right" valign="top"><a id="a32226502e97aa02f9750ca9f19a7d088"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a32226502e97aa02f9750ca9f19a7d088">parseIntersectionEB</a> ()</td></tr>
<tr class="memdesc:a32226502e97aa02f9750ca9f19a7d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse EB intersection algorithms. <br /></td></tr>
<tr class="separator:a32226502e97aa02f9750ca9f19a7d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f3f2f3702af5f599771e06b7df5e49"><td class="memItemLeft" align="right" valign="top"><a id="aa8f3f2f3702af5f599771e06b7df5e49"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa8f3f2f3702af5f599771e06b7df5e49">parseVerbosity</a> ()</td></tr>
<tr class="memdesc:aa8f3f2f3702af5f599771e06b7df5e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse class verbosity. <br /></td></tr>
<tr class="separator:aa8f3f2f3702af5f599771e06b7df5e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf6f91c6ad86c19f26c56962ac7cdcf"><td class="memItemLeft" align="right" valign="top"><a id="afaf6f91c6ad86c19f26c56962ac7cdcf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afaf6f91c6ad86c19f26c56962ac7cdcf">parsePlotVariables</a> ()</td></tr>
<tr class="memdesc:afaf6f91c6ad86c19f26c56962ac7cdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse plot variables. <br /></td></tr>
<tr class="separator:afaf6f91c6ad86c19f26c56962ac7cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077daa0e8d08f13bc81a9a7f19d079df"><td class="memItemLeft" align="right" valign="top"><a id="a077daa0e8d08f13bc81a9a7f19d079df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a077daa0e8d08f13bc81a9a7f19d079df">parseDiffusionHop</a> ()</td></tr>
<tr class="memdesc:a077daa0e8d08f13bc81a9a7f19d079df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse diffusion hop. <br /></td></tr>
<tr class="separator:a077daa0e8d08f13bc81a9a7f19d079df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ac1cf61d9ad50ba0f959088e4e083b"><td class="memItemLeft" align="right" valign="top"><a id="a40ac1cf61d9ad50ba0f959088e4e083b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a40ac1cf61d9ad50ba0f959088e4e083b">parseRedistribution</a> ()</td></tr>
<tr class="memdesc:a40ac1cf61d9ad50ba0f959088e4e083b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse whether or not to use redistribution. <br /></td></tr>
<tr class="separator:a40ac1cf61d9ad50ba0f959088e4e083b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4be69b978f264e422bcdf75498a81e"><td class="memItemLeft" align="right" valign="top"><a id="aac4be69b978f264e422bcdf75498a81e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aac4be69b978f264e422bcdf75498a81e">parseDivergenceComputation</a> ()</td></tr>
<tr class="memdesc:aac4be69b978f264e422bcdf75498a81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse whether or not to compute a "non-conservative" divergence when redistributing mass. <br /></td></tr>
<tr class="separator:aac4be69b978f264e422bcdf75498a81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74657cea12e9660c0e25db1b4982d647"><td class="memItemLeft" align="right" valign="top"><a id="a74657cea12e9660c0e25db1b4982d647"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a74657cea12e9660c0e25db1b4982d647">parseCheckpointing</a> ()</td></tr>
<tr class="memdesc:a74657cea12e9660c0e25db1b4982d647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse checkpointing method. <br /></td></tr>
<tr class="separator:a74657cea12e9660c0e25db1b4982d647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803e769f2adeed3b1a2f2b9d40c2422f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a803e769f2adeed3b1a2f2b9d40c2422f">drawNewParticles</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_particlesPerCell, const int a_level, const int a_newPPC)</td></tr>
<tr class="memdesc:a803e769f2adeed3b1a2f2b9d40c2422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart particles from a specified number of particles in the grid cell.  <a href="classItoSolver.html#a803e769f2adeed3b1a2f2b9d40c2422f">More...</a><br /></td></tr>
<tr class="separator:a803e769f2adeed3b1a2f2b9d40c2422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0ecc49bb1f0ece27a920c4ea6a1232"><td class="memTemplParams" colspan="2">template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a1c0ecc49bb1f0ece27a920c4ea6a1232"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1c0ecc49bb1f0ece27a920c4ea6a1232">depositKappaConservative</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition) const</td></tr>
<tr class="memdesc:a1c0ecc49bb1f0ece27a920c4ea6a1232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cell-centered deposition &ndash; this is the main deposition function.  <a href="classItoSolver.html#a1c0ecc49bb1f0ece27a920c4ea6a1232">More...</a><br /></td></tr>
<tr class="separator:a1c0ecc49bb1f0ece27a920c4ea6a1232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0ecc49bb1f0ece27a920c4ea6a1232"><td class="memTemplParams" colspan="2">template&lt;class P , Real(P::*)() const particleScalarField&gt; </td></tr>
<tr class="memitem:a1c0ecc49bb1f0ece27a920c4ea6a1232"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1c0ecc49bb1f0ece27a920c4ea6a1232">depositKappaConservative</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;a_particles, const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> a_deposition, const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a> a_coarseFineDeposition) const</td></tr>
<tr class="memdesc:a1c0ecc49bb1f0ece27a920c4ea6a1232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cell-centered deposition &ndash; this is the main deposition function.  <a href="classItoSolver.html#a1c0ecc49bb1f0ece27a920c4ea6a1232">More...</a><br /></td></tr>
<tr class="separator:a1c0ecc49bb1f0ece27a920c4ea6a1232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad599086b015754fd8dc25f94ba0b686d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad599086b015754fd8dc25f94ba0b686d">redistributeAMR</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi) const</td></tr>
<tr class="memdesc:ad599086b015754fd8dc25f94ba0b686d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribute mass in an AMR context.  <a href="classItoSolver.html#ad599086b015754fd8dc25f94ba0b686d">More...</a><br /></td></tr>
<tr class="separator:ad599086b015754fd8dc25f94ba0b686d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6778295d539cd8d0224bf2615e93bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1f6778295d539cd8d0224bf2615e93bb">depositNonConservative</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_depositionNC, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_depositionKappaC) const</td></tr>
<tr class="memdesc:a1f6778295d539cd8d0224bf2615e93bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the "non-conservative" kappa deposition &ndash; computing depositionNC = sum(kappa*depositionC)/sum(kappa) in a neighborhood around each vof.  <a href="classItoSolver.html#a1f6778295d539cd8d0224bf2615e93bb">More...</a><br /></td></tr>
<tr class="separator:a1f6778295d539cd8d0224bf2615e93bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2b82ed36f44539366b43564e352846"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aac2b82ed36f44539366b43564e352846">depositHybrid</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_depositionH, <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_massDifference, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_depositionNC) const</td></tr>
<tr class="memdesc:aac2b82ed36f44539366b43564e352846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the "hybrid" deposition phiH = kappa*phiC + (1-kappa)*phiNC. On input, a_depositionH should contain phiC.  <a href="classItoSolver.html#aac2b82ed36f44539366b43564e352846">More...</a><br /></td></tr>
<tr class="separator:aac2b82ed36f44539366b43564e352846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e2869b2f9907251a682b7d25198207"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad2e2869b2f9907251a682b7d25198207">interpolateMobilities</a> (const int a_level, const DataIndex &amp;a_dit, const EBCellFAB &amp;a_velocityMagnitude) noexcept</td></tr>
<tr class="memdesc:ad2e2869b2f9907251a682b7d25198207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate mobilities &ndash; this will switch between the two ways of computing the particle mobility.  <a href="classItoSolver.html#ad2e2869b2f9907251a682b7d25198207">More...</a><br /></td></tr>
<tr class="separator:ad2e2869b2f9907251a682b7d25198207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5934ada9e1588736018ece31217d6404"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5934ada9e1588736018ece31217d6404">interpolateMobilitiesDirect</a> (const int a_level, const DataIndex &amp;a_dit) noexcept</td></tr>
<tr class="memdesc:a5934ada9e1588736018ece31217d6404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly interpolate mobilities. Interpolates for all particles in the specified grid patch.  <a href="classItoSolver.html#a5934ada9e1588736018ece31217d6404">More...</a><br /></td></tr>
<tr class="separator:a5934ada9e1588736018ece31217d6404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2be7c7592bca502599911c75fc376a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#af2be7c7592bca502599911c75fc376a4">interpolateMobilitiesVelocity</a> (const int a_level, const DataIndex &amp;a_dit, const EBCellFAB &amp;a_velocityMagnitude) noexcept</td></tr>
<tr class="memdesc:af2be7c7592bca502599911c75fc376a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate mobilities through the velocity. Interpolates for all particles in the specified grid patch.  <a href="classItoSolver.html#af2be7c7592bca502599911c75fc376a4">More...</a><br /></td></tr>
<tr class="separator:af2be7c7592bca502599911c75fc376a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a9256055022575daeceafe643972f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ac7a9256055022575daeceafe643972f2">updateMobilities</a> (const int a_level, const DataIndex a_dit)</td></tr>
<tr class="memdesc:ac7a9256055022575daeceafe643972f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update mobilities parametrically from the particle energy.  <a href="classItoSolver.html#ac7a9256055022575daeceafe643972f2">More...</a><br /></td></tr>
<tr class="separator:ac7a9256055022575daeceafe643972f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3ef423300841c7a94bdb2ccd248189"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aef3ef423300841c7a94bdb2ccd248189">interpolateDiffusion</a> (const int a_level, const DataIndex &amp;a_dit)</td></tr>
<tr class="memdesc:aef3ef423300841c7a94bdb2ccd248189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the diffusion field to the particle positions.  <a href="classItoSolver.html#aef3ef423300841c7a94bdb2ccd248189">More...</a><br /></td></tr>
<tr class="separator:aef3ef423300841c7a94bdb2ccd248189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad686ec03d1b90c1f9b2e2bb2e45126bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad686ec03d1b90c1f9b2e2bb2e45126bf">updateDiffusion</a> (const int a_level, const DataIndex a_dit)</td></tr>
<tr class="memdesc:ad686ec03d1b90c1f9b2e2bb2e45126bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update mobilities parametrically from the particle energy.  <a href="classItoSolver.html#ad686ec03d1b90c1f9b2e2bb2e45126bf">More...</a><br /></td></tr>
<tr class="separator:ad686ec03d1b90c1f9b2e2bb2e45126bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1264160ab19dbcdd4279fd02977ca6a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#af1264160ab19dbcdd4279fd02977ca6a">writeData</a> (LevelData&lt; EBCellFAB &gt; &amp;a_output, int &amp;a_comp, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::string a_outputRealm, const int a_level, const bool a_interpToCentroids, const bool a_interpGhost) const noexcept</td></tr>
<tr class="memdesc:af1264160ab19dbcdd4279fd02977ca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to output. Convenience function.  <a href="classItoSolver.html#af1264160ab19dbcdd4279fd02977ca6a">More...</a><br /></td></tr>
<tr class="separator:af1264160ab19dbcdd4279fd02977ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a73a4bb5ebcec9cd208eb2328a1cc3840"><td class="memItemLeft" align="right" valign="top"><a id="a73a4bb5ebcec9cd208eb2328a1cc3840"></a>
<a class="el" href="classItoSolver.html#a93be4b5f935a4ba80472db227c9d75cd">WhichCheckpoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a73a4bb5ebcec9cd208eb2328a1cc3840">m_checkpointing</a></td></tr>
<tr class="memdesc:a73a4bb5ebcec9cd208eb2328a1cc3840"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to checkpoint files. particles =&gt; write particles to HDF5. numbers =&gt; write numbers to HDF5. <br /></td></tr>
<tr class="separator:a73a4bb5ebcec9cd208eb2328a1cc3840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a28b6a171ed4a0aa2093e39c42cebe"><td class="memItemLeft" align="right" valign="top"><a id="aa8a28b6a171ed4a0aa2093e39c42cebe"></a>
<a class="el" href="classItoSolver.html#ac7ea13986249a06a5185c8315e4548bc">WhichMobilityInterpolation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa8a28b6a171ed4a0aa2093e39c42cebe">m_mobilityInterp</a></td></tr>
<tr class="memdesc:aa8a28b6a171ed4a0aa2093e39c42cebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch for deciding how to interpolate mobilities, i.e. interpolating either mu*E or just mu (to the particle position) <br /></td></tr>
<tr class="separator:aa8a28b6a171ed4a0aa2093e39c42cebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad800ffce929d21041ba7e37797f535d0"><td class="memItemLeft" align="right" valign="top"><a id="ad800ffce929d21041ba7e37797f535d0"></a>
<a class="el" href="namespaceParticleManagement.html#abb4cc237cfca463592686cabeb3a6f75">ParticleManagement::ParticleMerger</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad800ffce929d21041ba7e37797f535d0">m_particleMerger</a></td></tr>
<tr class="memdesc:ad800ffce929d21041ba7e37797f535d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle merger. <br /></td></tr>
<tr class="separator:ad800ffce929d21041ba7e37797f535d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdbaf1fcff7620202eef2892684dcc"><td class="memItemLeft" align="right" valign="top"><a id="a2ecdbaf1fcff7620202eef2892684dcc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2ecdbaf1fcff7620202eef2892684dcc">m_restartPPC</a></td></tr>
<tr class="memdesc:a2ecdbaf1fcff7620202eef2892684dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of particles used when restarting a simulation &ndash; this is relevant only when restarting from a "fluid" checkpoint file. <br /></td></tr>
<tr class="separator:a2ecdbaf1fcff7620202eef2892684dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a9455e60b33ff6e057b561cca227af"><td class="memItemLeft" align="right" valign="top"><a id="a55a9455e60b33ff6e057b561cca227af"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a55a9455e60b33ff6e057b561cca227af">m_realm</a></td></tr>
<tr class="memdesc:a55a9455e60b33ff6e057b561cca227af"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where this solve lives. <br /></td></tr>
<tr class="separator:a55a9455e60b33ff6e057b561cca227af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadc148a0d39b1c381b4ef83cfe465b9"><td class="memItemLeft" align="right" valign="top"><a id="aeadc148a0d39b1c381b4ef83cfe465b9"></a>
RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aeadc148a0d39b1c381b4ef83cfe465b9">m_computationalGeometry</a></td></tr>
<tr class="memdesc:aeadc148a0d39b1c381b4ef83cfe465b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational geometry. <br /></td></tr>
<tr class="separator:aeadc148a0d39b1c381b4ef83cfe465b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3f016c77c3ce58e11f6e1e1243773a"><td class="memItemLeft" align="right" valign="top"><a id="aaf3f016c77c3ce58e11f6e1e1243773a"></a>
RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aaf3f016c77c3ce58e11f6e1e1243773a">m_amr</a></td></tr>
<tr class="memdesc:aaf3f016c77c3ce58e11f6e1e1243773a"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMR; needed for grid stuff. <br /></td></tr>
<tr class="separator:aaf3f016c77c3ce58e11f6e1e1243773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6142ed82b15d560df3f16d3921c37566"><td class="memItemLeft" align="right" valign="top"><a id="a6142ed82b15d560df3f16d3921c37566"></a>
RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6142ed82b15d560df3f16d3921c37566">m_species</a></td></tr>
<tr class="memdesc:a6142ed82b15d560df3f16d3921c37566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Species that this solver solves for. <br /></td></tr>
<tr class="separator:a6142ed82b15d560df3f16d3921c37566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1704d95090017c82c313acfdafdeeb5"><td class="memItemLeft" align="right" valign="top"><a id="ae1704d95090017c82c313acfdafdeeb5"></a>
phase::which_phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ae1704d95090017c82c313acfdafdeeb5">m_phase</a></td></tr>
<tr class="memdesc:ae1704d95090017c82c313acfdafdeeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase where this solver lives. <br /></td></tr>
<tr class="separator:ae1704d95090017c82c313acfdafdeeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8cdd7bdd007bc3fb1269adf0e92125"><td class="memItemLeft" align="right" valign="top"><a id="a6b8cdd7bdd007bc3fb1269adf0e92125"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6b8cdd7bdd007bc3fb1269adf0e92125">m_name</a></td></tr>
<tr class="memdesc:a6b8cdd7bdd007bc3fb1269adf0e92125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver name. <br /></td></tr>
<tr class="separator:a6b8cdd7bdd007bc3fb1269adf0e92125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfbc656f1f16c9b664b25ff0fedd92a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4cfbc656f1f16c9b664b25ff0fedd92a">m_className</a></td></tr>
<tr class="memdesc:a4cfbc656f1f16c9b664b25ff0fedd92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class name.  <a href="classItoSolver.html#a4cfbc656f1f16c9b664b25ff0fedd92a">More...</a><br /></td></tr>
<tr class="separator:a4cfbc656f1f16c9b664b25ff0fedd92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987806a343072c9ed15231c9a371a16e"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a987806a343072c9ed15231c9a371a16e">m_normalDistributionTruncation</a></td></tr>
<tr class="memdesc:a987806a343072c9ed15231c9a371a16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncation value for normal distribution.  <a href="classItoSolver.html#a987806a343072c9ed15231c9a371a16e">More...</a><br /></td></tr>
<tr class="separator:a987806a343072c9ed15231c9a371a16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3e2e32f016978fff89f34b876d0905"><td class="memItemLeft" align="right" valign="top"><a id="a2a3e2e32f016978fff89f34b876d0905"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a2a3e2e32f016978fff89f34b876d0905">m_bisectionStep</a></td></tr>
<tr class="memdesc:a2a3e2e32f016978fff89f34b876d0905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisection step size to use for particle intersection tests with EBs. <br /></td></tr>
<tr class="separator:a2a3e2e32f016978fff89f34b876d0905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddb00c8bcd19c7d23ce98738326c108"><td class="memItemLeft" align="right" valign="top"><a id="a8ddb00c8bcd19c7d23ce98738326c108"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a8ddb00c8bcd19c7d23ce98738326c108">m_verbosity</a></td></tr>
<tr class="memdesc:a8ddb00c8bcd19c7d23ce98738326c108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verbosity level for this solver. <br /></td></tr>
<tr class="separator:a8ddb00c8bcd19c7d23ce98738326c108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e82d759ba2e48638ad1226c2ccca5e5"><td class="memItemLeft" align="right" valign="top"><a id="a4e82d759ba2e48638ad1226c2ccca5e5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4e82d759ba2e48638ad1226c2ccca5e5">m_timeStep</a></td></tr>
<tr class="memdesc:a4e82d759ba2e48638ad1226c2ccca5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step. <br /></td></tr>
<tr class="separator:a4e82d759ba2e48638ad1226c2ccca5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89480b124a54ae732a71d2be4251a1c7"><td class="memItemLeft" align="right" valign="top"><a id="a89480b124a54ae732a71d2be4251a1c7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a89480b124a54ae732a71d2be4251a1c7">m_haloBuffer</a></td></tr>
<tr class="memdesc:a89480b124a54ae732a71d2be4251a1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of refinement boundary halo. <br /></td></tr>
<tr class="separator:a89480b124a54ae732a71d2be4251a1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7302d002cffb137588c1f08fef88ffb"><td class="memItemLeft" align="right" valign="top"><a id="ad7302d002cffb137588c1f08fef88ffb"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad7302d002cffb137588c1f08fef88ffb">m_time</a></td></tr>
<tr class="memdesc:ad7302d002cffb137588c1f08fef88ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current time. <br /></td></tr>
<tr class="separator:ad7302d002cffb137588c1f08fef88ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6747e8e5e18f1617c4fb773def7e5fdd"><td class="memItemLeft" align="right" valign="top"><a id="a6747e8e5e18f1617c4fb773def7e5fdd"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a6747e8e5e18f1617c4fb773def7e5fdd">m_dt</a></td></tr>
<tr class="memdesc:a6747e8e5e18f1617c4fb773def7e5fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step. <br /></td></tr>
<tr class="separator:a6747e8e5e18f1617c4fb773def7e5fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5381483b3eb70b58fda7a36a20774738"><td class="memItemLeft" align="right" valign="top"><a id="a5381483b3eb70b58fda7a36a20774738"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5381483b3eb70b58fda7a36a20774738">m_forceIrregDepositionNGP</a></td></tr>
<tr class="memdesc:a5381483b3eb70b58fda7a36a20774738"><td class="mdescLeft">&#160;</td><td class="mdescRight">NGP deposition in cut cells or not. <br /></td></tr>
<tr class="separator:a5381483b3eb70b58fda7a36a20774738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eff78633d5756c928ecfa7ade33e9b"><td class="memItemLeft" align="right" valign="top"><a id="a44eff78633d5756c928ecfa7ade33e9b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a44eff78633d5756c928ecfa7ade33e9b">m_forceIrregInterpolationNGP</a></td></tr>
<tr class="memdesc:a44eff78633d5756c928ecfa7ade33e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">NGP interpolation in cut cells or not. <br /></td></tr>
<tr class="separator:a44eff78633d5756c928ecfa7ade33e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3577bd63b657bd0e01a8fc16f36d66dc"><td class="memItemLeft" align="right" valign="top"><a id="a3577bd63b657bd0e01a8fc16f36d66dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a3577bd63b657bd0e01a8fc16f36d66dc">m_forceHaloNGP</a></td></tr>
<tr class="memdesc:a3577bd63b657bd0e01a8fc16f36d66dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force usage of NGP when depositing "halo" particles. <br /></td></tr>
<tr class="separator:a3577bd63b657bd0e01a8fc16f36d66dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c612b96f248ab1d4952f5640270158"><td class="memItemLeft" align="right" valign="top"><a id="a82c612b96f248ab1d4952f5640270158"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a82c612b96f248ab1d4952f5640270158">m_useRedistribution</a></td></tr>
<tr class="memdesc:a82c612b96f248ab1d4952f5640270158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use mass redistribution or not. <br /></td></tr>
<tr class="separator:a82c612b96f248ab1d4952f5640270158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee84b0a66255e6e5c8b798db2f32e0e"><td class="memItemLeft" align="right" valign="top"><a id="a9ee84b0a66255e6e5c8b798db2f32e0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a9ee84b0a66255e6e5c8b798db2f32e0e">m_blendConservation</a></td></tr>
<tr class="memdesc:a9ee84b0a66255e6e5c8b798db2f32e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for blending the deposition clouds with the "non-conservative" divergence. <br /></td></tr>
<tr class="separator:a9ee84b0a66255e6e5c8b798db2f32e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75440c5ecf1b1bf55e76bc13e28e80c5"><td class="memItemLeft" align="right" valign="top"><a id="a75440c5ecf1b1bf55e76bc13e28e80c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a75440c5ecf1b1bf55e76bc13e28e80c5">m_isDiffusive</a></td></tr>
<tr class="memdesc:a75440c5ecf1b1bf55e76bc13e28e80c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, solver is diffusive. <br /></td></tr>
<tr class="separator:a75440c5ecf1b1bf55e76bc13e28e80c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5525eae4b28bdd085b242d67ac5a1a"><td class="memItemLeft" align="right" valign="top"><a id="acc5525eae4b28bdd085b242d67ac5a1a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#acc5525eae4b28bdd085b242d67ac5a1a">m_isMobile</a></td></tr>
<tr class="memdesc:acc5525eae4b28bdd085b242d67ac5a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, solver is mobile, i.e. advection is turned on. <br /></td></tr>
<tr class="separator:acc5525eae4b28bdd085b242d67ac5a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102e31eab3cdf58100b390afbd6bac5a"><td class="memItemLeft" align="right" valign="top"><a id="a102e31eab3cdf58100b390afbd6bac5a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a102e31eab3cdf58100b390afbd6bac5a">m_plotPhi</a></td></tr>
<tr class="memdesc:a102e31eab3cdf58100b390afbd6bac5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for outputting m_phi to plot files. <br /></td></tr>
<tr class="separator:a102e31eab3cdf58100b390afbd6bac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd69a16d2fe7a28629d5f3a0f83b1ad0"><td class="memItemLeft" align="right" valign="top"><a id="afd69a16d2fe7a28629d5f3a0f83b1ad0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afd69a16d2fe7a28629d5f3a0f83b1ad0">m_plotVelocity</a></td></tr>
<tr class="memdesc:afd69a16d2fe7a28629d5f3a0f83b1ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for outputting m_velocityFunction to plot files. <br /></td></tr>
<tr class="separator:afd69a16d2fe7a28629d5f3a0f83b1ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9e7bdf7a18548a2f13572e8e2811c7"><td class="memItemLeft" align="right" valign="top"><a id="abe9e7bdf7a18548a2f13572e8e2811c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abe9e7bdf7a18548a2f13572e8e2811c7">m_plotDiffCo</a></td></tr>
<tr class="memdesc:abe9e7bdf7a18548a2f13572e8e2811c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for outputting m_diffusionFunction to plot files. <br /></td></tr>
<tr class="separator:abe9e7bdf7a18548a2f13572e8e2811c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9a240d402d0800d2420563b308e3f3"><td class="memItemLeft" align="right" valign="top"><a id="a4d9a240d402d0800d2420563b308e3f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a4d9a240d402d0800d2420563b308e3f3">m_plotParticles</a></td></tr>
<tr class="memdesc:a4d9a240d402d0800d2420563b308e3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the bulk particles on the mesh. <br /></td></tr>
<tr class="separator:a4d9a240d402d0800d2420563b308e3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf7209c5e935aed87c20cce97c09bb4"><td class="memItemLeft" align="right" valign="top"><a id="a9cf7209c5e935aed87c20cce97c09bb4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a9cf7209c5e935aed87c20cce97c09bb4">m_plotParticlesEB</a></td></tr>
<tr class="memdesc:a9cf7209c5e935aed87c20cce97c09bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the EB particles on the mesh. <br /></td></tr>
<tr class="separator:a9cf7209c5e935aed87c20cce97c09bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6a0ec3137e7d82d5c3eea897fd8de8"><td class="memItemLeft" align="right" valign="top"><a id="afc6a0ec3137e7d82d5c3eea897fd8de8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#afc6a0ec3137e7d82d5c3eea897fd8de8">m_plotParticlesDomain</a></td></tr>
<tr class="memdesc:afc6a0ec3137e7d82d5c3eea897fd8de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the domain particles on the mesh. <br /></td></tr>
<tr class="separator:afc6a0ec3137e7d82d5c3eea897fd8de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb34942c2186f94f4c765b3a5528223"><td class="memItemLeft" align="right" valign="top"><a id="a5eb34942c2186f94f4c765b3a5528223"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a5eb34942c2186f94f4c765b3a5528223">m_plotParticlesSource</a></td></tr>
<tr class="memdesc:a5eb34942c2186f94f4c765b3a5528223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the source particles on the mesh. <br /></td></tr>
<tr class="separator:a5eb34942c2186f94f4c765b3a5528223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6647bea673932d5ea9b09c914de6b49"><td class="memItemLeft" align="right" valign="top"><a id="ad6647bea673932d5ea9b09c914de6b49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad6647bea673932d5ea9b09c914de6b49">m_plotParticlesCovered</a></td></tr>
<tr class="memdesc:ad6647bea673932d5ea9b09c914de6b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for depositing and plotting the covered particles on the mesh. <br /></td></tr>
<tr class="separator:ad6647bea673932d5ea9b09c914de6b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b58fe18b09bce12f09dbdbcb5882825"><td class="memItemLeft" align="right" valign="top"><a id="a1b58fe18b09bce12f09dbdbcb5882825"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1b58fe18b09bce12f09dbdbcb5882825">m_plotEnergyDensity</a></td></tr>
<tr class="memdesc:a1b58fe18b09bce12f09dbdbcb5882825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for plotting the energy density on the mesh. <br /></td></tr>
<tr class="separator:a1b58fe18b09bce12f09dbdbcb5882825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757dc659ee8ad33e28fae138affb616b"><td class="memItemLeft" align="right" valign="top"><a id="a757dc659ee8ad33e28fae138affb616b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a757dc659ee8ad33e28fae138affb616b">m_plotAverageEnergy</a></td></tr>
<tr class="memdesc:a757dc659ee8ad33e28fae138affb616b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for plotting the average particle energy on the mesh. <br /></td></tr>
<tr class="separator:a757dc659ee8ad33e28fae138affb616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bc4b0940fd002ab82329890fbd3157"><td class="memItemLeft" align="right" valign="top"><a id="a61bc4b0940fd002ab82329890fbd3157"></a>
<a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a61bc4b0940fd002ab82329890fbd3157">m_deposition</a></td></tr>
<tr class="memdesc:a61bc4b0940fd002ab82329890fbd3157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposition method when depositing particles to the mesh. <br /></td></tr>
<tr class="separator:a61bc4b0940fd002ab82329890fbd3157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9d7bad8c2c17484b49d3f00be4402c"><td class="memItemLeft" align="right" valign="top"><a id="a0c9d7bad8c2c17484b49d3f00be4402c"></a>
<a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a0c9d7bad8c2c17484b49d3f00be4402c">m_coarseFineDeposition</a></td></tr>
<tr class="memdesc:a0c9d7bad8c2c17484b49d3f00be4402c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarse-fine deposition strategy. <br /></td></tr>
<tr class="separator:a0c9d7bad8c2c17484b49d3f00be4402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7796e2e15a35a118207dbf42741f3cf3"><td class="memItemLeft" align="right" valign="top"><a id="a7796e2e15a35a118207dbf42741f3cf3"></a>
<a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a7796e2e15a35a118207dbf42741f3cf3">m_plotDeposition</a></td></tr>
<tr class="memdesc:a7796e2e15a35a118207dbf42741f3cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deposition method when depositing particles to mesh during plotting. <br /></td></tr>
<tr class="separator:a7796e2e15a35a118207dbf42741f3cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5cbaceb9ea706db14a6d93094e2c7e"><td class="memItemLeft" align="right" valign="top"><a id="abc5cbaceb9ea706db14a6d93094e2c7e"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#abc5cbaceb9ea706db14a6d93094e2c7e">m_phi</a></td></tr>
<tr class="memdesc:abc5cbaceb9ea706db14a6d93094e2c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for particle mesh data. <br /></td></tr>
<tr class="separator:abc5cbaceb9ea706db14a6d93094e2c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842d9611dc970ba409a660600b75d922"><td class="memItemLeft" align="right" valign="top"><a id="a842d9611dc970ba409a660600b75d922"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a842d9611dc970ba409a660600b75d922">m_mobilityFunction</a></td></tr>
<tr class="memdesc:a842d9611dc970ba409a660600b75d922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mobility function &ndash; used when interpolating particle mobilities. <br /></td></tr>
<tr class="separator:a842d9611dc970ba409a660600b75d922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7358e6f0f8ba7d994b23cef61c33be69"><td class="memItemLeft" align="right" valign="top"><a id="a7358e6f0f8ba7d994b23cef61c33be69"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a7358e6f0f8ba7d994b23cef61c33be69">m_velocityFunction</a></td></tr>
<tr class="memdesc:a7358e6f0f8ba7d994b23cef61c33be69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell-centered field used for interpolating velocities. <br /></td></tr>
<tr class="separator:a7358e6f0f8ba7d994b23cef61c33be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1530feac364fec71833a2cc367538577"><td class="memItemLeft" align="right" valign="top"><a id="a1530feac364fec71833a2cc367538577"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a1530feac364fec71833a2cc367538577">m_diffusionFunction</a></td></tr>
<tr class="memdesc:a1530feac364fec71833a2cc367538577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diffusion-centerer field used for interpolating diffusion coefficients. <br /></td></tr>
<tr class="separator:a1530feac364fec71833a2cc367538577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dc43db44eb8cb98f208c66162d5e7b"><td class="memItemLeft" align="right" valign="top"><a id="a49dc43db44eb8cb98f208c66162d5e7b"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a49dc43db44eb8cb98f208c66162d5e7b">m_depositionNC</a></td></tr>
<tr class="memdesc:a49dc43db44eb8cb98f208c66162d5e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for holding the non-conservative deposition. <br /></td></tr>
<tr class="separator:a49dc43db44eb8cb98f208c66162d5e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92737393f3b0d1776c7116f65379fec"><td class="memItemLeft" align="right" valign="top"><a id="ab92737393f3b0d1776c7116f65379fec"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ab92737393f3b0d1776c7116f65379fec">m_massDiff</a></td></tr>
<tr class="memdesc:ab92737393f3b0d1776c7116f65379fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for holding the mass difference when using hybrid deposition. <br /></td></tr>
<tr class="separator:ab92737393f3b0d1776c7116f65379fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a391ecb6dd2afbe949ecba8190b1aa"><td class="memItemLeft" align="right" valign="top"><a id="a87a391ecb6dd2afbe949ecba8190b1aa"></a>
std::map&lt; <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>, <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a87a391ecb6dd2afbe949ecba8190b1aa">m_particleContainers</a></td></tr>
<tr class="memdesc:a87a391ecb6dd2afbe949ecba8190b1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various particle containers with identifiers. <br /></td></tr>
<tr class="separator:a87a391ecb6dd2afbe949ecba8190b1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7085664bc99192e140061cea2e06c83"><td class="memItemLeft" align="right" valign="top"><a id="ad7085664bc99192e140061cea2e06c83"></a>
<a class="el" href="CD__EBIntersection_8H.html#ad8aa543cfc22c9b4f2a6a6dab88ea1e9">EBIntersection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#ad7085664bc99192e140061cea2e06c83">m_intersectionAlg</a></td></tr>
<tr class="memdesc:ad7085664bc99192e140061cea2e06c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithm for EB intersection. <br /></td></tr>
<tr class="separator:ad7085664bc99192e140061cea2e06c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa9fb27c5e5045c58b9c8be966e78199b"><td class="memItemLeft" align="right" valign="top"><a id="aa9fb27c5e5045c58b9c8be966e78199b"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#aa9fb27c5e5045c58b9c8be966e78199b">m_comp</a> = 0</td></tr>
<tr class="memdesc:aa9fb27c5e5045c58b9c8be966e78199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default component in data holders (do not touch). <br /></td></tr>
<tr class="separator:aa9fb27c5e5045c58b9c8be966e78199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cee90b04b96ce937fc28d458ec77d96"><td class="memItemLeft" align="right" valign="top"><a id="a3cee90b04b96ce937fc28d458ec77d96"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItoSolver.html#a3cee90b04b96ce937fc28d458ec77d96">m_nComp</a> = 1</td></tr>
<tr class="memdesc:a3cee90b04b96ce937fc28d458ec77d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number of component in data holders (do not touch). <br /></td></tr>
<tr class="separator:a3cee90b04b96ce937fc28d458ec77d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for Ito diffusion particle models. </p>
<p>This is a particle class for solving Ito diffusion problems dX = v*dt + sqrt(2*D)*dW_t (dW_t is a Wiener process over dt) over an AMR hierarchy. The diffusion coefficient is related to the hydrodynamic diffusion coefficient by D(fluid) = sqrt(2*D(Ito)). </p><dl class="section note"><dt>Note</dt><dd>To use this class, the user must add a species and set the realm and phase where the solver will live. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a93be4b5f935a4ba80472db227c9d75cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93be4b5f935a4ba80472db227c9d75cd">&#9670;&nbsp;</a></span>WhichCheckpoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classItoSolver.html#a93be4b5f935a4ba80472db227c9d75cd">ItoSolver::WhichCheckpoint</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How to checkpoint files. </p>
<p>Particles =&gt; Write particles to HDF5. Numbers =&gt; Write particle numbers to HDF5 (and lose information) </p>

</div>
</div>
<a id="a070d75d0d3ac16e04013d25574c1ffa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d75d0d3ac16e04013d25574c1ffa5">&#9670;&nbsp;</a></span>WhichContainer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">ItoSolver::WhichContainer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum class for distinguishing various types of particle containers. </p>
<p>This exists because the <a class="el" href="classItoSolver.html" title="Base class for Ito diffusion particle models.">ItoSolver</a> can partition particles into various containers, which is very useful when one wants to add particles from a source term, remove particles that fall inside the EB, or parse boundary conditions on the EB and domain faces. Here, Bulk = "Active" particles, EB = Particles on the EBs , Domain = Particles on the domain sides, Source = Source particles &ndash; used to e.g. add new particles to the bulk particles, Covered = Particles inside the EB, Scratch = Scratch particles </p>

</div>
</div>
<a id="ac7ea13986249a06a5185c8315e4548bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ea13986249a06a5185c8315e4548bc">&#9670;&nbsp;</a></span>WhichMobilityInterpolation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classItoSolver.html#ac7ea13986249a06a5185c8315e4548bc">ItoSolver::WhichMobilityInterpolation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum for deciding how to interpolate particle mobilities. </p>
<p>Direct =&gt; Interpolate particle mobilities from the mesh. Velocity =&gt; Set particle mobilitys by computing mu = |v|/|V| where v is the particle velocity and V is the "velocity field". </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9630057bd092fce7fb72044a628459af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9630057bd092fce7fb72044a628459af">&#9670;&nbsp;</a></span>addParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ItoSolver::WhichContainer C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::addParticles </td>
          <td>(</td>
          <td class="paramtype">ListBox&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_inputParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_destructive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add particles to a contain. This adds into a specific grid level and patch. The user can delete the input particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_inputParticles</td><td>Input particles &ndash; can be destroyed if a_destructive=true </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_destructive</td><td>If true, delete the input particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6f2c8ad146edca5e4d248349fda2afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f2c8ad146edca5e4d248349fda2afb">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate internal storage. </p>
<p>This will allocate the required mesh data as well as all the particle data holders. </p><dl class="section note"><dt>Note</dt><dd>Storage for diffusion and advection fields are only allocate if the species is diffusive/mobile. </dd></dl>

</div>
</div>
<a id="a6fee60a86508b6ce121dea757f6a3144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fee60a86508b6ce121dea757f6a3144">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="CD__ParticleContainer_8H.html#ab57ee0582213ddd8962c5922528275a3">AMRParticles</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear particles &ndash; this will deleted all the particles in the input container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container to be emptied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad10a4355f45e56bd7b5a971b1173db1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10a4355f45e56bd7b5a971b1173db1d">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a particle container &ndash; this will delete all the particles in the input container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_whichContainer</td><td>Particle container to be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5766b96846e5e5f1b152e42aa752dd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5766b96846e5e5f1b152e42aa752dd53">&#9670;&nbsp;</a></span>clear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a particle container &ndash; this will delete all the particles in the input container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle container to be emptied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abafa5edfbb02fcab67e2e2e7da5a1ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafa5edfbb02fcab67e2e2e7da5a1ce0">&#9670;&nbsp;</a></span>computeAdvectiveDt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeAdvectiveDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the drift dt. This computes the minimum dt = dx/vMax on the input level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42432c4f69f66dfca9a5c74784664167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42432c4f69f66dfca9a5c74784664167">&#9670;&nbsp;</a></span>computeAdvectiveDt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeAdvectiveDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the drift dt. This computes the minimum dt = dx/vMax on one level and one box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd134aade2a3035692c1bd26599b157f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd134aade2a3035692c1bd26599b157f">&#9670;&nbsp;</a></span>computeAverageDiffusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::computeAverageDiffusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute average diffusion coefficient. </p>
<p>This computes the average diffusion coefficient as D_avg = sum(mass*D)/sum(mass) by depositing on the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0140880d0a497f9c2bf6bd3cbb97f2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0140880d0a497f9c2bf6bd3cbb97f2c0">&#9670;&nbsp;</a></span>computeAverageEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::computeAverageEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute average particle energy.. </p>
<p>This computes the average energy as E_avg = sum(mass*energy)/sum(mass) by depositing on the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65647094a4c039fd19e17dd944297eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65647094a4c039fd19e17dd944297eeb">&#9670;&nbsp;</a></span>computeAverageMobility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::computeAverageMobility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute average mobility. </p>
<p>This computes the average mobility as mu_avg = sum(mass*mu)/sum(mass) by depositing on the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb099bd8a10e78857d024d26f7b6570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb099bd8a10e78857d024d26f7b6570">&#9670;&nbsp;</a></span>computeDiffusiveDt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDiffusiveDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles on the input level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a040479280a818cbe4947529d7651ce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040479280a818cbe4947529d7651ce1c">&#9670;&nbsp;</a></span>computeDiffusiveDt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDiffusiveDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the diffusive dt. This computes dt = dx*dx/(2*D) for all particles on the input grid patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fad5fa4823fa70c9722b863ab3e35f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fad5fa4823fa70c9722b863ab3e35f5">&#9670;&nbsp;</a></span>computeDt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a time step for the advance &ndash; this calls the level function. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not have a fundamental time step limitation, so these limits "replicate" the time step selections in a 1D fluid model. If we only use advection advection the time step is computed as dt = dx/Vmax = dtA, where Vmax is the largest velocity component along any of the directions. If only diffusion is active the time step is computed as dt = (dx*dx)/(2*D) = dtD. If both advection and diffusion are active the time step is computed as dt = 1/(1/dtA + 1/dtD). </p>

</div>
</div>
<a id="a0fe18ba36b867d4ddc70f686dd977ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe18ba36b867d4ddc70f686dd977ab7">&#9670;&nbsp;</a></span>computeDt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a time step for the advance &ndash; this returns the maximum permitted time step on the input grid level. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not have a fundamental time step limitation, so these limits "replicate" the time step selections in a 1D fluid model. If we only use advection advection the time step is computed as dt = dx/Vmax = dtA, where Vmax is the largest velocity component along any of the directions. If only diffusion is active the time step is computed as dt = (dx*dx)/(2*D) = dtD. If both advection and diffusion are active the time step is computed as dt = 1/(1/dtA + 1/dtD). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41787bfa9dd5767989a63e7782e50e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41787bfa9dd5767989a63e7782e50e9">&#9670;&nbsp;</a></span>computeDt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeDt </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a time step for the advance &ndash; this returns the maximum permitted time step on the input grid patch. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not have a fundamental time step limitation, so these limits "replicate" the time step selections in a 1D fluid model. If we only use advection advection the time step is computed as dt = dx/Vmax = dtA, where Vmax is the largest velocity component along any of the directions. If only diffusion is active the time step is computed as dt = (dx*dx)/(2*D) = dtD. If both advection and diffusion are active the time step is computed as dt = 1/(1/dtA + 1/dtD). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40f48f81560c8a7d1c3952303187e519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f48f81560c8a7d1c3952303187e519">&#9670;&nbsp;</a></span>computeHopDt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeHopDt </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_maxCellsToMove</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on any grid level. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not a fundamental time step limitation, so this function does its best at computing a time step such that the particles do not move more than the specified amount of grid cells. If only advection is active the time step is computed as dt = a_maxCellsToMove * dx/vMax where vMax is the largest velocity component. If only diffusion is active the usual kernel is dX = dWt which yields a "hop" of length L_d = sqrt(2*D*dt)*N0 where N0 is the diffusion hop in one of the coordinates. We do not need to worry about SpaceDim-related corrections because the hops in each direction are independent, so solving for dt we find dtD = L_d^2/(2*D*N0^2). If both advectino and diffusion are active then we can move up to L_d = v_d*dt + sqrt(2*D*dt)*N0 in any one coordinate direction (this is the usual Ito kernel). This requires a solution to a quadratic equation. Fortunately, this is easy to solve for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxCellsToMove</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17ea187e51e51e3623459068cc281b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ea187e51e51e3623459068cc281b14">&#9670;&nbsp;</a></span>computeHopDt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeHopDt </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_maxCellsToMove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on the input grid level. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not a fundamental time step limitation, so this function does its best at computing a time step such that the particles do not move more than the specified amount of grid cells. If only advection is active the time step is computed as dt = a_maxCellsToMove * dx/vMax where vMax is the largest velocity component. If only diffusion is active the usual kernel is dX = dWt which yields a "hop" of length L_d = sqrt(2*D*dt)*N0 where N0 is the diffusion hop in one of the coordinates. We do not need to worry about SpaceDim-related corrections because the hops in each direction are independent, so solving for dt we find dtD = L_d^2/(2*D*N0^2). If both advectino and diffusion are active then we can move up to L_d = v_d*dt + sqrt(2*D*dt)*N0 in any one coordinate direction (this is the usual Ito kernel). This requires a solution to a quadratic equation. Fortunately, this is easy to solve for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxCellsToMove</td><td>Maximum number of cells to move with a standard Ito kernel dX = v*dt + sqrt(2*D*dt)*N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab053c9b08666c62e4527258f7762793c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab053c9b08666c62e4527258f7762793c">&#9670;&nbsp;</a></span>computeHopDt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::computeHopDt </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_maxCellsToMove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the largest possible time step such that the particles does not move more than a specified number of grid cells on the input grid level. </p>
<p>This computes the time step differently whether or not diffusion and advection are active. The Ito particle model does not a fundamental time step limitation, so this function does its best at computing a time step such that the particles do not move more than the specified amount of grid cells. If only advection is active the time step is computed as dt = a_maxCellsToMove * dx/vMax where vMax is the largest velocity component. If only diffusion is active the usual kernel is dX = dWt which yields a "hop" of length L_d = sqrt(2*D*dt)*N0 where N0 is the diffusion hop in one of the coordinates. We do not need to worry about SpaceDim-related corrections because the hops in each direction are independent, so solving for dt we find dtD = L_d^2/(2*D*N0^2). If both advectino and diffusion are active then we can move up to L_d = v_d*dt + sqrt(2*D*dt)*N0 in any one coordinate direction (this is the usual Ito kernel). This requires a solution to a quadratic equation. Fortunately, this is easy to solve for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_maxCellsToMove</td><td>Maximum number of cells to move with a standard Ito kernel dX = v*dt + sqrt(2*D*dt)*N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4dd656605d24d6171dd291bb20ab7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dd656605d24d6171dd291bb20ab7d4">&#9670;&nbsp;</a></span>computeLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::computeLoads </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_loads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DisjointBoxLayout &amp;&#160;</td>
          <td class="paramname"><em>a_dbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute particle load on a specific grid level &ndash; this will compute the number of particles in each box in the input grids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_loads</td><td>Loads on each grid patch. This follows the order from a_dbl.boxArray() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dbl</td><td>Grids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55cc85c3c9a7a0327f0a3c6fff256065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cc85c3c9a7a0327f0a3c6fff256065">&#9670;&nbsp;</a></span>depositConductivity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositConductivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit conductivities (i.e. mass*mobility / volume) </p>
<p>This deposits mass*mobility (not multiplied by charge) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09b82ab687e57ec23328b9b63927ff95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b82ab687e57ec23328b9b63927ff95">&#9670;&nbsp;</a></span>depositConductivity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositConductivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit conductivities (i.e. mass*mobility / volume) </p>
<p>This deposits mass*mobility (not multiplied by charge) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Coarse-fine deposition method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92fcaf6625351303b1b856ebc6d4c48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fcaf6625351303b1b856ebc6d4c48d">&#9670;&nbsp;</a></span>depositDiffusivity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositDiffusivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit diffusivity (i.e. mass*D/volume) </p>
<p>This deposits mass*diffusion (not multiplied by charge) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls the other versions with a_deposition = m_deposition </dd></dl>

</div>
</div>
<a id="ad21a6fcfd7c586497131343aa00efff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21a6fcfd7c586497131343aa00efff5">&#9670;&nbsp;</a></span>depositDiffusivity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositDiffusivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit diffusivity (i.e. mass*D/volume) </p>
<p>This deposits mass*mobility (not multiplied by charge) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Coarse-fine deposition method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab173a4bede9c8cebe09fc7c2d8ec1dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab173a4bede9c8cebe09fc7c2d8ec1dc6">&#9670;&nbsp;</a></span>depositEnergyDensity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositEnergyDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit energy densities (i.e. mass*energy/volume =&gt; total energy per unit volume) </p>
<p>This deposits mass*energy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls the other versions with a_deposition = m_deposition </dd></dl>

</div>
</div>
<a id="a00d57a8de8deee382a29d713bf7331e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d57a8de8deee382a29d713bf7331e2">&#9670;&nbsp;</a></span>depositEnergyDensity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositEnergyDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit energy densities (i.e. mass*energy/volume =&gt; total energy per unit volume) </p>
<p>This deposits mass*energy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particle data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Coarse-fine deposition method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac2b82ed36f44539366b43564e352846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2b82ed36f44539366b43564e352846">&#9670;&nbsp;</a></span>depositHybrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositHybrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_depositionH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_massDifference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_depositionNC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the "hybrid" deposition phiH = kappa*phiC + (1-kappa)*phiNC. On input, a_depositionH should contain phiC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_depositionH</td><td>On input, contains phiC. On output, contain phiH </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_massDifference</td><td>On output, contains mass loss in each cut-cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionNC</td><td>The "non-conservative" deposited variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c0ecc49bb1f0ece27a920c4ea6a1232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0ecc49bb1f0ece27a920c4ea6a1232">&#9670;&nbsp;</a></span>depositKappaConservative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositKappaConservative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cell-centered deposition &ndash; this is the main deposition function. </p>
<p>The template parameters indicate the particle type and quantity to be deposited. The second template parameter must be a pointer to a member function in the particle class with signature 'const Real&amp; P::function() const'. E.g. 'const Real&amp; P::mass() const' which is the default quantity to be deposited. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Cell-centered mesh data. Must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Coarse-fine deposition strategy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c0ecc49bb1f0ece27a920c4ea6a1232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0ecc49bb1f0ece27a920c4ea6a1232">&#9670;&nbsp;</a></span>depositKappaConservative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositKappaConservative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cell-centered deposition &ndash; this is the main deposition function. </p>
<p>Just like the version above except that the function signature is Real P::particleScalarField() const. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Cell-centered mesh data. Must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Coarse-fine deposition strategy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f6778295d539cd8d0224bf2615e93bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6778295d539cd8d0224bf2615e93bb">&#9670;&nbsp;</a></span>depositNonConservative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositNonConservative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_depositionNC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_depositionKappaC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the "non-conservative" kappa deposition &ndash; computing depositionNC = sum(kappa*depositionC)/sum(kappa) in a neighborhood around each vof. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_depositionNC</td><td>Non-conservative deposition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_depositionKappaC</td><td>Conserved deposition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18a43e827b7b8e1776cf9e4572ccf6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a43e827b7b8e1776cf9e4572ccf6a0">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit particles onto mesh. </p>
<p>This will deposit the mass (i.e., computational weight) "bulk" particles into m_phi. </p><dl class="section note"><dt>Note</dt><dd>Cells the other version with a_container = WhichContainer::Bulk </dd></dl>

</div>
</div>
<a id="a83fa3e39b93d9f4abf3c8ca352c61d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fa3e39b93d9f4abf3c8ca352c61d02">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deposit particles on to mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to deposit.</td></tr>
  </table>
  </dd>
</dl>
<p>This will deposit mass (i.e., computational weight) of the the input particle container particles onto the classes member 'm_phi'. </p><dl class="section note"><dt>Note</dt><dd>Calls the general version with arguments: m_phi, m_particles.at(a_container), m_deposition. </dd></dl>

</div>
</div>
<a id="a6209d584e115b2ae1958409f064bb668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6209d584e115b2ae1958409f064bb668">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , const Real &amp;(P::*)() const particleScalarField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic deposition function which deposits a particle field onto the mesh using a specified deposition method. </p>
<p>The template parameters indicate the particle type and quantity to be deposited. The second template parameter must be a pointer to a member function in the particle class with signature 'const Real&amp; P::function() const'. E.g. 'const Real&amp; P::mass() const' which is the default quantity to be deposited. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data &ndash; must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b813b27a3f4058f6208d2be5e8cba35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b813b27a3f4058f6208d2be5e8cba35">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic deposition function which deposits a particle field onto the mesh using a specified deposition method. </p>
<p>The template parameters indicate the particle type and quantity to be deposited. The second template parameter must be a pointer to a member function in the particle class with signature 'const Real&amp; P::function() const'. E.g. 'const Real&amp; P::mass() const' which is the default quantity to be deposited. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data &ndash; must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Coarse-fine deposition strategy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b813b27a3f4058f6208d2be5e8cba35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b813b27a3f4058f6208d2be5e8cba35">&#9670;&nbsp;</a></span>depositParticles() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P::*)() const particleScalarField&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a>&#160;</td>
          <td class="paramname"><em>a_deposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__CoarseFineDeposition_8H.html#a187d926e3e73dcdb6fe988f652cd3a0c">CoarseFineDeposition</a>&#160;</td>
          <td class="paramname"><em>a_coarseFineDeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic deposition function which deposits a particle field onto the mesh using a specified deposition method. </p>
<p>Just like the version above, but with a different function signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_phi</td><td>Mesh data &ndash; must have exactly one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to be deposited </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deposition</td><td>Deposition method </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_coarseFineDeposition</td><td>Coarse-fine deposition strategy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a538607e6b1f3f2c9e45b8def6d264bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538607e6b1f3f2c9e45b8def6d264bcc">&#9670;&nbsp;</a></span>depositParticlesNGP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P ::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticlesNGP </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do an NGP deposit on a specific grid level. Used for IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_output</td><td>Contains NGP deposition of particles. Ignores cut-cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a538607e6b1f3f2c9e45b8def6d264bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538607e6b1f3f2c9e45b8def6d264bcc">&#9670;&nbsp;</a></span>depositParticlesNGP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , Real(P ::*)() const particleScalarField&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::depositParticlesNGP </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do an NGP deposit on a specific grid level. Used for IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_output</td><td>Contains NGP deposition of particles. Ignores cut-cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a803e769f2adeed3b1a2f2b9d40c2422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803e769f2adeed3b1a2f2b9d40c2422f">&#9670;&nbsp;</a></span>drawNewParticles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::drawNewParticles </td>
          <td>(</td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newPPC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restart particles from a specified number of particles in the grid cell. </p>
<p>This will instantiate the bulk particles by randomly drawing new particles in each grid cell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Mesh data showing how many particles are in each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newPPC</td><td>Desired number of computational particles per cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6205a79851e8e13fee2fd0edc2b48c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6205a79851e8e13fee2fd0edc2b48c9">&#9670;&nbsp;</a></span>getDeposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CD__DepositionType_8H.html#a3e0386e57e39a4ba4ec16c3d7734a486">DepositionType</a> ItoSolver::getDeposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get deposition method. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_deposition </dd></dl>

</div>
</div>
<a id="a8a953e12f23840429f1888d2e49a95b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a953e12f23840429f1888d2e49a95b9">&#9670;&nbsp;</a></span>getDiffusionFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getDiffusionFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the diffusion function. </p>
<dl class="section return"><dt>Returns</dt><dd>m_diffusionFunction </dd></dl>

</div>
</div>
<a id="afcecd78eb94c06eacb8b4aaae2376dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcecd78eb94c06eacb8b4aaae2376dd2">&#9670;&nbsp;</a></span>getDiffusionFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getDiffusionFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the diffusion function. </p>
<dl class="section return"><dt>Returns</dt><dd>m_diffusionFunction </dd></dl>

</div>
</div>
<a id="ae614b9a9accb81aba62bce6435e52ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae614b9a9accb81aba62bce6435e52ebf">&#9670;&nbsp;</a></span>getMobilityFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getMobilityFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get mobility function. </p>
<dl class="section return"><dt>Returns</dt><dd>m_mobilityFunction </dd></dl>

</div>
</div>
<a id="a436073f3af21cc58fb23b744cd4ce77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436073f3af21cc58fb23b744cd4ce77e">&#9670;&nbsp;</a></span>getMobilityFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getMobilityFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get mobility function. </p>
<dl class="section return"><dt>Returns</dt><dd>m_mobilityFunction </dd></dl>

</div>
</div>
<a id="a6e6fcdccd99f9369d87b8e74646f0296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6fcdccd99f9369d87b8e74646f0296">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ItoSolver::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this solver's name. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_name </dd></dl>

</div>
</div>
<a id="ad0938b394aa25ddeac394ecce5d2b474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0938b394aa25ddeac394ecce5d2b474">&#9670;&nbsp;</a></span>getNumberOfPlotVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ItoSolver::getNumberOfPlotVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of plot variables. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of plot variables (Note: Scalars-&gt; one variable and vectors -&gt; SpaceDim variables). </dd></dl>

</div>
</div>
<a id="acfe37223efd84b9a1f174a600bd795df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe37223efd84b9a1f174a600bd795df">&#9670;&nbsp;</a></span>getNumParticles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long ItoSolver::getNumParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_localOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of particles in a specified particle container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_whichContainer</td><td>Which container to count particles in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_localOnly</td><td>Only report local particles (i.e. not reduced over MPI ranks) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a754df1d59ab75675768b1fdba4ce759a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754df1d59ab75675768b1fdba4ce759a">&#9670;&nbsp;</a></span>getParticles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp; ItoSolver::getParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a general particle container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to fetch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83b5921e65afb1442dc9a71ef2c83d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b5921e65afb1442dc9a71ef2c83d55">&#9670;&nbsp;</a></span>getParticles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp; ItoSolver::getParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a general particle container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to fetch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0728c740c0a9ced2691f193057b384fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0728c740c0a9ced2691f193057b384fa">&#9670;&nbsp;</a></span>getPhase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">phase::which_phase ItoSolver::getPhase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return phase. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_phase </dd></dl>

</div>
</div>
<a id="aa426b09943223c61f0a9a5c51ddb8822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa426b09943223c61f0a9a5c51ddb8822">&#9670;&nbsp;</a></span>getPhi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getPhi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mesh data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_phi </dd></dl>

</div>
</div>
<a id="a113c01d977f92e8048729f259cf32b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113c01d977f92e8048729f259cf32b81">&#9670;&nbsp;</a></span>getPlotVariableNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; std::string &gt; ItoSolver::getPlotVariableNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get output plot names. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a string of all variables that this solver can add to plot files. </dd></dl>

</div>
</div>
<a id="aa314653552338b3a526f5241bf874f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa314653552338b3a526f5241bf874f0d">&#9670;&nbsp;</a></span>getRealm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string ItoSolver::getRealm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the realm where this solver is registered. </p>
<dl class="section return"><dt>Returns</dt><dd>m_realm </dd></dl>

</div>
</div>
<a id="acab7ee2c7496bdad4c5331b4ccf84952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab7ee2c7496bdad4c5331b4ccf84952">&#9670;&nbsp;</a></span>getSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt; &amp; ItoSolver::getSpecies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the species. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_species </dd></dl>

</div>
</div>
<a id="a514eded13d2870997604e287111bb7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514eded13d2870997604e287111bb7a2">&#9670;&nbsp;</a></span>getVelocityFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getVelocityFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cell-centered velocity mesh data. </p>
<dl class="section return"><dt>Returns</dt><dd>m_velocityFunction </dd></dl>

</div>
</div>
<a id="a064a1b08192d33afdf02fa8d153f2a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064a1b08192d33afdf02fa8d153f2a8f">&#9670;&nbsp;</a></span>getVelocityFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; ItoSolver::getVelocityFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cell-centered velocity mesh data. </p>
<dl class="section return"><dt>Returns</dt><dd>m_velocityFunction </dd></dl>

</div>
</div>
<a id="abc86cb62b622c8ddfd0b7fb1601afda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc86cb62b622c8ddfd0b7fb1601afda7">&#9670;&nbsp;</a></span>initialData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::initialData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the initial data. </p>
<p>This will add the initial particles and deposit them. </p>

</div>
</div>
<a id="a64b5e34d86ab0286807678c7f753f57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b5e34d86ab0286807678c7f753f57e">&#9670;&nbsp;</a></span>interpolateDiffusion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateDiffusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the diffusion field to the particle positions. </p>
<p>This computes D_p = Df(X_p) where Df is the diffusion field on the mesh. </p>

</div>
</div>
<a id="aef3ef423300841c7a94bdb2ccd248189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3ef423300841c7a94bdb2ccd248189">&#9670;&nbsp;</a></span>interpolateDiffusion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateDiffusion </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the diffusion field to the particle positions. </p>
<p>This computes D_p = Df(X_p) where Df is the diffusion field on the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06df3eb32ebb71b1858298b2b0d7dd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df3eb32ebb71b1858298b2b0d7dd0b">&#9670;&nbsp;</a></span>interpolateMobilities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateMobilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate mobilities. </p>
<p>This will switch between the two ways of computing the particle mobility. </p>

</div>
</div>
<a id="ad2e2869b2f9907251a682b7d25198207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e2869b2f9907251a682b7d25198207">&#9670;&nbsp;</a></span>interpolateMobilities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateMobilities </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_velocityMagnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate mobilities &ndash; this will switch between the two ways of computing the particle mobility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_velocityMagnitude</td><td>Velocity magnitude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5934ada9e1588736018ece31217d6404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5934ada9e1588736018ece31217d6404">&#9670;&nbsp;</a></span>interpolateMobilitiesDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateMobilitiesDirect </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly interpolate mobilities. Interpolates for all particles in the specified grid patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2be7c7592bca502599911c75fc376a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2be7c7592bca502599911c75fc376a4">&#9670;&nbsp;</a></span>interpolateMobilitiesVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateMobilitiesVelocity </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_velocityMagnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate mobilities through the velocity. Interpolates for all particles in the specified grid patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_velocityMagnitude</td><td>Velocity magnitude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58a6d5963c8a82dca1aa2868e0988b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a6d5963c8a82dca1aa2868e0988b75">&#9670;&nbsp;</a></span>interpolateVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateVelocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the particle velocities. </p>
<p>This will compute the particle velocities as v = mu * V(Xp) where mu is the particle mobility and V(Xp) is the interpolation of m_velocityFunction to the particle position. </p>

</div>
</div>
<a id="a4f927ad3700a86bb8eaabb11912f81a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f927ad3700a86bb8eaabb11912f81a9">&#9670;&nbsp;</a></span>interpolateVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::interpolateVelocities </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex &amp;&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate the particle velocities. </p>
<p>This will compute the particle velocities as v = mu * V(Xp) where mu is the particle mobility and V(Xp) is the interpolation of m_velocityFunction to the particle position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a288e63ce8c95c93f6a66289c4b827dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288e63ce8c95c93f6a66289c4b827dbf">&#9670;&nbsp;</a></span>intersectParticles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::intersectParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="CD__EBIntersection_8H.html#ad8aa543cfc22c9b4f2a6a6dab88ea1e9">EBIntersection</a>&#160;</td>
          <td class="paramname"><em>a_ebIntersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>a_nonDeletionModifier</em> = <code>[](<a class="el" href="classItoParticle.html">ItoParticle</a>&amp;)&#160;-&gt;&#160;void&#160;{&#160;return;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do boundary intersection tests. </p>
<p>This will intersect the particles in the "bulk" particles data holder with the domain faces and EBs. If a particle crossed the EB it will be put into the "EB" particle data holder and likewise for the particles that crossed the domain side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebIntersection</td><td>Enum for switching between various types of intersection tests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, the origin particle will also be removed from the bulk particle data holder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nonDeletionModifier</td><td>Optional input argument for letting the user manipulate particles that were intersected but not deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will call the other version with WhichContainer::Bulk, WhichContainer::EB, and WhichContainer::Domain. </dd></dl>

</div>
</div>
<a id="aefea80730585dfd8585bc80c3cc9dbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefea80730585dfd8585bc80c3cc9dbdc">&#9670;&nbsp;</a></span>intersectParticles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::intersectParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_ebParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_domainParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EBIntersection_8H.html#ad8aa543cfc22c9b4f2a6a6dab88ea1e9">EBIntersection</a>&#160;</td>
          <td class="paramname"><em>a_ebIntersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>a_nonDeletionModifier</em> = <code>[](<a class="el" href="classItoParticle.html">ItoParticle</a>&amp;)&#160;-&gt;&#160;void&#160;{&#160;return;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do boundary intersection tests. </p>
<p>This will intersect the particles in the a_particles data holder with the domain faces and EBs. If a particle crossed the EB it will be put into the a_eb_particles particle data holder and likewise for the particles that crossed the domain side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Which particle container to use for the "active" particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebParticles</td><td>Which particle container to put the EB particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainParticles</td><td>Which particle container to put the domain particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebIntersection</td><td>Enum for switching between various types of intersection tests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, the origin particle will also be removed from the bulk particle data holder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nonDeletionModifier</td><td>Optional input argument for letting the user manipulate particles that were intersected but not deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will look up the <a class="el" href="classParticleContainer.html" title="Templated class for holding particles on an AMR hierarchy with particle remapping.">ParticleContainer</a> and call the other version. </dd></dl>

</div>
</div>
<a id="aca9d257d5bbe99cc64b94fbc8eb351cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9d257d5bbe99cc64b94fbc8eb351cf">&#9670;&nbsp;</a></span>intersectParticles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::intersectParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domainParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EBIntersection_8H.html#ad8aa543cfc22c9b4f2a6a6dab88ea1e9">EBIntersection</a>&#160;</td>
          <td class="paramname"><em>a_ebIntersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_deleteParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classItoParticle.html">ItoParticle</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>a_nonDeletionModifier</em> = <code>[](<a class="el" href="classItoParticle.html">ItoParticle</a>&amp;)&#160;-&gt;&#160;void&#160;{&#160;return;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do boundary intersection tests. </p>
<p>This will intersect the particles in the a_particles data holder with the domain faces and EBs. If a particle crossed the EB it will be put into the a_eb_particles particle data holder and likewise for the particles that crossed the domain side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Which particle container to use for the "active" particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebParticles</td><td>Which particle container to put the EB particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainParticles</td><td>Which particle container to put the domain particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebIntersection</td><td>Enum for switching between various types of intersection tests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_deleteParticles</td><td>If true, the origin particle will also be removed from the bulk particle data holder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nonDeletionModifier</td><td>Optional input argument for letting the user manipulate particles that were intersected but not deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1db74cb60c15142ce2729deb9179a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1db74cb60c15142ce2729deb9179a31">&#9670;&nbsp;</a></span>isDiffusive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ItoSolver::isDiffusive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if solver is diffusive. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_isDiffusive </dd></dl>

</div>
</div>
<a id="a8967ce2dec5194a8d54e0dd7e4acec08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8967ce2dec5194a8d54e0dd7e4acec08">&#9670;&nbsp;</a></span>isMobile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ItoSolver::isMobile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if solver is mobile. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_isMobile </dd></dl>

</div>
</div>
<a id="a90e0d074046485949984c3c074d1fe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e0d074046485949984c3c074d1fe58">&#9670;&nbsp;</a></span>makeSuperparticles() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::makeSuperparticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make superparticles for a full container &ndash; this is the AMR version that users will usually call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to repartition into new superparticles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc59aabefa256470657b9c0087725c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc59aabefa256470657b9c0087725c20">&#9670;&nbsp;</a></span>makeSuperparticles() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::makeSuperparticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make superparticles for a particle container &ndash; this is used for a specified grid level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to repartition into new superparticles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8859e84b563c9aa49927b39628571d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8859e84b563c9aa49927b39628571d3">&#9670;&nbsp;</a></span>makeSuperparticles() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::makeSuperparticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make superparticles for a particle container &ndash; this is used for a specified grid level and patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to repartition into new superparticles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea171a47b9ed6b7f3aed7c3d90ede120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea171a47b9ed6b7f3aed7c3d90ede120">&#9670;&nbsp;</a></span>makeSuperparticles() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::makeSuperparticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make superparticles for a full container &ndash; this is the AMR version that users will usually call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which container to repartition into new superparticles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell. Vector indicates grid levels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a054d02df4353cf514c5a7e84616c8b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054d02df4353cf514c5a7e84616c8b3b">&#9670;&nbsp;</a></span>makeSuperparticlesEqualWeightKD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::makeSuperparticlesEqualWeightKD </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCellInfo.html">CellInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Superparticle merging with KD/BVH trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be merged/split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellInfo</td><td>Arithmetic information about the current grid cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51538761f2825b0989349d640e8c061c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51538761f2825b0989349d640e8c061c">&#9670;&nbsp;</a></span>mergeParticles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::mergeParticles </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCellInfo.html">CellInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General superparticle merging with underlying algorithm through m_particleMerger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be merged/split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellInfo</td><td>Arithmetic information about the current grid cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a105469be7e9f0bda74d6e3ce523bd9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105469be7e9f0bda74d6e3ce523bd9bf">&#9670;&nbsp;</a></span>organizeParticlesByCell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::organizeParticlesByCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the input particle container by cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Container to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d2cd095f6e6b42efea7cf302b676883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2cd095f6e6b42efea7cf302b676883">&#9670;&nbsp;</a></span>organizeParticlesByPatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::organizeParticlesByPatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the input particle container by patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Container to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30eb3e95dfee2010652368ce894bda9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30eb3e95dfee2010652368ce894bda9d">&#9670;&nbsp;</a></span>preRegrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::preRegrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pre-regrid operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lbase</td><td>Coarsest level that changed during regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest grid level before the regrid operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This caches the bulk particles. </dd></dl>

</div>
</div>
<a id="a019fa52c90f664f338441ae58ee891cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019fa52c90f664f338441ae58ee891cf">&#9670;&nbsp;</a></span>randomDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealVect ItoSolver::randomDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a random direction in N-dimensional space. </p>
<p>We use the algorithm by Marsaglia (1972). </p>

</div>
</div>
<a id="a77cbe509c51f4fce01400a105760b1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cbe509c51f4fce01400a105760b1e9">&#9670;&nbsp;</a></span>randomGaussian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealVect ItoSolver::randomGaussian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a random N-dimensional Gaussian number from a normal distribution with zero with and unit standard deviation. </p>
<dl class="section note"><dt>Note</dt><dd>The distribution is truncated at m_normalDistributionTruncation &ndash; values above that threshold will be replaced by m_normalDistributionTruncation. </dd></dl>

</div>
</div>
<a id="ad599086b015754fd8dc25f94ba0b686d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad599086b015754fd8dc25f94ba0b686d">&#9670;&nbsp;</a></span>redistributeAMR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::redistributeAMR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redistribute mass in an AMR context. </p>
<p>We will have deposited particles into each cell, i.e. phi_i = m_i/dx^3. To obtain the true density in an EB context we need to divide by kappa such that phi_i = m_i/(kappa_i*dx^3). Unfortunately, this is numerically unstable because kappa_i can be arbitrarily small. We can set the density as phi_i = m_i/dx^3 but we will be missing a mass m_i*(1-kappa_i) from the cell. This mass can be smooshed into neighboring cells such as to make the total scheme conservative. As an option, we can also use a "non-conservative" divergence but the scheme is not guaranteed to be non-negative. All of this is just to say that we take the mass that fell inside the EB and put it back into the domain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>Quantity to be redistributed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a174efc0134a7417f1afa737b8f328d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174efc0134a7417f1afa737b8f328d16">&#9670;&nbsp;</a></span>registerOperators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::registerOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register operators. </p>
<p>This will register the required operators for running this class. </p>

</div>
</div>
<a id="a2ec90d5f802b40a624d7aa0be36a6f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec90d5f802b40a624d7aa0be36a6f6d">&#9670;&nbsp;</a></span>regrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::regrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regrid this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level where grids did not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest AMR level before the regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>Finest AMR level after the regrid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac96f3425ab87e0a7dfead3717f262f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96f3425ab87e0a7dfead3717f262f7b">&#9670;&nbsp;</a></span>reinitializeParticles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::reinitializeParticles </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCellInfo.html">CellInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_particlesPerCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Particle re-initialization algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_particles</td><td>Particles to be merged/split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellInfo</td><td>Arithmetic information about the current grid cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesPerCell</td><td>Target number of particles per cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b2ffd6f216e2fe3fc1b7d69134cd941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2ffd6f216e2fe3fc1b7d69134cd941">&#9670;&nbsp;</a></span>remap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::remap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remap all particles in the input container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Particle container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0f141c67d4052c5f75426e25e06c8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f141c67d4052c5f75426e25e06c8c1">&#9670;&nbsp;</a></span>removeCoveredParticles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::removeCoveredParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove particles that are inside the EB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls the other version with m_particles. </p>

</div>
</div>
<a id="a267ccadc8788c9fafe39a85c0426e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267ccadc8788c9fafe39a85c0426e1ad">&#9670;&nbsp;</a></span>removeCoveredParticles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::removeCoveredParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove particles that are inside the EB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_container</td><td>Which particle container to remove particles from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls the other version with <a class="el" href="classParticleContainer.html" title="Templated class for holding particles on an AMR hierarchy with particle remapping.">ParticleContainer</a> = m_particles.at(a_container) </dd></dl>

</div>
</div>
<a id="aeaa8089edbe2b6b13cb69b7a303e9685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa8089edbe2b6b13cb69b7a303e9685">&#9670;&nbsp;</a></span>removeCoveredParticles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::removeCoveredParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove particles that are inside the EB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particles</td><td>Particles to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a351676445e519924a3054b8433c30001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351676445e519924a3054b8433c30001">&#9670;&nbsp;</a></span>setAmr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setAmr </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_amr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_amr</td><td><a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3174bdfc77666ce0d0a7a46876389365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3174bdfc77666ce0d0a7a46876389365">&#9670;&nbsp;</a></span>setComputationalGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setComputationalGeometry </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_computationalGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set computational geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_computationalGeometry</td><td>Computational geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4426b5a48a8530afb511bec40f6b718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4426b5a48a8530afb511bec40f6b718">&#9670;&nbsp;</a></span>setDiffusionFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setDiffusionFunction </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_diffusionCoefficient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function &ndash; set a constant diffusion coefficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_diffusionCoefficient</td><td>Diffusion coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b76fa27520cfcf6b20bc2115cd2c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b76fa27520cfcf6b20bc2115cd2c18">&#9670;&nbsp;</a></span>setParticleDiffusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setParticleDiffusion </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_diffusion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets diffusion coefficient for all particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_diffusion</td><td>Particle diffusion value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae05b92be13086d225ea918350fdb006f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05b92be13086d225ea918350fdb006f">&#9670;&nbsp;</a></span>setParticleMerger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setParticleMerger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceParticleManagement.html#abb4cc237cfca463592686cabeb3a6f75">ParticleManagement::ParticleMerger</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particleMerger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the particle merger. This will get called when merging particles using makeSuperparticles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particleMerger</td><td>Particle merger </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a429895a5e10f6830cc6160654684f6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429895a5e10f6830cc6160654684f6e2">&#9670;&nbsp;</a></span>setParticleMobility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setParticleMobility </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_mobility</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets mobility coefficient for all particles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_mobility</td><td>Particle mobility. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b6b0c77343a02439242f7b9a84949bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6b0c77343a02439242f7b9a84949bf">&#9670;&nbsp;</a></span>setPhase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setPhase </td>
          <td>(</td>
          <td class="paramtype">const phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set phase where the particles will live. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a953bd44ffab98bb2b7e408194339aeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953bd44ffab98bb2b7e408194339aeca">&#9670;&nbsp;</a></span>setRealm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setRealm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the realm where this solver will live. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a134feb52bf6e0fdb4b0b25cd76b4ef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134feb52bf6e0fdb4b0b25cd76b4ef91">&#9670;&nbsp;</a></span>setSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setSpecies </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classItoSpecies.html">ItoSpecies</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_species</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the species. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_species</td><td>Species to be solved for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2293d2a6db7b36a451100e2e8400698f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2293d2a6db7b36a451100e2e8400698f">&#9670;&nbsp;</a></span>setTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setTime </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time for this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_step</td><td>Time step number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_time</td><td>Time (in seconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step increment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets m_step=a_step, m_time=a_time, m_dt=a_dt </dd></dl>

</div>
</div>
<a id="ae8f6cbb8805b459df5a6bcbcb0ff06ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f6cbb8805b459df5a6bcbcb0ff06ea">&#9670;&nbsp;</a></span>setVelocityFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setVelocityFunction </td>
          <td>(</td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_velocity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function &ndash; set a constant velocity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_velocity</td><td>Velocity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa01f68543f9b94f9d083ce3e3ed0339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa01f68543f9b94f9d083ce3e3ed0339">&#9670;&nbsp;</a></span>setVerbosity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::setVerbosity </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set verbosity level for this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_verbosity</td><td>Verbosity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a123d483c4c161b135bb967f3ef65b1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123d483c4c161b135bb967f3ef65b1ee">&#9670;&nbsp;</a></span>transferCoveredParticles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::transferCoveredParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer particles that are covered (within a_tol distance from EB) to another container. </p>
<p>Calls the other version with m_particles and m_coveredParticles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a460d077c67b4d5813e5bfd40558249ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460d077c67b4d5813e5bfd40558249ee">&#9670;&nbsp;</a></span>transferCoveredParticles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::transferCoveredParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_containerFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItoSolver.html#a070d75d0d3ac16e04013d25574c1ffa5">WhichContainer</a>&#160;</td>
          <td class="paramname"><em>a_containerTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer particles that are covered (within a_tol distance from EB) to another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_containerFrom</td><td>Which particle container to transfer particles from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_containerFrom</td><td>Which particle container to move particles into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a394a92928f87d63318249d9f42675096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394a92928f87d63318249d9f42675096">&#9670;&nbsp;</a></span>transferCoveredParticles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::transferCoveredParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticleContainer.html">ParticleContainer</a>&lt; <a class="el" href="classItoParticle.html">ItoParticle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_particlesTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__EBRepresentation_8H.html#ac839237a887a079963372760880f908f">EBRepresentation</a>&#160;</td>
          <td class="paramname"><em>a_representation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer particles that are inside the EB to another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesFrom</td><td>Which particle container to transfer particles from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_particlesTo</td><td>Which particle container to move particles into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebRepresentation</td><td>EB representation (e.g. implicit function, discrete, voxel) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tol</td><td>Tolerance &ndash; removes particles if they are less than a_tol*dx away from the boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d8246f963aa976e49c808a9d963b464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8246f963aa976e49c808a9d963b464">&#9670;&nbsp;</a></span>updateDiffusion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::updateDiffusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update mobilities parametrically from the particle energy. </p>
<p>This calls the diffusion function implemented by <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a>. The particle diffusion is set D = f(p.energy()) where f is the diffusion function in <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a> </p>

</div>
</div>
<a id="ad686ec03d1b90c1f9b2e2bb2e45126bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad686ec03d1b90c1f9b2e2bb2e45126bf">&#9670;&nbsp;</a></span>updateDiffusion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::updateDiffusion </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update mobilities parametrically from the particle energy. </p>
<p>This calls the diffusion function implemented by <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a>. The particle diffusion is set D = f(p.energy()) where f is the diffusion function in <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a877960fbdde4e57f9ce3061fc0bb703f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877960fbdde4e57f9ce3061fc0bb703f">&#9670;&nbsp;</a></span>updateMobilities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::updateMobilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update mobilities parametrically from the particle energy. </p>
<p>This calls the mobility function implemented by <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a>. The particle mobility is set mu = f(p.energy()) where f is the mobility function in <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a> </p>

</div>
</div>
<a id="ac7a9256055022575daeceafe643972f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a9256055022575daeceafe643972f2">&#9670;&nbsp;</a></span>updateMobilities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::updateMobilities </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataIndex&#160;</td>
          <td class="paramname"><em>a_dit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update mobilities parametrically from the particle energy. </p>
<p>This calls the mobility function implemented by <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a>. The particle mobility is set mu = f(p.energy()) where f is the mobility function in <a class="el" href="classItoSpecies.html" title="Class that acts as user interface for parsing initial data and mobility/diffusion kernels into ItoSol...">ItoSpecies</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dit</td><td>Grid index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1264160ab19dbcdd4279fd02977ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1264160ab19dbcdd4279fd02977ca6a">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::writeData </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_outputRealm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_interpToCentroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_interpGhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to output. Convenience function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_outputRealm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where a_output belongs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpToCentroids</td><td>If true, a_data will be interpolated to cell centroids before writing to a_output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interpGhost</td><td>If true, interpolate ghost cells </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe73dce206e99305dca7803e28e8e41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe73dce206e99305dca7803e28e8e41a">&#9670;&nbsp;</a></span>writePlotData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ItoSolver::writePlotData </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_outputRealm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write plot data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_outputRealm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where a_output belongs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will write the plot data in this solver to a_output, starting on a_comp </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4cfbc656f1f16c9b664b25ff0fedd92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfbc656f1f16c9b664b25ff0fedd92a">&#9670;&nbsp;</a></span>m_className</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ItoSolver::m_className</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class name. </p>
<p><a class="el" href="classItoSolver.html" title="Base class for Ito diffusion particle models.">ItoSolver</a> for parent class &ndash; derived classes might be named something else. </p>

</div>
</div>
<a id="a987806a343072c9ed15231c9a371a16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987806a343072c9ed15231c9a371a16e">&#9670;&nbsp;</a></span>m_normalDistributionTruncation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real ItoSolver::m_normalDistributionTruncation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncation value for normal distribution. </p>
<p>This is used when drawing numbers from the Gaussian distribution, replacing all values above m_normalDistributionTruncation by m_normalDistributionTruncation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/ItoDiffusion/<a class="el" href="CD__ItoSolver_8H_source.html">CD_ItoSolver.H</a></li>
<li>Source/ItoDiffusion/<a class="el" href="CD__ItoSolver_8cpp.html">CD_ItoSolver.cpp</a></li>
<li>Source/ItoDiffusion/<a class="el" href="CD__ItoSolverImplem_8H_source.html">CD_ItoSolverImplem.H</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
