<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: SigmaSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classSigmaSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SigmaSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Surface charge solver.  
 <a href="classSigmaSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__SigmaSolver_8H_source.html">CD_SigmaSolver.H</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for SigmaSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classSigmaSolver__coll__graph.png" border="0" usemap="#SigmaSolver_coll__map" alt="Collaboration graph"/></div>
<map name="SigmaSolver_coll__map" id="SigmaSolver_coll__map">
<area shape="rect" title="Surface charge solver." alt="" coords="45,139,149,165"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="5,5,189,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5cf6248780a420a683bdfee9499d232"><td class="memItemLeft" align="right" valign="top"><a id="ad5cf6248780a420a683bdfee9499d232"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ad5cf6248780a420a683bdfee9499d232">SigmaSolver</a> ()</td></tr>
<tr class="memdesc:ad5cf6248780a420a683bdfee9499d232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ad5cf6248780a420a683bdfee9499d232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54d527f996be8f9f9ac84ae9e474551"><td class="memItemLeft" align="right" valign="top"><a id="ab54d527f996be8f9f9ac84ae9e474551"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ab54d527f996be8f9f9ac84ae9e474551">~SigmaSolver</a> ()</td></tr>
<tr class="memdesc:ab54d527f996be8f9f9ac84ae9e474551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (does nothing). <br /></td></tr>
<tr class="separator:ab54d527f996be8f9f9ac84ae9e474551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dd3f4d497cc26c593223ede6e999b0"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a88dd3f4d497cc26c593223ede6e999b0">getRealm</a> () const</td></tr>
<tr class="memdesc:a88dd3f4d497cc26c593223ede6e999b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the realm where the solver is registered.  <a href="classSigmaSolver.html#a88dd3f4d497cc26c593223ede6e999b0">More...</a><br /></td></tr>
<tr class="separator:a88dd3f4d497cc26c593223ede6e999b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e68a136a683d6cf2849957e1eccab2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a79e68a136a683d6cf2849957e1eccab2">setRealm</a> (const std::string a_realm)</td></tr>
<tr class="memdesc:a79e68a136a683d6cf2849957e1eccab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the realm.  <a href="classSigmaSolver.html#a79e68a136a683d6cf2849957e1eccab2">More...</a><br /></td></tr>
<tr class="separator:a79e68a136a683d6cf2849957e1eccab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad524c496a2fc1dec567fe94da700eb3a"><td class="memItemLeft" align="right" valign="top"><a id="ad524c496a2fc1dec567fe94da700eb3a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ad524c496a2fc1dec567fe94da700eb3a">allocateInternals</a> ()</td></tr>
<tr class="memdesc:ad524c496a2fc1dec567fe94da700eb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate internal storage for this class. <br /></td></tr>
<tr class="separator:ad524c496a2fc1dec567fe94da700eb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1681fb0aba5bab238edae326490ff559"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a1681fb0aba5bab238edae326490ff559">preRegrid</a> (const int a_lbase, const int a_oldFinestLevel)</td></tr>
<tr class="memdesc:a1681fb0aba5bab238edae326490ff559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-regrid function.  <a href="classSigmaSolver.html#a1681fb0aba5bab238edae326490ff559">More...</a><br /></td></tr>
<tr class="separator:a1681fb0aba5bab238edae326490ff559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eba3c9e95c14bdc9a69b4e7e0d2fbde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a5eba3c9e95c14bdc9a69b4e7e0d2fbde">computeRHS</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_flux)</td></tr>
<tr class="memdesc:a5eba3c9e95c14bdc9a69b4e7e0d2fbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the right-hand side (i.e. the flux).  <a href="classSigmaSolver.html#a5eba3c9e95c14bdc9a69b4e7e0d2fbde">More...</a><br /></td></tr>
<tr class="separator:a5eba3c9e95c14bdc9a69b4e7e0d2fbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37572df10df7573bfbfc878a406d55e"><td class="memItemLeft" align="right" valign="top"><a id="ab37572df10df7573bfbfc878a406d55e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ab37572df10df7573bfbfc878a406d55e">deallocateInternals</a> ()</td></tr>
<tr class="memdesc:ab37572df10df7573bfbfc878a406d55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate internal storage. <br /></td></tr>
<tr class="separator:ab37572df10df7573bfbfc878a406d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf92f173ca69e2a4950221e3142ccc47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#acf92f173ca69e2a4950221e3142ccc47">regrid</a> (const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel)</td></tr>
<tr class="memdesc:acf92f173ca69e2a4950221e3142ccc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regrid function.  <a href="classSigmaSolver.html#acf92f173ca69e2a4950221e3142ccc47">More...</a><br /></td></tr>
<tr class="separator:acf92f173ca69e2a4950221e3142ccc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b60e9d7e73d2b3e493c68d1be786cb"><td class="memItemLeft" align="right" valign="top"><a id="a78b60e9d7e73d2b3e493c68d1be786cb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a78b60e9d7e73d2b3e493c68d1be786cb">registerOperators</a> ()</td></tr>
<tr class="memdesc:a78b60e9d7e73d2b3e493c68d1be786cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register operators. <br /></td></tr>
<tr class="separator:a78b60e9d7e73d2b3e493c68d1be786cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028fcd50cbdf83ced892f3aae2b19f61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a028fcd50cbdf83ced892f3aae2b19f61">resetCells</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_data)</td></tr>
<tr class="memdesc:a028fcd50cbdf83ced892f3aae2b19f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset data holder on non-dielectric cells.  <a href="classSigmaSolver.html#a028fcd50cbdf83ced892f3aae2b19f61">More...</a><br /></td></tr>
<tr class="separator:a028fcd50cbdf83ced892f3aae2b19f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7044e6573ff09ec3a2e1f8b8d5a47c01"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a7044e6573ff09ec3a2e1f8b8d5a47c01">setAmr</a> (const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;a_amrMesh)</td></tr>
<tr class="memdesc:a7044e6573ff09ec3a2e1f8b8d5a47c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amr object.  <a href="classSigmaSolver.html#a7044e6573ff09ec3a2e1f8b8d5a47c01">More...</a><br /></td></tr>
<tr class="separator:a7044e6573ff09ec3a2e1f8b8d5a47c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2d0f81a7b84e837414cd0e1a236be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ab3a2d0f81a7b84e837414cd0e1a236be">setComputationalGeometry</a> (const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; &amp;a_computationalGeometry)</td></tr>
<tr class="memdesc:ab3a2d0f81a7b84e837414cd0e1a236be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the computational geometry.  <a href="classSigmaSolver.html#ab3a2d0f81a7b84e837414cd0e1a236be">More...</a><br /></td></tr>
<tr class="separator:ab3a2d0f81a7b84e837414cd0e1a236be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca09ccfc0dc8d52231beef6b90497cd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#aca09ccfc0dc8d52231beef6b90497cd6">setPhase</a> (phase::which_phase a_phase=phase::gas)</td></tr>
<tr class="memdesc:aca09ccfc0dc8d52231beef6b90497cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set phase.  <a href="classSigmaSolver.html#aca09ccfc0dc8d52231beef6b90497cd6">More...</a><br /></td></tr>
<tr class="separator:aca09ccfc0dc8d52231beef6b90497cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3231df31992f7336770dba1e0d12d63d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a3231df31992f7336770dba1e0d12d63d">setSigma</a> (const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_sigma)</td></tr>
<tr class="memdesc:a3231df31992f7336770dba1e0d12d63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function. Set the surface charge equal to the input argument.  <a href="classSigmaSolver.html#a3231df31992f7336770dba1e0d12d63d">More...</a><br /></td></tr>
<tr class="separator:a3231df31992f7336770dba1e0d12d63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97de28a58cd88990dc26e87450d083b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ad97de28a58cd88990dc26e87450d083b">setSigma</a> (const Real a_sigma)</td></tr>
<tr class="memdesc:ad97de28a58cd88990dc26e87450d083b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function. Set the surface charge equal to the input argument.  <a href="classSigmaSolver.html#ad97de28a58cd88990dc26e87450d083b">More...</a><br /></td></tr>
<tr class="separator:ad97de28a58cd88990dc26e87450d083b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2285757ce009010831b3cb836ba8ec35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a2285757ce009010831b3cb836ba8ec35">setVerbosity</a> (const int a_verbosity)</td></tr>
<tr class="memdesc:a2285757ce009010831b3cb836ba8ec35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set verbosity.  <a href="classSigmaSolver.html#a2285757ce009010831b3cb836ba8ec35">More...</a><br /></td></tr>
<tr class="separator:a2285757ce009010831b3cb836ba8ec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77efe6b03c7ac24acac4c01779ededaf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a77efe6b03c7ac24acac4c01779ededaf">setTime</a> (const int a_step, const Real a_time, const Real a_dt)</td></tr>
<tr class="memdesc:a77efe6b03c7ac24acac4c01779ededaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time.  <a href="classSigmaSolver.html#a77efe6b03c7ac24acac4c01779ededaf">More...</a><br /></td></tr>
<tr class="separator:a77efe6b03c7ac24acac4c01779ededaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e41998d197bc6cd14fc1f5a00732a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a97e41998d197bc6cd14fc1f5a00732a9">writePlotData</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_output, int &amp;a_comp)</td></tr>
<tr class="memdesc:a97e41998d197bc6cd14fc1f5a00732a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write output data to a_output.  <a href="classSigmaSolver.html#a97e41998d197bc6cd14fc1f5a00732a9">More...</a><br /></td></tr>
<tr class="separator:a97e41998d197bc6cd14fc1f5a00732a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a80fe0350fb40b49e0c1399625290b3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a2a80fe0350fb40b49e0c1399625290b3">getNumberOfPlotVariables</a> ()</td></tr>
<tr class="memdesc:a2a80fe0350fb40b49e0c1399625290b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of variables to be plotted.  <a href="classSigmaSolver.html#a2a80fe0350fb40b49e0c1399625290b3">More...</a><br /></td></tr>
<tr class="separator:a2a80fe0350fb40b49e0c1399625290b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc935839c5a9643e5a57ae3e5786369"><td class="memItemLeft" align="right" valign="top">virtual Vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a4fc935839c5a9643e5a57ae3e5786369">getPlotVariableNames</a> () const</td></tr>
<tr class="memdesc:a4fc935839c5a9643e5a57ae3e5786369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output plot names.  <a href="classSigmaSolver.html#a4fc935839c5a9643e5a57ae3e5786369">More...</a><br /></td></tr>
<tr class="separator:a4fc935839c5a9643e5a57ae3e5786369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98dd0ab04238b3363e053c9a5a1250d"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#af98dd0ab04238b3363e053c9a5a1250d">computeCharge</a> ()</td></tr>
<tr class="memdesc:af98dd0ab04238b3363e053c9a5a1250d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total charge.  <a href="classSigmaSolver.html#af98dd0ab04238b3363e053c9a5a1250d">More...</a><br /></td></tr>
<tr class="separator:af98dd0ab04238b3363e053c9a5a1250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e1585bef654013a4759908adfed98a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ad4e1585bef654013a4759908adfed98a">getPhi</a> ()</td></tr>
<tr class="memdesc:ad4e1585bef654013a4759908adfed98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get internal state.  <a href="classSigmaSolver.html#ad4e1585bef654013a4759908adfed98a">More...</a><br /></td></tr>
<tr class="separator:ad4e1585bef654013a4759908adfed98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af942b0e7a0a99ef3a747302e1c34b609"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#af942b0e7a0a99ef3a747302e1c34b609">getFlux</a> ()</td></tr>
<tr class="memdesc:af942b0e7a0a99ef3a747302e1c34b609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get internal state.  <a href="classSigmaSolver.html#af942b0e7a0a99ef3a747302e1c34b609">More...</a><br /></td></tr>
<tr class="separator:af942b0e7a0a99ef3a747302e1c34b609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9fc7400cb7d4621fa937aaa9d19fa98e"><td class="memItemLeft" align="right" valign="top"><a id="a9fc7400cb7d4621fa937aaa9d19fa98e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a9fc7400cb7d4621fa937aaa9d19fa98e">m_realm</a></td></tr>
<tr class="memdesc:a9fc7400cb7d4621fa937aaa9d19fa98e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where this solver is registered. <br /></td></tr>
<tr class="separator:a9fc7400cb7d4621fa937aaa9d19fa98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadd9fa702cde771f65cc1da221a714d"><td class="memItemLeft" align="right" valign="top"><a id="adadd9fa702cde771f65cc1da221a714d"></a>
RefCountedPtr&lt; <a class="el" href="classMultiFluidIndexSpace.html">MultiFluidIndexSpace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#adadd9fa702cde771f65cc1da221a714d">m_multifluidIndexSpace</a></td></tr>
<tr class="memdesc:adadd9fa702cde771f65cc1da221a714d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index spaces. <br /></td></tr>
<tr class="separator:adadd9fa702cde771f65cc1da221a714d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedaad3c8b76702dd02b24a075db84cd"><td class="memItemLeft" align="right" valign="top"><a id="acedaad3c8b76702dd02b24a075db84cd"></a>
RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#acedaad3c8b76702dd02b24a075db84cd">m_computationalGeometry</a></td></tr>
<tr class="memdesc:acedaad3c8b76702dd02b24a075db84cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational geometry. <br /></td></tr>
<tr class="separator:acedaad3c8b76702dd02b24a075db84cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607e697c48ba14daa4fb0a7c834efb94"><td class="memItemLeft" align="right" valign="top"><a id="a607e697c48ba14daa4fb0a7c834efb94"></a>
RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a607e697c48ba14daa4fb0a7c834efb94">m_amr</a></td></tr>
<tr class="memdesc:a607e697c48ba14daa4fb0a7c834efb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMR; needed for grid stuff. <br /></td></tr>
<tr class="separator:a607e697c48ba14daa4fb0a7c834efb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c8322081766e0896f3c1f194464db9"><td class="memItemLeft" align="right" valign="top"><a id="ac6c8322081766e0896f3c1f194464db9"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ac6c8322081766e0896f3c1f194464db9">m_phi</a></td></tr>
<tr class="memdesc:ac6c8322081766e0896f3c1f194464db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">State &ndash; this holds the surface charge density. <br /></td></tr>
<tr class="separator:ac6c8322081766e0896f3c1f194464db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c90b9b110f1e4d32ed84fb04723a6d"><td class="memItemLeft" align="right" valign="top"><a id="ab1c90b9b110f1e4d32ed84fb04723a6d"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ab1c90b9b110f1e4d32ed84fb04723a6d">m_cache</a></td></tr>
<tr class="memdesc:ab1c90b9b110f1e4d32ed84fb04723a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached state for regridding. DO NOT TOUCH! <br /></td></tr>
<tr class="separator:ab1c90b9b110f1e4d32ed84fb04723a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfbe0403f437b2c6cbeb4b2f3dc4cea"><td class="memItemLeft" align="right" valign="top"><a id="aecfbe0403f437b2c6cbeb4b2f3dc4cea"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#aecfbe0403f437b2c6cbeb4b2f3dc4cea">m_flux</a></td></tr>
<tr class="memdesc:aecfbe0403f437b2c6cbeb4b2f3dc4cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface charge flux. <br /></td></tr>
<tr class="separator:aecfbe0403f437b2c6cbeb4b2f3dc4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f109befa3a7ecb91216c9b578646792"><td class="memItemLeft" align="right" valign="top"><a id="a7f109befa3a7ecb91216c9b578646792"></a>
phase::which_phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a7f109befa3a7ecb91216c9b578646792">m_phase</a></td></tr>
<tr class="memdesc:a7f109befa3a7ecb91216c9b578646792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase where the data lives. <br /></td></tr>
<tr class="separator:a7f109befa3a7ecb91216c9b578646792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fb22e2a7bc0e7e8114e933b994ac95"><td class="memItemLeft" align="right" valign="top"><a id="a92fb22e2a7bc0e7e8114e933b994ac95"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a92fb22e2a7bc0e7e8114e933b994ac95">m_verbosity</a></td></tr>
<tr class="memdesc:a92fb22e2a7bc0e7e8114e933b994ac95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver verbosity. <br /></td></tr>
<tr class="separator:a92fb22e2a7bc0e7e8114e933b994ac95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c378c7db41964c8be2702ba9f6f3e04"><td class="memItemLeft" align="right" valign="top"><a id="a8c378c7db41964c8be2702ba9f6f3e04"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a8c378c7db41964c8be2702ba9f6f3e04">m_timeStep</a></td></tr>
<tr class="memdesc:a8c378c7db41964c8be2702ba9f6f3e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step. <br /></td></tr>
<tr class="separator:a8c378c7db41964c8be2702ba9f6f3e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34abcd7d0abbedd36e7cf2c78355af4"><td class="memItemLeft" align="right" valign="top"><a id="ab34abcd7d0abbedd36e7cf2c78355af4"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#ab34abcd7d0abbedd36e7cf2c78355af4">m_time</a></td></tr>
<tr class="memdesc:ab34abcd7d0abbedd36e7cf2c78355af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current time. <br /></td></tr>
<tr class="separator:ab34abcd7d0abbedd36e7cf2c78355af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaec6959b0d50893df0695c3f36d5071"><td class="memItemLeft" align="right" valign="top"><a id="abaec6959b0d50893df0695c3f36d5071"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#abaec6959b0d50893df0695c3f36d5071">m_dt</a></td></tr>
<tr class="memdesc:abaec6959b0d50893df0695c3f36d5071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time increment. <br /></td></tr>
<tr class="separator:abaec6959b0d50893df0695c3f36d5071"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a002ebe6954326ba9a8cb150014d648cc"><td class="memItemLeft" align="right" valign="top"><a id="a002ebe6954326ba9a8cb150014d648cc"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a002ebe6954326ba9a8cb150014d648cc">m_comp</a> = 0</td></tr>
<tr class="memdesc:a002ebe6954326ba9a8cb150014d648cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component number in data holder. <br /></td></tr>
<tr class="separator:a002ebe6954326ba9a8cb150014d648cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e99b17e2196f212dd3348f74e958967"><td class="memItemLeft" align="right" valign="top"><a id="a9e99b17e2196f212dd3348f74e958967"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSigmaSolver.html#a9e99b17e2196f212dd3348f74e958967">m_nComp</a> = 1</td></tr>
<tr class="memdesc:a9e99b17e2196f212dd3348f74e958967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of components that this solver solves for. <br /></td></tr>
<tr class="separator:a9e99b17e2196f212dd3348f74e958967"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Surface charge solver. </p>
<p>This is a basic solver that essentially just holds the surface charge on dielectrics. It cannot (yet) transport charge along the dielectric surface and thus it solves d(sigma)/dt = F where F is the incoming charge flux. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af98dd0ab04238b3363e053c9a5a1250d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98dd0ab04238b3363e053c9a5a1250d">&#9670;&nbsp;</a></span>computeCharge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real SigmaSolver::computeCharge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute total charge. </p>
<dl class="section return"><dt>Returns</dt><dd>Computes the total charge on the dielectric surface. </dd></dl>

</div>
</div>
<a id="a5eba3c9e95c14bdc9a69b4e7e0d2fbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eba3c9e95c14bdc9a69b4e7e0d2fbde">&#9670;&nbsp;</a></span>computeRHS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::computeRHS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the right-hand side (i.e. the flux). </p>
<p>This just copies the input flux into the the internal data holder for the flux. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_flux</td><td>Incoming charge flux </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af942b0e7a0a99ef3a747302e1c34b609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af942b0e7a0a99ef3a747302e1c34b609">&#9670;&nbsp;</a></span>getFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp; SigmaSolver::getFlux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get internal state. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_flux </dd></dl>

</div>
</div>
<a id="a2a80fe0350fb40b49e0c1399625290b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a80fe0350fb40b49e0c1399625290b3">&#9670;&nbsp;</a></span>getNumberOfPlotVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SigmaSolver::getNumberOfPlotVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of variables to be plotted. </p>
<p>Returns 2 - the surface charge and the incoming flux. </p>

</div>
</div>
<a id="ad4e1585bef654013a4759908adfed98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e1585bef654013a4759908adfed98a">&#9670;&nbsp;</a></span>getPhi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp; SigmaSolver::getPhi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get internal state. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_phi </dd></dl>

</div>
</div>
<a id="a4fc935839c5a9643e5a57ae3e5786369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc935839c5a9643e5a57ae3e5786369">&#9670;&nbsp;</a></span>getPlotVariableNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; std::string &gt; SigmaSolver::getPlotVariableNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get output plot names. </p>
<dl class="section return"><dt>Returns</dt><dd>Return a list of plot variable names. </dd></dl>

</div>
</div>
<a id="a88dd3f4d497cc26c593223ede6e999b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88dd3f4d497cc26c593223ede6e999b0">&#9670;&nbsp;</a></span>getRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SigmaSolver::getRealm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the realm where the solver is registered. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns m_realm </dd></dl>

</div>
</div>
<a id="a1681fb0aba5bab238edae326490ff559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1681fb0aba5bab238edae326490ff559">&#9670;&nbsp;</a></span>preRegrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::preRegrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-regrid function. </p>
<p>This stores the data on the old mesh so it can be regridded later. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lbase</td><td>Coarsest level which will change during regrids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest level before the regrid operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf92f173ca69e2a4950221e3142ccc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf92f173ca69e2a4950221e3142ccc47">&#9670;&nbsp;</a></span>regrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::regrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regrid function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level where grids did not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest AMR level before the regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>Finest AMR level after the regrid.</td></tr>
  </table>
  </dd>
</dl>
<p>This interpolates or coarsens conservatively, e.g. sigma_c = sum(A_f * sigma_f)/A_c if we coarsen. </p>

</div>
</div>
<a id="a028fcd50cbdf83ced892f3aae2b19f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028fcd50cbdf83ced892f3aae2b19f61">&#9670;&nbsp;</a></span>resetCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::resetCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset data holder on non-dielectric cells. </p>
<p>This will set a_data to zero except in cells that are dielectric surface cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Input data to be reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7044e6573ff09ec3a2e1f8b8d5a47c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7044e6573ff09ec3a2e1f8b8d5a47c01">&#9670;&nbsp;</a></span>setAmr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::setAmr </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_amrMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the amr object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_amrMesh</td><td><a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3a2d0f81a7b84e837414cd0e1a236be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a2d0f81a7b84e837414cd0e1a236be">&#9670;&nbsp;</a></span>setComputationalGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::setComputationalGeometry </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_computationalGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the computational geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_computationalGeometry</td><td>The computational geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca09ccfc0dc8d52231beef6b90497cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca09ccfc0dc8d52231beef6b90497cd6">&#9670;&nbsp;</a></span>setPhase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::setPhase </td>
          <td>(</td>
          <td class="paramtype">phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em> = <code>phase::gas</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the phase where all the data will live. Note that the dielectric cells can be on the "inside" or "outside" of the dielectric and this function thus controls where the data is allocated. That might seem silly, but note that this essentially determines from which side the flux comes. We have this design because we consider the surface charge solver be a single-phase solver (in the future, this might change). </p><dl class="section note"><dt>Note</dt><dd>This must be done BEFORE callilng setComputationalGeometry </dd></dl>

</div>
</div>
<a id="a79e68a136a683d6cf2849957e1eccab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e68a136a683d6cf2849957e1eccab2">&#9670;&nbsp;</a></span>setRealm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::setRealm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the realm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3231df31992f7336770dba1e0d12d63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3231df31992f7336770dba1e0d12d63d">&#9670;&nbsp;</a></span>setSigma() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::setSigma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_sigma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function. Set the surface charge equal to the input argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_sigma</td><td>Surface charge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad97de28a58cd88990dc26e87450d083b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97de28a58cd88990dc26e87450d083b">&#9670;&nbsp;</a></span>setSigma() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::setSigma </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_sigma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function. Set the surface charge equal to the input argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_sigma</td><td>Surface charge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77efe6b03c7ac24acac4c01779ededaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77efe6b03c7ac24acac4c01779ededaf">&#9670;&nbsp;</a></span>setTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::setTime </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_step</td><td>Time step number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_time</td><td>Time (in seconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step increment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets m_step=a_step, m_time=a_time, m_dt=a_dt </dd></dl>

</div>
</div>
<a id="a2285757ce009010831b3cb836ba8ec35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2285757ce009010831b3cb836ba8ec35">&#9670;&nbsp;</a></span>setVerbosity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::setVerbosity </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set verbosity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_verbosity</td><td>Verbosity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97e41998d197bc6cd14fc1f5a00732a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e41998d197bc6cd14fc1f5a00732a9">&#9670;&nbsp;</a></span>writePlotData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SigmaSolver::writePlotData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write output data to a_output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will write the plot data in this solver to a_output, starting on a_comp </dd>
<dd>
This routine writes m_phi and m_flux into a_ouput. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/SigmaSolver/<a class="el" href="CD__SigmaSolver_8H_source.html">CD_SigmaSolver.H</a></li>
<li>Source/SigmaSolver/<a class="el" href="CD__SigmaSolver_8cpp.html">CD_SigmaSolver.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
