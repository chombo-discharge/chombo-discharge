<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: CdrSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classCdrSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CdrSolver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for solving convection-diffusion-reaction equations.  
 <a href="classCdrSolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__CdrSolver_8H_source.html">CD_CdrSolver.H</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CdrSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classCdrSolver__inherit__graph.png" border="0" usemap="#aCdrSolver_inherit__map" alt="Inheritance graph"/></div>
<map name="aCdrSolver_inherit__map" id="aCdrSolver_inherit__map">
<area shape="rect" title="Base class for solving convection&#45;diffusion&#45;reaction equations." alt="" coords="53,5,138,32"/>
<area shape="rect" href="classCdrMultigrid.html" title="Extension class of CdrSolver that uses multigrid for diffusion part. Can also solve for stochastic di..." alt="" coords="44,80,147,107"/>
<area shape="rect" href="classCdrCTU.html" title="Class that uses a slope limited method for advection, in combination with corner transport upwind (CT..." alt="" coords="5,155,76,181"/>
<area shape="rect" href="classCdrGodunov.html" title="Godunov implementation for advection." alt="" coords="100,155,203,181"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CdrSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classCdrSolver__coll__graph.png" border="0" usemap="#aCdrSolver_coll__map" alt="Collaboration graph"/></div>
<map name="aCdrSolver_coll__map" id="aCdrSolver_coll__map">
<area shape="rect" title="Base class for solving convection&#45;diffusion&#45;reaction equations." alt="" coords="888,187,973,213"/>
<area shape="rect" href="classCdrDomainBC.html" title="Class for encapsulating possible domain boundary conditions for CdrSolver." alt="" coords="421,23,534,49"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="385,145,569,186"/>
<area shape="rect" href="classEBAMRData.html" title="Default class for holding LevelData&lt;T&gt; data across an EBAMR realm." alt="" coords="5,275,144,301"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="355,220,600,247"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="379,303,575,329"/>
<area shape="rect" href="classEBAMRData.html" title=" " alt="" coords="378,380,577,407"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a288f9a76614a2ad006284a27953ab99d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a288f9a76614a2ad006284a27953ab99d">CdrSolver</a> ()</td></tr>
<tr class="memdesc:a288f9a76614a2ad006284a27953ab99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classCdrSolver.html#a288f9a76614a2ad006284a27953ab99d">More...</a><br /></td></tr>
<tr class="separator:a288f9a76614a2ad006284a27953ab99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bbc792582a47bad84d8e5b7e422b9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a36bbc792582a47bad84d8e5b7e422b9c">CdrSolver</a> (const <a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;a_other)=delete</td></tr>
<tr class="memdesc:a36bbc792582a47bad84d8e5b7e422b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed copy constructor.  <a href="classCdrSolver.html#a36bbc792582a47bad84d8e5b7e422b9c">More...</a><br /></td></tr>
<tr class="separator:a36bbc792582a47bad84d8e5b7e422b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22746309146ddd3db8e016806b4440a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a22746309146ddd3db8e016806b4440a3">CdrSolver</a> (const <a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;&amp;a_other)=delete</td></tr>
<tr class="memdesc:a22746309146ddd3db8e016806b4440a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed move constructor.  <a href="classCdrSolver.html#a22746309146ddd3db8e016806b4440a3">More...</a><br /></td></tr>
<tr class="separator:a22746309146ddd3db8e016806b4440a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52496339500d91032a33eed5aba5bc6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a52496339500d91032a33eed5aba5bc6c">operator=</a> (const <a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;a_other)=delete</td></tr>
<tr class="memdesc:a52496339500d91032a33eed5aba5bc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed assignment operator.  <a href="classCdrSolver.html#a52496339500d91032a33eed5aba5bc6c">More...</a><br /></td></tr>
<tr class="separator:a52496339500d91032a33eed5aba5bc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db986e6867f2f5759489f364d4ddc52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a5db986e6867f2f5759489f364d4ddc52">operator=</a> (const <a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;&amp;a_other)=delete</td></tr>
<tr class="memdesc:a5db986e6867f2f5759489f364d4ddc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallowed move assignement operator.  <a href="classCdrSolver.html#a5db986e6867f2f5759489f364d4ddc52">More...</a><br /></td></tr>
<tr class="separator:a5db986e6867f2f5759489f364d4ddc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae0fd3f92734d17614474df7236c55d"><td class="memItemLeft" align="right" valign="top"><a id="a8ae0fd3f92734d17614474df7236c55d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a8ae0fd3f92734d17614474df7236c55d">~CdrSolver</a> ()</td></tr>
<tr class="memdesc:a8ae0fd3f92734d17614474df7236c55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8ae0fd3f92734d17614474df7236c55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029f68f0bc510fda98ff272028f1fc14"><td class="memItemLeft" align="right" valign="top"><a id="a029f68f0bc510fda98ff272028f1fc14"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a029f68f0bc510fda98ff272028f1fc14">parseOptions</a> ()=0</td></tr>
<tr class="memdesc:a029f68f0bc510fda98ff272028f1fc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse class options. <br /></td></tr>
<tr class="separator:a029f68f0bc510fda98ff272028f1fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137123400e746afedff87a063a2d0c31"><td class="memItemLeft" align="right" valign="top"><a id="a137123400e746afedff87a063a2d0c31"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a137123400e746afedff87a063a2d0c31">parseRuntimeOptions</a> ()=0</td></tr>
<tr class="memdesc:a137123400e746afedff87a063a2d0c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse runtime options. <br /></td></tr>
<tr class="separator:a137123400e746afedff87a063a2d0c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848918913d3b8a132cb40ac28f402438"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a848918913d3b8a132cb40ac28f402438">setDefaultDomainBC</a> ()</td></tr>
<tr class="memdesc:a848918913d3b8a132cb40ac28f402438"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets default boundary conditions (wall type).  <a href="classCdrSolver.html#a848918913d3b8a132cb40ac28f402438">More...</a><br /></td></tr>
<tr class="separator:a848918913d3b8a132cb40ac28f402438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd54815817a9ce6206cf022d5dd5f4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#afd54815817a9ce6206cf022d5dd5f4d4">setDomainBcType</a> (const <a class="el" href="classCdrDomainBC.html#ab012a2d05bf927e27dd38aafaf2dba2d">CdrDomainBC::DomainSide</a> a_domainSide, const <a class="el" href="classCdrDomainBC.html#ababc737a5bb0b61d6774938f4d37d06b">CdrDomainBC::BcType</a> a_bcType)</td></tr>
<tr class="memdesc:afd54815817a9ce6206cf022d5dd5f4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set domain bc type on domain side.  <a href="classCdrSolver.html#afd54815817a9ce6206cf022d5dd5f4d4">More...</a><br /></td></tr>
<tr class="separator:afd54815817a9ce6206cf022d5dd5f4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb377e98b5214b2e62480df6a689a6ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#acb377e98b5214b2e62480df6a689a6ec">setDomainBcFunction</a> (const <a class="el" href="classCdrDomainBC.html#ab012a2d05bf927e27dd38aafaf2dba2d">CdrDomainBC::DomainSide</a> a_domainSide, const <a class="el" href="classCdrDomainBC.html#a6ffe2fab3e0f415bf30fb5d68efdcb51">CdrDomainBC::FluxFunction</a> a_fluxFunction)</td></tr>
<tr class="memdesc:acb377e98b5214b2e62480df6a689a6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set domain bc function on particular domain side.  <a href="classCdrSolver.html#acb377e98b5214b2e62480df6a689a6ec">More...</a><br /></td></tr>
<tr class="separator:acb377e98b5214b2e62480df6a689a6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f137bc464c9241b0ab868f0dcdd4c28"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a5f137bc464c9241b0ab868f0dcdd4c28">advanceEuler</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_newPhi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_oldPhi, const Real a_dt)</td></tr>
<tr class="memdesc:a5f137bc464c9241b0ab868f0dcdd4c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit diffusion Euler advance without source term.  <a href="classCdrSolver.html#a5f137bc464c9241b0ab868f0dcdd4c28">More...</a><br /></td></tr>
<tr class="separator:a5f137bc464c9241b0ab868f0dcdd4c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9595227430c85146057dcdbbe073f82"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aa9595227430c85146057dcdbbe073f82">advanceEuler</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_newPhi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_oldPhi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_source, const Real a_dt)=0</td></tr>
<tr class="memdesc:aa9595227430c85146057dcdbbe073f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit diffusion Euler advance with source term.  <a href="classCdrSolver.html#aa9595227430c85146057dcdbbe073f82">More...</a><br /></td></tr>
<tr class="separator:aa9595227430c85146057dcdbbe073f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2c38c8ee8a9edd58dd0e3e605ea190"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#acd2c38c8ee8a9edd58dd0e3e605ea190">advanceCrankNicholson</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_newPhi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_oldPhi, const Real a_dt)</td></tr>
<tr class="memdesc:acd2c38c8ee8a9edd58dd0e3e605ea190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit diffusion Crank-Nicholson advance without source term.  <a href="classCdrSolver.html#acd2c38c8ee8a9edd58dd0e3e605ea190">More...</a><br /></td></tr>
<tr class="separator:acd2c38c8ee8a9edd58dd0e3e605ea190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65a12aa88855ec2ff2d1e930ff52059"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ab65a12aa88855ec2ff2d1e930ff52059">advanceCrankNicholson</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_newPhi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_oldPhi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_source, const Real a_dt)=0</td></tr>
<tr class="memdesc:ab65a12aa88855ec2ff2d1e930ff52059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit diffusion Crank-Nicholson advance with source term.  <a href="classCdrSolver.html#ab65a12aa88855ec2ff2d1e930ff52059">More...</a><br /></td></tr>
<tr class="separator:ab65a12aa88855ec2ff2d1e930ff52059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5217d3b30e180a77515c9b18ac2bae96"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a5217d3b30e180a77515c9b18ac2bae96">computeDivJ</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_divJ, <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const Real a_extrapDt, const bool a_conservativeOnly, const bool a_ebFlux, const bool a_domainFlux)=0</td></tr>
<tr class="memdesc:a5217d3b30e180a77515c9b18ac2bae96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute div(J) explicitly, where J = nV - D*grad(n)  <a href="classCdrSolver.html#a5217d3b30e180a77515c9b18ac2bae96">More...</a><br /></td></tr>
<tr class="separator:a5217d3b30e180a77515c9b18ac2bae96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06082d89e6896cafdfa12e4ac5b20c38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a06082d89e6896cafdfa12e4ac5b20c38">computeDivF</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_divF, <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const Real a_extrapDt, const bool a_conservativeOnly, const bool a_ebFlux, const bool a_domainFlux)=0</td></tr>
<tr class="memdesc:a06082d89e6896cafdfa12e4ac5b20c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute div(v*phi) explicitly.  <a href="classCdrSolver.html#a06082d89e6896cafdfa12e4ac5b20c38">More...</a><br /></td></tr>
<tr class="separator:a06082d89e6896cafdfa12e4ac5b20c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa54cb2fb84bb7cb85836da38e334bc8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#afa54cb2fb84bb7cb85836da38e334bc8">computeDivD</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_divD, <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const bool a_conservativeOnly, const bool a_ebFlux, const bool a_domainFlux)=0</td></tr>
<tr class="memdesc:afa54cb2fb84bb7cb85836da38e334bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute div(D*grad(phi)) explicitly.  <a href="classCdrSolver.html#afa54cb2fb84bb7cb85836da38e334bc8">More...</a><br /></td></tr>
<tr class="separator:afa54cb2fb84bb7cb85836da38e334bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631e0828ef3b9205ed08852fe867a1e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a631e0828ef3b9205ed08852fe867a1e9">computeDivG</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_divG, <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_G, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_ebFlux, const bool a_conservativeOnly)</td></tr>
<tr class="memdesc:a631e0828ef3b9205ed08852fe867a1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute div(G) where G is a general face-centered flux on face centers and EB centers. This can involve mass redistribution.  <a href="classCdrSolver.html#a631e0828ef3b9205ed08852fe867a1e9">More...</a><br /></td></tr>
<tr class="separator:a631e0828ef3b9205ed08852fe867a1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f1bf755d1ea4024c9ef25afd0f74af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a01f1bf755d1ea4024c9ef25afd0f74af">gwnDiffusionSource</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_noiseSource, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_cellPhi)</td></tr>
<tr class="memdesc:a01f1bf755d1ea4024c9ef25afd0f74af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a random gaussian white noise source term.  <a href="classCdrSolver.html#a01f1bf755d1ea4024c9ef25afd0f74af">More...</a><br /></td></tr>
<tr class="separator:a01f1bf755d1ea4024c9ef25afd0f74af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1a72b74fb507ecc86b6977d259645b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a8b1a72b74fb507ecc86b6977d259645b">averageVelocityToFaces</a> ()</td></tr>
<tr class="memdesc:a8b1a72b74fb507ecc86b6977d259645b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average velocities to faces.  <a href="classCdrSolver.html#a8b1a72b74fb507ecc86b6977d259645b">More...</a><br /></td></tr>
<tr class="separator:a8b1a72b74fb507ecc86b6977d259645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55aa8718586ff2316626acc3698e49a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ab55aa8718586ff2316626acc3698e49a">preRegrid</a> (const int a_lbase, const int a_oldFinestLevel)</td></tr>
<tr class="memdesc:ab55aa8718586ff2316626acc3698e49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pre-regrid operations.  <a href="classCdrSolver.html#ab55aa8718586ff2316626acc3698e49a">More...</a><br /></td></tr>
<tr class="separator:ab55aa8718586ff2316626acc3698e49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b063a50d44a687080682587ff2597c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a12b063a50d44a687080682587ff2597c">deallocateInternals</a> ()</td></tr>
<tr class="memdesc:a12b063a50d44a687080682587ff2597c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate internal storage.  <a href="classCdrSolver.html#a12b063a50d44a687080682587ff2597c">More...</a><br /></td></tr>
<tr class="separator:a12b063a50d44a687080682587ff2597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441dc4214ab75b3c56190e0572ec95e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a441dc4214ab75b3c56190e0572ec95e3">registerOperators</a> ()</td></tr>
<tr class="memdesc:a441dc4214ab75b3c56190e0572ec95e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register operators for AMR operations.  <a href="classCdrSolver.html#a441dc4214ab75b3c56190e0572ec95e3">More...</a><br /></td></tr>
<tr class="separator:a441dc4214ab75b3c56190e0572ec95e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f44081662d2076d55dace1dc1a19491"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a2f44081662d2076d55dace1dc1a19491">setRealm</a> (const std::string a_realm)</td></tr>
<tr class="memdesc:a2f44081662d2076d55dace1dc1a19491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the realm for this solver.  <a href="classCdrSolver.html#a2f44081662d2076d55dace1dc1a19491">More...</a><br /></td></tr>
<tr class="separator:a2f44081662d2076d55dace1dc1a19491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83bc3b914b50dbd90f86987ad46a645"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ad83bc3b914b50dbd90f86987ad46a645">setSpecies</a> (const RefCountedPtr&lt; <a class="el" href="classCdrSpecies.html">CdrSpecies</a> &gt; &amp;a_species)</td></tr>
<tr class="memdesc:ad83bc3b914b50dbd90f86987ad46a645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set species.  <a href="classCdrSolver.html#ad83bc3b914b50dbd90f86987ad46a645">More...</a><br /></td></tr>
<tr class="separator:ad83bc3b914b50dbd90f86987ad46a645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb9fa3c62f24d774ff8589f50dc6960"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a4cb9fa3c62f24d774ff8589f50dc6960">setComputationalGeometry</a> (const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; &amp;a_computationalGeometry)</td></tr>
<tr class="memdesc:a4cb9fa3c62f24d774ff8589f50dc6960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set computational geometry.  <a href="classCdrSolver.html#a4cb9fa3c62f24d774ff8589f50dc6960">More...</a><br /></td></tr>
<tr class="separator:a4cb9fa3c62f24d774ff8589f50dc6960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a1f139fc38770c0196a29742ed0b4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ad5a1f139fc38770c0196a29742ed0b4d">setAmr</a> (const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;a_amr)</td></tr>
<tr class="memdesc:ad5a1f139fc38770c0196a29742ed0b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amr object.  <a href="classCdrSolver.html#ad5a1f139fc38770c0196a29742ed0b4d">More...</a><br /></td></tr>
<tr class="separator:ad5a1f139fc38770c0196a29742ed0b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cec5c237cc89b6bc520aa86e189c45e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a3cec5c237cc89b6bc520aa86e189c45e">setPhase</a> (phase::which_phase a_phase)</td></tr>
<tr class="memdesc:a3cec5c237cc89b6bc520aa86e189c45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set phase.  <a href="classCdrSolver.html#a3cec5c237cc89b6bc520aa86e189c45e">More...</a><br /></td></tr>
<tr class="separator:a3cec5c237cc89b6bc520aa86e189c45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d9e87e3aa5b84db8bcee295ca415fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a86d9e87e3aa5b84db8bcee295ca415fd">setVerbosity</a> (const int a_verbosity)</td></tr>
<tr class="memdesc:a86d9e87e3aa5b84db8bcee295ca415fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set verbosity.  <a href="classCdrSolver.html#a86d9e87e3aa5b84db8bcee295ca415fd">More...</a><br /></td></tr>
<tr class="separator:a86d9e87e3aa5b84db8bcee295ca415fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945c47e4e283b7217be8960a9932f171"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a945c47e4e283b7217be8960a9932f171">setTime</a> (const int a_step, const Real a_time, const Real a_dt)</td></tr>
<tr class="memdesc:a945c47e4e283b7217be8960a9932f171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time for this solver.  <a href="classCdrSolver.html#a945c47e4e283b7217be8960a9932f171">More...</a><br /></td></tr>
<tr class="separator:a945c47e4e283b7217be8960a9932f171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae378699f575d0bf248d737e655c58768"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ae378699f575d0bf248d737e655c58768">setVelocity</a> (const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_velocity)</td></tr>
<tr class="memdesc:ae378699f575d0bf248d737e655c58768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set velocity from data holder.  <a href="classCdrSolver.html#ae378699f575d0bf248d737e655c58768">More...</a><br /></td></tr>
<tr class="separator:ae378699f575d0bf248d737e655c58768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b16af6bab2bdea269187fa763d0225c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a6b16af6bab2bdea269187fa763d0225c">setVelocity</a> (const RealVect a_velocity)</td></tr>
<tr class="memdesc:a6b16af6bab2bdea269187fa763d0225c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set constant velocity.  <a href="classCdrSolver.html#a6b16af6bab2bdea269187fa763d0225c">More...</a><br /></td></tr>
<tr class="separator:a6b16af6bab2bdea269187fa763d0225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdda09c9719d57dd49d068e0ae7b60ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#afdda09c9719d57dd49d068e0ae7b60ec">setVelocity</a> (const std::function&lt; RealVect(const RealVect a_pos)&gt; &amp;a_velocity)</td></tr>
<tr class="memdesc:afdda09c9719d57dd49d068e0ae7b60ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set velocity using a polymorphic function.  <a href="classCdrSolver.html#afdda09c9719d57dd49d068e0ae7b60ec">More...</a><br /></td></tr>
<tr class="separator:afdda09c9719d57dd49d068e0ae7b60ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fbe47831f8b364e8a2fe5e2e19c1fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ad0fbe47831f8b364e8a2fe5e2e19c1fa">setDiffusionCoefficient</a> (const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_diffusionCoefficient, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_ebDiffusionCoefficient)</td></tr>
<tr class="memdesc:ad0fbe47831f8b364e8a2fe5e2e19c1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-based version of setting diffusion coefficients (which are stored on faces)  <a href="classCdrSolver.html#ad0fbe47831f8b364e8a2fe5e2e19c1fa">More...</a><br /></td></tr>
<tr class="separator:ad0fbe47831f8b364e8a2fe5e2e19c1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31af1a9cb5b8e6e14c40bb6c2be90e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aa31af1a9cb5b8e6e14c40bb6c2be90e5">setDiffusionCoefficient</a> (const Real a_diffusionCoefficient)</td></tr>
<tr class="memdesc:aa31af1a9cb5b8e6e14c40bb6c2be90e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set diffusion coefficient to be constant everywhere (they are stored on faces)  <a href="classCdrSolver.html#aa31af1a9cb5b8e6e14c40bb6c2be90e5">More...</a><br /></td></tr>
<tr class="separator:aa31af1a9cb5b8e6e14c40bb6c2be90e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956e0613a189894f5740568cdcbe1575"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a956e0613a189894f5740568cdcbe1575">setDiffusionCoefficient</a> (const std::function&lt; Real(const RealVect a_position)&gt; &amp;a_diffusionCoefficient)</td></tr>
<tr class="memdesc:a956e0613a189894f5740568cdcbe1575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic way of setting diffusion coefficients every.  <a href="classCdrSolver.html#a956e0613a189894f5740568cdcbe1575">More...</a><br /></td></tr>
<tr class="separator:a956e0613a189894f5740568cdcbe1575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fe1b9104d952d3f83798e23655b4c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ae2fe1b9104d952d3f83798e23655b4c9">setSource</a> (const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_source)</td></tr>
<tr class="memdesc:ae2fe1b9104d952d3f83798e23655b4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data based version of setting source terms.  <a href="classCdrSolver.html#ae2fe1b9104d952d3f83798e23655b4c9">More...</a><br /></td></tr>
<tr class="separator:ae2fe1b9104d952d3f83798e23655b4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3787c6ec6a4a01c25ea8dcd18be28fb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a3787c6ec6a4a01c25ea8dcd18be28fb9">setSource</a> (const Real a_source)</td></tr>
<tr class="memdesc:a3787c6ec6a4a01c25ea8dcd18be28fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set constant source terms everywhere.  <a href="classCdrSolver.html#a3787c6ec6a4a01c25ea8dcd18be28fb9">More...</a><br /></td></tr>
<tr class="separator:a3787c6ec6a4a01c25ea8dcd18be28fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78872d190b913655789ff725f77c1913"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a78872d190b913655789ff725f77c1913">setSource</a> (const std::function&lt; Real(const RealVect a_position)&gt; a_source)</td></tr>
<tr class="memdesc:a78872d190b913655789ff725f77c1913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic way of setting source terms.  <a href="classCdrSolver.html#a78872d190b913655789ff725f77c1913">More...</a><br /></td></tr>
<tr class="separator:a78872d190b913655789ff725f77c1913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445d5c10758ab2765fb1618f836f3059"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a445d5c10758ab2765fb1618f836f3059">setEbFlux</a> (const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_ebFlux)</td></tr>
<tr class="memdesc:a445d5c10758ab2765fb1618f836f3059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-based version of setting the EB flux.  <a href="classCdrSolver.html#a445d5c10758ab2765fb1618f836f3059">More...</a><br /></td></tr>
<tr class="separator:a445d5c10758ab2765fb1618f836f3059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab932f345a326a5c6bb97fbd338c1a05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aab932f345a326a5c6bb97fbd338c1a05">setEbFlux</a> (const Real a_ebFlux)</td></tr>
<tr class="memdesc:aab932f345a326a5c6bb97fbd338c1a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the eb flux to a constant.  <a href="classCdrSolver.html#aab932f345a326a5c6bb97fbd338c1a05">More...</a><br /></td></tr>
<tr class="separator:aab932f345a326a5c6bb97fbd338c1a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaf110ad3bb144212cfd15564dc43dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a6eaf110ad3bb144212cfd15564dc43dd">initialData</a> ()</td></tr>
<tr class="memdesc:a6eaf110ad3bb144212cfd15564dc43dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill m_phi state with initial data from m_species.  <a href="classCdrSolver.html#a6eaf110ad3bb144212cfd15564dc43dd">More...</a><br /></td></tr>
<tr class="separator:a6eaf110ad3bb144212cfd15564dc43dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7026663cd47dbf767cb969a7c0601020"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a7026663cd47dbf767cb969a7c0601020">allocateInternals</a> ()</td></tr>
<tr class="memdesc:a7026663cd47dbf767cb969a7c0601020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate internal storage.  <a href="classCdrSolver.html#a7026663cd47dbf767cb969a7c0601020">More...</a><br /></td></tr>
<tr class="separator:a7026663cd47dbf767cb969a7c0601020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ff5275be09e06043378eae81f89267"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ae5ff5275be09e06043378eae81f89267">writePlotFile</a> ()</td></tr>
<tr class="memdesc:ae5ff5275be09e06043378eae81f89267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write plot file.  <a href="classCdrSolver.html#ae5ff5275be09e06043378eae81f89267">More...</a><br /></td></tr>
<tr class="separator:ae5ff5275be09e06043378eae81f89267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae1ef6f463bded79a599bbe60505fb6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#afae1ef6f463bded79a599bbe60505fb6">writePlotData</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_output, int &amp;a_icomp)</td></tr>
<tr class="memdesc:afae1ef6f463bded79a599bbe60505fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write output data to a_output.  <a href="classCdrSolver.html#afae1ef6f463bded79a599bbe60505fb6">More...</a><br /></td></tr>
<tr class="separator:afae1ef6f463bded79a599bbe60505fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7446a0ff354cbd7b4ce57066b97e20"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ace7446a0ff354cbd7b4ce57066b97e20">regrid</a> (const int a_lmin, const int a_oldFinestLevel, const int a_newFinestLevel)</td></tr>
<tr class="memdesc:ace7446a0ff354cbd7b4ce57066b97e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write checkpoint data into HDF5 file. @paramo[out] a_handle HDF5 file.  <a href="classCdrSolver.html#ace7446a0ff354cbd7b4ce57066b97e20">More...</a><br /></td></tr>
<tr class="separator:ace7446a0ff354cbd7b4ce57066b97e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e0e2a4f74395f38bd403c98970979a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ae7e0e2a4f74395f38bd403c98970979a">setRedistWeights</a> (const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_weights)</td></tr>
<tr class="memdesc:ae7e0e2a4f74395f38bd403c98970979a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set redistribution weights.  <a href="classCdrSolver.html#ae7e0e2a4f74395f38bd403c98970979a">More...</a><br /></td></tr>
<tr class="separator:ae7e0e2a4f74395f38bd403c98970979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5259c827a4fb56c2e57d3db3f13d9f"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a9c5259c827a4fb56c2e57d3db3f13d9f">getRealm</a> () const</td></tr>
<tr class="memdesc:a9c5259c827a4fb56c2e57d3db3f13d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the realm where this solver is registered.  <a href="classCdrSolver.html#a9c5259c827a4fb56c2e57d3db3f13d9f">More...</a><br /></td></tr>
<tr class="separator:a9c5259c827a4fb56c2e57d3db3f13d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78889fbd012fbc6fa4bd7897fbd369b4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a78889fbd012fbc6fa4bd7897fbd369b4">getName</a> () const</td></tr>
<tr class="memdesc:a78889fbd012fbc6fa4bd7897fbd369b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get solver name.  <a href="classCdrSolver.html#a78889fbd012fbc6fa4bd7897fbd369b4">More...</a><br /></td></tr>
<tr class="separator:a78889fbd012fbc6fa4bd7897fbd369b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5406deb947700c436d9de4a89fc40f"><td class="memItemLeft" align="right" valign="top">virtual Vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aef5406deb947700c436d9de4a89fc40f">getPlotVariableNames</a> () const</td></tr>
<tr class="memdesc:aef5406deb947700c436d9de4a89fc40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output plot names.  <a href="classCdrSolver.html#aef5406deb947700c436d9de4a89fc40f">More...</a><br /></td></tr>
<tr class="separator:aef5406deb947700c436d9de4a89fc40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baa3e47cd960d3a4bc74e4aa9fb1b8b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a2baa3e47cd960d3a4bc74e4aa9fb1b8b">getNumberOfPlotVariables</a> () const</td></tr>
<tr class="memdesc:a2baa3e47cd960d3a4bc74e4aa9fb1b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of output fields.  <a href="classCdrSolver.html#a2baa3e47cd960d3a4bc74e4aa9fb1b8b">More...</a><br /></td></tr>
<tr class="separator:a2baa3e47cd960d3a4bc74e4aa9fb1b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a0d1be9cc5aee9f0573c4f3b75dd6c"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a40a0d1be9cc5aee9f0573c4f3b75dd6c">computeAdvectionDt</a> ()</td></tr>
<tr class="memdesc:a40a0d1be9cc5aee9f0573c4f3b75dd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible diffusive time step (for explicit methods)  <a href="classCdrSolver.html#a40a0d1be9cc5aee9f0573c4f3b75dd6c">More...</a><br /></td></tr>
<tr class="separator:a40a0d1be9cc5aee9f0573c4f3b75dd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05221de7e5cb6648fb19958ba02c7f0"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aa05221de7e5cb6648fb19958ba02c7f0">computeDiffusionDt</a> ()</td></tr>
<tr class="memdesc:aa05221de7e5cb6648fb19958ba02c7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible diffusive time step (for explicit methods)  <a href="classCdrSolver.html#aa05221de7e5cb6648fb19958ba02c7f0">More...</a><br /></td></tr>
<tr class="separator:aa05221de7e5cb6648fb19958ba02c7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eafbcb34050fd514c2839406299dc38"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a5eafbcb34050fd514c2839406299dc38">computeAdvectionDiffusionDt</a> ()</td></tr>
<tr class="memdesc:a5eafbcb34050fd514c2839406299dc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible diffusive time step (for explicit methods)  <a href="classCdrSolver.html#a5eafbcb34050fd514c2839406299dc38">More...</a><br /></td></tr>
<tr class="separator:a5eafbcb34050fd514c2839406299dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7bc8d5ac3c1e8fd65956313d6def8b"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#add7bc8d5ac3c1e8fd65956313d6def8b">computeSourceDt</a> (const Real a_max, const Real a_tolerance)</td></tr>
<tr class="memdesc:add7bc8d5ac3c1e8fd65956313d6def8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest possible source time step (for explicit methods.  <a href="classCdrSolver.html#add7bc8d5ac3c1e8fd65956313d6def8b">More...</a><br /></td></tr>
<tr class="separator:add7bc8d5ac3c1e8fd65956313d6def8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15c976354d426dd11bb9d2de8066c3a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aa15c976354d426dd11bb9d2de8066c3a">weightedUpwind</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_weightedUpwindPhi, const int a_pow)</td></tr>
<tr class="memdesc:aa15c976354d426dd11bb9d2de8066c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an upwind-weighted version of phi.  <a href="classCdrSolver.html#aa15c976354d426dd11bb9d2de8066c3a">More...</a><br /></td></tr>
<tr class="separator:aa15c976354d426dd11bb9d2de8066c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab130ea207184190aeb72bcb7e4f60810"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ab130ea207184190aeb72bcb7e4f60810">computeMass</a> ()</td></tr>
<tr class="memdesc:ab130ea207184190aeb72bcb7e4f60810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the "physical mass" in m_phi.  <a href="classCdrSolver.html#ab130ea207184190aeb72bcb7e4f60810">More...</a><br /></td></tr>
<tr class="separator:ab130ea207184190aeb72bcb7e4f60810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f01b3499d164a753030edb07a506e8"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ac7f01b3499d164a753030edb07a506e8">computeMass</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi)</td></tr>
<tr class="memdesc:ac7f01b3499d164a753030edb07a506e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the "physical mass" in the input argument.  <a href="classCdrSolver.html#ac7f01b3499d164a753030edb07a506e8">More...</a><br /></td></tr>
<tr class="separator:ac7f01b3499d164a753030edb07a506e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8829af72cf17208473dcef2eebb44b55"><td class="memItemLeft" align="right" valign="top">virtual Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a8829af72cf17208473dcef2eebb44b55">computeCharge</a> ()</td></tr>
<tr class="memdesc:a8829af72cf17208473dcef2eebb44b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the total charge in m_phi.  <a href="classCdrSolver.html#a8829af72cf17208473dcef2eebb44b55">More...</a><br /></td></tr>
<tr class="separator:a8829af72cf17208473dcef2eebb44b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600bb663a95395ef3fd95094ecbd10ee"><td class="memItemLeft" align="right" valign="top"><a id="a600bb663a95395ef3fd95094ecbd10ee"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a600bb663a95395ef3fd95094ecbd10ee">isDiffusive</a> ()</td></tr>
<tr class="memdesc:a600bb663a95395ef3fd95094ecbd10ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the solver is diffusive and false otherwise. <br /></td></tr>
<tr class="separator:a600bb663a95395ef3fd95094ecbd10ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bafb90170943f4bcc177a124695e0c4"><td class="memItemLeft" align="right" valign="top"><a id="a2bafb90170943f4bcc177a124695e0c4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a2bafb90170943f4bcc177a124695e0c4">isMobile</a> ()</td></tr>
<tr class="memdesc:a2bafb90170943f4bcc177a124695e0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the solver is mobile and false otherwise. <br /></td></tr>
<tr class="separator:a2bafb90170943f4bcc177a124695e0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e1673fb1c0cd109286735d2a6035e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a56e1673fb1c0cd109286735d2a6035e1">getPhi</a> ()</td></tr>
<tr class="memdesc:a56e1673fb1c0cd109286735d2a6035e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cell-centered phi.  <a href="classCdrSolver.html#a56e1673fb1c0cd109286735d2a6035e1">More...</a><br /></td></tr>
<tr class="separator:a56e1673fb1c0cd109286735d2a6035e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21db0f823153223f5b3a198f07a3b637"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a21db0f823153223f5b3a198f07a3b637">getSource</a> ()</td></tr>
<tr class="memdesc:a21db0f823153223f5b3a198f07a3b637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the source term.  <a href="classCdrSolver.html#a21db0f823153223f5b3a198f07a3b637">More...</a><br /></td></tr>
<tr class="separator:a21db0f823153223f5b3a198f07a3b637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada68d63038371ea21f526696459c51f6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ada68d63038371ea21f526696459c51f6">getCellCenteredVelocity</a> ()</td></tr>
<tr class="memdesc:ada68d63038371ea21f526696459c51f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cell-centered velocity.  <a href="classCdrSolver.html#ada68d63038371ea21f526696459c51f6">More...</a><br /></td></tr>
<tr class="separator:ada68d63038371ea21f526696459c51f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec9fa671f4dd6b75855fe15f0c7b063"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a2ec9fa671f4dd6b75855fe15f0c7b063">getFaceCenteredVelocity</a> ()</td></tr>
<tr class="memdesc:a2ec9fa671f4dd6b75855fe15f0c7b063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the face-centered velocities.  <a href="classCdrSolver.html#a2ec9fa671f4dd6b75855fe15f0c7b063">More...</a><br /></td></tr>
<tr class="separator:a2ec9fa671f4dd6b75855fe15f0c7b063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a080b3433328e7b74b9207d324f77cd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a1a080b3433328e7b74b9207d324f77cd">getEbCenteredVelocity</a> ()</td></tr>
<tr class="memdesc:a1a080b3433328e7b74b9207d324f77cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eb-centered velocities.  <a href="classCdrSolver.html#a1a080b3433328e7b74b9207d324f77cd">More...</a><br /></td></tr>
<tr class="separator:a1a080b3433328e7b74b9207d324f77cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f174f15a7402f961c5f370e739f092"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a41f174f15a7402f961c5f370e739f092">getFaceCenteredDiffusionCoefficient</a> ()</td></tr>
<tr class="memdesc:a41f174f15a7402f961c5f370e739f092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the face-centered diffusion coefficient.  <a href="classCdrSolver.html#a41f174f15a7402f961c5f370e739f092">More...</a><br /></td></tr>
<tr class="separator:a41f174f15a7402f961c5f370e739f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11331fb94290db965fdb62b51a51271d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a11331fb94290db965fdb62b51a51271d">getEbCenteredDiffusionCoefficient</a> ()</td></tr>
<tr class="memdesc:a11331fb94290db965fdb62b51a51271d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the EB-centered diffusion coefficient.  <a href="classCdrSolver.html#a11331fb94290db965fdb62b51a51271d">More...</a><br /></td></tr>
<tr class="separator:a11331fb94290db965fdb62b51a51271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa4e4ee7c1a01f99d4976fac4ada866"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#adaa4e4ee7c1a01f99d4976fac4ada866">getEbFlux</a> ()</td></tr>
<tr class="memdesc:adaa4e4ee7c1a01f99d4976fac4ada866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eb flux data holder.  <a href="classCdrSolver.html#adaa4e4ee7c1a01f99d4976fac4ada866">More...</a><br /></td></tr>
<tr class="separator:adaa4e4ee7c1a01f99d4976fac4ada866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6520f8f8ef319640e1bc32c7c61a5181"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a6520f8f8ef319640e1bc32c7c61a5181">getDomainFlux</a> ()</td></tr>
<tr class="memdesc:a6520f8f8ef319640e1bc32c7c61a5181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the domain flux data holder.  <a href="classCdrSolver.html#a6520f8f8ef319640e1bc32c7c61a5181">More...</a><br /></td></tr>
<tr class="separator:a6520f8f8ef319640e1bc32c7c61a5181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8022eea83998f3d752797efd45d372ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a8022eea83998f3d752797efd45d372ba">extrapolateAdvectiveFluxToEB</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_ebFlux) const noexcept</td></tr>
<tr class="memdesc:a8022eea83998f3d752797efd45d372ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolate advective flux to EB.  <a href="classCdrSolver.html#a8022eea83998f3d752797efd45d372ba">More...</a><br /></td></tr>
<tr class="separator:a8022eea83998f3d752797efd45d372ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a6c2cfa627dd07e57cb07c4ae896e3090"><td class="memItemLeft" align="right" valign="top"><a id="a6c2cfa627dd07e57cb07c4ae896e3090"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a6c2cfa627dd07e57cb07c4ae896e3090">Redistribution</a> { <b>VolumeWeighted</b>
, <b>MassWeighted</b>
, <b>None</b>
 }</td></tr>
<tr class="memdesc:a6c2cfa627dd07e57cb07c4ae896e3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribution method. <br /></td></tr>
<tr class="separator:a6c2cfa627dd07e57cb07c4ae896e3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2c2fc0117757f6198bfa24a8481a684b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a2c2fc0117757f6198bfa24a8481a684b">averageVelocityToFaces</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_faceVelocity, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_cellVelocity)</td></tr>
<tr class="memdesc:a2c2fc0117757f6198bfa24a8481a684b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average cell-centered velocities to face centers.  <a href="classCdrSolver.html#a2c2fc0117757f6198bfa24a8481a684b">More...</a><br /></td></tr>
<tr class="separator:a2c2fc0117757f6198bfa24a8481a684b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc070166e374bec593cb6da68cf36b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#accc070166e374bec593cb6da68cf36b0">advectToFaces</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_facePhi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const Real a_extrapDt)=0</td></tr>
<tr class="memdesc:accc070166e374bec593cb6da68cf36b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advection-only extrapolation to faces.  <a href="classCdrSolver.html#accc070166e374bec593cb6da68cf36b0">More...</a><br /></td></tr>
<tr class="separator:accc070166e374bec593cb6da68cf36b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ebe315836c30c22c1c02b9bfb40ce8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aa2ebe315836c30c22c1c02b9bfb40ce8">computeAdvectionFlux</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_flux, const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_facePhi, const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_faceVelocity, const bool a_addDomainFlux=true)</td></tr>
<tr class="memdesc:aa2ebe315836c30c22c1c02b9bfb40ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up face-centered advection flux.  <a href="classCdrSolver.html#aa2ebe315836c30c22c1c02b9bfb40ce8">More...</a><br /></td></tr>
<tr class="separator:aa2ebe315836c30c22c1c02b9bfb40ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ee682d52e18749e0997c0eb6d043a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a55ee682d52e18749e0997c0eb6d043a5">computeAdvectionFlux</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_flux, const LevelData&lt; EBFluxFAB &gt; &amp;a_facePhi, const LevelData&lt; EBFluxFAB &gt; &amp;a_faceVelocity, const int a_lvl)</td></tr>
<tr class="memdesc:a55ee682d52e18749e0997c0eb6d043a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up face-centered advection flux on a grid level.  <a href="classCdrSolver.html#a55ee682d52e18749e0997c0eb6d043a5">More...</a><br /></td></tr>
<tr class="separator:a55ee682d52e18749e0997c0eb6d043a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cdc7712e4382189c9750b3241df02a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ae8cdc7712e4382189c9750b3241df02a">computeDiffusionFlux</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_flux, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi, const bool a_addDomainFlux)</td></tr>
<tr class="memdesc:ae8cdc7712e4382189c9750b3241df02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the face-centered diffusion flux.  <a href="classCdrSolver.html#ae8cdc7712e4382189c9750b3241df02a">More...</a><br /></td></tr>
<tr class="separator:ae8cdc7712e4382189c9750b3241df02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa0a24e66721f2c1e62ae8e5ebb0ca5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#adfa0a24e66721f2c1e62ae8e5ebb0ca5">computeDiffusionFlux</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_flux, const LevelData&lt; EBCellFAB &gt; &amp;a_phi, const int a_lvl)</td></tr>
<tr class="memdesc:adfa0a24e66721f2c1e62ae8e5ebb0ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the face-centered diffusion flux.  <a href="classCdrSolver.html#adfa0a24e66721f2c1e62ae8e5ebb0ca5">More...</a><br /></td></tr>
<tr class="separator:adfa0a24e66721f2c1e62ae8e5ebb0ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080f394c63a7bcb66ca7a35e2cfeba24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a080f394c63a7bcb66ca7a35e2cfeba24">computeAdvectionDiffusionFlux</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_flux, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_cellStates, const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_faceStates, const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_faceVelocities, const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_faceDiffCo, const bool a_addDomainFlux)</td></tr>
<tr class="memdesc:a080f394c63a7bcb66ca7a35e2cfeba24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the full advection-diffusion flux. This assumes that the solver is mobile and diffusive.  <a href="classCdrSolver.html#a080f394c63a7bcb66ca7a35e2cfeba24">More...</a><br /></td></tr>
<tr class="separator:a080f394c63a7bcb66ca7a35e2cfeba24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608cefd6b0a47c9ffc909d5d0297625d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a608cefd6b0a47c9ffc909d5d0297625d">resetDomainFlux</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_flux)</td></tr>
<tr class="memdesc:a608cefd6b0a47c9ffc909d5d0297625d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flux to zero on domain boundaries.  <a href="classCdrSolver.html#a608cefd6b0a47c9ffc909d5d0297625d">More...</a><br /></td></tr>
<tr class="separator:a608cefd6b0a47c9ffc909d5d0297625d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac82d2f5099de3dd8837d2a0291704aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aac82d2f5099de3dd8837d2a0291704aa">fillDomainFlux</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_flux)</td></tr>
<tr class="memdesc:aac82d2f5099de3dd8837d2a0291704aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set domain in data holder. This sets the flux on the boundary to either zero or to m_domainFlux.  <a href="classCdrSolver.html#aac82d2f5099de3dd8837d2a0291704aa">More...</a><br /></td></tr>
<tr class="separator:aac82d2f5099de3dd8837d2a0291704aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c90f17f553d8bb2e67540deb7258af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ad7c90f17f553d8bb2e67540deb7258af">fillDomainFlux</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_flux, const int a_level)</td></tr>
<tr class="memdesc:ad7c90f17f553d8bb2e67540deb7258af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set domain in data holder. This sets the flux on the boundary to either zero or to m_domainFlux.  <a href="classCdrSolver.html#ad7c90f17f553d8bb2e67540deb7258af">More...</a><br /></td></tr>
<tr class="separator:ad7c90f17f553d8bb2e67540deb7258af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb06d2d9cb8acb7cc9456820b18c3ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a7bb06d2d9cb8acb7cc9456820b18c3ce">conservativeDivergenceNoKappaDivision</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_conservativeDivergence, <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_flux, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_ebFlux)</td></tr>
<tr class="memdesc:a7bb06d2d9cb8acb7cc9456820b18c3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute conservative divergence from fluxes.  <a href="classCdrSolver.html#a7bb06d2d9cb8acb7cc9456820b18c3ce">More...</a><br /></td></tr>
<tr class="separator:a7bb06d2d9cb8acb7cc9456820b18c3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cd6079923bd82e433df7961288d129"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a08cd6079923bd82e433df7961288d129">nonConservativeDivergence</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_nonConservativeDivergence, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_divG)</td></tr>
<tr class="memdesc:a08cd6079923bd82e433df7961288d129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the non-conservative divergence.  <a href="classCdrSolver.html#a08cd6079923bd82e433df7961288d129">More...</a><br /></td></tr>
<tr class="separator:a08cd6079923bd82e433df7961288d129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa32de02a211aabf541a09bf4e59d51"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a3fa32de02a211aabf541a09bf4e59d51">hybridDivergence</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_hybridDivergence, <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_massDifference, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_nonConservativeDivergence)</td></tr>
<tr class="memdesc:a3fa32de02a211aabf541a09bf4e59d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the non-conservative divergence to make the conservative divergence hold the hybrid divergence.  <a href="classCdrSolver.html#a3fa32de02a211aabf541a09bf4e59d51">More...</a><br /></td></tr>
<tr class="separator:a3fa32de02a211aabf541a09bf4e59d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde0af282267f61856a6213115ed8432"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#adde0af282267f61856a6213115ed8432">hybridDivergence</a> (LevelData&lt; EBCellFAB &gt; &amp;a_hybridDivergence, LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_massDifference, const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_nonConservativeDivergence, const int a_lvl)</td></tr>
<tr class="memdesc:adde0af282267f61856a6213115ed8432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the hybrid divergence. On the way in, a_hybridDivergence must hold the conservative divergence.  <a href="classCdrSolver.html#adde0af282267f61856a6213115ed8432">More...</a><br /></td></tr>
<tr class="separator:adde0af282267f61856a6213115ed8432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae720d11ad0145b4c92bddb2c4a7f9786"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ae720d11ad0145b4c92bddb2c4a7f9786">conservativeDivergenceRegular</a> (LevelData&lt; EBCellFAB &gt; &amp;a_divJ, const LevelData&lt; EBFluxFAB &gt; &amp;a_flux, const int a_lvl)</td></tr>
<tr class="memdesc:ae720d11ad0145b4c92bddb2c4a7f9786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conservative divergence over regular cells.  <a href="classCdrSolver.html#ae720d11ad0145b4c92bddb2c4a7f9786">More...</a><br /></td></tr>
<tr class="separator:ae720d11ad0145b4c92bddb2c4a7f9786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4752844cda9533c1a03a9c7119fc5fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ac4752844cda9533c1a03a9c7119fc5fa">interpolateFluxToFaceCentroids</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_flux)</td></tr>
<tr class="memdesc:ac4752844cda9533c1a03a9c7119fc5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate flux to centroids.  <a href="classCdrSolver.html#ac4752844cda9533c1a03a9c7119fc5fa">More...</a><br /></td></tr>
<tr class="separator:ac4752844cda9533c1a03a9c7119fc5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8001b143616c6e3d73c78b4dd730cc70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a8001b143616c6e3d73c78b4dd730cc70">interpolateFluxToFaceCentroids</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_flux, const int a_lvl)</td></tr>
<tr class="memdesc:a8001b143616c6e3d73c78b4dd730cc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate flux to centroids.  <a href="classCdrSolver.html#a8001b143616c6e3d73c78b4dd730cc70">More...</a><br /></td></tr>
<tr class="separator:a8001b143616c6e3d73c78b4dd730cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f16898f7e11431a6dcb26d842a91a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#af3f16898f7e11431a6dcb26d842a91a7">computeDivergenceIrregular</a> (LevelData&lt; EBCellFAB &gt; &amp;a_divG, const LevelData&lt; EBFluxFAB &gt; &amp;a_centroidFluxes, const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_ebFlux, const int a_lvl)</td></tr>
<tr class="memdesc:af3f16898f7e11431a6dcb26d842a91a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute conservative divergence on irregular cells (not kappa divided)  <a href="classCdrSolver.html#af3f16898f7e11431a6dcb26d842a91a7">More...</a><br /></td></tr>
<tr class="separator:af3f16898f7e11431a6dcb26d842a91a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c00568baee2b2cf76d4fba24af9423"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aa1c00568baee2b2cf76d4fba24af9423">incrementFluxRegister</a> (const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_flux)</td></tr>
<tr class="memdesc:aa1c00568baee2b2cf76d4fba24af9423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment flux registers.  <a href="classCdrSolver.html#aa1c00568baee2b2cf76d4fba24af9423">More...</a><br /></td></tr>
<tr class="separator:aa1c00568baee2b2cf76d4fba24af9423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8f5bd76e99d2e55746176942d4a84e"><td class="memItemLeft" align="right" valign="top"><a id="a9c8f5bd76e99d2e55746176942d4a84e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a9c8f5bd76e99d2e55746176942d4a84e">resetFluxRegister</a> ()</td></tr>
<tr class="memdesc:a9c8f5bd76e99d2e55746176942d4a84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flux registers to zero (so they can be increment later). <br /></td></tr>
<tr class="separator:a9c8f5bd76e99d2e55746176942d4a84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d9fcff15b936cd81802873cbd5ddb6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a44d9fcff15b936cd81802873cbd5ddb6">coarseFineIncrement</a> (const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;<a class="el" href="classCdrSolver.html#a33f71250c8b1ef93999310c109e765c4">m_massDifference</a>)</td></tr>
<tr class="memdesc:a44d9fcff15b936cd81802873cbd5ddb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the coarse-fine redist with mass difference (only for EB x CF)  <a href="classCdrSolver.html#a44d9fcff15b936cd81802873cbd5ddb6">More...</a><br /></td></tr>
<tr class="separator:a44d9fcff15b936cd81802873cbd5ddb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553fa6ca44573f91cc0522b971c0084f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a553fa6ca44573f91cc0522b971c0084f">hyperbolicRedistribution</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_stableDivergence)</td></tr>
<tr class="memdesc:a553fa6ca44573f91cc0522b971c0084f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do mass redistribution on each level.  <a href="classCdrSolver.html#a553fa6ca44573f91cc0522b971c0084f">More...</a><br /></td></tr>
<tr class="separator:a553fa6ca44573f91cc0522b971c0084f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c3c2ed50dd5146070c9d73157f6b44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a22c3c2ed50dd5146070c9d73157f6b44">incrementRedistFlux</a> ()</td></tr>
<tr class="memdesc:a22c3c2ed50dd5146070c9d73157f6b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment redistribution flux registers.  <a href="classCdrSolver.html#a22c3c2ed50dd5146070c9d73157f6b44">More...</a><br /></td></tr>
<tr class="separator:a22c3c2ed50dd5146070c9d73157f6b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9435b5365d81a1fdcbc2b37a2822149a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a9435b5365d81a1fdcbc2b37a2822149a">incrementRedist</a> (const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_massDifference)</td></tr>
<tr class="memdesc:a9435b5365d81a1fdcbc2b37a2822149a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment redistribution objects with mass to be redistributed.  <a href="classCdrSolver.html#a9435b5365d81a1fdcbc2b37a2822149a">More...</a><br /></td></tr>
<tr class="separator:a9435b5365d81a1fdcbc2b37a2822149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b718047e2c9bcc3810875dae9cf12f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a4b718047e2c9bcc3810875dae9cf12f5">coarseFineRedistribution</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi)</td></tr>
<tr class="memdesc:a4b718047e2c9bcc3810875dae9cf12f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do coarse-fine redistribution.  <a href="classCdrSolver.html#a4b718047e2c9bcc3810875dae9cf12f5">More...</a><br /></td></tr>
<tr class="separator:a4b718047e2c9bcc3810875dae9cf12f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfde982543d29db88613accff9d567b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#abfde982543d29db88613accff9d567b5">reflux</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_phi)</td></tr>
<tr class="memdesc:abfde982543d29db88613accff9d567b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflux across refinement boundaries, using whatever is inside the flux registers.  <a href="classCdrSolver.html#abfde982543d29db88613accff9d567b5">More...</a><br /></td></tr>
<tr class="separator:abfde982543d29db88613accff9d567b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f2ddd14ef7e7a38d9e3a7b2f9eb780"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a01f2ddd14ef7e7a38d9e3a7b2f9eb780">setEbIndexSpace</a> (const RefCountedPtr&lt; EBIndexSpace &gt; &amp;a_ebis)</td></tr>
<tr class="memdesc:a01f2ddd14ef7e7a38d9e3a7b2f9eb780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ebis.  <a href="classCdrSolver.html#a01f2ddd14ef7e7a38d9e3a7b2f9eb780">More...</a><br /></td></tr>
<tr class="separator:a01f2ddd14ef7e7a38d9e3a7b2f9eb780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b253df11825b4901b35bd6415262cb5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a5b253df11825b4901b35bd6415262cb5">initialDataDistribution</a> ()</td></tr>
<tr class="memdesc:a5b253df11825b4901b35bd6415262cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill initial data from a distribution function.  <a href="classCdrSolver.html#a5b253df11825b4901b35bd6415262cb5">More...</a><br /></td></tr>
<tr class="separator:a5b253df11825b4901b35bd6415262cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b4284381910cdd77ec863410db4670"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ae7b4284381910cdd77ec863410db4670">initialDataParticles</a> ()</td></tr>
<tr class="memdesc:ae7b4284381910cdd77ec863410db4670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill initial data from particles.  <a href="classCdrSolver.html#ae7b4284381910cdd77ec863410db4670">More...</a><br /></td></tr>
<tr class="separator:ae7b4284381910cdd77ec863410db4670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab965dcd94518ca2b80b4348d2a67a63c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ab965dcd94518ca2b80b4348d2a67a63c">defineInterpolationStencils</a> ()</td></tr>
<tr class="memdesc:ab965dcd94518ca2b80b4348d2a67a63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define stencils for doing face-centered to face-centroid-centered states.  <a href="classCdrSolver.html#ab965dcd94518ca2b80b4348d2a67a63c">More...</a><br /></td></tr>
<tr class="separator:ab965dcd94518ca2b80b4348d2a67a63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a40fcf6bfa8890f73ecacc8323affe"><td class="memItemLeft" align="right" valign="top"><a id="a72a40fcf6bfa8890f73ecacc8323affe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a72a40fcf6bfa8890f73ecacc8323affe">parseDomainBc</a> ()</td></tr>
<tr class="memdesc:a72a40fcf6bfa8890f73ecacc8323affe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses domain BC options. <br /></td></tr>
<tr class="separator:a72a40fcf6bfa8890f73ecacc8323affe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263002adff9c47a7711fdd4d56545b71"><td class="memItemLeft" align="right" valign="top"><a id="a263002adff9c47a7711fdd4d56545b71"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a263002adff9c47a7711fdd4d56545b71">parsePlotVariables</a> ()</td></tr>
<tr class="memdesc:a263002adff9c47a7711fdd4d56545b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses plot variables. <br /></td></tr>
<tr class="separator:a263002adff9c47a7711fdd4d56545b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f03d5d75d29053461ce5414d298916"><td class="memItemLeft" align="right" valign="top"><a id="a28f03d5d75d29053461ce5414d298916"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a28f03d5d75d29053461ce5414d298916">parsePlotMode</a> ()</td></tr>
<tr class="memdesc:a28f03d5d75d29053461ce5414d298916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse plot mode. <br /></td></tr>
<tr class="separator:a28f03d5d75d29053461ce5414d298916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f12d0796c3ab55419476d4fe471e6a"><td class="memItemLeft" align="right" valign="top"><a id="ab2f12d0796c3ab55419476d4fe471e6a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ab2f12d0796c3ab55419476d4fe471e6a">parseDivergenceComputation</a> ()</td></tr>
<tr class="memdesc:ab2f12d0796c3ab55419476d4fe471e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the conservation. <br /></td></tr>
<tr class="separator:ab2f12d0796c3ab55419476d4fe471e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e4d5966ffc4ae9699619014eaacb24"><td class="memItemLeft" align="right" valign="top"><a id="a88e4d5966ffc4ae9699619014eaacb24"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a88e4d5966ffc4ae9699619014eaacb24">parseRegridSlopes</a> ()</td></tr>
<tr class="memdesc:a88e4d5966ffc4ae9699619014eaacb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse slope regrid. <br /></td></tr>
<tr class="separator:a88e4d5966ffc4ae9699619014eaacb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89cf561173855d612997e5fca4a607b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#af89cf561173855d612997e5fca4a607b">makeBcString</a> (const int a_dir, const Side::LoHiSide a_side) const</td></tr>
<tr class="memdesc:af89cf561173855d612997e5fca4a607b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for making a boundary condition string.  <a href="classCdrSolver.html#af89cf561173855d612997e5fca4a607b">More...</a><br /></td></tr>
<tr class="separator:af89cf561173855d612997e5fca4a607b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e0136504fa6746458741c9dcf5f4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a444e0136504fa6746458741c9dcf5f4f">fillGwn</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_noise, const Real a_sigma)</td></tr>
<tr class="memdesc:a444e0136504fa6746458741c9dcf5f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian noise field.  <a href="classCdrSolver.html#a444e0136504fa6746458741c9dcf5f4f">More...</a><br /></td></tr>
<tr class="separator:a444e0136504fa6746458741c9dcf5f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717520ff49df061821a7411db2b00123"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a717520ff49df061821a7411db2b00123">smoothHeavisideFaces</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_facePhi, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_cellPhi)</td></tr>
<tr class="memdesc:a717520ff49df061821a7411db2b00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Heaviside smoothing for computing face-centered states.  <a href="classCdrSolver.html#a717520ff49df061821a7411db2b00123">More...</a><br /></td></tr>
<tr class="separator:a717520ff49df061821a7411db2b00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e5cf3b317437037e25187136d7ab0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a13e5cf3b317437037e25187136d7ab0e">writeData</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_output, int &amp;a_comp, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const bool a_interp)</td></tr>
<tr class="memdesc:a13e5cf3b317437037e25187136d7ab0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to output. Convenience function.  <a href="classCdrSolver.html#a13e5cf3b317437037e25187136d7ab0e">More...</a><br /></td></tr>
<tr class="separator:a13e5cf3b317437037e25187136d7ab0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af8479fa2eb98cbdd31f7e76de0d5118e"><td class="memItemLeft" align="right" valign="top"><a id="af8479fa2eb98cbdd31f7e76de0d5118e"></a>
RefCountedPtr&lt; EBIndexSpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#af8479fa2eb98cbdd31f7e76de0d5118e">m_ebis</a></td></tr>
<tr class="memdesc:af8479fa2eb98cbdd31f7e76de0d5118e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index space. <br /></td></tr>
<tr class="separator:af8479fa2eb98cbdd31f7e76de0d5118e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c1c25b5a5042ef46a6dc2e5ad31a6d"><td class="memItemLeft" align="right" valign="top"><a id="a43c1c25b5a5042ef46a6dc2e5ad31a6d"></a>
RefCountedPtr&lt; <a class="el" href="classCdrSpecies.html">CdrSpecies</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a43c1c25b5a5042ef46a6dc2e5ad31a6d">m_species</a></td></tr>
<tr class="memdesc:a43c1c25b5a5042ef46a6dc2e5ad31a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Species through which e.g. mobility/diffusion and initial conditions is passed. <br /></td></tr>
<tr class="separator:a43c1c25b5a5042ef46a6dc2e5ad31a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604d3787ec15b3cae8e7963b62a2233f"><td class="memItemLeft" align="right" valign="top"><a id="a604d3787ec15b3cae8e7963b62a2233f"></a>
RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a604d3787ec15b3cae8e7963b62a2233f">m_computationalGeometry</a></td></tr>
<tr class="memdesc:a604d3787ec15b3cae8e7963b62a2233f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational geometry. <br /></td></tr>
<tr class="separator:a604d3787ec15b3cae8e7963b62a2233f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439f72d7d51eef83e87dfef79c9a7023"><td class="memItemLeft" align="right" valign="top"><a id="a439f72d7d51eef83e87dfef79c9a7023"></a>
RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a439f72d7d51eef83e87dfef79c9a7023">m_amr</a></td></tr>
<tr class="memdesc:a439f72d7d51eef83e87dfef79c9a7023"><td class="mdescLeft">&#160;</td><td class="mdescRight">AMR; needed for grid stuff. <br /></td></tr>
<tr class="separator:a439f72d7d51eef83e87dfef79c9a7023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a227d738f86cdb554853b08e38543fc"><td class="memItemLeft" align="right" valign="top"><a id="a4a227d738f86cdb554853b08e38543fc"></a>
Vector&lt; RefCountedPtr&lt; LayoutData&lt; BaseIFFAB&lt; FaceStencil &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a4a227d738f86cdb554853b08e38543fc">m_interpStencils</a> [SpaceDim]</td></tr>
<tr class="memdesc:a4a227d738f86cdb554853b08e38543fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencils for interpolating face-centered fluxes to face centroids. <br /></td></tr>
<tr class="separator:a4a227d738f86cdb554853b08e38543fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1306df1fe75ae5b7847f2d9748c43d"><td class="memItemLeft" align="right" valign="top"><a id="afa1306df1fe75ae5b7847f2d9748c43d"></a>
phase::which_phase&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#afa1306df1fe75ae5b7847f2d9748c43d">m_phase</a></td></tr>
<tr class="memdesc:afa1306df1fe75ae5b7847f2d9748c43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase. <br /></td></tr>
<tr class="separator:afa1306df1fe75ae5b7847f2d9748c43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63b13a993b770db8c872c8964b4ce0a"><td class="memItemLeft" align="right" valign="top"><a id="af63b13a993b770db8c872c8964b4ce0a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#af63b13a993b770db8c872c8964b4ce0a">m_name</a></td></tr>
<tr class="memdesc:af63b13a993b770db8c872c8964b4ce0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver name. <br /></td></tr>
<tr class="separator:af63b13a993b770db8c872c8964b4ce0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a70b05d0a25a38e8bca59579251a12a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a8a70b05d0a25a38e8bca59579251a12a">m_className</a></td></tr>
<tr class="memdesc:a8a70b05d0a25a38e8bca59579251a12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class name.  <a href="classCdrSolver.html#a8a70b05d0a25a38e8bca59579251a12a">More...</a><br /></td></tr>
<tr class="separator:a8a70b05d0a25a38e8bca59579251a12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50211cb007006fb5db277d111963c3c1"><td class="memItemLeft" align="right" valign="top"><a id="a50211cb007006fb5db277d111963c3c1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a50211cb007006fb5db277d111963c3c1">m_realm</a></td></tr>
<tr class="memdesc:a50211cb007006fb5db277d111963c3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> where this solver is registered. <br /></td></tr>
<tr class="separator:a50211cb007006fb5db277d111963c3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7cb1d7987cf1ba8d7f2b08cfc152e3"><td class="memItemLeft" align="right" valign="top"><a id="afa7cb1d7987cf1ba8d7f2b08cfc152e3"></a>
<a class="el" href="classCdrDomainBC.html">CdrDomainBC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#afa7cb1d7987cf1ba8d7f2b08cfc152e3">m_domainBC</a></td></tr>
<tr class="memdesc:afa7cb1d7987cf1ba8d7f2b08cfc152e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain BCs. <br /></td></tr>
<tr class="separator:afa7cb1d7987cf1ba8d7f2b08cfc152e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c121c0e04fb0235b844e9e16efc3002"><td class="memItemLeft" align="right" valign="top"><a id="a5c121c0e04fb0235b844e9e16efc3002"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a5c121c0e04fb0235b844e9e16efc3002">m_phi</a></td></tr>
<tr class="memdesc:a5c121c0e04fb0235b844e9e16efc3002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell-centered data (i.e. the advected-diffused quantity) <br /></td></tr>
<tr class="separator:a5c121c0e04fb0235b844e9e16efc3002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203db9398f39a725c45f08e3d570ab61"><td class="memItemLeft" align="right" valign="top"><a id="a203db9398f39a725c45f08e3d570ab61"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a203db9398f39a725c45f08e3d570ab61">m_source</a></td></tr>
<tr class="memdesc:a203db9398f39a725c45f08e3d570ab61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source term. <br /></td></tr>
<tr class="separator:a203db9398f39a725c45f08e3d570ab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf91a2533184cf27893c1aebbcb6628"><td class="memItemLeft" align="right" valign="top"><a id="a6cf91a2533184cf27893c1aebbcb6628"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a6cf91a2533184cf27893c1aebbcb6628">m_cellVelocity</a></td></tr>
<tr class="memdesc:a6cf91a2533184cf27893c1aebbcb6628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell-centered velocities. <br /></td></tr>
<tr class="separator:a6cf91a2533184cf27893c1aebbcb6628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689092a6402573991df81b7ad3821a6a"><td class="memItemLeft" align="right" valign="top"><a id="a689092a6402573991df81b7ad3821a6a"></a>
<a class="el" href="classEBAMRData.html">EBAMRFluxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a689092a6402573991df81b7ad3821a6a">m_faceStates</a></td></tr>
<tr class="memdesc:a689092a6402573991df81b7ad3821a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holder for face centered states. <br /></td></tr>
<tr class="separator:a689092a6402573991df81b7ad3821a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00b83b3a5db90215a862a639c282593"><td class="memItemLeft" align="right" valign="top"><a id="af00b83b3a5db90215a862a639c282593"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#af00b83b3a5db90215a862a639c282593">m_scratch</a></td></tr>
<tr class="memdesc:af00b83b3a5db90215a862a639c282593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage. <br /></td></tr>
<tr class="separator:af00b83b3a5db90215a862a639c282593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc5d3c2d9c4c541be1d20abc986b087"><td class="memItemLeft" align="right" valign="top"><a id="adbc5d3c2d9c4c541be1d20abc986b087"></a>
<a class="el" href="classEBAMRData.html">EBAMRFluxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#adbc5d3c2d9c4c541be1d20abc986b087">m_scratchFluxOne</a></td></tr>
<tr class="memdesc:adbc5d3c2d9c4c541be1d20abc986b087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for flux. <br /></td></tr>
<tr class="separator:adbc5d3c2d9c4c541be1d20abc986b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ed4c055cb19becb3bc7cb342c23144"><td class="memItemLeft" align="right" valign="top"><a id="af4ed4c055cb19becb3bc7cb342c23144"></a>
<a class="el" href="classEBAMRData.html">EBAMRFluxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#af4ed4c055cb19becb3bc7cb342c23144">m_scratchFluxTwo</a></td></tr>
<tr class="memdesc:af4ed4c055cb19becb3bc7cb342c23144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for flux. <br /></td></tr>
<tr class="separator:af4ed4c055cb19becb3bc7cb342c23144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5228df358369ae320bd65349bb4beee8"><td class="memItemLeft" align="right" valign="top"><a id="a5228df358369ae320bd65349bb4beee8"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a5228df358369ae320bd65349bb4beee8">m_nonConservativeDivG</a></td></tr>
<tr class="memdesc:a5228df358369ae320bd65349bb4beee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for the non-conservative divergence. <br /></td></tr>
<tr class="separator:a5228df358369ae320bd65349bb4beee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f71250c8b1ef93999310c109e765c4"><td class="memItemLeft" align="right" valign="top"><a id="a33f71250c8b1ef93999310c109e765c4"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a33f71250c8b1ef93999310c109e765c4">m_massDifference</a></td></tr>
<tr class="memdesc:a33f71250c8b1ef93999310c109e765c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for the mass difference. <br /></td></tr>
<tr class="separator:a33f71250c8b1ef93999310c109e765c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba08059a9220cd8742e62c86b3e116e"><td class="memItemLeft" align="right" valign="top"><a id="abba08059a9220cd8742e62c86b3e116e"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#abba08059a9220cd8742e62c86b3e116e">m_ebZero</a></td></tr>
<tr class="memdesc:abba08059a9220cd8742e62c86b3e116e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratch storage for the EB flux. <br /></td></tr>
<tr class="separator:abba08059a9220cd8742e62c86b3e116e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79c991d045e4955deddf58b93007820"><td class="memItemLeft" align="right" valign="top"><a id="aa79c991d045e4955deddf58b93007820"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aa79c991d045e4955deddf58b93007820">m_cachePhi</a></td></tr>
<tr class="memdesc:aa79c991d045e4955deddf58b93007820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached state vector for regrid. <br /></td></tr>
<tr class="separator:aa79c991d045e4955deddf58b93007820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15216dfe727bdab4c9d527ad439eec4"><td class="memItemLeft" align="right" valign="top"><a id="ad15216dfe727bdab4c9d527ad439eec4"></a>
<a class="el" href="classEBAMRData.html">EBAMRCellData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ad15216dfe727bdab4c9d527ad439eec4">m_cacheSource</a></td></tr>
<tr class="memdesc:ad15216dfe727bdab4c9d527ad439eec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached source term for regrids. <br /></td></tr>
<tr class="separator:ad15216dfe727bdab4c9d527ad439eec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb689a4b309c028ae33c39feb261f88"><td class="memItemLeft" align="right" valign="top"><a id="acfb689a4b309c028ae33c39feb261f88"></a>
<a class="el" href="classEBAMRData.html">EBAMRFluxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#acfb689a4b309c028ae33c39feb261f88">m_faceVelocity</a></td></tr>
<tr class="memdesc:acfb689a4b309c028ae33c39feb261f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Face-centered velocities (only normal components) <br /></td></tr>
<tr class="separator:acfb689a4b309c028ae33c39feb261f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8711ef32b9ee6a8c00c53d8d8b493b0"><td class="memItemLeft" align="right" valign="top"><a id="ac8711ef32b9ee6a8c00c53d8d8b493b0"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ac8711ef32b9ee6a8c00c53d8d8b493b0">m_ebVelocity</a></td></tr>
<tr class="memdesc:ac8711ef32b9ee6a8c00c53d8d8b493b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">EB-centered velocities. <br /></td></tr>
<tr class="separator:ac8711ef32b9ee6a8c00c53d8d8b493b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6744ac521a68e9ab068927fd4591f7"><td class="memItemLeft" align="right" valign="top"><a id="a8c6744ac521a68e9ab068927fd4591f7"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a8c6744ac521a68e9ab068927fd4591f7">m_ebFlux</a></td></tr>
<tr class="memdesc:a8c6744ac521a68e9ab068927fd4591f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flux through the embedded boundary. <br /></td></tr>
<tr class="separator:a8c6744ac521a68e9ab068927fd4591f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fb9302465592fc1a65491a5b9d6ae9"><td class="memItemLeft" align="right" valign="top"><a id="ad2fb9302465592fc1a65491a5b9d6ae9"></a>
<a class="el" href="classEBAMRData.html">EBAMRIFData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ad2fb9302465592fc1a65491a5b9d6ae9">m_domainFlux</a></td></tr>
<tr class="memdesc:ad2fb9302465592fc1a65491a5b9d6ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain flux. <br /></td></tr>
<tr class="separator:ad2fb9302465592fc1a65491a5b9d6ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ba2dee22bc598e880686e353faeb5"><td class="memItemLeft" align="right" valign="top"><a id="a297ba2dee22bc598e880686e353faeb5"></a>
<a class="el" href="classEBAMRData.html">EBAMRFluxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a297ba2dee22bc598e880686e353faeb5">m_faceCenteredDiffusionCoefficient</a></td></tr>
<tr class="memdesc:a297ba2dee22bc598e880686e353faeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diffusion coefficients on face centers. <br /></td></tr>
<tr class="separator:a297ba2dee22bc598e880686e353faeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671be5eecf5ae4e148104905d1a2d984"><td class="memItemLeft" align="right" valign="top"><a id="a671be5eecf5ae4e148104905d1a2d984"></a>
<a class="el" href="classEBAMRData.html">EBAMRIVData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a671be5eecf5ae4e148104905d1a2d984">m_ebCenteredDiffusionCoefficient</a></td></tr>
<tr class="memdesc:a671be5eecf5ae4e148104905d1a2d984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diffusion coefficients on EB faces. <br /></td></tr>
<tr class="separator:a671be5eecf5ae4e148104905d1a2d984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7179cbf866842d59f826f8bb30469a45"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classCdrDomainBC.html#ab012a2d05bf927e27dd38aafaf2dba2d">CdrDomainBC::DomainSide</a>, <a class="el" href="classCdrDomainBC.html#a6ffe2fab3e0f415bf30fb5d68efdcb51">CdrDomainBC::FluxFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a7179cbf866842d59f826f8bb30469a45">m_domainFluxFunctions</a></td></tr>
<tr class="memdesc:a7179cbf866842d59f826f8bb30469a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain flux functions.  <a href="classCdrSolver.html#a7179cbf866842d59f826f8bb30469a45">More...</a><br /></td></tr>
<tr class="separator:a7179cbf866842d59f826f8bb30469a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d684e01266543c7ca2cdae12f39a54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ae0d684e01266543c7ca2cdae12f39a54">m_verbosity</a></td></tr>
<tr class="memdesc:ae0d684e01266543c7ca2cdae12f39a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver verbosity.  <a href="classCdrSolver.html#ae0d684e01266543c7ca2cdae12f39a54">More...</a><br /></td></tr>
<tr class="separator:ae0d684e01266543c7ca2cdae12f39a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbedb41bd30ae9677878427dd5dab73"><td class="memItemLeft" align="right" valign="top"><a id="a1fbedb41bd30ae9677878427dd5dab73"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a1fbedb41bd30ae9677878427dd5dab73">m_timeStep</a></td></tr>
<tr class="memdesc:a1fbedb41bd30ae9677878427dd5dab73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step. <br /></td></tr>
<tr class="separator:a1fbedb41bd30ae9677878427dd5dab73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2a15ca745927d0598ba5b4b16e1253"><td class="memItemLeft" align="right" valign="top"><a id="abb2a15ca745927d0598ba5b4b16e1253"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#abb2a15ca745927d0598ba5b4b16e1253">m_time</a></td></tr>
<tr class="memdesc:abb2a15ca745927d0598ba5b4b16e1253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current time. <br /></td></tr>
<tr class="separator:abb2a15ca745927d0598ba5b4b16e1253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d48c7cbd19af4ec0679b47f6a060f82"><td class="memItemLeft" align="right" valign="top"><a id="a3d48c7cbd19af4ec0679b47f6a060f82"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a3d48c7cbd19af4ec0679b47f6a060f82">m_dt</a></td></tr>
<tr class="memdesc:a3d48c7cbd19af4ec0679b47f6a060f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last time step increment. <br /></td></tr>
<tr class="separator:a3d48c7cbd19af4ec0679b47f6a060f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40471234e07910bdfac8219adea0df77"><td class="memItemLeft" align="right" valign="top"><a id="a40471234e07910bdfac8219adea0df77"></a>
<a class="el" href="classCdrSolver.html#a6c2cfa627dd07e57cb07c4ae896e3090">Redistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a40471234e07910bdfac8219adea0df77">m_whichRedistribution</a></td></tr>
<tr class="memdesc:a40471234e07910bdfac8219adea0df77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which type of redistribution to use. <br /></td></tr>
<tr class="separator:a40471234e07910bdfac8219adea0df77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac206836a046939423b2eb975a6844c26"><td class="memItemLeft" align="right" valign="top"><a id="ac206836a046939423b2eb975a6844c26"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ac206836a046939423b2eb975a6844c26">m_blendConservation</a></td></tr>
<tr class="memdesc:ac206836a046939423b2eb975a6844c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for blending the hybrid divergence. <br /></td></tr>
<tr class="separator:ac206836a046939423b2eb975a6844c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0678465818f5feb936184cd33981015a"><td class="memItemLeft" align="right" valign="top"><a id="a0678465818f5feb936184cd33981015a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a0678465818f5feb936184cd33981015a">m_isDiffusive</a></td></tr>
<tr class="memdesc:a0678465818f5feb936184cd33981015a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the solver diffusive or not. <br /></td></tr>
<tr class="separator:a0678465818f5feb936184cd33981015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4240b7f613bf6be2604a1921f04f2e7"><td class="memItemLeft" align="right" valign="top"><a id="ac4240b7f613bf6be2604a1921f04f2e7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#ac4240b7f613bf6be2604a1921f04f2e7">m_isMobile</a></td></tr>
<tr class="memdesc:ac4240b7f613bf6be2604a1921f04f2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve for advection/convection or not. <br /></td></tr>
<tr class="separator:ac4240b7f613bf6be2604a1921f04f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c596dc46f123ea6890bc9138c617256"><td class="memItemLeft" align="right" valign="top"><a id="a0c596dc46f123ea6890bc9138c617256"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a0c596dc46f123ea6890bc9138c617256">m_plotPhi</a></td></tr>
<tr class="memdesc:a0c596dc46f123ea6890bc9138c617256"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, m_phi is added to plot files. <br /></td></tr>
<tr class="separator:a0c596dc46f123ea6890bc9138c617256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cd24c5ac6efdbd0528531614115c4f"><td class="memItemLeft" align="right" valign="top"><a id="a40cd24c5ac6efdbd0528531614115c4f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a40cd24c5ac6efdbd0528531614115c4f">m_plotVelocity</a></td></tr>
<tr class="memdesc:a40cd24c5ac6efdbd0528531614115c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output velocities. <br /></td></tr>
<tr class="separator:a40cd24c5ac6efdbd0528531614115c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f00c2d486c274db5831b7314e399298"><td class="memItemLeft" align="right" valign="top"><a id="a2f00c2d486c274db5831b7314e399298"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a2f00c2d486c274db5831b7314e399298">m_plotDiffusionCoefficient</a></td></tr>
<tr class="memdesc:a2f00c2d486c274db5831b7314e399298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output diffusion coefficients. <br /></td></tr>
<tr class="separator:a2f00c2d486c274db5831b7314e399298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688c29d9656ea0bad13ea7fc78ffb532"><td class="memItemLeft" align="right" valign="top"><a id="a688c29d9656ea0bad13ea7fc78ffb532"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a688c29d9656ea0bad13ea7fc78ffb532">m_plotEbFlux</a></td></tr>
<tr class="memdesc:a688c29d9656ea0bad13ea7fc78ffb532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output EB fluxes. <br /></td></tr>
<tr class="separator:a688c29d9656ea0bad13ea7fc78ffb532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e6fb6669efada67c621d803b9712a3"><td class="memItemLeft" align="right" valign="top"><a id="af1e6fb6669efada67c621d803b9712a3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#af1e6fb6669efada67c621d803b9712a3">m_plotSource</a></td></tr>
<tr class="memdesc:af1e6fb6669efada67c621d803b9712a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output source term. <br /></td></tr>
<tr class="separator:af1e6fb6669efada67c621d803b9712a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf7f04fc081be3d451f1e23b515ac73"><td class="memItemLeft" align="right" valign="top"><a id="aacf7f04fc081be3d451f1e23b515ac73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#aacf7f04fc081be3d451f1e23b515ac73">m_plotNumbers</a></td></tr>
<tr class="memdesc:aacf7f04fc081be3d451f1e23b515ac73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot numbers or densities. <br /></td></tr>
<tr class="separator:aacf7f04fc081be3d451f1e23b515ac73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d63800edcde7eb0c4baff91296f2d0"><td class="memItemLeft" align="right" valign="top"><a id="a71d63800edcde7eb0c4baff91296f2d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a71d63800edcde7eb0c4baff91296f2d0">m_regridSlopes</a></td></tr>
<tr class="memdesc:a71d63800edcde7eb0c4baff91296f2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use slopes when regridding. <br /></td></tr>
<tr class="separator:a71d63800edcde7eb0c4baff91296f2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d996c12787910f172576275c98c01df"><td class="memItemLeft" align="right" valign="top"><a id="a9d996c12787910f172576275c98c01df"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a9d996c12787910f172576275c98c01df">m_seed</a></td></tr>
<tr class="memdesc:a9d996c12787910f172576275c98c01df"><td class="mdescLeft">&#160;</td><td class="mdescRight">RNG seed. <br /></td></tr>
<tr class="separator:a9d996c12787910f172576275c98c01df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:acd316da2cdb9014040df086372ac131e"><td class="memItemLeft" align="right" valign="top"><a id="acd316da2cdb9014040df086372ac131e"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#acd316da2cdb9014040df086372ac131e">m_comp</a> = 0</td></tr>
<tr class="memdesc:acd316da2cdb9014040df086372ac131e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component number in data holder. <br /></td></tr>
<tr class="separator:acd316da2cdb9014040df086372ac131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378f6d09b1084617586df3dd03c54444"><td class="memItemLeft" align="right" valign="top"><a id="a378f6d09b1084617586df3dd03c54444"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCdrSolver.html#a378f6d09b1084617586df3dd03c54444">m_nComp</a> = 1</td></tr>
<tr class="memdesc:a378f6d09b1084617586df3dd03c54444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of components that this solver solves for. <br /></td></tr>
<tr class="separator:a378f6d09b1084617586df3dd03c54444"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for solving convection-diffusion-reaction equations. </p>
<p>On embedded boundaries, users must always set the flux directly (but possibly via a function, if desired).</p>
<p>On domain edges/faces, the user can select between various ways of setting the domain boundary conditions (e.g. wall, data-based, function-based, outflow). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a288f9a76614a2ad006284a27953ab99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288f9a76614a2ad006284a27953ab99d">&#9670;&nbsp;</a></span>CdrSolver() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CdrSolver::CdrSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This sets the realm to primal and populates the domain flux functions (with zero-fluxes, i.e. wall BCs) </dd></dl>

</div>
</div>
<a id="a36bbc792582a47bad84d8e5b7e422b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bbc792582a47bad84d8e5b7e422b9c">&#9670;&nbsp;</a></span>CdrSolver() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CdrSolver::CdrSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22746309146ddd3db8e016806b4440a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22746309146ddd3db8e016806b4440a3">&#9670;&nbsp;</a></span>CdrSolver() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CdrSolver::CdrSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab65a12aa88855ec2ff2d1e930ff52059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65a12aa88855ec2ff2d1e930ff52059">&#9670;&nbsp;</a></span>advanceCrankNicholson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CdrSolver::advanceCrankNicholson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit diffusion Crank-Nicholson advance with source term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_newPhi</td><td>Solution at time t + dt </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldPhi</td><td>Solution at time t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classCdrMultigrid.html#aff120a11bcefdabecc667693aeb70cdd">CdrMultigrid</a>.</p>

</div>
</div>
<a id="acd2c38c8ee8a9edd58dd0e3e605ea190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2c38c8ee8a9edd58dd0e3e605ea190">&#9670;&nbsp;</a></span>advanceCrankNicholson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::advanceCrankNicholson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit diffusion Crank-Nicholson advance without source term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_newPhi</td><td>Solution at time t + dt </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldPhi</td><td>Solution at time t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This calls the other version with a zero source term. </dd></dl>

</div>
</div>
<a id="aa9595227430c85146057dcdbbe073f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9595227430c85146057dcdbbe073f82">&#9670;&nbsp;</a></span>advanceEuler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CdrSolver::advanceEuler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit diffusion Euler advance with source term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_newPhi</td><td>Solution at time t + dt </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldPhi</td><td>Solution at time t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For purely implicit Euler the source term should be centered at t+dt (otherwise it's an implicit-explicit method)</dd></dl>
<p>This solves the implicit diffusion equation equation a_newPhi - a_oldPhi = dt*Laplacian(a_newPhi) + dt*a_source. </p>

<p>Implemented in <a class="el" href="classCdrMultigrid.html#a09626f2c30134864d8ef00a273b5bcd7">CdrMultigrid</a>.</p>

</div>
</div>
<a id="a5f137bc464c9241b0ab868f0dcdd4c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f137bc464c9241b0ab868f0dcdd4c28">&#9670;&nbsp;</a></span>advanceEuler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::advanceEuler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_newPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oldPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit diffusion Euler advance without source term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_newPhi</td><td>Solution at time t + dt </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldPhi</td><td>Solution at time t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This calls the other version with a zero source term. </dd></dl>

</div>
</div>
<a id="accc070166e374bec593cb6da68cf36b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc070166e374bec593cb6da68cf36b0">&#9670;&nbsp;</a></span>advectToFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CdrSolver::advectToFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_facePhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_extrapDt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advection-only extrapolation to faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_facePhi</td><td>Phi on faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Phi on cell center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_extrapDt</td><td>Time centering/extrapolation (if the advective integrator can do it) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classCdrMultigrid.html#a80c584c1c8c83a3c662f61285a764f8e">CdrMultigrid</a>, <a class="el" href="classCdrGodunov.html#ae87cf3d3fd8fd683c5775bff147ab43e">CdrGodunov</a>, and <a class="el" href="classCdrCTU.html#aa4437b38dd5063ea6a81ca7fc94afc9f">CdrCTU</a>.</p>

</div>
</div>
<a id="a7026663cd47dbf767cb969a7c0601020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7026663cd47dbf767cb969a7c0601020">&#9670;&nbsp;</a></span>allocateInternals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::allocateInternals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate internal storage. </p>
<dl class="section note"><dt>Note</dt><dd>This allocates a bunch of storage &ndash; if the solver is not diffusive or mobile then we do our best to trim memory. </dd></dl>

<p>Reimplemented in <a class="el" href="classCdrMultigrid.html#ab73b4a0b28827832b032b7e4e032f56a">CdrMultigrid</a>, and <a class="el" href="classCdrGodunov.html#aa9aba1f157d2eea3268e07451f3e923b">CdrGodunov</a>.</p>

</div>
</div>
<a id="a8b1a72b74fb507ecc86b6977d259645b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1a72b74fb507ecc86b6977d259645b">&#9670;&nbsp;</a></span>averageVelocityToFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::averageVelocityToFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average velocities to faces. </p>
<dl class="section note"><dt>Note</dt><dd>This takes the cell-centered velocities in m_cellVelocity and averages them onto m_faceVelocity. Only the velocity component normal to the face is stored in m_faceVelocity. </dd></dl>

</div>
</div>
<a id="a2c2fc0117757f6198bfa24a8481a684b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2fc0117757f6198bfa24a8481a684b">&#9670;&nbsp;</a></span>averageVelocityToFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::averageVelocityToFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_faceVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellVelocity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average cell-centered velocities to face centers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_faceVelocity</td><td>Face-centered velocities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellVelocity</td><td>Cell-centered velocities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets the velocity component normal to the face to be the arithmetic average of the cell center velocities on the low/high side of the face. </dd>
<dd>
Virtual because some solvers might want to do this differently. </dd></dl>

</div>
</div>
<a id="a44d9fcff15b936cd81802873cbd5ddb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d9fcff15b936cd81802873cbd5ddb6">&#9670;&nbsp;</a></span>coarseFineIncrement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::coarseFineIncrement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>m_massDifference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the coarse-fine redist with mass difference (only for EB x CF) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_massDifference</td><td>Mass difference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This increments the so-called redistribution registers for ensuring that redistributed mass around the cut cells ends up in the right place. </dd></dl>

</div>
</div>
<a id="a4b718047e2c9bcc3810875dae9cf12f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b718047e2c9bcc3810875dae9cf12f5">&#9670;&nbsp;</a></span>coarseFineRedistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::coarseFineRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do coarse-fine redistribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>On output, this will be incremented with redistributed mass across refinement boundaries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This redistributes mass around the CF region, using the coarse-fine redistribution registers </dd></dl>

</div>
</div>
<a id="a5eafbcb34050fd514c2839406299dc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eafbcb34050fd514c2839406299dc38">&#9670;&nbsp;</a></span>computeAdvectionDiffusionDt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real CdrSolver::computeAdvectionDiffusionDt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the largest possible diffusive time step (for explicit methods) </p>
<p>This computes dt = 1/[ dx/(|vx|+|vy|+|vz|) + (dx*dx)/(2*D*d) ] and minimizes the result over all grid levels and patches. </p><dl class="section note"><dt>Note</dt><dd>This is the appropriate time step routine for explicit advection-diffusion solvers. </dd></dl>

</div>
</div>
<a id="a080f394c63a7bcb66ca7a35e2cfeba24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080f394c63a7bcb66ca7a35e2cfeba24">&#9670;&nbsp;</a></span>computeAdvectionDiffusionFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::computeAdvectionDiffusionFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_faceStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_faceVelocities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_faceDiffCo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_addDomainFlux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the full advection-diffusion flux. This assumes that the solver is mobile and diffusive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_flux</td><td>Face-centered flux. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellStates</td><td>Cell-centered states. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_faceVelocities</td><td>Face-centered velocities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_faceStates</td><td>Face-centered (advected) states. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_faceDiffCo</td><td>Face-centered diffusion coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_addDomainFlux</td><td>Add domain flux or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40a0d1be9cc5aee9f0573c4f3b75dd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a0d1be9cc5aee9f0573c4f3b75dd6c">&#9670;&nbsp;</a></span>computeAdvectionDt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real CdrSolver::computeAdvectionDt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the largest possible diffusive time step (for explicit methods) </p>
<p>This computes dt = dx/sum(|vx| + |vy| + |vz|), minimized over all grid levels and patches. <br  />
 </p><dl class="section note"><dt>Note</dt><dd>This is the appropriate time step routine for explicit advection solvers. </dd></dl>

<p>Reimplemented in <a class="el" href="classCdrGodunov.html#ab5a641037882491c2996c0704943ed0d">CdrGodunov</a>, and <a class="el" href="classCdrCTU.html#a819e4dee2d5c7bf95d4c6d3b0ec29c95">CdrCTU</a>.</p>

</div>
</div>
<a id="aa2ebe315836c30c22c1c02b9bfb40ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ebe315836c30c22c1c02b9bfb40ce8">&#9670;&nbsp;</a></span>computeAdvectionFlux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::computeAdvectionFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_facePhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_faceVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_addDomainFlux</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up face-centered advection flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_flux</td><td>Face-centered fluxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_facePhi</td><td>Face-centered state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_faceVelocity</td><td>Face-centered velocities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_addDomainFlux</td><td>Add the domain flux </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes flux = phi*vel on all face centers. If a_addDomainFlux is true, we enforce BC fluxes on the domain sides. Otherwise, the flux on the domain sides is set to zero. </dd></dl>

</div>
</div>
<a id="a55ee682d52e18749e0997c0eb6d043a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ee682d52e18749e0997c0eb6d043a5">&#9670;&nbsp;</a></span>computeAdvectionFlux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::computeAdvectionFlux </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_facePhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_faceVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up face-centered advection flux on a grid level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_flux</td><td>Face-centered fluxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_facePhi</td><td>Face-centered state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_faceVelocity</td><td>Face-centered velocities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainFlux</td><td>Domain flux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes flux = v*phi on all face centers. If a_addDomainFlux is true, we enforce BC fluxes on the domain sides. Otherwise, the flux on the domain sides is set to zero. </dd></dl>

</div>
</div>
<a id="a8829af72cf17208473dcef2eebb44b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8829af72cf17208473dcef2eebb44b55">&#9670;&nbsp;</a></span>computeCharge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real CdrSolver::computeCharge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the total charge in m_phi. </p>
<p>Calls computeMass and multiplies by charge </p>

</div>
</div>
<a id="aa05221de7e5cb6648fb19958ba02c7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05221de7e5cb6648fb19958ba02c7f0">&#9670;&nbsp;</a></span>computeDiffusionDt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real CdrSolver::computeDiffusionDt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the largest possible diffusive time step (for explicit methods) </p>
<p>This computes dt = (dx*dx)/(2*D*d) where D is the diffusion coefficient. The result is minimized over all grid levels and patches. </p><dl class="section note"><dt>Note</dt><dd>This is the appropriate time step routine for explicit diffusion solvers. </dd></dl>

</div>
</div>
<a id="ae8cdc7712e4382189c9750b3241df02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cdc7712e4382189c9750b3241df02a">&#9670;&nbsp;</a></span>computeDiffusionFlux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::computeDiffusionFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_addDomainFlux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the face-centered diffusion flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_flux</td><td>Face-centered flux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell centered phi </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_addDomainFlux</td><td>Add domain flux or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes flux = D*grad(phi) on all face centers. If a_addDomainFlux is true, we enforce BC fluxes on the domain sides. Otherwise, the flux on the domain sides is set to zero. </dd></dl>

</div>
</div>
<a id="adfa0a24e66721f2c1e62ae8e5ebb0ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa0a24e66721f2c1e62ae8e5ebb0ca5">&#9670;&nbsp;</a></span>computeDiffusionFlux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::computeDiffusionFlux </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the face-centered diffusion flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_flux</td><td>Face-centered flux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell centered phi </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes flux = D*grad(phi) on all face centers. The flux is set to zero on domain edges/faces </dd></dl>

</div>
</div>
<a id="afa54cb2fb84bb7cb85836da38e334bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa54cb2fb84bb7cb85836da38e334bc8">&#9670;&nbsp;</a></span>computeDivD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CdrSolver::computeDivD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_divD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_conservativeOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_ebFlux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_domainFlux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute div(D*grad(phi)) explicitly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_divF</td><td>Divergence term, i.e. finite volume approximation to Div(D*Grad(phi)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainBc</td><td>Flag for setting domain boundary conditions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_conservativeOnly</td><td>If true, we compute div(D) = 1/dx*sum(fluxes), which does not involve redistribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_useEbFlux</td><td>If true, the embedded boundary flux will be injected and included in div(D) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainFlux</td><td>If true, the domain flux will injected and included in div(D) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_phi is non-const because ghost cells will be interpolated in this routine. Valid data in a_phi is not touched. </dd></dl>

<p>Implemented in <a class="el" href="classCdrMultigrid.html#a238d43f4b50efea9ab3438669d00fb51">CdrMultigrid</a>.</p>

</div>
</div>
<a id="af3f16898f7e11431a6dcb26d842a91a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f16898f7e11431a6dcb26d842a91a7">&#9670;&nbsp;</a></span>computeDivergenceIrregular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::computeDivergenceIrregular </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_divG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_centroidFluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebFlux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute conservative divergence on irregular cells (not kappa divided) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_divG</td><td>Conservative divergence (not kappa divided) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_centroidFlux</td><td>Face centroid centered fluxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebFlux</td><td>EB flux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overwrites the result of divG in cut-cells, using the eb flux and face centroid fluxes to compute kappa*div(G) = sum(fluxes)/dx </dd></dl>

</div>
</div>
<a id="a06082d89e6896cafdfa12e4ac5b20c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06082d89e6896cafdfa12e4ac5b20c38">&#9670;&nbsp;</a></span>computeDivF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CdrSolver::computeDivF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_divF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_extrapDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_conservativeOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_ebFlux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_domainFlux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute div(v*phi) explicitly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_divF</td><td>Divergence term, i.e. finite volume approximation to Div(v*phi), including redistribution magic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_extrapDt</td><td>Extrapolation in time, i.e. shifting of div(F) towards e.g. half time step. Only affects the advective term. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_conservativeOnly</td><td>If true, we compute div(F)=1/dx*sum(fluxes), which does not involve redistribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainBc</td><td>How to set domain fluxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebFlux</td><td>If true, the embedded boundary flux will injected be included in div(F) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainFlux</td><td>If true, the domain flux will injected and included in div(F) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_phi is non-const because ghost cells will be interpolated in this routine. Valid data in a_phi is not touched. </dd></dl>

<p>Implemented in <a class="el" href="classCdrMultigrid.html#ad192526154dfb1380b94fee1c032f828">CdrMultigrid</a>.</p>

</div>
</div>
<a id="a631e0828ef3b9205ed08852fe867a1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631e0828ef3b9205ed08852fe867a1e9">&#9670;&nbsp;</a></span>computeDivG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::computeDivG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_divG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_ebFlux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_conservativeOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute div(G) where G is a general face-centered flux on face centers and EB centers. This can involve mass redistribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_divG</td><td>div(G) or kappa*div(G). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_G</td><td>Vector field which contains face-centered fluxes on input. Contains face-centroid fluxes on output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebFlux</td><td>Flux on the EB centroids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_conservativeOnly</td><td>If true, we compute div(G)=1/dx*sum(fluxes), which does not involve redistribution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5217d3b30e180a77515c9b18ac2bae96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5217d3b30e180a77515c9b18ac2bae96">&#9670;&nbsp;</a></span>computeDivJ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CdrSolver::computeDivJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_divJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_extrapDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_conservativeOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_ebFlux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_domainFlux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute div(J) explicitly, where J = nV - D*grad(n) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_divJ</td><td>Divergence term, i.e. finite volume approximation to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_extrapDt</td><td>Extrapolation in time, i.e. shifting of div(J) towards e.g. half time step. Only affects the advective term. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_conservativeOnly</td><td>If true, we compute div(J) = 1/dx*sum(fluxes), which does not involve redistribution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebFlux</td><td>If true, the embedded boundary flux will injected and included in div(J) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainFlux</td><td>If true, the domain flux will injected and included in div(J) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_phi is non-const because ghost cells will be re-filled </dd></dl>

<p>Implemented in <a class="el" href="classCdrMultigrid.html#ad87773680e2ab4d91afb8ef735a143eb">CdrMultigrid</a>.</p>

</div>
</div>
<a id="ab130ea207184190aeb72bcb7e4f60810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab130ea207184190aeb72bcb7e4f60810">&#9670;&nbsp;</a></span>computeMass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real CdrSolver::computeMass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the "physical mass" in m_phi. </p>
<p>This conservatively coarsens the solution and computes on the coarsest level only </p>

</div>
</div>
<a id="ac7f01b3499d164a753030edb07a506e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f01b3499d164a753030edb07a506e8">&#9670;&nbsp;</a></span>computeMass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real CdrSolver::computeMass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the "physical mass" in the input argument. </p>
<p>This conservatively coarsens the solution and computes on the coarsest level only </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phi</td><td>Cell-centered data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add7bc8d5ac3c1e8fd65956313d6def8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7bc8d5ac3c1e8fd65956313d6def8b">&#9670;&nbsp;</a></span>computeSourceDt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real CdrSolver::computeSourceDt </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the largest possible source time step (for explicit methods. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_max</td><td>Maximum value of m_phi </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tolerance</td><td>Tolerance</td></tr>
  </table>
  </dd>
</dl>
<p>This computes dt = phi/source, but only for cells where phi lies within a_tolerance*a_max (and source &gt; 0) </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>An old routine which we could (probably) remove. </dd></dl>

</div>
</div>
<a id="a7bb06d2d9cb8acb7cc9456820b18c3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb06d2d9cb8acb7cc9456820b18c3ce">&#9670;&nbsp;</a></span>conservativeDivergenceNoKappaDivision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::conservativeDivergenceNoKappaDivision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_conservativeDivergence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_ebFlux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute conservative divergence from fluxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_conservativeDivergence</td><td>Conservative divergence computed as div(F) using finite volumes. Not divided by kappa. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_flux</td><td>Face-centered fluxes. Includes domain fluxes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebFlux</td><td>EB flux. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes the conservative divergence kappa*div(F) = sum(fluxes). </dd></dl>

</div>
</div>
<a id="ae720d11ad0145b4c92bddb2c4a7f9786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae720d11ad0145b4c92bddb2c4a7f9786">&#9670;&nbsp;</a></span>conservativeDivergenceRegular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::conservativeDivergenceRegular </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_divJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the conservative divergence over regular cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_divJ</td><td>Conservative divergence. Not kappa-divided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_flux</td><td>Face-centered fluxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This computes the finite volume approximation to div(J) in regular cells &ndash; cut-cells (in a_divJ are set to zero) </dd></dl>

</div>
</div>
<a id="a12b063a50d44a687080682587ff2597c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b063a50d44a687080682587ff2597c">&#9670;&nbsp;</a></span>deallocateInternals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::deallocateInternals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate internal storage. </p>
<dl class="section note"><dt>Note</dt><dd>This deallocates a bunch of storage which is not needed (during regrids). It can be used to trim memory during Berger-Rigoutsous regrids (which EAT memory). </dd></dl>

</div>
</div>
<a id="ab965dcd94518ca2b80b4348d2a67a63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab965dcd94518ca2b80b4348d2a67a63c">&#9670;&nbsp;</a></span>defineInterpolationStencils()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::defineInterpolationStencils </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define stencils for doing face-centered to face-centroid-centered states. </p>
<dl class="section note"><dt>Note</dt><dd>This computes standard finite-difference stencils for interpolating from face centers to face centroids. </dd></dl>

</div>
</div>
<a id="a8022eea83998f3d752797efd45d372ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8022eea83998f3d752797efd45d372ba">&#9670;&nbsp;</a></span>extrapolateAdvectiveFluxToEB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::extrapolateAdvectiveFluxToEB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_ebFlux</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolate advective flux to EB. </p>
<p>This does not use any slope limiting (derived classes might want to redo this routine). The returned flux is equal to -n.(phi * v) where n is the normal vector. This is constructed so that a positive eb flux yields an influx when doing an purely advective advance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_ebFlux</td><td>Projected flux on the EB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac82d2f5099de3dd8837d2a0291704aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac82d2f5099de3dd8837d2a0291704aa">&#9670;&nbsp;</a></span>fillDomainFlux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::fillDomainFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set domain in data holder. This sets the flux on the boundary to either zero or to m_domainFlux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_flux</td><td>Flux to be modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7c90f17f553d8bb2e67540deb7258af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c90f17f553d8bb2e67540deb7258af">&#9670;&nbsp;</a></span>fillDomainFlux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::fillDomainFlux </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set domain in data holder. This sets the flux on the boundary to either zero or to m_domainFlux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_flux</td><td>Flux to be modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a444e0136504fa6746458741c9dcf5f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444e0136504fa6746458741c9dcf5f4f">&#9670;&nbsp;</a></span>fillGwn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::fillGwn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_noise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gaussian noise field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_noise</td><td>Gaussian white nosie </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada68d63038371ea21f526696459c51f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada68d63038371ea21f526696459c51f6">&#9670;&nbsp;</a></span>getCellCenteredVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; CdrSolver::getCellCenteredVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cell-centered velocity. </p>
<dl class="section return"><dt>Returns</dt><dd>m_cellVelocity </dd></dl>

</div>
</div>
<a id="a6520f8f8ef319640e1bc32c7c61a5181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6520f8f8ef319640e1bc32c7c61a5181">&#9670;&nbsp;</a></span>getDomainFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp; CdrSolver::getDomainFlux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the domain flux data holder. </p>
<dl class="section return"><dt>Returns</dt><dd>m_domainFlux </dd></dl>

</div>
</div>
<a id="a11331fb94290db965fdb62b51a51271d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11331fb94290db965fdb62b51a51271d">&#9670;&nbsp;</a></span>getEbCenteredDiffusionCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp; CdrSolver::getEbCenteredDiffusionCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the EB-centered diffusion coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>m_ebCentereDiffusionCoefficient </dd></dl>

</div>
</div>
<a id="a1a080b3433328e7b74b9207d324f77cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a080b3433328e7b74b9207d324f77cd">&#9670;&nbsp;</a></span>getEbCenteredVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp; CdrSolver::getEbCenteredVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the eb-centered velocities. </p>
<dl class="section return"><dt>Returns</dt><dd>m_ebVelocity </dd></dl>

</div>
</div>
<a id="adaa4e4ee7c1a01f99d4976fac4ada866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa4e4ee7c1a01f99d4976fac4ada866">&#9670;&nbsp;</a></span>getEbFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp; CdrSolver::getEbFlux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the eb flux data holder. </p>
<dl class="section return"><dt>Returns</dt><dd>m_ebFlux </dd></dl>

</div>
</div>
<a id="a41f174f15a7402f961c5f370e739f092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f174f15a7402f961c5f370e739f092">&#9670;&nbsp;</a></span>getFaceCenteredDiffusionCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp; CdrSolver::getFaceCenteredDiffusionCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the face-centered diffusion coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>m_faceCentereDiffusionCoefficient </dd></dl>

</div>
</div>
<a id="a2ec9fa671f4dd6b75855fe15f0c7b063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec9fa671f4dd6b75855fe15f0c7b063">&#9670;&nbsp;</a></span>getFaceCenteredVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp; CdrSolver::getFaceCenteredVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the face-centered velocities. </p>
<dl class="section return"><dt>Returns</dt><dd>m_faceVelocity </dd></dl>

</div>
</div>
<a id="a78889fbd012fbc6fa4bd7897fbd369b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78889fbd012fbc6fa4bd7897fbd369b4">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CdrSolver::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get solver name. </p>
<dl class="section note"><dt>Note</dt><dd>Not necessarily equal to class name (we can have many CdrSolvers instantiated). </dd></dl>

</div>
</div>
<a id="a2baa3e47cd960d3a4bc74e4aa9fb1b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2baa3e47cd960d3a4bc74e4aa9fb1b8b">&#9670;&nbsp;</a></span>getNumberOfPlotVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CdrSolver::getNumberOfPlotVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of output fields. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns number of plot variables include in <a class="el" href="classCdrSolver.html#ae5ff5275be09e06043378eae81f89267" title="Write plot file.">writePlotFile()</a> and <a class="el" href="classCdrSolver.html#afae1ef6f463bded79a599bbe60505fb6" title="Write output data to a_output.">writePlotData()</a> </dd></dl>

</div>
</div>
<a id="a56e1673fb1c0cd109286735d2a6035e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e1673fb1c0cd109286735d2a6035e1">&#9670;&nbsp;</a></span>getPhi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; CdrSolver::getPhi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cell-centered phi. </p>
<dl class="section return"><dt>Returns</dt><dd>m_phi </dd></dl>

</div>
</div>
<a id="aef5406deb947700c436d9de4a89fc40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5406deb947700c436d9de4a89fc40f">&#9670;&nbsp;</a></span>getPlotVariableNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; std::string &gt; CdrSolver::getPlotVariableNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get output plot names. </p>
<dl class="section return"><dt>Returns</dt><dd>Return a list of plot variable names. </dd></dl>

</div>
</div>
<a id="a9c5259c827a4fb56c2e57d3db3f13d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5259c827a4fb56c2e57d3db3f13d9f">&#9670;&nbsp;</a></span>getRealm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CdrSolver::getRealm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the realm where this solver is registered. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns realm name. </dd></dl>

</div>
</div>
<a id="a21db0f823153223f5b3a198f07a3b637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21db0f823153223f5b3a198f07a3b637">&#9670;&nbsp;</a></span>getSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp; CdrSolver::getSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the source term. </p>
<dl class="section return"><dt>Returns</dt><dd>m_source </dd></dl>

</div>
</div>
<a id="a01f1bf755d1ea4024c9ef25afd0f74af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f1bf755d1ea4024c9ef25afd0f74af">&#9670;&nbsp;</a></span>gwnDiffusionSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::gwnDiffusionSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_noiseSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellPhi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a random gaussian white noise source term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_noiseSource</td><td>Source term </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellPhi</td><td>Cell-centered states </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Used e.g. for fluctuating hydrodynamics. </dd></dl>

</div>
</div>
<a id="a3fa32de02a211aabf541a09bf4e59d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa32de02a211aabf541a09bf4e59d51">&#9670;&nbsp;</a></span>hybridDivergence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::hybridDivergence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_hybridDivergence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_massDifference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_nonConservativeDivergence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the non-conservative divergence to make the conservative divergence hold the hybrid divergence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_hybridDivergence</td><td>On input, contains the conservative divergence (without kappa division). Contains hybrid divergence on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_massDifference</td><td>Mass difference between updating with hybrid divergence and true divergence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nonConservativeDivergence</td><td>Non-conservative divergence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adde0af282267f61856a6213115ed8432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde0af282267f61856a6213115ed8432">&#9670;&nbsp;</a></span>hybridDivergence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::hybridDivergence </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_hybridDivergence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_massDifference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_nonConservativeDivergence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the hybrid divergence. On the way in, a_hybridDivergence must hold the conservative divergence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_hybridDivergence</td><td>On input, contains the conservative divergence (without kappa division). Contains hybrid divergence on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_massDifference</td><td>Mass difference between updating with hybrid divergence and true divergence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_nonConservativeDivergence</td><td>Non-conservative divergence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a553fa6ca44573f91cc0522b971c0084f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553fa6ca44573f91cc0522b971c0084f">&#9670;&nbsp;</a></span>hyperbolicRedistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::hyperbolicRedistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_stableDivergence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do mass redistribution on each level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_stableDivergence</td><td>Hybrid divergence on input, stable and conservative divergence on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only redistributes on the level &ndash; it does not account for distribution across refinement boundaries (need the other routines for that). </dd></dl>

</div>
</div>
<a id="aa1c00568baee2b2cf76d4fba24af9423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c00568baee2b2cf76d4fba24af9423">&#9670;&nbsp;</a></span>incrementFluxRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::incrementFluxRegister </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment flux registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_flux</td><td>Face centered fluxes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9435b5365d81a1fdcbc2b37a2822149a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9435b5365d81a1fdcbc2b37a2822149a">&#9670;&nbsp;</a></span>incrementRedist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::incrementRedist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_massDifference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment redistribution objects with mass to be redistributed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_massDifference</td><td>Mass to be redistributed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only increments the level-register &ndash; must call coarseFineIncrement to do the other registers. </dd></dl>

</div>
</div>
<a id="a22c3c2ed50dd5146070c9d73157f6b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c3c2ed50dd5146070c9d73157f6b44">&#9670;&nbsp;</a></span>incrementRedistFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::incrementRedistFlux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment redistribution flux registers. </p>
<dl class="section note"><dt>Note</dt><dd>This just tells the flux registers about whats going on near EB refinement boundaries. </dd></dl>

</div>
</div>
<a id="a6eaf110ad3bb144212cfd15564dc43dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaf110ad3bb144212cfd15564dc43dd">&#9670;&nbsp;</a></span>initialData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::initialData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill m_phi state with initial data from m_species. </p>
<dl class="section note"><dt>Note</dt><dd>This will call <a class="el" href="classCdrSolver.html#ae7b4284381910cdd77ec863410db4670" title="Fill initial data from particles.">initialDataParticles()</a> and initialDataFunction(). </dd></dl>

</div>
</div>
<a id="a5b253df11825b4901b35bd6415262cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b253df11825b4901b35bd6415262cb5">&#9670;&nbsp;</a></span>initialDataDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::initialDataDistribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill initial data from a distribution function. </p>
<dl class="section note"><dt>Note</dt><dd>This increments m_phi on the mesh with data from m_species-&gt;<a class="el" href="classCdrSolver.html#a6eaf110ad3bb144212cfd15564dc43dd" title="Fill m_phi state with initial data from m_species.">initialData()</a>. </dd></dl>

</div>
</div>
<a id="ae7b4284381910cdd77ec863410db4670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b4284381910cdd77ec863410db4670">&#9670;&nbsp;</a></span>initialDataParticles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::initialDataParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill initial data from particles. </p>
<dl class="section note"><dt>Note</dt><dd>This will set m_phi to zero before depositing the particles (which are deposited with an NGP scheme, ignoring modifactions near cut-cells) </dd></dl>

</div>
</div>
<a id="ac4752844cda9533c1a03a9c7119fc5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4752844cda9533c1a03a9c7119fc5fa">&#9670;&nbsp;</a></span>interpolateFluxToFaceCentroids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::interpolateFluxToFaceCentroids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate flux to centroids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_flux</td><td>On input, contains centered fluxes. Output contains centroid fluxes</td></tr>
  </table>
  </dd>
</dl>
<p>This interpolates face fluxes to centroids. </p>

</div>
</div>
<a id="a8001b143616c6e3d73c78b4dd730cc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8001b143616c6e3d73c78b4dd730cc70">&#9670;&nbsp;</a></span>interpolateFluxToFaceCentroids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::interpolateFluxToFaceCentroids </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate flux to centroids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_flux</td><td>On input, contains centered fluxes. Output contains centroid fluxes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lvl</td><td>Grid level</td></tr>
  </table>
  </dd>
</dl>
<p>This interpolates face fluxes to centroids. </p>

</div>
</div>
<a id="af89cf561173855d612997e5fca4a607b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89cf561173855d612997e5fca4a607b">&#9670;&nbsp;</a></span>makeBcString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CdrSolver::makeBcString </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Side::LoHiSide&#160;</td>
          <td class="paramname"><em>a_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut for making a boundary condition string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dir</td><td>Direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_side</td><td>Coordinate side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns string of type m_className.bc.direction.side. </dd></dl>

</div>
</div>
<a id="a08cd6079923bd82e433df7961288d129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cd6079923bd82e433df7961288d129">&#9670;&nbsp;</a></span>nonConservativeDivergence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::nonConservativeDivergence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_nonConservativeDivergence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_divG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the non-conservative divergence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_nonConservativeDivergence</td><td>Non-conservative divergence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_divG</td><td>Conservative divergence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will compute the non-conservative divergence as divNC(G) = sum(kappa*div(G))/sum(kappa) in the cut-cell neighborhood. </dd></dl>

</div>
</div>
<a id="a5db986e6867f2f5759489f364d4ddc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db986e6867f2f5759489f364d4ddc52">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCdrSolver.html">CdrSolver</a>&amp; CdrSolver::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed move assignement operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52496339500d91032a33eed5aba5bc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52496339500d91032a33eed5aba5bc6c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCdrSolver.html">CdrSolver</a>&amp; CdrSolver::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCdrSolver.html">CdrSolver</a> &amp;&#160;</td>
          <td class="paramname"><em>a_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallowed assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_other</td><td>Other solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab55aa8718586ff2316626acc3698e49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55aa8718586ff2316626acc3698e49a">&#9670;&nbsp;</a></span>preRegrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::preRegrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pre-regrid operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lbase</td><td>Coarsest level that changed during regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest grid level before the regrid operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This stores m_phi and m_source. </dd></dl>

</div>
</div>
<a id="abfde982543d29db88613accff9d567b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfde982543d29db88613accff9d567b5">&#9670;&nbsp;</a></span>reflux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::reflux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_phi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflux across refinement boundaries, using whatever is inside the flux registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_phi</td><td>Cell-centered state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a441dc4214ab75b3c56190e0572ec95e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441dc4214ab75b3c56190e0572ec95e3">&#9670;&nbsp;</a></span>registerOperators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::registerOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register operators for AMR operations. </p>
<dl class="section note"><dt>Note</dt><dd>This includes operators for redistribution, flux registers, regridding, ghost cell interpolation, and conservative coarsening. </dd></dl>

<p>Reimplemented in <a class="el" href="classCdrMultigrid.html#a0034a5ef2613e6f829834db1376f2685">CdrMultigrid</a>.</p>

</div>
</div>
<a id="ace7446a0ff354cbd7b4ce57066b97e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7446a0ff354cbd7b4ce57066b97e20">&#9670;&nbsp;</a></span>regrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::regrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_oldFinestLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_newFinestLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write checkpoint data into HDF5 file. @paramo[out] a_handle HDF5 file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_level</td><td>Grid level</td></tr>
  </table>
  </dd>
</dl>
<p>Read checkpoint data from HDF5 file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_handle</td><td>HDF5 handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">const</td><td>int a_level Grid level</td></tr>
  </table>
  </dd>
</dl>
<p>Regrid this solver. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lmin</td><td>Coarsest level where grids did not change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_oldFinestLevel</td><td>Finest AMR level before the regrid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_newFinestLevel</td><td>Finest AMR level after the regrid.</td></tr>
  </table>
  </dd>
</dl>
<p>This linearly interpolates (with limiters) m_state to the new grids. Velocities are left undefined. </p>

</div>
</div>
<a id="a608cefd6b0a47c9ffc909d5d0297625d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608cefd6b0a47c9ffc909d5d0297625d">&#9670;&nbsp;</a></span>resetDomainFlux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::resetDomainFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_flux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set flux to zero on domain boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_flux</td><td>Flux data holder &ndash; on domain edges this is modified so the flux is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5a1f139fc38770c0196a29742ed0b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a1f139fc38770c0196a29742ed0b4d">&#9670;&nbsp;</a></span>setAmr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setAmr </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classAmrMesh.html">AmrMesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_amr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the amr object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_amr</td><td><a class="el" href="classAmrMesh.html" title="Class for handling spatial operations.">AmrMesh</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cb9fa3c62f24d774ff8589f50dc6960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb9fa3c62f24d774ff8589f50dc6960">&#9670;&nbsp;</a></span>setComputationalGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setComputationalGeometry </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classComputationalGeometry.html">ComputationalGeometry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_computationalGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set computational geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_computationalGeometry</td><td>The computational geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a848918913d3b8a132cb40ac28f402438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848918913d3b8a132cb40ac28f402438">&#9670;&nbsp;</a></span>setDefaultDomainBC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setDefaultDomainBC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sets default boundary conditions (wall type). </p>
<p>Called in constructor for setting domain BCs. </p><dl class="section note"><dt>Note</dt><dd>This sets the domain boundary condition to be a wall BC (no incoming/outgoing mass). This is the default behavior &ndash; if the user wants different BCs he can call setDomainBcType and setDomainBcFunction. </dd></dl>

</div>
</div>
<a id="ad0fbe47831f8b364e8a2fe5e2e19c1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fbe47831f8b364e8a2fe5e2e19c1fa">&#9670;&nbsp;</a></span>setDiffusionCoefficient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setDiffusionCoefficient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_diffusionCoefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_ebDiffusionCoefficient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data-based version of setting diffusion coefficients (which are stored on faces) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_diffusionCoefficient</td><td>Face-centered diffusion coefficient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebDiffusionCoefficient</td><td>EB-centered diffusion coefficient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Realms do not have to be the same. </dd></dl>

</div>
</div>
<a id="aa31af1a9cb5b8e6e14c40bb6c2be90e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31af1a9cb5b8e6e14c40bb6c2be90e5">&#9670;&nbsp;</a></span>setDiffusionCoefficient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setDiffusionCoefficient </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_diffusionCoefficient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set diffusion coefficient to be constant everywhere (they are stored on faces) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_diffusionCoefficient</td><td>Global diffusion coefficient.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the diffusion coefficient to be constant on both faces and EB faces. </p>

</div>
</div>
<a id="a956e0613a189894f5740568cdcbe1575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956e0613a189894f5740568cdcbe1575">&#9670;&nbsp;</a></span>setDiffusionCoefficient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setDiffusionCoefficient </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Real(const RealVect a_position)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_diffusionCoefficient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic way of setting diffusion coefficients every. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_diffusionCoefficient</td><td>Diffusion coefficient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will evaluate the function in all grid cells and set the diffusion coefficient </dd></dl>

</div>
</div>
<a id="acb377e98b5214b2e62480df6a689a6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb377e98b5214b2e62480df6a689a6ec">&#9670;&nbsp;</a></span>setDomainBcFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setDomainBcFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCdrDomainBC.html#ab012a2d05bf927e27dd38aafaf2dba2d">CdrDomainBC::DomainSide</a>&#160;</td>
          <td class="paramname"><em>a_domainSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCdrDomainBC.html#a6ffe2fab3e0f415bf30fb5d68efdcb51">CdrDomainBC::FluxFunction</a>&#160;</td>
          <td class="paramname"><em>a_fluxFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set domain bc function on particular domain side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainSide</td><td>Domain side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fluxFunction</td><td>Flux function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only associates a function with a domain side &ndash; to use it one must also call setDomainBcType(a_domainSide, BcType::Function) </dd></dl>

</div>
</div>
<a id="afd54815817a9ce6206cf022d5dd5f4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd54815817a9ce6206cf022d5dd5f4d4">&#9670;&nbsp;</a></span>setDomainBcType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setDomainBcType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCdrDomainBC.html#ab012a2d05bf927e27dd38aafaf2dba2d">CdrDomainBC::DomainSide</a>&#160;</td>
          <td class="paramname"><em>a_domainSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCdrDomainBC.html#ababc737a5bb0b61d6774938f4d37d06b">CdrDomainBC::BcType</a>&#160;</td>
          <td class="paramname"><em>a_bcType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set domain bc type on domain side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domainSide</td><td>Domain side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_bcType</td><td>Boundary condition type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a445d5c10758ab2765fb1618f836f3059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445d5c10758ab2765fb1618f836f3059">&#9670;&nbsp;</a></span>setEbFlux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setEbFlux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_ebFlux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data-based version of setting the EB flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebFlux</td><td>Flux on EB centroids. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_ebFlux does not have to be the same realm as in the solver. </dd></dl>

</div>
</div>
<a id="aab932f345a326a5c6bb97fbd338c1a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab932f345a326a5c6bb97fbd338c1a05">&#9670;&nbsp;</a></span>setEbFlux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setEbFlux </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_ebFlux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the eb flux to a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebFlux</td><td>Flux on EB centroids.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets a constant EB-flux on all EBs. </p>

</div>
</div>
<a id="a01f2ddd14ef7e7a38d9e3a7b2f9eb780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f2ddd14ef7e7a38d9e3a7b2f9eb780">&#9670;&nbsp;</a></span>setEbIndexSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setEbIndexSpace </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; EBIndexSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_ebis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set ebis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_ebis</td><td>EBIndexspace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cec5c237cc89b6bc520aa86e189c45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cec5c237cc89b6bc520aa86e189c45e">&#9670;&nbsp;</a></span>setPhase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setPhase </td>
          <td>(</td>
          <td class="paramtype">phase::which_phase&#160;</td>
          <td class="paramname"><em>a_phase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_phase</td><td>Phase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f44081662d2076d55dace1dc1a19491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f44081662d2076d55dace1dc1a19491">&#9670;&nbsp;</a></span>setRealm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setRealm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>a_realm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the realm for this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_realm</td><td><a class="el" href="classRealm.html" title="Class for holding multifluid Realms, which are the Realms that we actually use.">Realm</a> identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e0e2a4f74395f38bd403c98970979a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e0e2a4f74395f38bd403c98970979a">&#9670;&nbsp;</a></span>setRedistWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setRedistWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set redistribution weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_weights</td><td>Weights to use for redistribution (e.g., mass) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2fe1b9104d952d3f83798e23655b4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fe1b9104d952d3f83798e23655b4c9">&#9670;&nbsp;</a></span>setSource() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data based version of setting source terms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets m_source to be equal to a_source </p>

</div>
</div>
<a id="a3787c6ec6a4a01c25ea8dcd18be28fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3787c6ec6a4a01c25ea8dcd18be28fb9">&#9670;&nbsp;</a></span>setSource() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setSource </td>
          <td>(</td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set constant source terms everywhere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets m_source to a_source everywhere </dd></dl>

</div>
</div>
<a id="a78872d190b913655789ff725f77c1913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78872d190b913655789ff725f77c1913">&#9670;&nbsp;</a></span>setSource() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setSource </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Real(const RealVect a_position)&gt;&#160;</td>
          <td class="paramname"><em>a_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic way of setting source terms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_source</td><td>Source term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This fills m_source with the evaluation of a_source </dd></dl>

</div>
</div>
<a id="ad83bc3b914b50dbd90f86987ad46a645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83bc3b914b50dbd90f86987ad46a645">&#9670;&nbsp;</a></span>setSpecies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setSpecies </td>
          <td>(</td>
          <td class="paramtype">const RefCountedPtr&lt; <a class="el" href="classCdrSpecies.html">CdrSpecies</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_species</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set species. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_species</td><td>Species (where this solver gets its name, charge, initial conditions etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a945c47e4e283b7217be8960a9932f171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945c47e4e283b7217be8960a9932f171">&#9670;&nbsp;</a></span>setTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setTime </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time for this solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_step</td><td>Time step number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_time</td><td>Time (in seconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dt</td><td>Time step increment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This sets m_step=a_step, m_time=a_time, m_dt=a_dt </dd></dl>

</div>
</div>
<a id="ae378699f575d0bf248d737e655c58768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae378699f575d0bf248d737e655c58768">&#9670;&nbsp;</a></span>setVelocity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_velocity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set velocity from data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_velocity</td><td>Cell centered velocities.</td></tr>
  </table>
  </dd>
</dl>
<p>This copies a_velo onto m_cellVelocity. </p>

</div>
</div>
<a id="a6b16af6bab2bdea269187fa763d0225c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b16af6bab2bdea269187fa763d0225c">&#9670;&nbsp;</a></span>setVelocity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setVelocity </td>
          <td>(</td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_velocity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set constant velocity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_velocity</td><td>Velocity</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the cell centered velocity to be a_velo in every grid cell. </p>

</div>
</div>
<a id="afdda09c9719d57dd49d068e0ae7b60ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdda09c9719d57dd49d068e0ae7b60ec">&#9670;&nbsp;</a></span>setVelocity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setVelocity </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; RealVect(const RealVect a_pos)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_velocity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set velocity using a polymorphic function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_velocity</td><td>Velocity to be set. You can use e.g. a lambda to set it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86d9e87e3aa5b84db8bcee295ca415fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d9e87e3aa5b84db8bcee295ca415fd">&#9670;&nbsp;</a></span>setVerbosity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::setVerbosity </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set verbosity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_verbosity</td><td>Verbosity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717520ff49df061821a7411db2b00123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717520ff49df061821a7411db2b00123">&#9670;&nbsp;</a></span>smoothHeavisideFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::smoothHeavisideFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_facePhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellPhi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use Heaviside smoothing for computing face-centered states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_facePhi</td><td>Face centered state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellPhi</td><td>Cell-centered states </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is only intended to be used with FHD functionality. </dd></dl>

</div>
</div>
<a id="aa15c976354d426dd11bb9d2de8066c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15c976354d426dd11bb9d2de8066c3a">&#9670;&nbsp;</a></span>weightedUpwind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::weightedUpwind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_weightedUpwindPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_pow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an upwind-weighted version of phi. </p>
<p>This is equal to sum(alpha * v^p * phi)/sum(alpha * v^p) where alpha is the face aperture and v is the face velocity. phi is taken as the upwind value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_weightedUpwindPhi</td><td>Weighted upwind phi </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_pow</td><td>Weighting factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13e5cf3b317437037e25187136d7ab0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e5cf3b317437037e25187136d7ab0e">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_interp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to output. Convenience function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Data to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_interp</td><td>If true, a_data will be interpolated to cell centroids before writing to a_output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afae1ef6f463bded79a599bbe60505fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae1ef6f463bded79a599bbe60505fb6">&#9670;&nbsp;</a></span>writePlotData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::writePlotData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a_icomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write output data to a_output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_output</td><td>Output data holder. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_icomp</td><td>Starting component where this solver begins writing the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will write the plot data in this solver to a_output, starting on a_comp </dd>
<dd>
This routine writes m_phi on centroids (and not cell-centers). </dd></dl>

<p>Reimplemented in <a class="el" href="classCdrMultigrid.html#aa4ef76ca5e21090769881055fd1dd5a5">CdrMultigrid</a>.</p>

</div>
</div>
<a id="ae5ff5275be09e06043378eae81f89267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ff5275be09e06043378eae81f89267">&#9670;&nbsp;</a></span>writePlotFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CdrSolver::writePlotFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write plot file. </p>
<p>The name of the plot file is m_name.stepXXXXX.DIM.hdf5 </p><dl class="section note"><dt>Note</dt><dd>This calls writePlotData(...) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8a70b05d0a25a38e8bca59579251a12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a70b05d0a25a38e8bca59579251a12a">&#9670;&nbsp;</a></span>m_className</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CdrSolver::m_className</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class name. </p>
<p>This will be different for different implementations of <a class="el" href="classCdrSolver.html" title="Base class for solving convection-diffusion-reaction equations.">CdrSolver</a> </p>

</div>
</div>
<a id="a7179cbf866842d59f826f8bb30469a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7179cbf866842d59f826f8bb30469a45">&#9670;&nbsp;</a></span>m_domainFluxFunctions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classCdrDomainBC.html#ab012a2d05bf927e27dd38aafaf2dba2d">CdrDomainBC::DomainSide</a>, <a class="el" href="classCdrDomainBC.html#a6ffe2fab3e0f415bf30fb5d68efdcb51">CdrDomainBC::FluxFunction</a>&gt; CdrSolver::m_domainFluxFunctions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Domain flux functions. </p>
<p>Used when the user specifies that the domain flux is function-based </p>

</div>
</div>
<a id="ae0d684e01266543c7ca2cdae12f39a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d684e01266543c7ca2cdae12f39a54">&#9670;&nbsp;</a></span>m_verbosity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CdrSolver::m_verbosity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solver verbosity. </p>
<p>A high number gives lots of output </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/ConvectionDiffusionReaction/<a class="el" href="CD__CdrSolver_8H_source.html">CD_CdrSolver.H</a></li>
<li>Source/ConvectionDiffusionReaction/<a class="el" href="CD__CdrSolver_8cpp.html">CD_CdrSolver.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
