<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chombo-discharge: DataOps Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chombo-discharge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classDataOps-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataOps Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Agglomeration of useful data operations.  
 <a href="classDataOps.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CD__DataOps_8H_source.html">CD_DataOps.H</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4429514331ff31eb2f7a0bfb896884e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4429514331ff31eb2f7a0bfb896884e3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOps.html#a4429514331ff31eb2f7a0bfb896884e3">setValue</a> (LevelData&lt; <a class="el" href="classMFInterfaceFAB.html">MFInterfaceFAB</a>&lt; T &gt;&gt; &amp;a_lhs, const T &amp;a_value)</td></tr>
<tr class="memdesc:a4429514331ff31eb2f7a0bfb896884e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in an <a class="el" href="classMFInterfaceFAB.html" title="Class for holding BaseIVFAB&lt;T&gt; on the interface between two phases.">MFInterfaceFAB</a> data holder.  <a href="classDataOps.html#a4429514331ff31eb2f7a0bfb896884e3">More...</a><br /></td></tr>
<tr class="separator:a4429514331ff31eb2f7a0bfb896884e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431748ec65eb6252e0c8d5dcd380d858"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a431748ec65eb6252e0c8d5dcd380d858"><td class="memTemplItemLeft" align="right" valign="top">static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOps.html#a431748ec65eb6252e0c8d5dcd380d858">sgn</a> (const T a_value)</td></tr>
<tr class="memdesc:a431748ec65eb6252e0c8d5dcd380d858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign function. Returns +/- if the value is &gt; 0 or &lt; 0.  <a href="classDataOps.html#a431748ec65eb6252e0c8d5dcd380d858">More...</a><br /></td></tr>
<tr class="separator:a431748ec65eb6252e0c8d5dcd380d858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0125dcf3865e53b410f74962034ce91f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a0125dcf3865e53b410f74962034ce91f">averageCellVelocityToFaceVelocity</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_faceData, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_cellData, const Vector&lt; ProblemDomain &gt; &amp;a_domains, const int a_tanGhosts)</td></tr>
<tr class="memdesc:a0125dcf3865e53b410f74962034ce91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine which computes the average of a cell-centered quantity on faces for the normal component only.  <a href="classDataOps.html#a0125dcf3865e53b410f74962034ce91f">More...</a><br /></td></tr>
<tr class="separator:a0125dcf3865e53b410f74962034ce91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a305958f894d18dedbf15f4a08469f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad0a305958f894d18dedbf15f4a08469f">averageCellVelocityToFaceVelocity</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_faceData, const LevelData&lt; EBCellFAB &gt; &amp;a_cellData, const ProblemDomain &amp;a_domain, const int a_tanGhosts)</td></tr>
<tr class="memdesc:ad0a305958f894d18dedbf15f4a08469f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine which computes the average of a cell-centered quantity on faces for the normal component only.  <a href="classDataOps.html#ad0a305958f894d18dedbf15f4a08469f">More...</a><br /></td></tr>
<tr class="separator:ad0a305958f894d18dedbf15f4a08469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e607a3cb21f0528af1d61cc9d29bda"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#af6e607a3cb21f0528af1d61cc9d29bda">averageCellToFace</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_faceData, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_cellData, const Vector&lt; ProblemDomain &gt; &amp;a_domains)</td></tr>
<tr class="memdesc:af6e607a3cb21f0528af1d61cc9d29bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average all components of the cell-centered data to faces.  <a href="classDataOps.html#af6e607a3cb21f0528af1d61cc9d29bda">More...</a><br /></td></tr>
<tr class="separator:af6e607a3cb21f0528af1d61cc9d29bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b238b21e8f218986e9214a2af25227"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad1b238b21e8f218986e9214a2af25227">averageCellToFace</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_faceData, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_cellData, const Vector&lt; ProblemDomain &gt; &amp;a_domains, const int a_tanGhosts, const Interval &amp;a_faceVars, const Interval &amp;a_cellVars, const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;a_average)</td></tr>
<tr class="memdesc:ad1b238b21e8f218986e9214a2af25227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine which averages a cell-centered component to faces.  <a href="classDataOps.html#ad1b238b21e8f218986e9214a2af25227">More...</a><br /></td></tr>
<tr class="separator:ad1b238b21e8f218986e9214a2af25227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac639022efff04463bb98209dad057c65"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ac639022efff04463bb98209dad057c65">averageCellToFace</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_faceData, const LevelData&lt; EBCellFAB &gt; &amp;a_cellData, const ProblemDomain &amp;a_domain, const int a_tanGhosts, const Interval &amp;a_faceVars, const Interval &amp;a_cellVars, const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;a_average)</td></tr>
<tr class="memdesc:ac639022efff04463bb98209dad057c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine which averages a cell-centered component to faces.  <a href="classDataOps.html#ac639022efff04463bb98209dad057c65">More...</a><br /></td></tr>
<tr class="separator:ac639022efff04463bb98209dad057c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8a8a9e9723b81eb87b5a4a952ca9de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a0c8a8a9e9723b81eb87b5a4a952ca9de">averageFaceToCell</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_cellData, const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_fluxData, const Vector&lt; ProblemDomain &gt; &amp;a_domains)</td></tr>
<tr class="memdesc:a0c8a8a9e9723b81eb87b5a4a952ca9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average all components of face centered data to cell centers.  <a href="classDataOps.html#a0c8a8a9e9723b81eb87b5a4a952ca9de">More...</a><br /></td></tr>
<tr class="separator:a0c8a8a9e9723b81eb87b5a4a952ca9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b2f78fdee7dfd457d03da57a1fabb1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ae0b2f78fdee7dfd457d03da57a1fabb1">averageFaceToCell</a> (LevelData&lt; EBCellFAB &gt; &amp;a_cellData, const LevelData&lt; EBFluxFAB &gt; &amp;a_fluxData, const ProblemDomain &amp;a_domain)</td></tr>
<tr class="memdesc:ae0b2f78fdee7dfd457d03da57a1fabb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average all components of face centered data to cell centers.  <a href="classDataOps.html#ae0b2f78fdee7dfd457d03da57a1fabb1">More...</a><br /></td></tr>
<tr class="separator:ae0b2f78fdee7dfd457d03da57a1fabb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380921f9b664379fc6738dffdfe6bfcd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a380921f9b664379fc6738dffdfe6bfcd">compute</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const std::function&lt; Real(const Real a_cellValue)&gt; &amp;a_func) noexcept</td></tr>
<tr class="memdesc:a380921f9b664379fc6738dffdfe6bfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a new value given the old cell value.  <a href="classDataOps.html#a380921f9b664379fc6738dffdfe6bfcd">More...</a><br /></td></tr>
<tr class="separator:a380921f9b664379fc6738dffdfe6bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26172cef3ac6df3e23499d67de2c31b9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a26172cef3ac6df3e23499d67de2c31b9">compute</a> (LevelData&lt; EBCellFAB &gt; &amp;a_data, const std::function&lt; Real(const Real a_cellValue)&gt; &amp;a_func) noexcept</td></tr>
<tr class="memdesc:a26172cef3ac6df3e23499d67de2c31b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a new value given the old cell value.  <a href="classDataOps.html#a26172cef3ac6df3e23499d67de2c31b9">More...</a><br /></td></tr>
<tr class="separator:a26172cef3ac6df3e23499d67de2c31b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a534acad1c2edb95b95fd89ccaa156"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ab9a534acad1c2edb95b95fd89ccaa156">dotProduct</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_result, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data1, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data2)</td></tr>
<tr class="memdesc:ab9a534acad1c2edb95b95fd89ccaa156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compote the cell-wise dot product between two data holders.  <a href="classDataOps.html#ab9a534acad1c2edb95b95fd89ccaa156">More...</a><br /></td></tr>
<tr class="separator:ab9a534acad1c2edb95b95fd89ccaa156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c8998faa8838dbbcd0156b98790e44"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a87c8998faa8838dbbcd0156b98790e44">dotProduct</a> (LevelData&lt; MFCellFAB &gt; &amp;a_result, const LevelData&lt; MFCellFAB &gt; &amp;a_data1, const LevelData&lt; MFCellFAB &gt; &amp;a_data2)</td></tr>
<tr class="memdesc:a87c8998faa8838dbbcd0156b98790e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compote the cell-wise dot product between two data holders.  <a href="classDataOps.html#a87c8998faa8838dbbcd0156b98790e44">More...</a><br /></td></tr>
<tr class="separator:a87c8998faa8838dbbcd0156b98790e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2aa61abb2b7ad935fe13bc1a3a36e55"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ab2aa61abb2b7ad935fe13bc1a3a36e55">dotProduct</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_result, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data1, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data2)</td></tr>
<tr class="memdesc:ab2aa61abb2b7ad935fe13bc1a3a36e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compote the cell-wise dot product between two data holders.  <a href="classDataOps.html#ab2aa61abb2b7ad935fe13bc1a3a36e55">More...</a><br /></td></tr>
<tr class="separator:ab2aa61abb2b7ad935fe13bc1a3a36e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfcb77c051d0d3457dd0db7ec967ddd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a0bfcb77c051d0d3457dd0db7ec967ddd">dotProduct</a> (LevelData&lt; EBCellFAB &gt; &amp;a_result, const LevelData&lt; EBCellFAB &gt; &amp;a_data1, const LevelData&lt; EBCellFAB &gt; &amp;a_data2)</td></tr>
<tr class="memdesc:a0bfcb77c051d0d3457dd0db7ec967ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compote the cell-wise dot product between two data holders.  <a href="classDataOps.html#a0bfcb77c051d0d3457dd0db7ec967ddd">More...</a><br /></td></tr>
<tr class="separator:a0bfcb77c051d0d3457dd0db7ec967ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a46d6c23aeeb3c5122acb6a87b92ae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a12a46d6c23aeeb3c5122acb6a87b92ae">dotProduct</a> (EBCellFAB &amp;a_result, const EBCellFAB &amp;a_data1, const EBCellFAB &amp;a_data2, const Box &amp;a_box)</td></tr>
<tr class="memdesc:a12a46d6c23aeeb3c5122acb6a87b92ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compote the cell-wise dot product between two data holders.  <a href="classDataOps.html#a12a46d6c23aeeb3c5122acb6a87b92ae">More...</a><br /></td></tr>
<tr class="separator:a12a46d6c23aeeb3c5122acb6a87b92ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505cd90f96964992607c08e02c845170"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a505cd90f96964992607c08e02c845170">filterSmooth</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const Real a_alpha, const int a_stride, const bool a_zeroEB) noexcept</td></tr>
<tr class="memdesc:a505cd90f96964992607c08e02c845170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a convolved filter phi = alpha * phi_i + 0.5*(1-alpha) * [phi_(i+s) + phi_(i-s)] in each direction.  <a href="classDataOps.html#a505cd90f96964992607c08e02c845170">More...</a><br /></td></tr>
<tr class="separator:a505cd90f96964992607c08e02c845170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cf66aa022399705b36d49cad9b4de9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ac0cf66aa022399705b36d49cad9b4de9">filterSmooth</a> (LevelData&lt; EBCellFAB &gt; &amp;a_data, const Real a_alpha, const int a_stride, const bool a_zeroEB) noexcept</td></tr>
<tr class="memdesc:ac0cf66aa022399705b36d49cad9b4de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a convolved filter phi = alpha * phi_i + 0.5*(1-alpha) * [phi_(i+s) + phi_(i-s)] in each direction.  <a href="classDataOps.html#ac0cf66aa022399705b36d49cad9b4de9">More...</a><br /></td></tr>
<tr class="separator:ac0cf66aa022399705b36d49cad9b4de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d3d9b487c6182b3941fcab221e727f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a77d3d9b487c6182b3941fcab221e727f">incr</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_rhs, const Real a_scale)</td></tr>
<tr class="memdesc:a77d3d9b487c6182b3941fcab221e727f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#a77d3d9b487c6182b3941fcab221e727f">More...</a><br /></td></tr>
<tr class="separator:a77d3d9b487c6182b3941fcab221e727f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad378bfb45533d3cff03d5f38d0175286"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad378bfb45533d3cff03d5f38d0175286">incr</a> (LevelData&lt; MFCellFAB &gt; &amp;a_lhs, const LevelData&lt; MFCellFAB &gt; &amp;a_rhs, const Real a_scale)</td></tr>
<tr class="memdesc:ad378bfb45533d3cff03d5f38d0175286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#ad378bfb45533d3cff03d5f38d0175286">More...</a><br /></td></tr>
<tr class="separator:ad378bfb45533d3cff03d5f38d0175286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286804b303d4c74fdcb79ea20522b745"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a286804b303d4c74fdcb79ea20522b745">incr</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:a286804b303d4c74fdcb79ea20522b745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#a286804b303d4c74fdcb79ea20522b745">More...</a><br /></td></tr>
<tr class="separator:a286804b303d4c74fdcb79ea20522b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd55a67f0ab7f80a053c71dffed1413"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#acbd55a67f0ab7f80a053c71dffed1413">incr</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:acbd55a67f0ab7f80a053c71dffed1413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#acbd55a67f0ab7f80a053c71dffed1413">More...</a><br /></td></tr>
<tr class="separator:acbd55a67f0ab7f80a053c71dffed1413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3b52c379710ee0e21bf3af2f63b1e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a1f3b52c379710ee0e21bf3af2f63b1e8">incr</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:a1f3b52c379710ee0e21bf3af2f63b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#a1f3b52c379710ee0e21bf3af2f63b1e8">More...</a><br /></td></tr>
<tr class="separator:a1f3b52c379710ee0e21bf3af2f63b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f432a0768436d5dd6c3575acce3435"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a50f432a0768436d5dd6c3575acce3435">incr</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_lhs, const LevelData&lt; EBFluxFAB &gt; &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:a50f432a0768436d5dd6c3575acce3435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#a50f432a0768436d5dd6c3575acce3435">More...</a><br /></td></tr>
<tr class="separator:a50f432a0768436d5dd6c3575acce3435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6a94d62d0ebe552762342af00e2886"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#adf6a94d62d0ebe552762342af00e2886">incr</a> (EBFluxFAB &amp;a_lhs, const EBFluxFAB &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:adf6a94d62d0ebe552762342af00e2886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#adf6a94d62d0ebe552762342af00e2886">More...</a><br /></td></tr>
<tr class="separator:adf6a94d62d0ebe552762342af00e2886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5844899601a61593b56e3854d9f46c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aa5844899601a61593b56e3854d9f46c6">incr</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:aa5844899601a61593b56e3854d9f46c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#aa5844899601a61593b56e3854d9f46c6">More...</a><br /></td></tr>
<tr class="separator:aa5844899601a61593b56e3854d9f46c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4fd99c841261c069cc120236b753ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a5f4fd99c841261c069cc120236b753ab">incr</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:a5f4fd99c841261c069cc120236b753ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#a5f4fd99c841261c069cc120236b753ab">More...</a><br /></td></tr>
<tr class="separator:a5f4fd99c841261c069cc120236b753ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad239c1d43ded952a79e1d29b6c2f6944"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad239c1d43ded952a79e1d29b6c2f6944">incr</a> (<a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:ad239c1d43ded952a79e1d29b6c2f6944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#ad239c1d43ded952a79e1d29b6c2f6944">More...</a><br /></td></tr>
<tr class="separator:ad239c1d43ded952a79e1d29b6c2f6944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7375f2009e0cebaad7bf76b3316ffc0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad7375f2009e0cebaad7bf76b3316ffc0">incr</a> (LevelData&lt; <a class="el" href="classDomainFluxIFFAB.html">DomainFluxIFFAB</a> &gt; &amp;a_lhs, const LevelData&lt; <a class="el" href="classDomainFluxIFFAB.html">DomainFluxIFFAB</a> &gt; &amp;a_rhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:ad7375f2009e0cebaad7bf76b3316ffc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#ad7375f2009e0cebaad7bf76b3316ffc0">More...</a><br /></td></tr>
<tr class="separator:ad7375f2009e0cebaad7bf76b3316ffc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21405f73fb2cb46485b92fa3aafcd83"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad21405f73fb2cb46485b92fa3aafcd83">incr</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_rhs, const Real a_scale)</td></tr>
<tr class="memdesc:ad21405f73fb2cb46485b92fa3aafcd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#ad21405f73fb2cb46485b92fa3aafcd83">More...</a><br /></td></tr>
<tr class="separator:ad21405f73fb2cb46485b92fa3aafcd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c85212dd696e4eb7520c21b00df6cb1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a8c85212dd696e4eb7520c21b00df6cb1">incr</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_rhs, const Real a_scale)</td></tr>
<tr class="memdesc:a8c85212dd696e4eb7520c21b00df6cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#a8c85212dd696e4eb7520c21b00df6cb1">More...</a><br /></td></tr>
<tr class="separator:a8c85212dd696e4eb7520c21b00df6cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406474f3ade41f61c4b98eb723078b6a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a406474f3ade41f61c4b98eb723078b6a">incr</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs, const Real a_scale)</td></tr>
<tr class="memdesc:a406474f3ade41f61c4b98eb723078b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#a406474f3ade41f61c4b98eb723078b6a">More...</a><br /></td></tr>
<tr class="separator:a406474f3ade41f61c4b98eb723078b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c733f245c10e9c172e3d9424ab4fd98"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a0c733f245c10e9c172e3d9424ab4fd98">incr</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const Real a_scale)</td></tr>
<tr class="memdesc:a0c733f245c10e9c172e3d9424ab4fd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components.  <a href="classDataOps.html#a0c733f245c10e9c172e3d9424ab4fd98">More...</a><br /></td></tr>
<tr class="separator:a0c733f245c10e9c172e3d9424ab4fd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9695c22d415df5658913bd9de3aade3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#af9695c22d415df5658913bd9de3aade3">copy</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_dst, const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_src)</td></tr>
<tr class="memdesc:af9695c22d415df5658913bd9de3aade3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one data holder to another.  <a href="classDataOps.html#af9695c22d415df5658913bd9de3aade3">More...</a><br /></td></tr>
<tr class="separator:af9695c22d415df5658913bd9de3aade3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5716697fdd8d4f494d8f35cd5ef9777d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a5716697fdd8d4f494d8f35cd5ef9777d">copy</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_dst, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_src)</td></tr>
<tr class="memdesc:a5716697fdd8d4f494d8f35cd5ef9777d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one data holder to another.  <a href="classDataOps.html#a5716697fdd8d4f494d8f35cd5ef9777d">More...</a><br /></td></tr>
<tr class="separator:a5716697fdd8d4f494d8f35cd5ef9777d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a4550420d098d1e1bd77fdb88a7182"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a25a4550420d098d1e1bd77fdb88a7182">copy</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_dst, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_src)</td></tr>
<tr class="memdesc:a25a4550420d098d1e1bd77fdb88a7182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one data holder to another.  <a href="classDataOps.html#a25a4550420d098d1e1bd77fdb88a7182">More...</a><br /></td></tr>
<tr class="separator:a25a4550420d098d1e1bd77fdb88a7182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8098fcedc68a9105187d5e0696b321e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad8098fcedc68a9105187d5e0696b321e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad8098fcedc68a9105187d5e0696b321e">copy</a> (<a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;a_dst, const <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;a_src, const Interval a_dstInterv, const Interval a_srcInterv)</td></tr>
<tr class="memdesc:ad8098fcedc68a9105187d5e0696b321e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from one data holder to another. Allows specification of components.  <a href="classDataOps.html#ad8098fcedc68a9105187d5e0696b321e">More...</a><br /></td></tr>
<tr class="separator:ad8098fcedc68a9105187d5e0696b321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506dc21e62a8c1aeccbc16803b44c284"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a506dc21e62a8c1aeccbc16803b44c284">divide</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs, const int a_lhsComp, const int a_rhsComp)</td></tr>
<tr class="memdesc:a506dc21e62a8c1aeccbc16803b44c284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide one data holder by another. Does specified components.  <a href="classDataOps.html#a506dc21e62a8c1aeccbc16803b44c284">More...</a><br /></td></tr>
<tr class="separator:a506dc21e62a8c1aeccbc16803b44c284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479ec23a25a7349f4c9c943bad789fa2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a479ec23a25a7349f4c9c943bad789fa2">divide</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const int a_lhsComp, const int a_rhsComp)</td></tr>
<tr class="memdesc:a479ec23a25a7349f4c9c943bad789fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide one data holder by another. Does specified components.  <a href="classDataOps.html#a479ec23a25a7349f4c9c943bad789fa2">More...</a><br /></td></tr>
<tr class="separator:a479ec23a25a7349f4c9c943bad789fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633190f7c7b99ec502349854875beccf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a633190f7c7b99ec502349854875beccf">divideByScalar</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs)</td></tr>
<tr class="memdesc:a633190f7c7b99ec502349854875beccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide all components in a data holder by a scalar value.  <a href="classDataOps.html#a633190f7c7b99ec502349854875beccf">More...</a><br /></td></tr>
<tr class="separator:a633190f7c7b99ec502349854875beccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b251c20524ce05127d4b8fbaf00fd5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad0b251c20524ce05127d4b8fbaf00fd5">divideByScalar</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs)</td></tr>
<tr class="memdesc:ad0b251c20524ce05127d4b8fbaf00fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide all components in a data holder by a scalar value.  <a href="classDataOps.html#ad0b251c20524ce05127d4b8fbaf00fd5">More...</a><br /></td></tr>
<tr class="separator:ad0b251c20524ce05127d4b8fbaf00fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f23fc2c3618349b37259125fb40dbce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a1f23fc2c3618349b37259125fb40dbce">divideFallback</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_numerator, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_denominator, const Real a_fallback)</td></tr>
<tr class="memdesc:a1f23fc2c3618349b37259125fb40dbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide data. If the denominator is zero, set the value to a fallback option.  <a href="classDataOps.html#a1f23fc2c3618349b37259125fb40dbce">More...</a><br /></td></tr>
<tr class="separator:a1f23fc2c3618349b37259125fb40dbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e789c7302d1d3f984c3d59007fe6072"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a1e789c7302d1d3f984c3d59007fe6072">divideFallback</a> (LevelData&lt; EBCellFAB &gt; &amp;a_numerator, const LevelData&lt; EBCellFAB &gt; &amp;a_denominator, const Real a_fallback)</td></tr>
<tr class="memdesc:a1e789c7302d1d3f984c3d59007fe6072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide data. If the denominator is zero, set the value to a fallback option.  <a href="classDataOps.html#a1e789c7302d1d3f984c3d59007fe6072">More...</a><br /></td></tr>
<tr class="separator:a1e789c7302d1d3f984c3d59007fe6072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb2d0e8071428af765ab335dc363a08"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aacb2d0e8071428af765ab335dc363a08">divideFallback</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_numerator, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_denominator, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_fallback)</td></tr>
<tr class="memdesc:aacb2d0e8071428af765ab335dc363a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide data. If the denominator is zero, set the value to a fallback option.  <a href="classDataOps.html#aacb2d0e8071428af765ab335dc363a08">More...</a><br /></td></tr>
<tr class="separator:aacb2d0e8071428af765ab335dc363a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f4ef9b6dd3ce711552a93ae448b6a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a76f4ef9b6dd3ce711552a93ae448b6a4">divideFallback</a> (LevelData&lt; EBCellFAB &gt; &amp;a_numerator, const LevelData&lt; EBCellFAB &gt; &amp;a_denominator, const LevelData&lt; EBCellFAB &gt; &amp;a_fallback)</td></tr>
<tr class="memdesc:a76f4ef9b6dd3ce711552a93ae448b6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide data. If the denominator is zero, set the value to a fallback option.  <a href="classDataOps.html#a76f4ef9b6dd3ce711552a93ae448b6a4">More...</a><br /></td></tr>
<tr class="separator:a76f4ef9b6dd3ce711552a93ae448b6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b79c45f70a1b587edef171ae37cfc3f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a3b79c45f70a1b587edef171ae37cfc3f">floor</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:a3b79c45f70a1b587edef171ae37cfc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor values in data holder. This sets all values below a_value to a_value.  <a href="classDataOps.html#a3b79c45f70a1b587edef171ae37cfc3f">More...</a><br /></td></tr>
<tr class="separator:a3b79c45f70a1b587edef171ae37cfc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e303c4b9aac749c6c82b7378751546"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ae3e303c4b9aac749c6c82b7378751546">floor</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:ae3e303c4b9aac749c6c82b7378751546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor values in data holder. This sets all values below a_value to a_value.  <a href="classDataOps.html#ae3e303c4b9aac749c6c82b7378751546">More...</a><br /></td></tr>
<tr class="separator:ae3e303c4b9aac749c6c82b7378751546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778aec86d833f1963fb2962f99913286"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a778aec86d833f1963fb2962f99913286">floor</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:a778aec86d833f1963fb2962f99913286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor values in data holder. This sets all values below a_value to a_value.  <a href="classDataOps.html#a778aec86d833f1963fb2962f99913286">More...</a><br /></td></tr>
<tr class="separator:a778aec86d833f1963fb2962f99913286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1a49a9cd876da89e3e3bef4c2bc1b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aae1a49a9cd876da89e3e3bef4c2bc1b7">floor</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:aae1a49a9cd876da89e3e3bef4c2bc1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor values in data holder. This sets all values below a_value to a_value.  <a href="classDataOps.html#aae1a49a9cd876da89e3e3bef4c2bc1b7">More...</a><br /></td></tr>
<tr class="separator:aae1a49a9cd876da89e3e3bef4c2bc1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eecb9d5aa052cc3569b09e325909f6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ab9eecb9d5aa052cc3569b09e325909f6">roof</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:ab9eecb9d5aa052cc3569b09e325909f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roof values in data holder. This sets all values above a_value to a_value.  <a href="classDataOps.html#ab9eecb9d5aa052cc3569b09e325909f6">More...</a><br /></td></tr>
<tr class="separator:ab9eecb9d5aa052cc3569b09e325909f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01754851bb2502eec69e140d53acacae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a01754851bb2502eec69e140d53acacae">roof</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:a01754851bb2502eec69e140d53acacae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roof values in data holder. This sets all values above a_value to a_value.  <a href="classDataOps.html#a01754851bb2502eec69e140d53acacae">More...</a><br /></td></tr>
<tr class="separator:a01754851bb2502eec69e140d53acacae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd25d01b1be678aea3023ec32631e51d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#afd25d01b1be678aea3023ec32631e51d">roof</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:afd25d01b1be678aea3023ec32631e51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roof values in data holder. This sets all values above a_value to a_value.  <a href="classDataOps.html#afd25d01b1be678aea3023ec32631e51d">More...</a><br /></td></tr>
<tr class="separator:afd25d01b1be678aea3023ec32631e51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44be6edb8a25b5d7c028f2286a2a095d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a44be6edb8a25b5d7c028f2286a2a095d">roof</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:a44be6edb8a25b5d7c028f2286a2a095d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roof values in data holder. This sets all values above a_value to a_value.  <a href="classDataOps.html#a44be6edb8a25b5d7c028f2286a2a095d">More...</a><br /></td></tr>
<tr class="separator:a44be6edb8a25b5d7c028f2286a2a095d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55267a7e87eb9baa3306b3a5856553cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a55267a7e87eb9baa3306b3a5856553cd">max</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data1, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data2)</td></tr>
<tr class="memdesc:a55267a7e87eb9baa3306b3a5856553cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a_data = max(a_data1, a_data2)  <a href="classDataOps.html#a55267a7e87eb9baa3306b3a5856553cd">More...</a><br /></td></tr>
<tr class="separator:a55267a7e87eb9baa3306b3a5856553cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08f7f4e51cda580cfa00a7780b00775"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ac08f7f4e51cda580cfa00a7780b00775">max</a> (LevelData&lt; EBCellFAB &gt; &amp;a_data, const LevelData&lt; EBCellFAB &gt; &amp;a_data1, const LevelData&lt; EBCellFAB &gt; &amp;a_data2)</td></tr>
<tr class="memdesc:ac08f7f4e51cda580cfa00a7780b00775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a_data = max(a_data1, a_data2)  <a href="classDataOps.html#ac08f7f4e51cda580cfa00a7780b00775">More...</a><br /></td></tr>
<tr class="separator:ac08f7f4e51cda580cfa00a7780b00775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de2e0bae557d084310a1991f183d339"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a5de2e0bae557d084310a1991f183d339">getMaxMin</a> (Real &amp;<a class="el" href="classDataOps.html#a55267a7e87eb9baa3306b3a5856553cd">max</a>, Real &amp;min, <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const int a_comp)</td></tr>
<tr class="memdesc:a5de2e0bae557d084310a1991f183d339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum and minimum value of specified component.  <a href="classDataOps.html#a5de2e0bae557d084310a1991f183d339">More...</a><br /></td></tr>
<tr class="separator:a5de2e0bae557d084310a1991f183d339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9670a14cbaddb9258b7b7740e152d11"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ac9670a14cbaddb9258b7b7740e152d11">getMaxMin</a> (Real &amp;<a class="el" href="classDataOps.html#a55267a7e87eb9baa3306b3a5856553cd">max</a>, Real &amp;min, LevelData&lt; EBCellFAB &gt; &amp;a_data, const int a_comp)</td></tr>
<tr class="memdesc:ac9670a14cbaddb9258b7b7740e152d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum and minimum value of specified component.  <a href="classDataOps.html#ac9670a14cbaddb9258b7b7740e152d11">More...</a><br /></td></tr>
<tr class="separator:ac9670a14cbaddb9258b7b7740e152d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37af20b672ebecacc0bfd111ce11aadb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a37af20b672ebecacc0bfd111ce11aadb">getMaxMin</a> (Vector&lt; Real &gt; &amp;a_max, Vector&lt; Real &gt; &amp;a_min, Vector&lt; <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &gt; &amp;a_data)</td></tr>
<tr class="memdesc:a37af20b672ebecacc0bfd111ce11aadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum and minimum value. Assumes single-component data.  <a href="classDataOps.html#a37af20b672ebecacc0bfd111ce11aadb">More...</a><br /></td></tr>
<tr class="separator:a37af20b672ebecacc0bfd111ce11aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f11e992c657224003ab61e6680c11"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a323f11e992c657224003ab61e6680c11">getMaxMinNorm</a> (Real &amp;a_max, Real &amp;a_min, <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;data)</td></tr>
<tr class="memdesc:a323f11e992c657224003ab61e6680c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum and minimum value of normed data.  <a href="classDataOps.html#a323f11e992c657224003ab61e6680c11">More...</a><br /></td></tr>
<tr class="separator:a323f11e992c657224003ab61e6680c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2a03862cae1159b56c451397eb17da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aca2a03862cae1159b56c451397eb17da">getMaxMinNorm</a> (Real &amp;a_max, Real &amp;a_min, LevelData&lt; EBCellFAB &gt; &amp;data)</td></tr>
<tr class="memdesc:aca2a03862cae1159b56c451397eb17da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum and minimum value of normed data.  <a href="classDataOps.html#aca2a03862cae1159b56c451397eb17da">More...</a><br /></td></tr>
<tr class="separator:aca2a03862cae1159b56c451397eb17da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3ce9b44348e95885c403dfe72c1f36"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a1e3ce9b44348e95885c403dfe72c1f36">getMaxMinNorm</a> (Real &amp;a_max, Real &amp;a_min, <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;data)</td></tr>
<tr class="memdesc:a1e3ce9b44348e95885c403dfe72c1f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum and minimum value of normed data.  <a href="classDataOps.html#a1e3ce9b44348e95885c403dfe72c1f36">More...</a><br /></td></tr>
<tr class="separator:a1e3ce9b44348e95885c403dfe72c1f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fb473dc78a9389a3120d73380478e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a27fb473dc78a9389a3120d73380478e2">getMaxMinNorm</a> (Real &amp;a_max, Real &amp;a_min, LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;data)</td></tr>
<tr class="memdesc:a27fb473dc78a9389a3120d73380478e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum and minimum value of normed data.  <a href="classDataOps.html#a27fb473dc78a9389a3120d73380478e2">More...</a><br /></td></tr>
<tr class="separator:a27fb473dc78a9389a3120d73380478e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8df0470b182aca8787328d40569b887"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ac8df0470b182aca8787328d40569b887">invert</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_data)</td></tr>
<tr class="memdesc:ac8df0470b182aca8787328d40569b887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert data.  <a href="classDataOps.html#ac8df0470b182aca8787328d40569b887">More...</a><br /></td></tr>
<tr class="separator:ac8df0470b182aca8787328d40569b887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecafa38c8ae9c3bceb9cca1e6f41fc4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a0ecafa38c8ae9c3bceb9cca1e6f41fc4">invert</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_data)</td></tr>
<tr class="memdesc:a0ecafa38c8ae9c3bceb9cca1e6f41fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert data.  <a href="classDataOps.html#a0ecafa38c8ae9c3bceb9cca1e6f41fc4">More...</a><br /></td></tr>
<tr class="separator:a0ecafa38c8ae9c3bceb9cca1e6f41fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efeac6bdd32a2b7de5e1be30c7dab88"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a7efeac6bdd32a2b7de5e1be30c7dab88">invert</a> (EBFluxFAB &amp;a_data)</td></tr>
<tr class="memdesc:a7efeac6bdd32a2b7de5e1be30c7dab88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert data.  <a href="classDataOps.html#a7efeac6bdd32a2b7de5e1be30c7dab88">More...</a><br /></td></tr>
<tr class="separator:a7efeac6bdd32a2b7de5e1be30c7dab88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4261230f2d9ceb036ad1294b8f947d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ae4261230f2d9ceb036ad1294b8f947d0">kappaSum</a> (Real &amp;a_mass, const LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const int a_comp=0)</td></tr>
<tr class="memdesc:ae4261230f2d9ceb036ad1294b8f947d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the kappa-weighted sum of the input data. Assumes one component.  <a href="classDataOps.html#ae4261230f2d9ceb036ad1294b8f947d0">More...</a><br /></td></tr>
<tr class="separator:ae4261230f2d9ceb036ad1294b8f947d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1139f7cd961f218905b627acc8a19e2e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a1139f7cd961f218905b627acc8a19e2e">kappaScale</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data)</td></tr>
<tr class="memdesc:a1139f7cd961f218905b627acc8a19e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by volume fraction.  <a href="classDataOps.html#a1139f7cd961f218905b627acc8a19e2e">More...</a><br /></td></tr>
<tr class="separator:a1139f7cd961f218905b627acc8a19e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2937f528899e9f13ec2244e366514c1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a2937f528899e9f13ec2244e366514c1e">kappaScale</a> (LevelData&lt; EBCellFAB &gt; &amp;a_data)</td></tr>
<tr class="memdesc:a2937f528899e9f13ec2244e366514c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by volume fraction.  <a href="classDataOps.html#a2937f528899e9f13ec2244e366514c1e">More...</a><br /></td></tr>
<tr class="separator:a2937f528899e9f13ec2244e366514c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb248476bdb7363b0220cfc8e7e69c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a8cb248476bdb7363b0220cfc8e7e69c5">kappaScale</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_data)</td></tr>
<tr class="memdesc:a8cb248476bdb7363b0220cfc8e7e69c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by volume fraction.  <a href="classDataOps.html#a8cb248476bdb7363b0220cfc8e7e69c5">More...</a><br /></td></tr>
<tr class="separator:a8cb248476bdb7363b0220cfc8e7e69c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4e399aab0ca657b6c746eaf99807f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a0b4e399aab0ca657b6c746eaf99807f8">kappaScale</a> (LevelData&lt; MFCellFAB &gt; &amp;a_data)</td></tr>
<tr class="memdesc:a0b4e399aab0ca657b6c746eaf99807f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by volume fraction.  <a href="classDataOps.html#a0b4e399aab0ca657b6c746eaf99807f8">More...</a><br /></td></tr>
<tr class="separator:a0b4e399aab0ca657b6c746eaf99807f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e0e1adb30575c6a4342f5bb5931de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a2b3e0e1adb30575c6a4342f5bb5931de">volumeScale</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_data, const Vector&lt; Real &gt; &amp;a_dx)</td></tr>
<tr class="memdesc:a2b3e0e1adb30575c6a4342f5bb5931de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by dx^SpaceDim.  <a href="classDataOps.html#a2b3e0e1adb30575c6a4342f5bb5931de">More...</a><br /></td></tr>
<tr class="separator:a2b3e0e1adb30575c6a4342f5bb5931de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72685cbfeebb9d46777890fbf5a0b3e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a72685cbfeebb9d46777890fbf5a0b3e6">multiply</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs)</td></tr>
<tr class="memdesc:a72685cbfeebb9d46777890fbf5a0b3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#a72685cbfeebb9d46777890fbf5a0b3e6">More...</a><br /></td></tr>
<tr class="separator:a72685cbfeebb9d46777890fbf5a0b3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1208055ecb1c07f59713e9d071d43a03"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a1208055ecb1c07f59713e9d071d43a03">multiply</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs)</td></tr>
<tr class="memdesc:a1208055ecb1c07f59713e9d071d43a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#a1208055ecb1c07f59713e9d071d43a03">More...</a><br /></td></tr>
<tr class="separator:a1208055ecb1c07f59713e9d071d43a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efd55f250957e1a8134a75c1b070c01"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a1efd55f250957e1a8134a75c1b070c01">multiply</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_rhs)</td></tr>
<tr class="memdesc:a1efd55f250957e1a8134a75c1b070c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#a1efd55f250957e1a8134a75c1b070c01">More...</a><br /></td></tr>
<tr class="separator:a1efd55f250957e1a8134a75c1b070c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1db0f9d0037ea500a6b892db88cf311"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad1db0f9d0037ea500a6b892db88cf311">multiply</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_lhs, const LevelData&lt; EBFluxFAB &gt; &amp;a_rhs)</td></tr>
<tr class="memdesc:ad1db0f9d0037ea500a6b892db88cf311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#ad1db0f9d0037ea500a6b892db88cf311">More...</a><br /></td></tr>
<tr class="separator:ad1db0f9d0037ea500a6b892db88cf311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e82a4cea51da220dc78684fe897dcce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a2e82a4cea51da220dc78684fe897dcce">multiply</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_rhs)</td></tr>
<tr class="memdesc:a2e82a4cea51da220dc78684fe897dcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#a2e82a4cea51da220dc78684fe897dcce">More...</a><br /></td></tr>
<tr class="separator:a2e82a4cea51da220dc78684fe897dcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c721845ac943dbe2470334a9767a6d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a2c721845ac943dbe2470334a9767a6d5">multiply</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_rhs)</td></tr>
<tr class="memdesc:a2c721845ac943dbe2470334a9767a6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#a2c721845ac943dbe2470334a9767a6d5">More...</a><br /></td></tr>
<tr class="separator:a2c721845ac943dbe2470334a9767a6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff01271b712d6dd72dbdd40f2c33a001"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aff01271b712d6dd72dbdd40f2c33a001">multiplyScalar</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs)</td></tr>
<tr class="memdesc:aff01271b712d6dd72dbdd40f2c33a001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#aff01271b712d6dd72dbdd40f2c33a001">More...</a><br /></td></tr>
<tr class="separator:aff01271b712d6dd72dbdd40f2c33a001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae960c5190d2423bb4247bb6c58516e4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ae960c5190d2423bb4247bb6c58516e4c">multiplyScalar</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs)</td></tr>
<tr class="memdesc:ae960c5190d2423bb4247bb6c58516e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#ae960c5190d2423bb4247bb6c58516e4c">More...</a><br /></td></tr>
<tr class="separator:ae960c5190d2423bb4247bb6c58516e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2e5e74146775c916a97582d3b44865"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a6b2e5e74146775c916a97582d3b44865">multiplyScalar</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_rhs)</td></tr>
<tr class="memdesc:a6b2e5e74146775c916a97582d3b44865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#a6b2e5e74146775c916a97582d3b44865">More...</a><br /></td></tr>
<tr class="separator:a6b2e5e74146775c916a97582d3b44865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb637ca465e480d7bad3130d4f2f8b8d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#acb637ca465e480d7bad3130d4f2f8b8d">multiplyScalar</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_rhs)</td></tr>
<tr class="memdesc:acb637ca465e480d7bad3130d4f2f8b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply data holder by another data holder.  <a href="classDataOps.html#acb637ca465e480d7bad3130d4f2f8b8d">More...</a><br /></td></tr>
<tr class="separator:acb637ca465e480d7bad3130d4f2f8b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39cbfb09b48df4994c78f07b22c2a8e"><td class="memItemLeft" align="right" valign="top">static Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad39cbfb09b48df4994c78f07b22c2a8e">norm</a> (const LevelData&lt; EBCellFAB &gt; &amp;a_data, const int a_p, const int a_comp=0)</td></tr>
<tr class="memdesc:ad39cbfb09b48df4994c78f07b22c2a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute specified norm of data.  <a href="classDataOps.html#ad39cbfb09b48df4994c78f07b22c2a8e">More...</a><br /></td></tr>
<tr class="separator:ad39cbfb09b48df4994c78f07b22c2a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30f972ce853e2ffafba4cce6d27f40d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ae30f972ce853e2ffafba4cce6d27f40d">plus</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs, const int a_srcComp, const int a_dstComp, const int a_numComp)</td></tr>
<tr class="memdesc:ae30f972ce853e2ffafba4cce6d27f40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">General addition operator for adding together data. The user can choose which components to add.  <a href="classDataOps.html#ae30f972ce853e2ffafba4cce6d27f40d">More...</a><br /></td></tr>
<tr class="separator:ae30f972ce853e2ffafba4cce6d27f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9897e0082692437768f37b5213d59c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a1d9897e0082692437768f37b5213d59c">plus</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs, const int a_srcComp, const int a_dstComp, const int a_numComp)</td></tr>
<tr class="memdesc:a1d9897e0082692437768f37b5213d59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">General addition operator for adding together data. The user can choose which components to add.  <a href="classDataOps.html#a1d9897e0082692437768f37b5213d59c">More...</a><br /></td></tr>
<tr class="separator:a1d9897e0082692437768f37b5213d59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd8d88fb7786769bbdd16c39ee6637a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#accd8d88fb7786769bbdd16c39ee6637a">scale</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_lhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:accd8d88fb7786769bbdd16c39ee6637a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#accd8d88fb7786769bbdd16c39ee6637a">More...</a><br /></td></tr>
<tr class="separator:accd8d88fb7786769bbdd16c39ee6637a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60cd8dc87c3127c81c5ec99aca333a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ae60cd8dc87c3127c81c5ec99aca333a8">scale</a> (LevelData&lt; MFCellFAB &gt; &amp;a_lhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:ae60cd8dc87c3127c81c5ec99aca333a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#ae60cd8dc87c3127c81c5ec99aca333a8">More...</a><br /></td></tr>
<tr class="separator:ae60cd8dc87c3127c81c5ec99aca333a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6605122661a344974cd6b0b540c50d96"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a6605122661a344974cd6b0b540c50d96">scale</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_lhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:a6605122661a344974cd6b0b540c50d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#a6605122661a344974cd6b0b540c50d96">More...</a><br /></td></tr>
<tr class="separator:a6605122661a344974cd6b0b540c50d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e6d037941dfb563e19c392d70b2d1c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad8e6d037941dfb563e19c392d70b2d1c">scale</a> (LevelData&lt; MFFluxFAB &gt; &amp;a_lhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:ad8e6d037941dfb563e19c392d70b2d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#ad8e6d037941dfb563e19c392d70b2d1c">More...</a><br /></td></tr>
<tr class="separator:ad8e6d037941dfb563e19c392d70b2d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4379faf3a9701f15c0ed16f549d048a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a4379faf3a9701f15c0ed16f549d048a0">scale</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:a4379faf3a9701f15c0ed16f549d048a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#a4379faf3a9701f15c0ed16f549d048a0">More...</a><br /></td></tr>
<tr class="separator:a4379faf3a9701f15c0ed16f549d048a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73881aa89a4288cd0120292991a005f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a73881aa89a4288cd0120292991a005f2">scale</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const Real a_scale)</td></tr>
<tr class="memdesc:a73881aa89a4288cd0120292991a005f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#a73881aa89a4288cd0120292991a005f2">More...</a><br /></td></tr>
<tr class="separator:a73881aa89a4288cd0120292991a005f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddaf35e97f5d99bdbeea6312944e91b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#afddaf35e97f5d99bdbeea6312944e91b">scale</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const Real a_scale)</td></tr>
<tr class="memdesc:afddaf35e97f5d99bdbeea6312944e91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#afddaf35e97f5d99bdbeea6312944e91b">More...</a><br /></td></tr>
<tr class="separator:afddaf35e97f5d99bdbeea6312944e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21800fc80d4cf5cc8e0813ba33d91bfe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a21800fc80d4cf5cc8e0813ba33d91bfe">scale</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_lhs, const Real a_scale)</td></tr>
<tr class="memdesc:a21800fc80d4cf5cc8e0813ba33d91bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#a21800fc80d4cf5cc8e0813ba33d91bfe">More...</a><br /></td></tr>
<tr class="separator:a21800fc80d4cf5cc8e0813ba33d91bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0d0d7c6509da37eb18bbee323bfbc6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aab0d0d7c6509da37eb18bbee323bfbc6">scale</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_lhs, const Real a_scale)</td></tr>
<tr class="memdesc:aab0d0d7c6509da37eb18bbee323bfbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#aab0d0d7c6509da37eb18bbee323bfbc6">More...</a><br /></td></tr>
<tr class="separator:aab0d0d7c6509da37eb18bbee323bfbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f39ac1b0ea74aaffccd68f1d9004b1a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a2f39ac1b0ea74aaffccd68f1d9004b1a">scale</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const Real &amp;a_scale)</td></tr>
<tr class="memdesc:a2f39ac1b0ea74aaffccd68f1d9004b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale data by factor.  <a href="classDataOps.html#a2f39ac1b0ea74aaffccd68f1d9004b1a">More...</a><br /></td></tr>
<tr class="separator:a2f39ac1b0ea74aaffccd68f1d9004b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987ece8d8671b9165e74c1e204889061"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a987ece8d8671b9165e74c1e204889061">setCoveredValue</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const int a_comp, const Real a_value)</td></tr>
<tr class="memdesc:a987ece8d8671b9165e74c1e204889061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in covered cells. Does specified component.  <a href="classDataOps.html#a987ece8d8671b9165e74c1e204889061">More...</a><br /></td></tr>
<tr class="separator:a987ece8d8671b9165e74c1e204889061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c8d0741771e046f92dd12d1171abbe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a12c8d0741771e046f92dd12d1171abbe">setCoveredValue</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const int a_comp, const Real a_value)</td></tr>
<tr class="memdesc:a12c8d0741771e046f92dd12d1171abbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in covered cells. Does specified component.  <a href="classDataOps.html#a12c8d0741771e046f92dd12d1171abbe">More...</a><br /></td></tr>
<tr class="separator:a12c8d0741771e046f92dd12d1171abbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa432e87a368830570a43a296990c74c0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aa432e87a368830570a43a296990c74c0">setCoveredValue</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:aa432e87a368830570a43a296990c74c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of setCoveredValue which does all component.  <a href="classDataOps.html#aa432e87a368830570a43a296990c74c0">More...</a><br /></td></tr>
<tr class="separator:aa432e87a368830570a43a296990c74c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab902dba90673edace2259eb4581f66e7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ab902dba90673edace2259eb4581f66e7">setCoveredValue</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:ab902dba90673edace2259eb4581f66e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of setCoveredValue which does all component.  <a href="classDataOps.html#ab902dba90673edace2259eb4581f66e7">More...</a><br /></td></tr>
<tr class="separator:ab902dba90673edace2259eb4581f66e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575d4b28f80135f82786b19d8011faee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a575d4b28f80135f82786b19d8011faee">setInvalidValue</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const Vector&lt; int &gt; &amp;a_refRat, const Real a_value)</td></tr>
<tr class="memdesc:a575d4b28f80135f82786b19d8011faee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in cells that are covered by a finer grid.  <a href="classDataOps.html#a575d4b28f80135f82786b19d8011faee">More...</a><br /></td></tr>
<tr class="separator:a575d4b28f80135f82786b19d8011faee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d07859f9bf92fdc259bf56226e2f1f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a4d07859f9bf92fdc259bf56226e2f1f3">setValue</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_lhs, const std::function&lt; Real(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Vector&lt; Real &gt; &amp;a_dx, const int a_comp)</td></tr>
<tr class="memdesc:a4d07859f9bf92fdc259bf56226e2f1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function.  <a href="classDataOps.html#a4d07859f9bf92fdc259bf56226e2f1f3">More...</a><br /></td></tr>
<tr class="separator:a4d07859f9bf92fdc259bf56226e2f1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24c0d4d9a29d806bf6593fb710607c1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#af24c0d4d9a29d806bf6593fb710607c1">setValue</a> (LevelData&lt; MFCellFAB &gt; &amp;a_lhs, const std::function&lt; Real(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Real a_dx, const int a_comp)</td></tr>
<tr class="memdesc:af24c0d4d9a29d806bf6593fb710607c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function.  <a href="classDataOps.html#af24c0d4d9a29d806bf6593fb710607c1">More...</a><br /></td></tr>
<tr class="separator:af24c0d4d9a29d806bf6593fb710607c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ced551d676991dc16d64cdf345716c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#af1ced551d676991dc16d64cdf345716c">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const std::function&lt; Real(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Vector&lt; Real &gt; &amp;a_dx, const int a_comp)</td></tr>
<tr class="memdesc:af1ced551d676991dc16d64cdf345716c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function.  <a href="classDataOps.html#af1ced551d676991dc16d64cdf345716c">More...</a><br /></td></tr>
<tr class="separator:af1ced551d676991dc16d64cdf345716c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed73b3e1b19f3242dde6169413e2e5fa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aed73b3e1b19f3242dde6169413e2e5fa">setValue</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const std::function&lt; Real(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Real a_dx, const int a_comp)</td></tr>
<tr class="memdesc:aed73b3e1b19f3242dde6169413e2e5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function.  <a href="classDataOps.html#aed73b3e1b19f3242dde6169413e2e5fa">More...</a><br /></td></tr>
<tr class="separator:aed73b3e1b19f3242dde6169413e2e5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0861dec163556964809620b18eaffad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad0861dec163556964809620b18eaffad">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_lhs, const std::function&lt; Real(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Vector&lt; Real &gt; &amp;a_dx, const int a_comp)</td></tr>
<tr class="memdesc:ad0861dec163556964809620b18eaffad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function.  <a href="classDataOps.html#ad0861dec163556964809620b18eaffad">More...</a><br /></td></tr>
<tr class="separator:ad0861dec163556964809620b18eaffad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d1e024abafd6a12b9f655823389ef1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a66d1e024abafd6a12b9f655823389ef1">setValue</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_lhs, const std::function&lt; Real(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Real a_dx, const int a_comp)</td></tr>
<tr class="memdesc:a66d1e024abafd6a12b9f655823389ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function.  <a href="classDataOps.html#a66d1e024abafd6a12b9f655823389ef1">More...</a><br /></td></tr>
<tr class="separator:a66d1e024abafd6a12b9f655823389ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b3f9e61553e9f9d3466ac4d2371fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#acb6b3f9e61553e9f9d3466ac4d2371fe">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const std::function&lt; Real(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Vector&lt; Real &gt; &amp;a_dx, const int a_comp)</td></tr>
<tr class="memdesc:acb6b3f9e61553e9f9d3466ac4d2371fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function.  <a href="classDataOps.html#acb6b3f9e61553e9f9d3466ac4d2371fe">More...</a><br /></td></tr>
<tr class="separator:acb6b3f9e61553e9f9d3466ac4d2371fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ae0723549ff58593114317a85f4a96"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad9ae0723549ff58593114317a85f4a96">setValue</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const std::function&lt; Real(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Real a_dx, const int a_comp)</td></tr>
<tr class="memdesc:ad9ae0723549ff58593114317a85f4a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function.  <a href="classDataOps.html#ad9ae0723549ff58593114317a85f4a96">More...</a><br /></td></tr>
<tr class="separator:ad9ae0723549ff58593114317a85f4a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7ce40d638c4dc1e639a37002d37063"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ada7ce40d638c4dc1e639a37002d37063">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const std::function&lt; RealVect(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Vector&lt; Real &gt; &amp;a_dx)</td></tr>
<tr class="memdesc:ada7ce40d638c4dc1e639a37002d37063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Assumes that a_lhs has SpaceDim components and sets all those components from the input function.  <a href="classDataOps.html#ada7ce40d638c4dc1e639a37002d37063">More...</a><br /></td></tr>
<tr class="separator:ada7ce40d638c4dc1e639a37002d37063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88842bda224e78bec3d37d365120f5bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a88842bda224e78bec3d37d365120f5bd">setValue</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const std::function&lt; RealVect(const RealVect)&gt; &amp;a_function, const RealVect a_probLo, const Real a_dx)</td></tr>
<tr class="memdesc:a88842bda224e78bec3d37d365120f5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic set value function. Assumes that a_lhs has SpaceDim components and sets all those components from the input function.  <a href="classDataOps.html#a88842bda224e78bec3d37d365120f5bd">More...</a><br /></td></tr>
<tr class="separator:a88842bda224e78bec3d37d365120f5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6eb9c0394ac7cb093edea27a5cf54c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a6b6eb9c0394ac7cb093edea27a5cf54c">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:a6b6eb9c0394ac7cb093edea27a5cf54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#a6b6eb9c0394ac7cb093edea27a5cf54c">More...</a><br /></td></tr>
<tr class="separator:a6b6eb9c0394ac7cb093edea27a5cf54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aac5fe21299b5ada3a1c50433e01302"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a6aac5fe21299b5ada3a1c50433e01302">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const Real a_value, const int a_comp)</td></tr>
<tr class="memdesc:a6aac5fe21299b5ada3a1c50433e01302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data with specified component.  <a href="classDataOps.html#a6aac5fe21299b5ada3a1c50433e01302">More...</a><br /></td></tr>
<tr class="separator:a6aac5fe21299b5ada3a1c50433e01302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c536871304eebea8c09289eb0c7313c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a6c536871304eebea8c09289eb0c7313c">setValue</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const Real a_value, const int a_comp)</td></tr>
<tr class="memdesc:a6c536871304eebea8c09289eb0c7313c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data with specified component.  <a href="classDataOps.html#a6c536871304eebea8c09289eb0c7313c">More...</a><br /></td></tr>
<tr class="separator:a6c536871304eebea8c09289eb0c7313c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af5a0e62dde48ec74cfde15fd501b3d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a2af5a0e62dde48ec74cfde15fd501b3d">setValue</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:a2af5a0e62dde48ec74cfde15fd501b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#a2af5a0e62dde48ec74cfde15fd501b3d">More...</a><br /></td></tr>
<tr class="separator:a2af5a0e62dde48ec74cfde15fd501b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7b49942bb6ffd6bb1a1d7eec5ea169"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#afe7b49942bb6ffd6bb1a1d7eec5ea169">setValue</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:afe7b49942bb6ffd6bb1a1d7eec5ea169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#afe7b49942bb6ffd6bb1a1d7eec5ea169">More...</a><br /></td></tr>
<tr class="separator:afe7b49942bb6ffd6bb1a1d7eec5ea169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70307222838211ad1a4cad28ed369c2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a70307222838211ad1a4cad28ed369c2d">setValue</a> (LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:a70307222838211ad1a4cad28ed369c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#a70307222838211ad1a4cad28ed369c2d">More...</a><br /></td></tr>
<tr class="separator:a70307222838211ad1a4cad28ed369c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b0187a50e5163bb0c25e21e18ccda5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a22b0187a50e5163bb0c25e21e18ccda5">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:a22b0187a50e5163bb0c25e21e18ccda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#a22b0187a50e5163bb0c25e21e18ccda5">More...</a><br /></td></tr>
<tr class="separator:a22b0187a50e5163bb0c25e21e18ccda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac245ba9f041399abc500abc70ed252a1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ac245ba9f041399abc500abc70ed252a1">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:ac245ba9f041399abc500abc70ed252a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#ac245ba9f041399abc500abc70ed252a1">More...</a><br /></td></tr>
<tr class="separator:ac245ba9f041399abc500abc70ed252a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0d43ba9750041a999eb649b7f3aba8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#adb0d43ba9750041a999eb649b7f3aba8">setValue</a> (<a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:adb0d43ba9750041a999eb649b7f3aba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#adb0d43ba9750041a999eb649b7f3aba8">More...</a><br /></td></tr>
<tr class="separator:adb0d43ba9750041a999eb649b7f3aba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e2d55727161e4430e3de6a5ecc3275"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a11e2d55727161e4430e3de6a5ecc3275">setValue</a> (LevelData&lt; MFCellFAB &gt; &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:a11e2d55727161e4430e3de6a5ecc3275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#a11e2d55727161e4430e3de6a5ecc3275">More...</a><br /></td></tr>
<tr class="separator:a11e2d55727161e4430e3de6a5ecc3275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf67a93627ccd787e3bfc7529084a70c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#acf67a93627ccd787e3bfc7529084a70c">setValue</a> (<a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:acf67a93627ccd787e3bfc7529084a70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#acf67a93627ccd787e3bfc7529084a70c">More...</a><br /></td></tr>
<tr class="separator:acf67a93627ccd787e3bfc7529084a70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004b94a724e372beb5f476864fc2f07f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a004b94a724e372beb5f476864fc2f07f">setValue</a> (LevelData&lt; MFFluxFAB &gt; &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:a004b94a724e372beb5f476864fc2f07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#a004b94a724e372beb5f476864fc2f07f">More...</a><br /></td></tr>
<tr class="separator:a004b94a724e372beb5f476864fc2f07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe05846e18cde903a168acc347de337b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#afe05846e18cde903a168acc347de337b">setValue</a> (<a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:afe05846e18cde903a168acc347de337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#afe05846e18cde903a168acc347de337b">More...</a><br /></td></tr>
<tr class="separator:afe05846e18cde903a168acc347de337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d85f173b863a6387ae1a22fd19c3b1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ab6d85f173b863a6387ae1a22fd19c3b1">setValue</a> (LevelData&lt; <a class="el" href="classMFBaseIVFAB.html">MFBaseIVFAB</a> &gt; &amp;a_lhs, const Real &amp;a_value)</td></tr>
<tr class="memdesc:ab6d85f173b863a6387ae1a22fd19c3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#ab6d85f173b863a6387ae1a22fd19c3b1">More...</a><br /></td></tr>
<tr class="separator:ab6d85f173b863a6387ae1a22fd19c3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c60f5d12db82f9fe05c09b23df8a75"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ae7c60f5d12db82f9fe05c09b23df8a75">setValue</a> (<a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:ae7c60f5d12db82f9fe05c09b23df8a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#ae7c60f5d12db82f9fe05c09b23df8a75">More...</a><br /></td></tr>
<tr class="separator:ae7c60f5d12db82f9fe05c09b23df8a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84a475f273ba9cb34375581bebe5e9f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad84a475f273ba9cb34375581bebe5e9f">setValue</a> (LevelData&lt; <a class="el" href="classDomainFluxIFFAB.html">DomainFluxIFFAB</a> &gt; &amp;a_lhs, const Real a_value)</td></tr>
<tr class="memdesc:ad84a475f273ba9cb34375581bebe5e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value in data.  <a href="classDataOps.html#ad84a475f273ba9cb34375581bebe5e9f">More...</a><br /></td></tr>
<tr class="separator:ad84a475f273ba9cb34375581bebe5e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ee9a6beae5fe39e0f58189b50ffded"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a82ee9a6beae5fe39e0f58189b50ffded">sum</a> (Real &amp;a_value)</td></tr>
<tr class="memdesc:a82ee9a6beae5fe39e0f58189b50ffded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the input value.  <a href="classDataOps.html#a82ee9a6beae5fe39e0f58189b50ffded">More...</a><br /></td></tr>
<tr class="separator:a82ee9a6beae5fe39e0f58189b50ffded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41975c91646bbb7ecd30af180167897f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a41975c91646bbb7ecd30af180167897f">squareRoot</a> (<a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;a_lhs)</td></tr>
<tr class="memdesc:a41975c91646bbb7ecd30af180167897f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of the input data.  <a href="classDataOps.html#a41975c91646bbb7ecd30af180167897f">More...</a><br /></td></tr>
<tr class="separator:a41975c91646bbb7ecd30af180167897f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26000910520cee19d4e09c75eeb2a23b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a26000910520cee19d4e09c75eeb2a23b">squareRoot</a> (LevelData&lt; EBFluxFAB &gt; &amp;a_lhs)</td></tr>
<tr class="memdesc:a26000910520cee19d4e09c75eeb2a23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square root of the input data.  <a href="classDataOps.html#a26000910520cee19d4e09c75eeb2a23b">More...</a><br /></td></tr>
<tr class="separator:a26000910520cee19d4e09c75eeb2a23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db420704c57abcd062e11d4594b5acf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a2db420704c57abcd062e11d4594b5acf">vectorLength</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs)</td></tr>
<tr class="memdesc:a2db420704c57abcd062e11d4594b5acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vector length of a data holder. Sets a_lhs = |a_rhs| where a_rhs contains SpaceDim components.  <a href="classDataOps.html#a2db420704c57abcd062e11d4594b5acf">More...</a><br /></td></tr>
<tr class="separator:a2db420704c57abcd062e11d4594b5acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f9de8e4dbd6001cc45aec8080c939"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a656f9de8e4dbd6001cc45aec8080c939">vectorLength</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs)</td></tr>
<tr class="memdesc:a656f9de8e4dbd6001cc45aec8080c939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vector length of a data holder. Sets a_lhs = |a_rhs| where a_rhs contains SpaceDim components.  <a href="classDataOps.html#a656f9de8e4dbd6001cc45aec8080c939">More...</a><br /></td></tr>
<tr class="separator:a656f9de8e4dbd6001cc45aec8080c939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720e37f1e4af8543d68ef52b4a52f86b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a720e37f1e4af8543d68ef52b4a52f86b">vectorLength</a> (EBCellFAB &amp;a_lhs, const EBCellFAB &amp;a_rhs, const Box &amp;box)</td></tr>
<tr class="memdesc:a720e37f1e4af8543d68ef52b4a52f86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vector length of a data holder. Sets a_lhs = |a_rhs| where a_rhs contains SpaceDim components.  <a href="classDataOps.html#a720e37f1e4af8543d68ef52b4a52f86b">More...</a><br /></td></tr>
<tr class="separator:a720e37f1e4af8543d68ef52b4a52f86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e0acad3fbc0a68ad44806858e4ef7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#af76e0acad3fbc0a68ad44806858e4ef7">vectorLength2</a> (<a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_lhs, const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;a_rhs)</td></tr>
<tr class="memdesc:af76e0acad3fbc0a68ad44806858e4ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared vector length of a data holder. Sets a_lhs = |a_rhs|^2 where a_rhs contains SpaceDim components.  <a href="classDataOps.html#af76e0acad3fbc0a68ad44806858e4ef7">More...</a><br /></td></tr>
<tr class="separator:af76e0acad3fbc0a68ad44806858e4ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa612159193303d55e680a0aecdb9ac2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#aa612159193303d55e680a0aecdb9ac2b">vectorLength2</a> (LevelData&lt; EBCellFAB &gt; &amp;a_lhs, const LevelData&lt; EBCellFAB &gt; &amp;a_rhs)</td></tr>
<tr class="memdesc:aa612159193303d55e680a0aecdb9ac2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared vector length of a data holder. Sets a_lhs = |a_rhs|^2 where a_rhs contains SpaceDim components.  <a href="classDataOps.html#aa612159193303d55e680a0aecdb9ac2b">More...</a><br /></td></tr>
<tr class="separator:aa612159193303d55e680a0aecdb9ac2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ac60f55f833ba88fc2c10fdfd5445e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ad0ac60f55f833ba88fc2c10fdfd5445e">vectorLength2</a> (EBCellFAB &amp;a_lhs, const EBCellFAB &amp;a_rhs, const Box &amp;box)</td></tr>
<tr class="memdesc:ad0ac60f55f833ba88fc2c10fdfd5445e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared vector length of a data holder. Sets a_lhs = |a_rhs|^2 where a_rhs contains SpaceDim components.  <a href="classDataOps.html#ad0ac60f55f833ba88fc2c10fdfd5445e">More...</a><br /></td></tr>
<tr class="separator:ad0ac60f55f833ba88fc2c10fdfd5445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f9a265ea9e8feb9ffddbb66d674811"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a58f9a265ea9e8feb9ffddbb66d674811">computeMinValidBox</a> (RealVect &amp;a_lo, RealVect &amp;a_hi, const RealVect a_normal, const RealVect a_centroid)</td></tr>
<tr class="memdesc:a58f9a265ea9e8feb9ffddbb66d674811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tightest possible valid box around a cut-cell volume.  <a href="classDataOps.html#a58f9a265ea9e8feb9ffddbb66d674811">More...</a><br /></td></tr>
<tr class="separator:a58f9a265ea9e8feb9ffddbb66d674811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21f9cca03ec5e975a05e304584acb7e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#ac21f9cca03ec5e975a05e304584acb7e">allCornersInsideEb</a> (const Vector&lt; RealVect &gt; &amp;a_corners, const RealVect a_normal, const RealVect a_centroid)</td></tr>
<tr class="memdesc:ac21f9cca03ec5e975a05e304584acb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all corners/points are inside an EB.  <a href="classDataOps.html#ac21f9cca03ec5e975a05e304584acb7e">More...</a><br /></td></tr>
<tr class="separator:ac21f9cca03ec5e975a05e304584acb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d602876ceed2278fc4e94ddabcb5a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOps.html#a62d602876ceed2278fc4e94ddabcb5a0">shiftCorners</a> (Vector&lt; RealVect &gt; &amp;a_corners, const RealVect &amp;a_distance)</td></tr>
<tr class="memdesc:a62d602876ceed2278fc4e94ddabcb5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift pointes by a specified distance.  <a href="classDataOps.html#a62d602876ceed2278fc4e94ddabcb5a0">More...</a><br /></td></tr>
<tr class="separator:a62d602876ceed2278fc4e94ddabcb5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Agglomeration of useful data operations. </p>
<dl class="section note"><dt>Note</dt><dd>All methods in this class assumes that data are allocated over the same realm. If you are trying to do something across realms, you need to copy the data onto realms that lie on the same data holders first!. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac21f9cca03ec5e975a05e304584acb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21f9cca03ec5e975a05e304584acb7e">&#9670;&nbsp;</a></span>allCornersInsideEb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DataOps::allCornersInsideEb </td>
          <td>(</td>
          <td class="paramtype">const Vector&lt; RealVect &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all corners/points are inside an EB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_corner</td><td>Corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_normal</td><td>EB face normal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_centroid</td><td>EB centroid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if all points are inside the EB and false otherwise. </dd></dl>

</div>
</div>
<a id="af6e607a3cb21f0528af1d61cc9d29bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e607a3cb21f0528af1d61cc9d29bda">&#9670;&nbsp;</a></span>averageCellToFace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::averageCellToFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_faceData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; ProblemDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average all components of the cell-centered data to faces. </p>
<p>Calls the other version; uses arihtmetic averaging and does not fill ghost faces. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_faceData</td><td>Face data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellData</td><td>Cell data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domains</td><td>AMR domains. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does not fill "tangential" ghost faces. </dd></dl>

</div>
</div>
<a id="ad1b238b21e8f218986e9214a2af25227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b238b21e8f218986e9214a2af25227">&#9670;&nbsp;</a></span>averageCellToFace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::averageCellToFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_faceData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; ProblemDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_tanGhosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval &amp;&#160;</td>
          <td class="paramname"><em>a_faceVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval &amp;&#160;</td>
          <td class="paramname"><em>a_cellVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Routine which averages a cell-centered component to faces. </p>
<p>User can choose what type of averaging to use, as well as choosing the number of ghost face to fill. These faces are "tangential ghost faces", i.e. if the face direction is along +x, we extend the box with faces in the y- and z- directions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_faceData</td><td>Face data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellData</td><td>Cell data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domain</td><td>Problem domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tanGhost</td><td>Number of ghost faces to fill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_faceVars</td><td>Face variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellVars</td><td>Cell variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac639022efff04463bb98209dad057c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac639022efff04463bb98209dad057c65">&#9670;&nbsp;</a></span>averageCellToFace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::averageCellToFace </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_faceData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_cellData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProblemDomain &amp;&#160;</td>
          <td class="paramname"><em>a_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_tanGhosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval &amp;&#160;</td>
          <td class="paramname"><em>a_faceVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval &amp;&#160;</td>
          <td class="paramname"><em>a_cellVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="CD__Average_8H.html#ad98181732ac62b1b3b276f48772349c4">Average</a> &amp;&#160;</td>
          <td class="paramname"><em>a_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Routine which averages a cell-centered component to faces. </p>
<p>User can choose what type of averaging to use, as well as choosing the number of ghost face to fill. These faces are "tangential ghost faces", i.e. if the face direction is along +x, we extend the box with faces in the y- and z- directions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_faceData</td><td>Face data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellData</td><td>Cell data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domain</td><td>Problem domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tanGhost</td><td>Number of ghost faces to fill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_faceVars</td><td>Face variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellVars</td><td>Cell variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_average</td><td>Averaging method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0125dcf3865e53b410f74962034ce91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0125dcf3865e53b410f74962034ce91f">&#9670;&nbsp;</a></span>averageCellVelocityToFaceVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::averageCellVelocityToFaceVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_faceData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; ProblemDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_tanGhosts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Routine which computes the average of a cell-centered quantity on faces for the normal component only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_faceData</td><td>Face data. Must have one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellData</td><td>Cell data. Must have SpaceDim components. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domains</td><td>AMR domains. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tanGhost</td><td>Number of ghost faces to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0a305958f894d18dedbf15f4a08469f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a305958f894d18dedbf15f4a08469f">&#9670;&nbsp;</a></span>averageCellVelocityToFaceVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::averageCellVelocityToFaceVelocity </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_faceData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_cellData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProblemDomain &amp;&#160;</td>
          <td class="paramname"><em>a_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_tanGhosts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Routine which computes the average of a cell-centered quantity on faces for the normal component only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_faceData</td><td>Face data. Must have one component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_cellData</td><td>Cell data. Must have SpaceDim components. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domain</td><td>Problem domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_tanGhost</td><td>Number of ghost faces to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c8a8a9e9723b81eb87b5a4a952ca9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8a8a9e9723b81eb87b5a4a952ca9de">&#9670;&nbsp;</a></span>averageFaceToCell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::averageFaceToCell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_cellData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_fluxData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; ProblemDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_domains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average all components of face centered data to cell centers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_cellData</td><td>Cell data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[int]</td><td>a_faceData Face data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domains</td><td>AMR domains. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only valid cells are filled (not ghost cells) </dd></dl>

</div>
</div>
<a id="ae0b2f78fdee7dfd457d03da57a1fabb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b2f78fdee7dfd457d03da57a1fabb1">&#9670;&nbsp;</a></span>averageFaceToCell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::averageFaceToCell </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_cellData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_fluxData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProblemDomain &amp;&#160;</td>
          <td class="paramname"><em>a_domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average all components of face centered data to cell centers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_cellData</td><td>Cell data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[int]</td><td>a_faceData Face data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_domains</td><td>Domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only valid cells are filled (not ghost cells) </dd></dl>

</div>
</div>
<a id="a380921f9b664379fc6738dffdfe6bfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380921f9b664379fc6738dffdfe6bfcd">&#9670;&nbsp;</a></span>compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::compute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const Real a_cellValue)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a new value given the old cell value. </p>
<p>Useful for quickly calculating a cell value as e.g. exp(x) where the original data was only x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_func</td><td>Function for transforming the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26172cef3ac6df3e23499d67de2c31b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26172cef3ac6df3e23499d67de2c31b9">&#9670;&nbsp;</a></span>compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::compute </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const Real a_cellValue)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a new value given the old cell value. </p>
<p>Useful for quickly calculating a cell value as e.g. exp(x) where the original data was only x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_func</td><td>Function for transforming the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58f9a265ea9e8feb9ffddbb66d674811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f9a265ea9e8feb9ffddbb66d674811">&#9670;&nbsp;</a></span>computeMinValidBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::computeMinValidBox </td>
          <td>(</td>
          <td class="paramtype">RealVect &amp;&#160;</td>
          <td class="paramname"><em>a_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVect &amp;&#160;</td>
          <td class="paramname"><em>a_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_centroid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the tightest possible valid box around a cut-cell volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lo</td><td>Low corner </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_hi</td><td>High corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_normal</td><td>EB face normal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_centroid</td><td>EB centroid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5716697fdd8d4f494d8f35cd5ef9777d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5716697fdd8d4f494d8f35cd5ef9777d">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from one data holder to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_dst</td><td>Destination data holder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_src</td><td>Source data holder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8098fcedc68a9105187d5e0696b321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8098fcedc68a9105187d5e0696b321e">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval&#160;</td>
          <td class="paramname"><em>a_dstInterv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interval&#160;</td>
          <td class="paramname"><em>a_srcInterv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from one data holder to another. Allows specification of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_dst</td><td>Destination data holder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_src</td><td>Source data holder </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_dstInterv</td><td>Destination data component </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_srcInterv</td><td>Source data components </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25a4550420d098d1e1bd77fdb88a7182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a4550420d098d1e1bd77fdb88a7182">&#9670;&nbsp;</a></span>copy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from one data holder to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_dst</td><td>Destination data holder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_src</td><td>Source data holder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9695c22d415df5658913bd9de3aade3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9695c22d415df5658913bd9de3aade3">&#9670;&nbsp;</a></span>copy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from one data holder to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_dst</td><td>Destination data holder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_src</td><td>Source data holder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a506dc21e62a8c1aeccbc16803b44c284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506dc21e62a8c1aeccbc16803b44c284">&#9670;&nbsp;</a></span>divide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lhsComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_rhsComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide one data holder by another. Does specified components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be divided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Divisor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lhsComp</td><td>Destination data component </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhsComp</td><td>Source data component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a479ec23a25a7349f4c9c943bad789fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479ec23a25a7349f4c9c943bad789fa2">&#9670;&nbsp;</a></span>divide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::divide </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_lhsComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_rhsComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide one data holder by another. Does specified components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be divided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Divisor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lhsComp</td><td>Destination data component </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhsComp</td><td>Source data component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a633190f7c7b99ec502349854875beccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633190f7c7b99ec502349854875beccf">&#9670;&nbsp;</a></span>divideByScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::divideByScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide all components in a data holder by a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be divided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Divisor. Must have exactly one component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0b251c20524ce05127d4b8fbaf00fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b251c20524ce05127d4b8fbaf00fd5">&#9670;&nbsp;</a></span>divideByScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::divideByScalar </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide all components in a data holder by a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be divided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Divisor. Must have exactly one component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacb2d0e8071428af765ab335dc363a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb2d0e8071428af765ab335dc363a08">&#9670;&nbsp;</a></span>divideFallback() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::divideFallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_denominator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_fallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide data. If the denominator is zero, set the value to a fallback option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_numerator</td><td>Dividend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_denominator</td><td>Divisor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fallback</td><td>Fallback data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f23fc2c3618349b37259125fb40dbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f23fc2c3618349b37259125fb40dbce">&#9670;&nbsp;</a></span>divideFallback() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::divideFallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_denominator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_fallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide data. If the denominator is zero, set the value to a fallback option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_numerator</td><td>Dividend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_denominator</td><td>Divisor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fallback</td><td>Fallback value in case denominator is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76f4ef9b6dd3ce711552a93ae448b6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f4ef9b6dd3ce711552a93ae448b6a4">&#9670;&nbsp;</a></span>divideFallback() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::divideFallback </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_denominator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_fallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide data. If the denominator is zero, set the value to a fallback option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_numerator</td><td>Dividend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_denominator</td><td>Divisor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fallback</td><td>Fallback data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components. </dd></dl>

</div>
</div>
<a id="a1e789c7302d1d3f984c3d59007fe6072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e789c7302d1d3f984c3d59007fe6072">&#9670;&nbsp;</a></span>divideFallback() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::divideFallback </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_denominator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_fallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide data. If the denominator is zero, set the value to a fallback option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_numerator</td><td>Dividend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_denominator</td><td>Divisor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_fallback</td><td>Fallback value in case denominator is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components. </dd></dl>

</div>
</div>
<a id="ab2aa61abb2b7ad935fe13bc1a3a36e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2aa61abb2b7ad935fe13bc1a3a36e55">&#9670;&nbsp;</a></span>dotProduct() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::dotProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compote the cell-wise dot product between two data holders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_result</td><td>Result. Holds the dot product in each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data1</td><td>First data holder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data2</td><td>Other data holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The input data data1 and data2 must have the same number of input components. Summation is done over all components (does not have to be SpaceDim). </dd></dl>

</div>
</div>
<a id="a12a46d6c23aeeb3c5122acb6a87b92ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a46d6c23aeeb3c5122acb6a87b92ae">&#9670;&nbsp;</a></span>dotProduct() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::dotProduct </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_data2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a_box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compote the cell-wise dot product between two data holders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_result</td><td>Result. Holds the dot product in each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data1</td><td>First data holder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data2</td><td>Other data holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The input data data1 and data2 must have the same number of input components. Summation is done over all components (does not have to be SpaceDim). </dd></dl>

</div>
</div>
<a id="a0bfcb77c051d0d3457dd0db7ec967ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfcb77c051d0d3457dd0db7ec967ddd">&#9670;&nbsp;</a></span>dotProduct() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::dotProduct </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compote the cell-wise dot product between two data holders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_result</td><td>Result. Holds the dot product in each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data1</td><td>First data holder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data2</td><td>Other data holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The input data data1 and data2 must have the same number of input components. Summation is done over all components (does not have to be SpaceDim). </dd></dl>

</div>
</div>
<a id="a87c8998faa8838dbbcd0156b98790e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c8998faa8838dbbcd0156b98790e44">&#9670;&nbsp;</a></span>dotProduct() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::dotProduct </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compote the cell-wise dot product between two data holders. </p>
<p>This calls the single-phase dotProduct patch versions with EBCellFABs on each phase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_result</td><td>Result. Holds the dot product in each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data1</td><td>First data holder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data2</td><td>Other data holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The input data data1 and data2 must have the same number of input components. Summation is done over all components (does not have to be SpaceDim). </dd></dl>

</div>
</div>
<a id="ab9a534acad1c2edb95b95fd89ccaa156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a534acad1c2edb95b95fd89ccaa156">&#9670;&nbsp;</a></span>dotProduct() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::dotProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compote the cell-wise dot product between two data holders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_result</td><td>Result. Holds the dot product in each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data1</td><td>First data holder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data2</td><td>Other data holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The input data data1 and data2 must have the same number of input components. Summation is done over all components (does not have to be SpaceDim). </dd></dl>

</div>
</div>
<a id="a505cd90f96964992607c08e02c845170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505cd90f96964992607c08e02c845170">&#9670;&nbsp;</a></span>filterSmooth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::filterSmooth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_zeroEB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a convolved filter phi = alpha * phi_i + 0.5*(1-alpha) * [phi_(i+s) + phi_(i-s)] in each direction. </p>
<p>Ghost cells and coarsening must be done before entering this routine </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_alpha</td><td>Filter factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_stride</td><td>Cell stride s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_zeroEB</td><td>Set value in covered cells to zero or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will fill ghost cells outside the domain boundary, but ignore the corner ghost cells at the domain corners. This routine may be dangerous to use with EBs as the data inside the EB is either kept as-is or replaced by zero. </dd></dl>

</div>
</div>
<a id="ac0cf66aa022399705b36d49cad9b4de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cf66aa022399705b36d49cad9b4de9">&#9670;&nbsp;</a></span>filterSmooth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::filterSmooth </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>a_zeroEB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a convolved filter phi = alpha * phi_i + 0.5*(1-alpha) * [phi_(i+s) + phi_(i-s)] in each direction. </p>
<p>Ghost cells must be updated before entering this routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_alpha</td><td>Filter factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_stride</td><td>Cell stride s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_zeroEB</td><td>Set value in covered cells to zero or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine will fill ghost cells outside the domain boundary, but ignore the corner ghost cells at the domain corners. This routine may be dangerous to use with EBs as the data inside the EB is either kept as-is or replaced by zero. </dd></dl>

</div>
</div>
<a id="a3b79c45f70a1b587edef171ae37cfc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b79c45f70a1b587edef171ae37cfc3f">&#9670;&nbsp;</a></span>floor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Floor values in data holder. This sets all values below a_value to a_value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be floored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Floor value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Also floors ghost cells. </dd></dl>

</div>
</div>
<a id="a778aec86d833f1963fb2962f99913286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778aec86d833f1963fb2962f99913286">&#9670;&nbsp;</a></span>floor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Floor values in data holder. This sets all values below a_value to a_value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be floored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Floor value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Also floors ghost cells. </dd></dl>

</div>
</div>
<a id="aae1a49a9cd876da89e3e3bef4c2bc1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1a49a9cd876da89e3e3bef4c2bc1b7">&#9670;&nbsp;</a></span>floor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::floor </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Floor values in data holder. This sets all values below a_value to a_value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be floored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Floor value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Also floors ghost cells. </dd></dl>

</div>
</div>
<a id="ae3e303c4b9aac749c6c82b7378751546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e303c4b9aac749c6c82b7378751546">&#9670;&nbsp;</a></span>floor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::floor </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Floor values in data holder. This sets all values below a_value to a_value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be floored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Floor value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Also floors ghost cells. </dd></dl>

</div>
</div>
<a id="a5de2e0bae557d084310a1991f183d339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de2e0bae557d084310a1991f183d339">&#9670;&nbsp;</a></span>getMaxMin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::getMaxMin </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum and minimum value of specified component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_max</td><td>Maximum value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_min</td><td>Minium value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Cell-centered data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does the calculation over all levels, including grids that is covered by other grids. </dd></dl>

</div>
</div>
<a id="ac9670a14cbaddb9258b7b7740e152d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9670a14cbaddb9258b7b7740e152d11">&#9670;&nbsp;</a></span>getMaxMin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::getMaxMin </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum and minimum value of specified component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_max</td><td>Maximum value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_min</td><td>Minium value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Cell-centered data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37af20b672ebecacc0bfd111ce11aadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37af20b672ebecacc0bfd111ce11aadb">&#9670;&nbsp;</a></span>getMaxMin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::getMaxMin </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum and minimum value. Assumes single-component data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_max</td><td>Maximum value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_min</td><td>Minium value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Cell-centered data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does the calculation over all levels, including grids that is covered by other grids. </dd></dl>

</div>
</div>
<a id="a323f11e992c657224003ab61e6680c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323f11e992c657224003ab61e6680c11">&#9670;&nbsp;</a></span>getMaxMinNorm() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::getMaxMinNorm </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum and minimum value of normed data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_max</td><td>Maximum value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_min</td><td>Minium value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Cell-centered data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does the calculation over all levels, including grids that is covered by other grids. </dd></dl>

</div>
</div>
<a id="a1e3ce9b44348e95885c403dfe72c1f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3ce9b44348e95885c403dfe72c1f36">&#9670;&nbsp;</a></span>getMaxMinNorm() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::getMaxMinNorm </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum and minimum value of normed data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_max</td><td>Maximum value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_min</td><td>Minium value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Cell-centered data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does the calculation over all levels, including grids that is covered by other grids. </dd></dl>

</div>
</div>
<a id="a27fb473dc78a9389a3120d73380478e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fb473dc78a9389a3120d73380478e2">&#9670;&nbsp;</a></span>getMaxMinNorm() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::getMaxMinNorm </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum and minimum value of normed data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_max</td><td>Maximum value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_min</td><td>Minium value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Cell-centered data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca2a03862cae1159b56c451397eb17da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2a03862cae1159b56c451397eb17da">&#9670;&nbsp;</a></span>getMaxMinNorm() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::getMaxMinNorm </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum and minimum value of normed data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_max</td><td>Maximum value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_min</td><td>Minium value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Cell-centered data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a286804b303d4c74fdcb79ea20522b745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286804b303d4c74fdcb79ea20522b745">&#9670;&nbsp;</a></span>incr() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad21405f73fb2cb46485b92fa3aafcd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21405f73fb2cb46485b92fa3aafcd83">&#9670;&nbsp;</a></span>incr() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<p>This versions only adds irregular data from an EBAMRIVFAB. It ignores regular cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f3b52c379710ee0e21bf3af2f63b1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3b52c379710ee0e21bf3af2f63b1e8">&#9670;&nbsp;</a></span>incr() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad239c1d43ded952a79e1d29b6c2f6944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad239c1d43ded952a79e1d29b6c2f6944">&#9670;&nbsp;</a></span>incr() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a406474f3ade41f61c4b98eb723078b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406474f3ade41f61c4b98eb723078b6a">&#9670;&nbsp;</a></span>incr() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<p>This versions only adds irregular data form an EBCellFAB to an BaseIVFAB. It ignores regular cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5844899601a61593b56e3854d9f46c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5844899601a61593b56e3854d9f46c6">&#9670;&nbsp;</a></span>incr() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf6a94d62d0ebe552762342af00e2886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6a94d62d0ebe552762342af00e2886">&#9670;&nbsp;</a></span>incr() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype">EBFluxFAB &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBFluxFAB &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f4fd99c841261c069cc120236b753ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4fd99c841261c069cc120236b753ab">&#9670;&nbsp;</a></span>incr() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c733f245c10e9c172e3d9424ab4fd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c733f245c10e9c172e3d9424ab4fd98">&#9670;&nbsp;</a></span>incr() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<p>This versions only adds irregular data form an EBCellFAB to an BaseIVFAB. It ignores regular cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7375f2009e0cebaad7bf76b3316ffc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7375f2009e0cebaad7bf76b3316ffc0">&#9670;&nbsp;</a></span>incr() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; <a class="el" href="classDomainFluxIFFAB.html">DomainFluxIFFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; <a class="el" href="classDomainFluxIFFAB.html">DomainFluxIFFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c85212dd696e4eb7520c21b00df6cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c85212dd696e4eb7520c21b00df6cb1">&#9670;&nbsp;</a></span>incr() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<p>This versions only adds irregular data from an EBAMRIVFAB. It ignores regular cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbd55a67f0ab7f80a053c71dffed1413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd55a67f0ab7f80a053c71dffed1413">&#9670;&nbsp;</a></span>incr() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50f432a0768436d5dd6c3575acce3435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f432a0768436d5dd6c3575acce3435">&#9670;&nbsp;</a></span>incr() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad378bfb45533d3cff03d5f38d0175286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad378bfb45533d3cff03d5f38d0175286">&#9670;&nbsp;</a></span>incr() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77d3d9b487c6182b3941fcab221e727f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d3d9b487c6182b3941fcab221e727f">&#9670;&nbsp;</a></span>incr() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function which increments data in the form a_lhs = a_lhs + a_rhs*a_scale for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be incremented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Incrementation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8df0470b182aca8787328d40569b887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8df0470b182aca8787328d40569b887">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>to be inverted. On output we have a_data = 1/a_data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components and does not guard against division by zero. </dd></dl>

</div>
</div>
<a id="a7efeac6bdd32a2b7de5e1be30c7dab88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efeac6bdd32a2b7de5e1be30c7dab88">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DataOps::invert </td>
          <td>(</td>
          <td class="paramtype">EBFluxFAB &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>to be inverted. On output we have a_data = 1/a_data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components and does not guard against division by zero. </dd></dl>

</div>
</div>
<a id="a0ecafa38c8ae9c3bceb9cca1e6f41fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecafa38c8ae9c3bceb9cca1e6f41fc4">&#9670;&nbsp;</a></span>invert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::invert </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Data</td><td>to be inverted. On output we have a_data = 1/a_data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components and does not guard against division by zero. </dd></dl>

</div>
</div>
<a id="a1139f7cd961f218905b627acc8a19e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1139f7cd961f218905b627acc8a19e2e">&#9670;&nbsp;</a></span>kappaScale() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::kappaScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by volume fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be scaled. On output we have a_data = kappa * a_data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2937f528899e9f13ec2244e366514c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2937f528899e9f13ec2244e366514c1e">&#9670;&nbsp;</a></span>kappaScale() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::kappaScale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by volume fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be scaled. On output we have a_data = kappa * a_data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b4e399aab0ca657b6c746eaf99807f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4e399aab0ca657b6c746eaf99807f8">&#9670;&nbsp;</a></span>kappaScale() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::kappaScale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by volume fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be scaled. On output we have a_data = kappa * a_data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cb248476bdb7363b0220cfc8e7e69c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb248476bdb7363b0220cfc8e7e69c5">&#9670;&nbsp;</a></span>kappaScale() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::kappaScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by volume fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be scaled. On output we have a_data = kappa * a_data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4261230f2d9ceb036ad1294b8f947d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4261230f2d9ceb036ad1294b8f947d0">&#9670;&nbsp;</a></span>kappaSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::kappaSum </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the kappa-weighted sum of the input data. Assumes one component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_mass</td><td>Total mass, computed as kappa * lhs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lhs</td><td>Cell data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55267a7e87eb9baa3306b3a5856553cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55267a7e87eb9baa3306b3a5856553cd">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a_data = max(a_data1, a_data2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Output data. Will be max(a_data1, a_data2) in every cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data1</td><td>Input data holder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data2</td><td>Input data holder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac08f7f4e51cda580cfa00a7780b00775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08f7f4e51cda580cfa00a7780b00775">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::max </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a_data = max(a_data1, a_data2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_data</td><td>Output data. Will be max(a_data1, a_data2) in every cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data1</td><td>Input data holder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data2</td><td>Input data holder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72685cbfeebb9d46777890fbf5a0b3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72685cbfeebb9d46777890fbf5a0b3e6">&#9670;&nbsp;</a></span>multiply() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components </dd></dl>

</div>
</div>
<a id="a1efd55f250957e1a8134a75c1b070c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efd55f250957e1a8134a75c1b070c01">&#9670;&nbsp;</a></span>multiply() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components </dd></dl>

</div>
</div>
<a id="a2e82a4cea51da220dc78684fe897dcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e82a4cea51da220dc78684fe897dcce">&#9670;&nbsp;</a></span>multiply() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components </dd></dl>

</div>
</div>
<a id="a2c721845ac943dbe2470334a9767a6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c721845ac943dbe2470334a9767a6d5">&#9670;&nbsp;</a></span>multiply() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiply </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components </dd></dl>

</div>
</div>
<a id="a1208055ecb1c07f59713e9d071d43a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1208055ecb1c07f59713e9d071d43a03">&#9670;&nbsp;</a></span>multiply() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiply </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components </dd></dl>

</div>
</div>
<a id="ad1db0f9d0037ea500a6b892db88cf311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1db0f9d0037ea500a6b892db88cf311">&#9670;&nbsp;</a></span>multiply() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiply </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does all components </dd></dl>

</div>
</div>
<a id="aff01271b712d6dd72dbdd40f2c33a001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff01271b712d6dd72dbdd40f2c33a001">&#9670;&nbsp;</a></span>multiplyScalar() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiplyScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This multiplies all components in a_lhs with the single component in a_rhs </dd></dl>

</div>
</div>
<a id="a6b2e5e74146775c916a97582d3b44865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2e5e74146775c916a97582d3b44865">&#9670;&nbsp;</a></span>multiplyScalar() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiplyScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This multiplies all components in a_lhs with the single component in a_rhs </dd></dl>

</div>
</div>
<a id="acb637ca465e480d7bad3130d4f2f8b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb637ca465e480d7bad3130d4f2f8b8d">&#9670;&nbsp;</a></span>multiplyScalar() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiplyScalar </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This multiplies all components in a_lhs with the single component in a_rhs </dd></dl>

</div>
</div>
<a id="ae960c5190d2423bb4247bb6c58516e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae960c5190d2423bb4247bb6c58516e4c">&#9670;&nbsp;</a></span>multiplyScalar() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::multiplyScalar </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply data holder by another data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This multiplies all components in a_lhs with the single component in a_rhs </dd></dl>

</div>
</div>
<a id="ad39cbfb09b48df4994c78f07b22c2a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39cbfb09b48df4994c78f07b22c2a8e">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real DataOps::norm </td>
          <td>(</td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute specified norm of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_data</td><td>Data to compute the norm of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_p</td><td>Norm factor, e.g. a_p = 2 =&gt; squared norm. 0 =&gt; inf norm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not do kappa-weighting; if user needs </dd></dl>

</div>
</div>
<a id="ae30f972ce853e2ffafba4cce6d27f40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30f972ce853e2ffafba4cce6d27f40d">&#9670;&nbsp;</a></span>plus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_srcComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_dstComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_numComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General addition operator for adding together data. The user can choose which components to add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Output data component </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_rhs</td><td>Data to be added to a_lhs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_srcComp</td><td>Component in a_rhs to add from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dstComp</td><td>Component in a_lhs to add into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numComp</td><td>Number of components to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will add a_lhs(a_dstComp + icomp) += a_rhs(a_srcComp + icomp) for icomp = 0,1,2,..numComp-1. </dd></dl>

</div>
</div>
<a id="a1d9897e0082692437768f37b5213d59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9897e0082692437768f37b5213d59c">&#9670;&nbsp;</a></span>plus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::plus </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_srcComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_dstComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_numComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General addition operator for adding together data. The user can choose which components to add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Output data component </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_rhs</td><td>Data to be added to a_lhs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_srcComp</td><td>Component in a_rhs to add from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dstComp</td><td>Component in a_lhs to add into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_numComp</td><td>Number of components to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will add a_lhs(a_dstComp + icomp) += a_rhs(a_srcComp + icomp) for icomp = 0,1,2,..numComp-1. </dd></dl>

</div>
</div>
<a id="ab9eecb9d5aa052cc3569b09e325909f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9eecb9d5aa052cc3569b09e325909f6">&#9670;&nbsp;</a></span>roof() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::roof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roof values in data holder. This sets all values above a_value to a_value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be roofed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Roof value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Also roofs ghost cells. </dd></dl>

</div>
</div>
<a id="afd25d01b1be678aea3023ec32631e51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd25d01b1be678aea3023ec32631e51d">&#9670;&nbsp;</a></span>roof() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::roof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roof values in data holder. This sets all values above a_value to a_value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be roofed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Roof value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Also roofs ghost cells. </dd></dl>

</div>
</div>
<a id="a44be6edb8a25b5d7c028f2286a2a095d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44be6edb8a25b5d7c028f2286a2a095d">&#9670;&nbsp;</a></span>roof() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::roof </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roof values in data holder. This sets all values above a_value to a_value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be roofed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Roof value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Also roofs ghost cells. </dd></dl>

</div>
</div>
<a id="a01754851bb2502eec69e140d53acacae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01754851bb2502eec69e140d53acacae">&#9670;&nbsp;</a></span>roof() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::roof </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roof values in data holder. This sets all values above a_value to a_value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be roofed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Roof value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Also roofs ghost cells. </dd></dl>

</div>
</div>
<a id="a73881aa89a4288cd0120292991a005f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73881aa89a4288cd0120292991a005f2">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21800fc80d4cf5cc8e0813ba33d91bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21800fc80d4cf5cc8e0813ba33d91bfe">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4379faf3a9701f15c0ed16f549d048a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4379faf3a9701f15c0ed16f549d048a0">&#9670;&nbsp;</a></span>scale() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f39ac1b0ea74aaffccd68f1d9004b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f39ac1b0ea74aaffccd68f1d9004b1a">&#9670;&nbsp;</a></span>scale() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afddaf35e97f5d99bdbeea6312944e91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddaf35e97f5d99bdbeea6312944e91b">&#9670;&nbsp;</a></span>scale() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab0d0d7c6509da37eb18bbee323bfbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0d0d7c6509da37eb18bbee323bfbc6">&#9670;&nbsp;</a></span>scale() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae60cd8dc87c3127c81c5ec99aca333a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60cd8dc87c3127c81c5ec99aca333a8">&#9670;&nbsp;</a></span>scale() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8e6d037941dfb563e19c392d70b2d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e6d037941dfb563e19c392d70b2d1c">&#9670;&nbsp;</a></span>scale() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; MFFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accd8d88fb7786769bbdd16c39ee6637a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd8d88fb7786769bbdd16c39ee6637a">&#9670;&nbsp;</a></span>scale() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6605122661a344974cd6b0b540c50d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6605122661a344974cd6b0b540c50d96">&#9670;&nbsp;</a></span>scale() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data to be scaled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_scale</td><td>Scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a987ece8d8671b9165e74c1e204889061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987ece8d8671b9165e74c1e204889061">&#9670;&nbsp;</a></span>setCoveredValue() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setCoveredValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in covered cells. Does specified component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Input/output data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[ino]</td><td>a_comp Component to set </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[ino]</td><td>a_value Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa432e87a368830570a43a296990c74c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa432e87a368830570a43a296990c74c0">&#9670;&nbsp;</a></span>setCoveredValue() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setCoveredValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of setCoveredValue which does all component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value in covered grid cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12c8d0741771e046f92dd12d1171abbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c8d0741771e046f92dd12d1171abbe">&#9670;&nbsp;</a></span>setCoveredValue() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setCoveredValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in covered cells. Does specified component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Input/output data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[ino]</td><td>a_comp Component to set </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[ino]</td><td>a_value Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab902dba90673edace2259eb4581f66e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab902dba90673edace2259eb4581f66e7">&#9670;&nbsp;</a></span>setCoveredValue() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setCoveredValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of setCoveredValue which does all component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>Data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value in covered grid cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a575d4b28f80135f82786b19d8011faee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575d4b28f80135f82786b19d8011faee">&#9670;&nbsp;</a></span>setInvalidValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setInvalidValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_refRat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in cells that are covered by a finer grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>AMR data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_refRat</td><td>Refinement ratios between levels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set in cells covered by a finer grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b6eb9c0394ac7cb093edea27a5cf54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6eb9c0394ac7cb093edea27a5cf54c">&#9670;&nbsp;</a></span>setValue() <span class="overload">[1/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6aac5fe21299b5ada3a1c50433e01302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aac5fe21299b5ada3a1c50433e01302">&#9670;&nbsp;</a></span>setValue() <span class="overload">[2/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data with specified component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1ced551d676991dc16d64cdf345716c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ced551d676991dc16d64cdf345716c">&#9670;&nbsp;</a></span>setValue() <span class="overload">[3/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="ada7ce40d638c4dc1e639a37002d37063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7ce40d638c4dc1e639a37002d37063">&#9670;&nbsp;</a></span>setValue() <span class="overload">[4/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; RealVect(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Assumes that a_lhs has SpaceDim components and sets all those components from the input function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="a22b0187a50e5163bb0c25e21e18ccda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b0187a50e5163bb0c25e21e18ccda5">&#9670;&nbsp;</a></span>setValue() <span class="overload">[5/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0861dec163556964809620b18eaffad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0861dec163556964809620b18eaffad">&#9670;&nbsp;</a></span>setValue() <span class="overload">[6/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="ae7c60f5d12db82f9fe05c09b23df8a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c60f5d12db82f9fe05c09b23df8a75">&#9670;&nbsp;</a></span>setValue() <span class="overload">[7/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIFData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac245ba9f041399abc500abc70ed252a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac245ba9f041399abc500abc70ed252a1">&#9670;&nbsp;</a></span>setValue() <span class="overload">[8/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb6b3f9e61553e9f9d3466ac4d2371fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6b3f9e61553e9f9d3466ac4d2371fe">&#9670;&nbsp;</a></span>setValue() <span class="overload">[9/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="a70307222838211ad1a4cad28ed369c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70307222838211ad1a4cad28ed369c2d">&#9670;&nbsp;</a></span>setValue() <span class="overload">[10/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9ae0723549ff58593114317a85f4a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ae0723549ff58593114317a85f4a96">&#9670;&nbsp;</a></span>setValue() <span class="overload">[11/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; BaseIVFAB&lt; Real &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="ad84a475f273ba9cb34375581bebe5e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84a475f273ba9cb34375581bebe5e9f">&#9670;&nbsp;</a></span>setValue() <span class="overload">[12/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; <a class="el" href="classDomainFluxIFFAB.html">DomainFluxIFFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2af5a0e62dde48ec74cfde15fd501b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af5a0e62dde48ec74cfde15fd501b3d">&#9670;&nbsp;</a></span>setValue() <span class="overload">[13/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c536871304eebea8c09289eb0c7313c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c536871304eebea8c09289eb0c7313c">&#9670;&nbsp;</a></span>setValue() <span class="overload">[14/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data with specified component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed73b3e1b19f3242dde6169413e2e5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed73b3e1b19f3242dde6169413e2e5fa">&#9670;&nbsp;</a></span>setValue() <span class="overload">[15/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="a88842bda224e78bec3d37d365120f5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88842bda224e78bec3d37d365120f5bd">&#9670;&nbsp;</a></span>setValue() <span class="overload">[16/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; RealVect(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Assumes that a_lhs has SpaceDim components and sets all those components from the input function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="afe7b49942bb6ffd6bb1a1d7eec5ea169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7b49942bb6ffd6bb1a1d7eec5ea169">&#9670;&nbsp;</a></span>setValue() <span class="overload">[17/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66d1e024abafd6a12b9f655823389ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d1e024abafd6a12b9f655823389ef1">&#9670;&nbsp;</a></span>setValue() <span class="overload">[18/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="ab6d85f173b863a6387ae1a22fd19c3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d85f173b863a6387ae1a22fd19c3b1">&#9670;&nbsp;</a></span>setValue() <span class="overload">[19/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; <a class="el" href="classMFBaseIVFAB.html">MFBaseIVFAB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11e2d55727161e4430e3de6a5ecc3275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e2d55727161e4430e3de6a5ecc3275">&#9670;&nbsp;</a></span>setValue() <span class="overload">[20/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af24c0d4d9a29d806bf6593fb710607c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24c0d4d9a29d806bf6593fb710607c1">&#9670;&nbsp;</a></span>setValue() <span class="overload">[21/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; MFCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="a004b94a724e372beb5f476864fc2f07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004b94a724e372beb5f476864fc2f07f">&#9670;&nbsp;</a></span>setValue() <span class="overload">[22/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; MFFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4429514331ff31eb2f7a0bfb896884e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4429514331ff31eb2f7a0bfb896884e3">&#9670;&nbsp;</a></span>setValue() <span class="overload">[23/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; <a class="el" href="classMFInterfaceFAB.html">MFInterfaceFAB</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in an <a class="el" href="classMFInterfaceFAB.html" title="Class for holding BaseIVFAB&lt;T&gt; on the interface between two phases.">MFInterfaceFAB</a> data holder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_lhs</td><td>Data holder </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb0d43ba9750041a999eb649b7f3aba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0d43ba9750041a999eb649b7f3aba8">&#9670;&nbsp;</a></span>setValue() <span class="overload">[24/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d07859f9bf92fdc259bf56226e2f1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d07859f9bf92fdc259bf56226e2f1f3">&#9670;&nbsp;</a></span>setValue() <span class="overload">[25/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Real(const RealVect)&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect&#160;</td>
          <td class="paramname"><em>a_probLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic set value function. Takes a spatially varying function and sets the value in the specified component from that function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_function</td><td>Function to use for setting the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_probLo</td><td>Lower-left corner of physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_dx</td><td>Grid resolutions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_comp</td><td>Component to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses a VofIterator everywhere to this might be slow! </dd></dl>

</div>
</div>
<a id="acf67a93627ccd787e3bfc7529084a70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf67a93627ccd787e3bfc7529084a70c">&#9670;&nbsp;</a></span>setValue() <span class="overload">[26/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe05846e18cde903a168acc347de337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe05846e18cde903a168acc347de337b">&#9670;&nbsp;</a></span>setValue() <span class="overload">[27/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">MFAMRIVData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value in data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Input/output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a431748ec65eb6252e0c8d5dcd380d858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431748ec65eb6252e0c8d5dcd380d858">&#9670;&nbsp;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DataOps::sgn </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign function. Returns +/- if the value is &gt; 0 or &lt; 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_value</td><td>Value to evaluate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62d602876ceed2278fc4e94ddabcb5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d602876ceed2278fc4e94ddabcb5a0">&#9670;&nbsp;</a></span>shiftCorners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::shiftCorners </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; RealVect &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVect &amp;&#160;</td>
          <td class="paramname"><em>a_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift pointes by a specified distance. </p>
<p>On output, every point in a_corners is shifted by a_distance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_corners</td><td>Points to be shifted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_distance</td><td>Shift vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41975c91646bbb7ecd30af180167897f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41975c91646bbb7ecd30af180167897f">&#9670;&nbsp;</a></span>squareRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::squareRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRFluxData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square root of the input data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>On output, contains sqrt(a_lhs) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not do ghosted faces. </dd></dl>

</div>
</div>
<a id="a26000910520cee19d4e09c75eeb2a23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26000910520cee19d4e09c75eeb2a23b">&#9670;&nbsp;</a></span>squareRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::squareRoot </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBFluxFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the square root of the input data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_lhs</td><td>On output, contains sqrt(a_lhs) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not do ghosted faces. </dd></dl>

</div>
</div>
<a id="a82ee9a6beae5fe39e0f58189b50ffded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ee9a6beae5fe39e0f58189b50ffded">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::sum </td>
          <td>(</td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>a_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of the input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_value</td><td>On output, contains the sum of a_value over all MPI processes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2db420704c57abcd062e11d4594b5acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db420704c57abcd062e11d4594b5acf">&#9670;&nbsp;</a></span>vectorLength() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::vectorLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the vector length of a data holder. Sets a_lhs = |a_rhs| where a_rhs contains SpaceDim components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_lhs must have one component and a_rhs must have SpaceDim components. </dd></dl>

</div>
</div>
<a id="a720e37f1e4af8543d68ef52b4a52f86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720e37f1e4af8543d68ef52b4a52f86b">&#9670;&nbsp;</a></span>vectorLength() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::vectorLength </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the vector length of a data holder. Sets a_lhs = |a_rhs| where a_rhs contains SpaceDim components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Vector length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Input vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_box</td><td>Computation box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_lhs must have one component and a_rhs must have SpaceDim components. </dd></dl>

</div>
</div>
<a id="a656f9de8e4dbd6001cc45aec8080c939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656f9de8e4dbd6001cc45aec8080c939">&#9670;&nbsp;</a></span>vectorLength() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::vectorLength </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the vector length of a data holder. Sets a_lhs = |a_rhs| where a_rhs contains SpaceDim components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_lhs must have one component and a_rhs must have SpaceDim components. </dd></dl>

</div>
</div>
<a id="af76e0acad3fbc0a68ad44806858e4ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76e0acad3fbc0a68ad44806858e4ef7">&#9670;&nbsp;</a></span>vectorLength2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::vectorLength2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the squared vector length of a data holder. Sets a_lhs = |a_rhs|^2 where a_rhs contains SpaceDim components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_lhs must have one component and a_rhs must have SpaceDim components. </dd></dl>

</div>
</div>
<a id="ad0ac60f55f833ba88fc2c10fdfd5445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ac60f55f833ba88fc2c10fdfd5445e">&#9670;&nbsp;</a></span>vectorLength2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::vectorLength2 </td>
          <td>(</td>
          <td class="paramtype">EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EBCellFAB &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the squared vector length of a data holder. Sets a_lhs = |a_rhs|^2 where a_rhs contains SpaceDim components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_lhs must have one component and a_rhs must have SpaceDim components. </dd></dl>

</div>
</div>
<a id="aa612159193303d55e680a0aecdb9ac2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa612159193303d55e680a0aecdb9ac2b">&#9670;&nbsp;</a></span>vectorLength2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::vectorLength2 </td>
          <td>(</td>
          <td class="paramtype">LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LevelData&lt; EBCellFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the squared vector length of a data holder. Sets a_lhs = |a_rhs|^2 where a_rhs contains SpaceDim components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a_lhs</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_rhs</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a_lhs must have one component and a_rhs must have SpaceDim components. </dd></dl>

</div>
</div>
<a id="a2b3e0e1adb30575c6a4342f5bb5931de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3e0e1adb30575c6a4342f5bb5931de">&#9670;&nbsp;</a></span>volumeScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataOps::volumeScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEBAMRData.html">EBAMRCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>a_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale data by dx^SpaceDim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a_data</td><td>Data to be scaled. On output we have a_data = dx^SpaceDim * a_data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/Utilities/<a class="el" href="CD__DataOps_8H_source.html">CD_DataOps.H</a></li>
<li>Source/Utilities/<a class="el" href="CD__DataOps_8cpp.html">CD_DataOps.cpp</a></li>
<li>Source/Utilities/<a class="el" href="CD__DataOpsImplem_8H_source.html">CD_DataOpsImplem.H</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
