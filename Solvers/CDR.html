<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Convection-Diffusion-Reaction &mdash; chombo-discharge  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Electrostatic solver" href="Electrostatics.html" />
    <link rel="prev" title="Verification and validation" href="../Source/VV.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> chombo-discharge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Documentation.html">Using this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Testing.html">Code testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Acknowledgements.html">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Source/DesignOverview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/CellTagger.html">CellTagger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/GeoCoarsener.html">GeoCoarsener</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Source/SpatialDiscretization.html">Spatial discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/MeshData.html">Mesh data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Regridding.html">Regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/LinearSolvers.html">Linear solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/VV.html">Verification and validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Convection-Diffusion-Reaction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cdrsolver">CdrSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discretization-details">Discretization details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#explicit-divergences-and-redistribution">Explicit divergences and redistribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-advection">Explicit advection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-diffusion">Explicit diffusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-advection-diffusion">Explicit advection-diffusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-diffusion">Implicit diffusion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cdrmultigrid">CdrMultigrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cdrctu">CdrCTU</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#face-extrapolation">Face extrapolation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slopes">Slopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#time-step-limitation">Time step limitation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-options">Class options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cdrgodunov">CdrGodunov</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-cdrsolver">Using CdrSolver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#setting-up-the-solver">Setting up the solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filling-the-solver">Filling the solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adjusting-output">Adjusting output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cdrspecies">CdrSpecies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-application-s">Example application(s)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Electrostatics.html">Electrostatic solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshODESolver.html">Mesh ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="SurfaceODESolver.html">Surface ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="TracerParticles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ito.html">Îto diffusion</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multi-physics applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/StreamerInceptionModel.html">Streamer inception model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Single-solver applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection-diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/MeshODEModel.html">Mesh ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/TracerParticleModel.html">Tracer particle model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#creating-a-geometry">Creating a geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#setting-up-a-timestepper">Setting up a <code class="docutils literal notranslate"><span class="pre">TimeStepper</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">Lookup tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Convection-Diffusion-Reaction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Solvers/CDR.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="convection-diffusion-reaction">
<span id="chap-cdr"></span><h1>Convection-Diffusion-Reaction<a class="headerlink" href="#convection-diffusion-reaction" title="Permalink to this heading"></a></h1>
<p>Here, we discuss the discretization of the equation</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + \nabla\cdot\left(\mathbf{v} \phi - D\nabla \phi\right) = S.\]</div>
<p>We assume that <span class="math notranslate nohighlight">\(\phi\)</span> is discretized by cell-centered averages (note that cell centers may lie inside solid boundaries), and use finite volume methods to construct fluxes in a cut-cells and regular cells.
Here, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> indicates a drift velocity and <span class="math notranslate nohighlight">\(D\)</span> is the diffusion coefficient.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using cell-centered versions <span class="math notranslate nohighlight">\(\phi\)</span> might be problematic for some models since the state is extended outside the valid region.
Models might have to recenter the state in order compute e.g. physically meaningful reaction terms in cut-cells.</p>
</div>
<p>Source code for the convection-diffusion-reaction solvers reside in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Source/ConvectionDiffusionReaction</span></code> and the full API can be found at <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classCdrSolver.html">https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classCdrSolver.html</a>.</p>
<div class="section" id="cdrsolver">
<span id="chap-cdrsolver"></span><h2>CdrSolver<a class="headerlink" href="#cdrsolver" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> class contains the interface for solving advection-diffusion-reaction problems.
<code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> is an abstract class and does not contain any specific advective or diffusive discretization (these are added by implementation classes).</p>
<p>Currently, the implementation layers consist of the following:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#chap-cdrmultigrid"><span class="std std-ref">CdrMultigrid</span></a>, which inherits from <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> and adds a second order accurate discretization for the diffusion operator.</p></li>
<li><p><a class="reference internal" href="#chap-cdrctu"><span class="std std-ref">CdrCTU</span></a> and <a class="reference internal" href="#chap-cdrgodunov"><span class="std std-ref">CdrGodunov</span></a> which inherit from <code class="docutils literal notranslate"><span class="pre">CdrMultigrid</span></code> and add a second order accurate spatial discretization for the advection operator.</p></li>
</ol>
<p>Currently, we mostly use the <code class="docutils literal notranslate"><span class="pre">CTU</span></code> class which contains a second order accurate discretization with slope limiters.
<code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> is a similar operator, but the advection code for this is distributed by the <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> team.
The C++ API for these classes can be obtained from <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classCdrSolver.html">https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classCdrSolver.html</a>.</p>
<p>The advance methods for <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> are encapsulated by the following functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For advancing the diffusion equation with an implicit Euler method.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">advanceEuler</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_newPhi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_oldPhi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_source</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_dt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// For advancing the diffusion equation with a Crank-Nicholson method.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">advanceCrankNicholson</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_newPhi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_oldPhi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_source</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_dt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// For computing div(v*phi - D*grad(phi)).</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">computeDivJ</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_divJ</span><span class="p">,</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_phi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_dt</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_conservativeOnly</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_ebFlux</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_domainFlux</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// For computing div(v*phi).</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">computeDivF</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_divJ</span><span class="p">,</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_phi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_dt</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_conservativeOnly</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_ebFlux</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_domainFlux</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// For computing div(D*grad(phi)).</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">computeDivD</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_divJ</span><span class="p">,</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_phi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_dt</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_conservativeOnly</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_ebFlux</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_domainFlux</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="discretization-details">
<span id="chap-cdrdetails"></span><h2>Discretization details<a class="headerlink" href="#discretization-details" title="Permalink to this heading"></a></h2>
<div class="section" id="explicit-divergences-and-redistribution">
<span id="chap-explicitdivergence"></span><h3>Explicit divergences and redistribution<a class="headerlink" href="#explicit-divergences-and-redistribution" title="Permalink to this heading"></a></h3>
<p>Computing explicit divergences for equations like</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + \nabla\cdot\mathbf{G} = 0\]</div>
<p>is problematic because of the arbitarily small volume fractions of cut cells.
In general, we seek a method-of-lines update <span class="math notranslate nohighlight">\(\phi^{k+1} = \phi^k - \Delta t \left[\nabla\cdot \mathbf{G}^k\right]\)</span> where <span class="math notranslate nohighlight">\(\left[\nabla\cdot\mathbf{G}\right]\)</span> is a stable numerical approximation based on some finite volume approximation.</p>
<p>Pure finite volume methods use</p>
<div class="math notranslate nohighlight" id="equation-conservativeupdate">
<span class="eqno">(2)<a class="headerlink" href="#equation-conservativeupdate" title="Permalink to this equation"></a></span>\[\phi^{k+1} = \phi^k - \frac{\Delta t}{\kappa \Delta x^{\textrm{DIM}}}\int_V\nabla\cdot\mathbf{G}dV,\]</div>
<p>where <span class="math notranslate nohighlight">\(\kappa\)</span> is the volume fraction of a grid cell, <span class="math notranslate nohighlight">\(\textrm{DIM}\)</span> is the spatial dimension and the volume integral is written as discretized surface integral</p>
<div class="math notranslate nohighlight">
\[\int_V\nabla\cdot\mathbf{G}dV =\sum_{f\in f(V)}\left(\mathbf{G}_f\cdot \mathbf{n}_f\right)\alpha_f\Delta x^{\textrm{DIM} -1}.\]</div>
<p>The sum runs over all cell edges (faces in 3D) of the cell where <span class="math notranslate nohighlight">\(G_f\)</span> is the flux on the edge centroid and <span class="math notranslate nohighlight">\(\alpha_f\)</span> is the edge (face) aperture.</p>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="../_images/CutCell.png"><img alt="../_images/CutCell.png" src="../_images/CutCell.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 22 </span><span class="caption-text">Location of centroid fluxes for cut cells.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</div>
<p>However, taking <span class="math notranslate nohighlight">\([\nabla\cdot\mathbf{G}^k]\)</span> to be this sum leads to a time step constraint proportional to <span class="math notranslate nohighlight">\(\kappa\)</span>, which can be arbitrarily small.
This leads to an unacceptable time step constraint for <a class="reference internal" href="#equation-conservativeupdate">Eq. 2</a>.
We use the Chombo approach and expand the range of influence of the cut cells in order to stabilize the discretization and allow the use of a normal time step constraint.
First, we compute the conservative divergence</p>
<div class="math notranslate nohighlight">
\[\kappa_{\mathbf{i}} D_\mathbf{i}^c =  \sum_f G_f\alpha_f\Delta x^{\textrm{DIM} -1},\]</div>
<p>where <span class="math notranslate nohighlight">\(G_f = \mathbf{G}_f\cdot \mathbf{n}_f\)</span>. Next, we compute a non-conservative divergence <span class="math notranslate nohighlight">\(D_{\mathbf{i}}^{nc}\)</span></p>
<div class="math notranslate nohighlight">
\[D_\mathbf{i}^{nc} =  \frac{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}D_\mathbf{i}^c}{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}}\]</div>
<p>where <span class="math notranslate nohighlight">\(N(\mathbf{i})\)</span> indicates some neighborhood of cells around cell <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>. Next, we compute a hybridization of the divergences,</p>
<div class="math notranslate nohighlight">
\[D_{\mathbf{i}}^H = \kappa_{\mathbf{i}} D_{\mathbf{i}}^c + (1-\kappa_{\mathbf{i}})D_{\mathbf{i}}^{nc},\]</div>
<p>and perform an intermediate update</p>
<div class="math notranslate nohighlight">
\[\phi_{\mathbf{i}}^{k+1} = \phi_{\mathbf{i}}^k - \Delta tD_{\mathbf{i}}^H.\]</div>
<p>The hybrid divergence update fails to conserve mass by an amount <span class="math notranslate nohighlight">\(\delta M_{\mathbf{i}} = \kappa_{\mathbf{i}}\left(1-\kappa_{\mathbf{i}}\right)\left(D_{\mathbf{i}}^c - D_{\mathbf{i}}^{nc}\right)\)</span>.
In order to main overall conservation, the excess mass is redistributed into neighboring grid cells.
Let <span class="math notranslate nohighlight">\(\delta M_{\mathbf{i}, \mathbf{j}}\)</span> be the redistributed mass from <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> to <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> where</p>
<div class="math notranslate nohighlight">
\[\delta M_{\mathbf{i}} = \sum_{\mathbf{j} \in N(\mathbf{i})}\delta M_{\mathbf{i}, \mathbf{i}}.\]</div>
<p>This mass is used as a local correction in the vicinity of the cut cells, i.e.</p>
<div class="math notranslate nohighlight">
\[\phi_{\mathbf{i}}^{k+1} \rightarrow \phi_{\mathbf{i}}^{k+1} + \delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}},\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}}\)</span> is the total mass redistributed to cell <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> from the other cells.
After these steps, we define</p>
<div class="math notranslate nohighlight">
\[\left[\nabla\cdot\mathbf{G}^k\right]_{\mathbf{i}} \equiv \frac{1}{\Delta t}\left(\phi_{\mathbf{i}}^{k+1} - \phi_{\mathbf{i}}^k\right)\]</div>
<p>Numerically, the above steps for computing a conservative divergence of a one-component flux <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> are implemented in the convection-diffusion-reaction solvers, which also respects boundary conditions (e.g. charge injection).
The user will need to call the function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">CdrSolver</span><span class="o">::</span><span class="n">computeDivG</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_divG</span><span class="p">,</span><span class="w"> </span><span class="n">EBAMRFluxData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_G</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRIVData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_ebG</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a_G</span></code> is the numerical representation of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> over the cut-cell AMR hierarchy and must be stored on cell-centered faces, and <code class="docutils literal notranslate"><span class="pre">a_ebG</span></code> is the flux on the embedded boundary.
The above steps are performed by interpolating <code class="docutils literal notranslate"><span class="pre">a_G</span></code> to face centroids in the cut cells for computing the conservative divergence, and the remaining steps are then performed successively.
The result is put in <code class="docutils literal notranslate"><span class="pre">a_divG</span></code>.</p>
<p>Note that when refinement boundaries intersect with embedded boundaries, the redistribution process is far more complicated since it needs to account for mass that moves over refinement boundaries.
These additional complicated are taken care of inside <code class="docutils literal notranslate"><span class="pre">a_divG</span></code>, but are not discussed in detail here.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Mass redistribution has the effect of not being monotone and thus not TVD, and the discretization order is formally <span class="math notranslate nohighlight">\(\mathcal{O}(\Delta x)\)</span>.</p>
</div>
</div>
<div class="section" id="explicit-advection">
<span id="chap-explicitadvection"></span><h3>Explicit advection<a class="headerlink" href="#explicit-advection" title="Permalink to this heading"></a></h3>
<p>Scalar advection updates follows the computation of the explicit divergence discussed in <a class="reference internal" href="#chap-explicitdivergence"><span class="std std-ref">Explicit divergences and redistribution</span></a>.
The face-centered fluxes <span class="math notranslate nohighlight">\(\mathbf{G} = \phi\mathbf{v}\)</span> are computed by instantiation classes for the convection-diffusion-reaction solvers.
The function signature for explicit advection is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">computeDivF</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_divF</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_state</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_dt</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where the face-centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in <code class="docutils literal notranslate"><span class="pre">a_divF</span></code> using the procedure outlined above.
The argument <code class="docutils literal notranslate"><span class="pre">a_dt</span></code> is the time step size.
It is not needed in a method-of-lines context, but it is used in e.g. <a class="reference internal" href="#chap-cdrctu"><span class="std std-ref">CdrCTU</span></a> for computing transverse derivatives in order to expand the stability region (i.e., use larger CFL numbers).</p>
<p>For example, in order to perform an advective advance over a time step <span class="math notranslate nohighlight">\(\Delta t\)</span>, one would perform the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="o">*</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">phi</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">getPhi</span><span class="p">();</span><span class="w">     </span><span class="c1">// Cell-centered state</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">divF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">getScratch</span><span class="p">();</span><span class="w"> </span><span class="c1">// Scratch storage in solver</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w">        </span><span class="c1">// Computes divF</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="n">divF</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">dt</span><span class="p">);</span><span class="w">               </span><span class="c1">// makes phi -&gt; phi - dt*divF</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-diffusion">
<span id="chap-explicitdiffusion"></span><h3>Explicit diffusion<a class="headerlink" href="#explicit-diffusion" title="Permalink to this heading"></a></h3>
<p>Explicit diffusion is performed in much the same way as implicit advection, with the exception that the general flux <span class="math notranslate nohighlight">\(\mathbf{G} = D\nabla\phi\)</span> is computed by using centered differences on face centers.
The function signature for explicit diffusion is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">computeDivD</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_divF</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_state</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>and we increment in the same way as for explicit advection:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="o">*</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">phi</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">getPhi</span><span class="p">();</span><span class="w">     </span><span class="c1">// Cell-centered state</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">divD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">getScratch</span><span class="p">();</span><span class="w"> </span><span class="c1">// Scratch storage in solver</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divD</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w">        </span><span class="c1">// Computes divD</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="n">divD</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span><span class="w">                </span><span class="c1">// makes phi -&gt; phi + dt*divD</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-advection-diffusion">
<span id="chap-explicitadvectiondiffusion"></span><h3>Explicit advection-diffusion<a class="headerlink" href="#explicit-advection-diffusion" title="Permalink to this heading"></a></h3>
<p>There is also functionality for aggregating explicit advection and diffusion advances.
The reason for this is that the cut-cell overhead is only applied once on the combined flux <span class="math notranslate nohighlight">\(\phi\mathbf{v} - D\nabla\phi\)</span> rather than on the individual fluxes.
For non-split methods this leads to some performance improvement since the interpolation of fluxes on cut-cell faces only needs to be performed once.
The signature for this is precisely the same as for explicit advection only:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">computeDivJ</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_divJ</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_state</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_extrapDt</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>where the face-centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in <code class="docutils literal notranslate"><span class="pre">a_divF</span></code>.
For example, in order to perform an advective advance over a time step <span class="math notranslate nohighlight">\(\Delta t\)</span>, one would perform the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">phi</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">getPhi</span><span class="p">();</span><span class="w">     </span><span class="c1">// Cell-centered state</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">divJ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">getScratch</span><span class="p">();</span><span class="w"> </span><span class="c1">// Scratch storage in solver</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivJ</span><span class="p">(</span><span class="n">divJ</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w">        </span><span class="c1">// Computes divD</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="n">divJ</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">dt</span><span class="p">);</span><span class="w">               </span><span class="c1">// makes phi -&gt; phi - dt*divJ</span>
</pre></div>
</div>
<p>Often, time integrators have the option of using implicit or explicit diffusion.
If the time-evolution is not split (i.e. not using a Strang or Godunov splitting), the integrators will often call <code class="docutils literal notranslate"><span class="pre">computeDivJ</span></code> rather separately calling <code class="docutils literal notranslate"><span class="pre">computeDivF</span></code> and <code class="docutils literal notranslate"><span class="pre">computeDivD</span></code>.
If you had a split-step Godunov method, the above procedure for a forward Euler method for both parts would be:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="o">*</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>

<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Computes divF = div(n*phi)</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="n">divF</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">dt</span><span class="p">);</span><span class="w">        </span><span class="c1">// makes phi -&gt; phi - dt*divF</span>

<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivD</span><span class="p">(</span><span class="n">divD</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">);</span><span class="w">      </span><span class="c1">// Computes divD = div(D*nabla(phi))</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="n">divD</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span><span class="w">         </span><span class="c1">// makes phi -&gt; phi + dt*divD</span>
</pre></div>
</div>
<p>However, the cut-cell redistribution dance (flux interpolation, hybrid divergence, and redistribution) would be performed twice.</p>
</div>
<div class="section" id="implicit-diffusion">
<span id="chap-implicitdiffusion"></span><h3>Implicit diffusion<a class="headerlink" href="#implicit-diffusion" title="Permalink to this heading"></a></h3>
<p>Implicit diffusion can occasionally be necesasry.
The convection-diffusion-reaction solvers support two basic diffusion solves:
Backward Euler and the Crank-Nicholson methods.
The function signatures for these are</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">advanceEuler</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_newPhi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_oldPhi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_source</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_dt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">advanceCrankNicholson</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_newPhi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_oldPhi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_source</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_dt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a_newPhi</span></code> is the state at the new time <span class="math notranslate nohighlight">\(t + \Delta t\)</span>, <code class="docutils literal notranslate"><span class="pre">a_oldPhi</span></code> is the state at time <span class="math notranslate nohighlight">\(t\)</span> and <code class="docutils literal notranslate"><span class="pre">a_source</span></code> is the source term which strictly speaking should be centered at time <span class="math notranslate nohighlight">\(t + \Delta t\)</span> for the Euler update and at time <span class="math notranslate nohighlight">\(t + \Delta t/2\)</span> for the Crank-Nicholson update.
This may or may not be possible for your particular problem.</p>
<p>For example, performing a split step Godunov method for advection-diffusion is as simple as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// First. Compute phi = phi - dt*div(F)</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="n">divF</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Implicit diffusion advance over a time step dt</span>
<span class="n">DataOps</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">phiOld</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">);</span><span class="w"></span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">advanceEuler</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="n">phiOld</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cdrmultigrid">
<span id="chap-cdrmultigrid"></span><h2>CdrMultigrid<a class="headerlink" href="#cdrmultigrid" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">CdrMultigrid</span></code> adds second-order accurate implicit diffusion code to <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, but leaves the advection code unimplemented.
The class can use either implicit or explicit diffusion using second-order cell-centered stencils.
In addition, <code class="docutils literal notranslate"><span class="pre">CdrMultigrid</span></code> adds two implicit time-integrators, an implicit Euler method and a Crank-Nicholson method.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">CdrMultigrid</span></code> layer uses the Helmholtz discretization discussed in <a class="reference internal" href="../Source/LinearSolvers.html#chap-helmholtz"><span class="std std-ref">Helmholtz equation</span></a>.
It implements the pure functions required by <a class="reference internal" href="#chap-cdrsolver"><span class="std std-ref">CdrSolver</span></a> but introduces a new pure function</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="n">void</span> <span class="n">advectToFaces</span><span class="p">(</span><span class="n">EBAMRFluxData</span><span class="o">&amp;</span> <span class="n">a_facePhi</span><span class="p">,</span> <span class="n">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_phi</span><span class="p">,</span> <span class="n">const</span> <span class="n">Real</span> <span class="n">a_dt</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The faces states defined by the above function are used when forming a finite-volume approximation to the divergence operators, see <a class="reference internal" href="#chap-cdrdetails"><span class="std std-ref">Discretization details</span></a>.</p>
</div>
<div class="section" id="cdrctu">
<span id="chap-cdrctu"></span><h2>CdrCTU<a class="headerlink" href="#cdrctu" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">CdrCTU</span></code> is an implementation class that uses the corner transport upwind (CTU) discretization.
The CTU discretization uses information that propagates over corners of grid cells when calculating the face states.
It can combine this with use various limiters:</p>
<ul class="simple">
<li><p>No limiter (pure CTU)</p></li>
<li><p>Minmod</p></li>
<li><p>Superbee</p></li>
<li><p>Monotonized central differences</p></li>
</ul>
<p>In addition, <code class="docutils literal notranslate"><span class="pre">CdrCTU</span></code> can turn off the transverse terms in which case the discretization reduces to the donor cell method.
Our motivation for using the CTU discretization lies in the time step selection for the CTU and donor-cell methods, see <a class="reference internal" href="#chap-ctustep"><span class="std std-ref">Time step limitation</span></a>.
Typically, we want to achieve a dimensionally independent time step that is the same in 1D, 2D, and 3D, but without directional splitting.</p>
<div class="section" id="face-extrapolation">
<h3>Face extrapolation<a class="headerlink" href="#face-extrapolation" title="Permalink to this heading"></a></h3>
<p>The finite volume discretization uses an upstream-centered Taylor expansion that extrapolates the cell-centered term to half-edges and half-steps:</p>
<div class="math notranslate nohighlight">
\[\phi_{i+1/2,j,}^{n+1/2} = \phi_{i,j,k}^n + \frac{\Delta x}{2}\frac{\partial \phi}{\partial x} + \frac{\Delta t}{2}\frac{\partial \phi}{\partial t} + \mathcal{O}\left(\Delta t^2\right) + \mathcal{O}\left(\Delta t\Delta x\right)\]</div>
<p>Note that the truncation order is <span class="math notranslate nohighlight">\(\Delta t^2 + \Delta x\Delta t\)</span> where the latter term is due to the cross-derivative <span class="math notranslate nohighlight">\(\frac{\partial^2\phi}{\partial t\partial x}\)</span>.
The resulting expression in 2D for a velocity field <span class="math notranslate nohighlight">\(\mathbf{v} = (u,v)\)</span> is</p>
<div class="math notranslate nohighlight">
\[\phi_{i\pm1/2,j}^{n+1/2,+} = \phi_{i,j}^n \pm \frac{1}{2}\min\left[1, 1 \mp \frac{\Delta t}{\Delta x}u_{i,j}^n\right]\left(\Delta^x\phi\right)_{i,j}^n - \frac{\Delta t}{2\Delta x}v_{i,j}^n\left(\Delta^y\phi\right)_{i,j}^n,\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\Delta^x\)</span> are the regular (normal) slopes whereas <span class="math notranslate nohighlight">\(\Delta^y\)</span> are the transverse slopes.
The transverse slopes are given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}(\Delta^y\phi)_{i,j}^n = \begin{cases}
\phi_{i,j+1}^n - \phi_{i,j}^n, &amp; v_{i,j}^n &lt; 0 \\
\phi_{i,j}^n - \phi_{i,j-1}^n, &amp; v_{i,j}^n &gt; 0 \\
\end{cases}\end{split}\]</div>
</div>
<div class="section" id="slopes">
<span id="chap-ctuslopes"></span><h3>Slopes<a class="headerlink" href="#slopes" title="Permalink to this heading"></a></h3>
<p>For the normal slopes, the user can choose between the minmod, superbee, and monotonized central difference (MC) slopes.
Let <span class="math notranslate nohighlight">\(\Delta_l = \phi_{i,j}^n - \phi_{i-1,j}^n\)</span> and <span class="math notranslate nohighlight">\(\Delta_r = \phi_{i+1,j}^n - \phi_{i,j}^n\)</span>.
The slopes are given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{minmod: }\left(\Delta^x\phi\right)_{i,j}^n &amp;= \begin{cases}
\Delta_l &amp; |\Delta_l| &lt; |\Delta_r| \text { and } \Delta_l\Delta_r &gt; 0 \\
\Delta_r &amp; |\Delta_l| &gt; |\Delta_r| \text { and } \Delta_l\Delta_r &gt; 0 \\
0 &amp; \text{otherwise}.
\end{cases} \\[1ex]
\text{MC: } \left(\Delta^x\phi\right)_{i,j}^n &amp;= \text{sgn}\left(\Delta_l + \Delta_r\right)\min\left(\left|\frac{\Delta_l + \Delta_r}{2}\right|, 2\left|\Delta_l\right|, 2\left|\Delta_r\right|\right),\\[1ex]
\text{superbee: }\left(\Delta^x\phi\right)_{i,j}^n &amp;= \begin{cases}
\Delta_1 &amp; |\Delta_1| &gt; |\Delta_2| \text { and } \Delta_1\Delta_2 &gt; 0 \\
\Delta_2 &amp; |\Delta_1| &lt; |\Delta_2| \text { and } \Delta_1\Delta_2 &gt; 0 \\
0 &amp; \text{otherwise},
\end{cases} \\[1ex]\end{split}\]</div>
<p>where for the superbee slope we have <span class="math notranslate nohighlight">\(\Delta_1 = \text{minmod}\left(\Delta_l, 2\Delta_r\right)\)</span> and <span class="math notranslate nohighlight">\(\Delta_2 = \text{minmod}\left(\Delta_r, 2\Delta_l\right)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using slopes, monotonicity is not guaranteed for the CTU discretization.
If slopes are turned off, however, the scheme is guaranteed to be monotone.</p>
</div>
</div>
<div class="section" id="time-step-limitation">
<span id="chap-ctustep"></span><h3>Time step limitation<a class="headerlink" href="#time-step-limitation" title="Permalink to this heading"></a></h3>
<p>The stability region for the donor-cell and corner transport upwind methods are:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\text{Donor-cell}: \Delta t \leq \frac{\Delta x}{|v_x| + |v_y| + |v_z|}\\\text{CTU}: \Delta t \leq \frac{\Delta x}{\max\left(|v_x|,|v_y|,|v_z|\right)}\end{aligned}\end{align} \]</div>
<p>Note that when the flow is diagonal to the grid, i.e. <span class="math notranslate nohighlight">\(|v_x| = |v_y| = |v_z|\)</span>, the CTU can use a time step that is three times larger than for the donor-cell method.</p>
</div>
<div class="section" id="class-options">
<h3>Class options<a class="headerlink" href="#class-options" title="Permalink to this heading"></a></h3>
<p>When running the <code class="docutils literal notranslate"><span class="pre">CdrCTU</span></code> solver the user can adjust the advective algorithm by turning on/off slope limiters and the transverse term through the class options:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CdrCTU.slope_limiter</span></code>, which must be <em>none</em>, <em>minmod</em>, <em>mc</em>, or <em>superbee</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CdrCTU.use_ctu</span></code>, which must be <em>true</em> or <em>false</em>.</p></li>
</ul>
<p>If the transverse terms are turned off, <code class="docutils literal notranslate"><span class="pre">CdrCTU</span></code> will compute the donor-cell time step.</p>
</div>
</div>
<div class="section" id="cdrgodunov">
<span id="chap-cdrgodunov"></span><h2>CdrGodunov<a class="headerlink" href="#cdrgodunov" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">CdrMultigrid</span></code> and adds advection code for Godunov methods.
This class borrows from <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> internals (specifically, <code class="docutils literal notranslate"><span class="pre">EBLevelAdvectIntegrator</span></code>) and can do second-order advection with time-extrapolation.</p>
<p><code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> supplies (almost) the same discretization as <code class="docutils literal notranslate"><span class="pre">CdrCTU</span></code> with the exception that the underlying discretization can also be used for the incompressible Navier-Stokes equation.
However, it only supports the monotonized central difference limiter.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p><code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> will be removed from future versions of <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.</p>
</div>
</div>
<div class="section" id="using-cdrsolver">
<h2>Using CdrSolver<a class="headerlink" href="#using-cdrsolver" title="Permalink to this heading"></a></h2>
<div class="section" id="setting-up-the-solver">
<h3>Setting up the solver<a class="headerlink" href="#setting-up-the-solver" title="Permalink to this heading"></a></h3>
<p>To set up the <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, the following commands are usually sufficient:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume m_solver and m_species are pointers to a CdrSolver and CdrSpecies</span>
<span class="k">auto</span><span class="w"> </span><span class="n">solver</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">CdrSolver</span><span class="o">&gt;</span><span class="w">  </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">MyCdrSolver</span><span class="p">());</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">species</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">CdrSpecies</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">MyCdrSpecies</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>To see an example, the advection-diffusion code in <code class="file docutils literal notranslate"><span class="pre">/Physics/AdvectionDiffusion/CD_AdvectionDiffusionStepper.cpp</span></code> shows how to set up a <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>.</p>
</div>
<div class="section" id="filling-the-solver">
<h3>Filling the solver<a class="headerlink" href="#filling-the-solver" title="Permalink to this heading"></a></h3>
<p>In order to obtain mesh data from the <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, the user should use the following public member functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">getPhi</span><span class="p">();</span><span class="w">                               </span><span class="c1">// Return  phi</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">getSource</span><span class="p">();</span><span class="w">                            </span><span class="c1">// Returns S</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">getCellCenteredVelocity</span><span class="p">();</span><span class="w">              </span><span class="c1">// Get cell-centered velocity</span>
<span class="n">EBAMRFluxData</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">getFaceCenteredDiffusionCoefficient</span><span class="p">();</span><span class="w">  </span><span class="c1">// Returns D</span>
<span class="n">EBAMRIVData</span><span class="o">&amp;</span><span class="w">   </span><span class="nf">getEbFlux</span><span class="p">();</span><span class="w">                            </span><span class="c1">// Returns flux at EB</span>
<span class="n">EBAMRIFData</span><span class="o">&amp;</span><span class="w">   </span><span class="nf">getDomainFlux</span><span class="p">();</span><span class="w">                        </span><span class="c1">// Returns flux at domain boundaries</span>
</pre></div>
</div>
<p>To set the drift velocities, the user will fill the <em>cell-centered</em> velocities.
Interpolation to face-centered transport fluxes are done by <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> during the discretization step.</p>
<p>The general way of setting the velocity is to get a direct handle to the velocity data:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span><span class="w"></span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">veloCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">getCellCenteredVelocity</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>Then, <code class="docutils literal notranslate"><span class="pre">veloCell</span></code> can be filled with the cell-centered velocity.
This would typically look something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">veloCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">getCellCenteredVelocity</span><span class="p">();</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getFinestLevel</span><span class="p">();</span><span class="w"> </span><span class="n">lvl</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DisjointBoxLayout</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dbl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getGrids</span><span class="p">()[</span><span class="n">lvl</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">DataIterator</span><span class="w"> </span><span class="n">dit</span><span class="p">(</span><span class="n">dbl</span><span class="p">);</span><span class="w"> </span><span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">dit</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="n">EBCellFAB</span><span class="o">&amp;</span><span class="w"> </span><span class="n">patchVel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">veloCell</span><span class="p">[</span><span class="n">lvl</span><span class="p">])[</span><span class="n">dit</span><span class="p">()];</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Do something with patchVel</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The same procedure goes for the source terms, diffusion coefficients, boundary conditions and so on.
For example, an explicit Euler discretization for the problem <span class="math notranslate nohighlight">\(\partial_t\phi = S\)</span> is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="o">*</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">phi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">getPhi</span><span class="p">();</span><span class="w"></span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">getSource</span><span class="p">();</span><span class="w"></span>

<span class="n">DataOps</span><span class="o">::</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="adjusting-output">
<h3>Adjusting output<a class="headerlink" href="#adjusting-output" title="Permalink to this heading"></a></h3>
<p>It is possible to adjust solver output when plotting data.
This is done through the input file for the class that you’re using.
For example, for the <code class="docutils literal notranslate"><span class="pre">CdrCTU</span></code> implementation the following variables are available:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>CdrCTU.plt_vars = phi vel src dco ebflux  # Plot variables. Options are &#39;phi&#39;, &#39;vel&#39;, &#39;dco&#39;, &#39;src&#39;
</pre></div>
</div>
<p>Here, you adjust the plotted variables by adding or omitting them from your input script.
E.g. if you only want to plot the cell-centered states you would do:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>CdrGodunov.plt_vars <span class="o">=</span> phi  <span class="c1"># Plot variables. Options are &#39;phi&#39;, &#39;vel&#39;, &#39;dco&#39;, &#39;src&#39;, &#39;ebflux&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cdrspecies">
<span id="chap-cdrspecies"></span><h2>CdrSpecies<a class="headerlink" href="#cdrspecies" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">CdrSpecies</span></code> class is a supporting class that passes information and initial conditions into <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> instances.
<code class="docutils literal notranslate"><span class="pre">CdrSpecies</span></code> specifies whether or not the advect-diffusion solver will use only advection, diffusion, both advection and diffusion, or neither.
It also specifies initial data, and provides a string identifier to the class (e.g. for identifying output in plot files).
However, it does not contain any discretization.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classCdrSpecies.html">here</a> for the <code class="docutils literal notranslate"><span class="pre">CdrSpecies</span></code> C++ API.</p>
</div>
<p>The below code block shows an example of how to instantiate a species.
Here, diffusion code is turned off and the initial data is one everywhere.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MySpecies</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">CdrSpecies</span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>

<span class="w">   </span><span class="n">MySpecies</span><span class="p">(){</span><span class="w"></span>
<span class="w">      </span><span class="n">m_mobile</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">m_diffusive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">m_name</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mySpecies&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="o">~</span><span class="n">MySpecies</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">Real</span><span class="w"> </span><span class="nf">initialData</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>It is also possible to use computational particles as an initial condition in <code class="docutils literal notranslate"><span class="pre">CdrSpecies</span></code>.
In this case you need to fill <code class="docutils literal notranslate"><span class="pre">m_initialParticles</span></code>, and these are then deposited with a nearest-grid-point scheme when instantiating the solver.
See <a class="reference internal" href="../Source/Particles.html#chap-particles"><span class="std std-ref">Particles</span></a> for further details.</p>
</div>
</div>
<div class="section" id="example-application-s">
<h2>Example application(s)<a class="headerlink" href="#example-application-s" title="Permalink to this heading"></a></h2>
<p>Example applications that use the <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html#chap-advectiondiffusionmodel"><span class="std std-ref">Advection-diffusion model</span></a>.</p></li>
<li><p><a class="reference internal" href="../Applications/CdrPlasmaModel.html#chap-cdrplasmamodel"><span class="std std-ref">CDR plasma</span></a>.</p></li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../Source/VV.html" class="btn btn-neutral float-left" title="Verification and validation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Electrostatics.html" class="btn btn-neutral float-right" title="Electrostatic solver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>