<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Convection-Diffusion-Reaction &mdash; chombo-discharge latest documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Electrostatics" href="Electrostatics.html" />
    <link rel="prev" title="GeoCoarsener" href="../Source/GeoCoarsener.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> chombo-discharge
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Documentation.html">Using this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html"><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/GettingStarted.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Source/SpatialDiscretization.html">Spatial discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/MeshData.html">Mesh data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/LinearSolvers.html">Linear solvers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ImplementedModels.html">Implemented models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#creating-a-geometry">Creating a geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#setting-up-a-timestepper">Setting up a <code class="docutils literal notranslate"><span class="pre">TimeStepper</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Source/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/CellTagger.html">CellTagger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/GeoCoarsener.html">GeoCoarsener</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Convection-Diffusion-Reaction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#design">Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cdrspecies">CdrSpecies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdrsolver">CdrSolver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cdrtga">CdrTGA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cdrgodunov">CdrGodunov</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cdrmuscl">CdrMuscl</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementations">Implementations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-cdrsolver">Using CdrSolver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#setting-up-the-solver">Setting up the solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filling-the-solver">Filling the solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adjusting-output">Adjusting output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#discretization-details">Discretization details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#computing-explicit-divergences">Computing explicit divergences</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-advection">Explicit advection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-diffusion">Explicit diffusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-advection-diffusion">Explicit advection-diffusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-diffusion">Implicit diffusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-stochastic-flux">Adding a stochastic flux</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#example-application">Example application</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Electrostatics.html">Electrostatics</a></li>
<li class="toctree-l1"><a class="reference internal" href="RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sigma.html">Surface charge solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ito.html">Îto diffusion</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">Lookup tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/ComplexGeometries.html">Complex geometries</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Convection-Diffusion-Reaction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Solvers/CDR.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="convection-diffusion-reaction">
<span id="chap-cdr"></span><h1>Convection-Diffusion-Reaction<a class="headerlink" href="#convection-diffusion-reaction" title="Permalink to this headline"></a></h1>
<p>Here, we discuss the discretization of the equation</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + \nabla\cdot\left(\mathbf{v} \phi - D\nabla \phi + \sqrt{2D\phi}\mathbf{Z}\right) = S.\]</div>
<p>We assume that <span class="math notranslate nohighlight">\(\phi\)</span> is discretized by cell-centered averages (note that cell centers may lie inside solid boundaries), and use finite volume methods to construct fluxes in a cut-cells and regular cells.
Here, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> indicates a drift velocity, <span class="math notranslate nohighlight">\(D\)</span> is the diffusion coefficient, and the term <span class="math notranslate nohighlight">\(\sqrt{2D\phi}\mathbf{Z}\)</span> is a stochastic diffusion flux. <span class="math notranslate nohighlight">\(S\)</span> is the source term.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using cell-centered versions <span class="math notranslate nohighlight">\(\phi\)</span> might be problematic for some models since the state is extended outside the valid region.
Models might have to recenter the state in order compute e.g. physically meaningful reaction terms in cut-cells.</p>
</div>
<p>Source code for the convection-diffusion-reaction solvers reside in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Source/ConvectionDiffusionReaction</span></code>.</p>
<div class="section" id="design">
<span id="chap-cdrsolver"></span><h2>Design<a class="headerlink" href="#design" title="Permalink to this headline"></a></h2>
<div class="section" id="cdrspecies">
<span id="chap-cdrspecies"></span><h3>CdrSpecies<a class="headerlink" href="#cdrspecies" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">CdrSpecies</span></code> class is a supporting class that passes information and initial conditions into <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> instances.
<code class="docutils literal notranslate"><span class="pre">CdrSpecies</span></code> specifies whether or not the advect-diffusion solver will use only advection, diffusion, both advection and diffusion, or neither.
It also specifies initial data, and provides a string identifier to the class (e.g. for identifying output in plot files).</p>
<p>The below code block shows an example of how to instantiate a species.
Here, diffusion code is turned off and the initial data is one everywhere.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">mySpecies</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CdrSpecies</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="n">mySpecies</span><span class="p">(){</span>
      <span class="n">m_mobile</span>    <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">m_diffusive</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">m_name</span>      <span class="o">=</span> <span class="s">&quot;mySpecies&quot;</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="o">~</span><span class="n">mySpecies</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

   <span class="n">Real</span> <span class="nf">initial_data</span><span class="p">(</span><span class="k">const</span> <span class="n">RealVect</span> <span class="n">a_pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">a_time</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that you can also deposit computational particles as an initial condition.
In this case you need to fill <code class="docutils literal notranslate"><span class="pre">m_initial_particles</span></code>.
By default, these are deposited with a nearest-grid-point scheme.</p>
</div>
<div class="section" id="cdrsolver">
<h3>CdrSolver<a class="headerlink" href="#cdrsolver" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> class contains the interface for solving advection-diffusion-reaction problems.
The class is abstract but there are currently two specific implementations of this class.
By design <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> does not contain any specific advective and diffusive discretization, and these are supposed to be added through inheritance.
For example, <code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> and adds a second order diffusion discretization.
It also add multigrid code for performing implicit diffusion.
Below that, the classes <code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> and <code class="docutils literal notranslate"><span class="pre">CdrMuscl</span></code> inherit everything from <code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code> and also adds in the advective discretization.
Thus, adding new advection code is done by inheriting from <code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code> and implementing new advection schemes.</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-8c761ae70a0e6f2a35322d0ab46d37a9cffa6cff.png" alt="digraph {
   rankdir=&quot;LR&quot;;
   &quot;CdrSolver&quot; -&gt; &quot;CdrTGA&quot; -&gt; {&quot;CdrGodunov&quot;, &quot;CdrMuscl&quot;};
}" class="graphviz" /></div>
</div>
<p>Currently, we mostly use the <code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> class which contains a second order accurate discretization with slope limiters, and the advection code for this is distributed by the <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> team.
The alternative implementation in <code class="file docutils literal notranslate"><span class="pre">/src/CdrMuscl.H(cpp)</span></code> contains a MUSCL implementation with van Leer slope limiting (i.e. much the same as the Chombo code), but it does not include extrapolation in time.</p>
<div class="section" id="cdrtga">
<h4>CdrTGA<a class="headerlink" href="#cdrtga" title="Permalink to this headline"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code> adds second-order accurate implicit diffusion code to <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, but leaves the advection code unimplemented.
The class can use either implicit or explicit diffusion using second-order cell-centered stencils.
In addition, <code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code> adds two implicit time-integrators, an implicit Euler method and the Twizel-Gumel-Arigu (TGA) method.</p>
</div>
<div class="section" id="cdrgodunov">
<h4>CdrGodunov<a class="headerlink" href="#cdrgodunov" title="Permalink to this headline"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code> and adds advection code for Godunov methods.
This class borrows from <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> internals (specifically, <code class="docutils literal notranslate"><span class="pre">EBLevelAdvectIntegrator</span></code>) and can do second-order advection with time-extrapolation.
For example, when extrapolating cell-centered data to faces, the extrapolation can be done (with Van Leer limiters) in both space and time.</p>
</div>
<div class="section" id="cdrmuscl">
<h4>CdrMuscl<a class="headerlink" href="#cdrmuscl" title="Permalink to this headline"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">CdrMuscl</span></code> adds MUSCL advection code to <code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code>.
It uses the same slope limiters as <code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> but can not extrapolate in time.</p>
</div>
</div>
<div class="section" id="implementations">
<h3>Implementations<a class="headerlink" href="#implementations" title="Permalink to this headline"></a></h3>
<p>To use a <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, one must instantiate either <code class="docutils literal notranslate"><span class="pre">CdrGodunov</span></code> or <code class="docutils literal notranslate"><span class="pre">CdrMuscl</span></code> (which differ only in their treatment of advection).
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSpecies</span><span class="o">*</span> <span class="n">spec</span>  <span class="o">=</span> <span class="p">(</span><span class="n">CdrSpecies</span><span class="o">*</span><span class="p">)</span> <span class="n">mySpecies</span><span class="p">();</span>
<span class="n">CdrSolver</span><span class="o">*</span> <span class="n">solver</span> <span class="o">=</span> <span class="p">(</span><span class="n">CdrSolver</span><span class="o">*</span><span class="p">)</span>  <span class="k">new</span> <span class="n">CdrGodunov</span><span class="p">();</span>

<span class="n">solver</span><span class="o">-&gt;</span><span class="n">set_species</span><span class="p">(</span><span class="n">spec</span><span class="p">);</span>
</pre></div>
</div>
<p>Instantiating <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> or <code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code> directly will cause compile-time errors.</p>
<p>Note that if you want to add new advection code to <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, you may inherit from <code class="docutils literal notranslate"><span class="pre">CdrTGA</span></code> and implement new advection routines.</p>
</div>
</div>
<div class="section" id="using-cdrsolver">
<h2>Using CdrSolver<a class="headerlink" href="#using-cdrsolver" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> is intended to be used in a method-of-lines context where the user will</p>
<ol class="arabic simple">
<li><p>Fill the solver with relevant data (e.g. velocities, diffusion coefficients, source terms etc.).</p></li>
<li><p>Call public member functions for explicit advection or diffusion, or for performing implicit diffusion advances.</p></li>
</ol>
<p>It is up to the developer to ensure that the solver is filled with appropriate data before calling the public member functions.
This would typically look something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">vel</span> <span class="o">=</span> <span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">getCellCenteredVelocity</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lvl</span> <span class="o">&lt;=</span> <span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getFinestLevel</span><span class="p">();</span> <span class="n">lvl</span><span class="o">++</span><span class="p">){</span>
   <span class="k">const</span> <span class="n">DisjointBoxLayout</span><span class="o">&amp;</span> <span class="n">dbl</span> <span class="o">=</span> <span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getGrids</span><span class="p">()[</span><span class="n">lvl</span><span class="p">];</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">DataIterator</span> <span class="n">dit</span> <span class="o">=</span> <span class="n">dbl</span><span class="p">.</span><span class="n">dataIterator</span><span class="p">();</span> <span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">dit</span><span class="p">){</span>
      <span class="n">EBCellFAB</span><span class="o">&amp;</span> <span class="n">patchVel</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">vel</span><span class="p">[</span><span class="n">lvl</span><span class="p">])[</span><span class="n">dit</span><span class="p">()];</span>

      <span class="c1">// Set velocity of some patch</span>
      <span class="n">callSomeFunction</span><span class="p">(</span><span class="n">patchVel</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Compute div(v*phi)</span>
<span class="n">computeDivF</span><span class="p">(....)</span>
</pre></div>
</div>
<p>There are no time integration algorithms built into the <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, and the user will have to supply these through <code class="docutils literal notranslate"><span class="pre">TimeStepper</span></code>.
More complete code is given in the physics module for advection-diffusion problems in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Physics/AdvectionDiffusion/</span></code>.
This code is also part of a regression test found in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Regression/AdvectionDiffusion</span></code>.</p>
<div class="section" id="setting-up-the-solver">
<h3>Setting up the solver<a class="headerlink" href="#setting-up-the-solver" title="Permalink to this headline"></a></h3>
<p>To set up the <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, the following commands are usually included in <code class="docutils literal notranslate"><span class="pre">time_stepper::setup_solvers()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume m_solver and m_species are pointers to a CdrSolver and CdrSpecies</span>
<span class="n">m_solver</span>  <span class="o">=</span> <span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">CdrSolver</span><span class="o">&gt;</span>  <span class="p">(</span><span class="k">new</span> <span class="n">MyCdrSolver</span><span class="p">());</span>
<span class="n">m_species</span> <span class="o">=</span> <span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">CdrSpecies</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">new</span> <span class="n">MyCdrSpecies</span><span class="p">());</span>

<span class="c1">// Solver setup</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">setVerbosity</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">setSpecies</span><span class="p">(</span><span class="n">m_species</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">parseOptions</span><span class="p">();</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">setPhase</span><span class="p">(</span><span class="n">phase</span><span class="o">::</span><span class="n">gas</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">setAmr</span><span class="p">(</span><span class="n">m_amr</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">setComputational_geometry</span><span class="p">(</span><span class="n">m_compgeom</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">sanityCheck</span><span class="p">();</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">allocateInternals</span><span class="p">();</span>
</pre></div>
</div>
<p>To see an example, the advection-diffusion code in <code class="file docutils literal notranslate"><span class="pre">/physics/AdvectionDiffusion/AdvectionDiffusion_stepper</span></code> shows how to set up this particular solver.</p>
</div>
<div class="section" id="filling-the-solver">
<h3>Filling the solver<a class="headerlink" href="#filling-the-solver" title="Permalink to this headline"></a></h3>
<p>In order to obtain mesh data from the <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code>, the user should use the following public member functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">getPhi</span><span class="p">();</span>                               <span class="c1">// Return  phi</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">getSource</span><span class="p">();</span>                            <span class="c1">// Returns S</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">getCellCenteredVelocity</span><span class="p">();</span>              <span class="c1">// Get cell-centered velocity</span>
<span class="n">EBAMRFluxData</span><span class="o">&amp;</span> <span class="n">getFaceCenteredDiffusionCoefficient</span><span class="p">();</span>  <span class="c1">// Returns D</span>
<span class="n">EBAMRIVData</span><span class="o">&amp;</span> <span class="n">getEbFlux</span><span class="p">();</span>                              <span class="c1">// Returns flux at EB</span>
<span class="n">EBAMRIFData</span><span class="o">&amp;</span> <span class="n">getDomainFlux</span><span class="p">();</span>                          <span class="c1">// Returns flux at domain boundaries</span>
</pre></div>
</div>
<p>To set the drift velocities, the user will fill the <em>cell-centered</em> velocities.
Interpolation to face-centered transport fluxes are done by <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> during the discretization step.</p>
<p>The general way of setting the velocity is to get a direct handle to the velocity data:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span> <span class="nf">solver</span><span class="p">(...);</span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">veloCell</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">getCellCenteredVelocity</span><span class="p">();</span>
</pre></div>
</div>
<p>Then, <code class="docutils literal notranslate"><span class="pre">veloCell</span></code> can be filled with the cell-centered velocity.
The same procedure goes for the source terms, diffusion coefficients, boundary conditions and so on.</p>
<p>For example, an explicit Euler discretization for the problem <span class="math notranslate nohighlight">\(\partial_t\phi = S\)</span> is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="o">*</span> <span class="n">solver</span><span class="p">;</span>

<span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getPhi</span><span class="p">();</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">src</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getSource</span><span class="p">();</span>

<span class="n">DataOps</span><span class="o">::</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="adjusting-output">
<h3>Adjusting output<a class="headerlink" href="#adjusting-output" title="Permalink to this headline"></a></h3>
<p>It is possible to adjust solver output when plotting data.
This is done through the input file for the class that you’re using (e.g. <code class="file docutils literal notranslate"><span class="pre">/src/CdrSolver/CdrGodunov.options</span></code>):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>CdrGodunov.plt_vars <span class="o">=</span> phi vel src dco ebflux  <span class="c1"># Plot variables. Options are &#39;phi&#39;, &#39;vel&#39;, &#39;dco&#39;, &#39;src&#39;, &#39;ebflux&#39;</span>
</pre></div>
</div>
<p>Here, you adjust the plotted variables by adding or omitting them from your input script.
E.g. if you only want to plot the cell-centered states you would do:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>CdrGodunov.plt_vars <span class="o">=</span> phi  <span class="c1"># Plot variables. Options are &#39;phi&#39;, &#39;vel&#39;, &#39;dco&#39;, &#39;src&#39;, &#39;ebflux&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="discretization-details">
<h2>Discretization details<a class="headerlink" href="#discretization-details" title="Permalink to this headline"></a></h2>
<div class="section" id="computing-explicit-divergences">
<span id="chap-explicitdivergence"></span><h3>Computing explicit divergences<a class="headerlink" href="#computing-explicit-divergences" title="Permalink to this headline"></a></h3>
<p>Computing explicit divergences for equations like</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + \nabla\cdot\mathbf{G} = 0\]</div>
<p>is problematic because of the arbitarily small volume fractions of cut cells.
In general, we seek a method-of-lines update <span class="math notranslate nohighlight">\(\phi^{k+1} = \phi^k - \Delta t \left[\nabla\cdot \mathbf{G}^k\right]\)</span> where <span class="math notranslate nohighlight">\(\left[\nabla\cdot\mathbf{G}\right]\)</span> is a stable numerical approximation based on some finite volume approximation.</p>
<p>Pure finite volume methods use</p>
<div class="math notranslate nohighlight" id="equation-conservativeupdate">
<span class="eqno">(4)<a class="headerlink" href="#equation-conservativeupdate" title="Permalink to this equation"></a></span>\[\phi^{k+1} = \phi^k - \frac{\Delta t}{\kappa \Delta x^{\textrm{DIM}}}\int_V\nabla\cdot\mathbf{G}dV,\]</div>
<p>where <span class="math notranslate nohighlight">\(\kappa\)</span> is the volume fraction of a grid cell, <span class="math notranslate nohighlight">\(\textrm{DIM}\)</span> is the spatial dimension and the volume integral is written as discretized surface integral</p>
<div class="math notranslate nohighlight">
\[\int_V\nabla\cdot\mathbf{G}dV =\sum_{f\in f(V)}\left(\mathbf{G}_f\cdot \mathbf{n}_f\right)\alpha_f\Delta x^{\textrm{DIM} -1}.\]</div>
<p>The sum runs over all cell edges (faces in 3D) of the cell where <span class="math notranslate nohighlight">\(G_f\)</span> is the flux on the edge centroid and <span class="math notranslate nohighlight">\(\alpha_f\)</span> is the edge (face) aperture.</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="../_images/CutCell.png"><img alt="../_images/CutCell.png" src="../_images/CutCell.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">Location of centroid fluxes for cut cells.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</div>
<p>However, taking <span class="math notranslate nohighlight">\([\nabla\cdot\mathbf{G}^k]\)</span> to be this sum leads to a time step constraint proportional to <span class="math notranslate nohighlight">\(\kappa\)</span>, which can be arbitrarily small.
This leads to an unacceptable time step constraint for <a class="reference internal" href="#equation-conservativeupdate">Eq. 4</a>.
We use the Chombo approach and expand the range of influence of the cut cells in order to stabilize the discretization and allow the use of a normal time step constraint.
First, we compute the conservative divergence</p>
<div class="math notranslate nohighlight">
\[\kappa_{\mathbf{i}} D_\mathbf{i}^c =  \sum_f G_f\alpha_f\Delta x^{\textrm{DIM} -1},\]</div>
<p>where <span class="math notranslate nohighlight">\(G_f = \mathbf{G}_f\cdot \mathbf{n}_f\)</span>. Next, we compute a non-conservative divergence <span class="math notranslate nohighlight">\(D_{\mathbf{i}}^{nc}\)</span></p>
<div class="math notranslate nohighlight">
\[D_\mathbf{i}^{nc} =  \frac{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}D_\mathbf{i}^c}{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}}\]</div>
<p>where <span class="math notranslate nohighlight">\(N(\mathbf{i})\)</span> indicates some neighborhood of cells around cell <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>. Next, we compute a hybridization of the divergences,</p>
<div class="math notranslate nohighlight">
\[D_{\mathbf{i}}^H = \kappa_{\mathbf{i}} D_{\mathbf{i}}^c + (1-\kappa_{\mathbf{i}})D_{\mathbf{i}}^{nc},\]</div>
<p>and perform an intermediate update</p>
<div class="math notranslate nohighlight">
\[\phi_{\mathbf{i}}^{k+1} = \phi_{\mathbf{i}}^k - \Delta tD_{\mathbf{i}}^H.\]</div>
<p>The hybrid divergence update fails to conserve mass by an amount <span class="math notranslate nohighlight">\(\delta M_{\mathbf{i}} = \kappa_{\mathbf{i}}\left(1-\kappa_{\mathbf{i}}\right)\left(D_{\mathbf{i}}^c - D_{\mathbf{i}}^{nc}\right)\)</span>.
In order to main overall conservation, the excess mass is redistributed into neighboring grid cells.
Let <span class="math notranslate nohighlight">\(\delta M_{\mathbf{i}, \mathbf{j}}\)</span> be the redistributed mass from <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> to <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> where</p>
<div class="math notranslate nohighlight">
\[\delta M_{\mathbf{i}} = \sum_{\mathbf{j} \in N(\mathbf{i})}\delta M_{\mathbf{i}, \mathbf{i}}.\]</div>
<p>This mass is used as a local correction in the vicinity of the cut cells, i.e.</p>
<div class="math notranslate nohighlight">
\[\phi_{\mathbf{i}}^{k+1} \rightarrow \phi_{\mathbf{i}}^{k+1} + \delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}},\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}}\)</span> is the total mass redistributed to cell <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> from the other cells.
After these steps, we define</p>
<div class="math notranslate nohighlight">
\[\left[\nabla\cdot\mathbf{G}^k\right]_{\mathbf{i}} \equiv \frac{1}{\Delta t}\left(\phi_{\mathbf{i}}^{k+1} - \phi_{\mathbf{i}}^k\right)\]</div>
<p>Numerically, the above steps for computing a conservative divergence of a one-component flux <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> are implemented in the convection-diffusion-reaction solvers, which also respects boundary conditions (e.g. charge injection).
The user will need to call the function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">void</span> <span class="n">CdrSolver</span><span class="o">::</span><span class="n">computeDivG</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_divG</span><span class="p">,</span> <span class="n">EBAMRFluxData</span><span class="o">&amp;</span> <span class="n">a_G</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRIVData</span><span class="o">&amp;</span> <span class="n">a_ebG</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a_G</span></code> is the numerical representation of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> over the cut-cell AMR hierarchy and must be stored on cell-centered faces, and <code class="docutils literal notranslate"><span class="pre">a_ebG</span></code> is the flux on the embedded boundary.
The above steps are performed by interpolating <code class="docutils literal notranslate"><span class="pre">a_G</span></code> to face centroids in the cut cells for computing the conservative divergence, and the remaining steps are then performed successively.
The result is put in <code class="docutils literal notranslate"><span class="pre">a_divG</span></code>.</p>
<p>Note that when refinement boundaries intersect with embedded boundaries, the redistribution process is far more complicated since it needs to account for mass that moves over refinement boundaries.
These additional complicated are taken care of inside <code class="docutils literal notranslate"><span class="pre">a_divG</span></code>, but are not discussed in detail here.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mass redistribution has the effect of not being monotone and thus not TVD, and the discretization order is formally <span class="math notranslate nohighlight">\(\mathcal{O}(\Delta x)\)</span>.
If negative densities are a problem, the <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> has an option to use mass-weighted redistribution in order to redistribute mass in the neighborhood of the cut cells.
The default is false, in which case the redistribution uses volume-weighted redistribution.</p>
</div>
</div>
<div class="section" id="explicit-advection">
<span id="chap-explicitadvection"></span><h3>Explicit advection<a class="headerlink" href="#explicit-advection" title="Permalink to this headline"></a></h3>
<p>Scalar advection updates follows the computation of the explicit divergence discussed in <a class="reference internal" href="#chap-explicitdivergence"><span class="std std-ref">Computing explicit divergences</span></a>.
The face-centered fluxes <span class="math notranslate nohighlight">\(\mathbf{G} = \phi\mathbf{v}\)</span> are computed by instantiation classes for the convection-diffusion-reaction solvers.
The function signature for explicit advection is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">computeDivF</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_divF</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_state</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">a_extrap_dt</span><span class="p">)</span>
</pre></div>
</div>
<p>where the face-centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in <code class="docutils literal notranslate"><span class="pre">a_divF</span></code> using the procedure outlined above.
For example, in order to perform an advective advance over a time step <span class="math notranslate nohighlight">\(\Delta t\)</span>, one would perform the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="o">*</span> <span class="n">solver</span><span class="p">;</span>

<span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phi</span>  <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getPhi</span><span class="p">();</span>     <span class="c1">// Cell-centered state</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">divF</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getScratch</span><span class="p">();</span> <span class="c1">// Scratch storage in solver</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>        <span class="c1">// Computes divF</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divF</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>               <span class="c1">// makes phi -&gt; phi - dt*divF</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-diffusion">
<span id="chap-explicitdiffusion"></span><h3>Explicit diffusion<a class="headerlink" href="#explicit-diffusion" title="Permalink to this headline"></a></h3>
<p>Explicit diffusion is performed in much the same way as implicit advection, with the exception that the general flux <span class="math notranslate nohighlight">\(\mathbf{G} = D\nabla\phi\)</span> is computed by using centered differences on face centers.
The function signature for explicit diffusion is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">computeDivD</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_divF</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_state</span><span class="p">)</span>
</pre></div>
</div>
<p>and we increment in the same way as for explicit advection:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="o">*</span> <span class="n">solver</span><span class="p">;</span>

<span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phi</span>  <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getPhi</span><span class="p">();</span>     <span class="c1">// Cell-centered state</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">divD</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getScratch</span><span class="p">();</span> <span class="c1">// Scratch storage in solver</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divD</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>        <span class="c1">// Computes divD</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divD</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>                <span class="c1">// makes phi -&gt; phi + dt*divD</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-advection-diffusion">
<span id="chap-explicitadvectiondiffusion"></span><h3>Explicit advection-diffusion<a class="headerlink" href="#explicit-advection-diffusion" title="Permalink to this headline"></a></h3>
<p>There is also functionality for aggregating explicit advection and diffusion advances.
The reason for this is that the cut-cell overhead is only applied once on the combined flux <span class="math notranslate nohighlight">\(\phi\mathbf{v} - D\nabla\phi\)</span> rather than on the individual fluxes.
For non-split methods this leads to some performance improvement since the interpolation of fluxes on cut-cell faces only needs to be performed once.
The signature for this is precisely the same as for explicit advection only:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">computeDivJ</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_divJ</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_state</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">a_extrapDt</span><span class="p">)</span>
</pre></div>
</div>
<p>where the face-centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in <code class="docutils literal notranslate"><span class="pre">a_divF</span></code>.
For example, in order to perform an advective advance over a time step <span class="math notranslate nohighlight">\(\Delta t\)</span>, one would perform the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phi</span>  <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getPhi</span><span class="p">();</span>     <span class="c1">// Cell-centered state</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">divJ</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">getScratch</span><span class="p">();</span> <span class="c1">// Scratch storage in solver</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivJ</span><span class="p">(</span><span class="n">divJ</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>        <span class="c1">// Computes divD</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divJ</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>               <span class="c1">// makes phi -&gt; phi - dt*divJ</span>
</pre></div>
</div>
<p>Often, time integrators have the option of using implicit or explicit diffusion.
If the time-evolution is not split (i.e. not using a Strang or Godunov splitting), the integrators will often call <code class="docutils literal notranslate"><span class="pre">computeDivJ</span></code> rather separately calling <code class="docutils literal notranslate"><span class="pre">computeDivF</span></code> and <code class="docutils literal notranslate"><span class="pre">computeDivD</span></code>.
If you had a split-step Godunov method, the above procedure for a forward Euler method for both parts would be:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CdrSolver</span><span class="o">*</span> <span class="n">solver</span><span class="p">;</span>

<span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Computes divF = div(n*phi)</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divF</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>        <span class="c1">// makes phi -&gt; phi - dt*divF</span>

<span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivD</span><span class="p">(</span><span class="n">divD</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span>      <span class="c1">// Computes divD = div(D*nabla(phi))</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divD</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>         <span class="c1">// makes phi -&gt; phi + dt*divD</span>
</pre></div>
</div>
<p>However, the cut-cell redistribution dance (flux interpolation, hybrid divergence, and redistribution) would be performed twice.</p>
</div>
<div class="section" id="implicit-diffusion">
<span id="chap-implicitdiffusion"></span><h3>Implicit diffusion<a class="headerlink" href="#implicit-diffusion" title="Permalink to this headline"></a></h3>
<p>Occasionally, the use of implicit diffusion is necessary.
The convection-diffusion-reaction solvers support two basic diffusion solves:
Backward Euler and the Twizel-Gumel-Arigu (TGA) methods.
The function signatures for these are</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">advanceEuler</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiNew</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiOld</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">advanceTGA</span><span class="p">(</span>  <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiNew</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiOld</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>

<span class="kt">void</span> <span class="n">advanceEuler</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiNew</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiOld</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">advanceTGA</span><span class="p">(</span>  <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiNew</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiOld</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">phiNew</span></code> is the state at the new time <span class="math notranslate nohighlight">\(t + \Delta t\)</span>, <code class="docutils literal notranslate"><span class="pre">phiOld</span></code> is the state at time <span class="math notranslate nohighlight">\(t\)</span> and <code class="docutils literal notranslate"><span class="pre">src</span></code> is the source term which strictly speaking should be centered at time <span class="math notranslate nohighlight">\(t + \Delta t\)</span> for the Euler update and at time <span class="math notranslate nohighlight">\(t + \Delta t/2\)</span> for the TGA update.
This may or may not be possible for your particular problem.</p>
<p>For example, performing a split step Godunov method for advection-diffusion is as simple as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Computes divF = div(n*phi)</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divF</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>        <span class="c1">// makes phi -&gt; phi - dt*divF</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">redistribute_negative</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>   <span class="c1">// Redist negative mass in cut cells</span>

<span class="n">DataOps</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">phiOld</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span>            <span class="c1">// Copy state</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">advanceEuler</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">phiOld</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span> <span class="c1">// Backward Euler diffusion solve</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The backward Euler method can easily by turned into a Crank-Nicholson method by modifying the source term and time step.</p>
</div>
</div>
<div class="section" id="adding-a-stochastic-flux">
<h3>Adding a stochastic flux<a class="headerlink" href="#adding-a-stochastic-flux" title="Permalink to this headline"></a></h3>
<p>It is possible to add a stochastic flux through the public member functions of <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> in the odd case that one wants to use fluctuating hydrodynamics (FHD).
This is done by calling a function that computes the term <span class="math notranslate nohighlight">\(\sqrt{2D\phi}\mathbf{Z}\)</span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">gwnDiffusionSource</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_noiseSource</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_cellPhi</span><span class="p">);</span>
</pre></div>
</div>
<p>When FHD is used, there is no guarantee that the evolution leads to non-negative values.
We do our best to ensure that the stochastic flux is turned off when <span class="math notranslate nohighlight">\(\phi \Delta V\)</span> approaches 0 by computing the face-centered states for the stochastic term using an arithmetic mean that goes to zero as <span class="math notranslate nohighlight">\(\phi\)</span> approaches 0.</p>
<p>In the above function, <code class="docutils literal notranslate"><span class="pre">a_ransource</span></code> can be used directly in a MOL context, e.g.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">computeDivF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Computes divF = div(n*phi)</span>
<span class="nl">DataOps</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divF</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>        <span class="c1">// makes phi -&gt; phi - dt*divF</span>

<span class="n">solver</span><span class="o">-&gt;</span><span class="n">gwnDiffusionSource</span><span class="p">(</span><span class="n">ransource</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span>  <span class="c1">// Compute stochastic flux</span>
<span class="n">DataOps</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">phiOld</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span>                  <span class="c1">// phiOld = phi - dt*divF</span>
<span class="n">DataOps</span><span class="o">::</span><span class="n">incr</span><span class="p">(</span><span class="n">phiOld</span><span class="p">,</span> <span class="n">ransource</span><span class="p">,</span> <span class="n">a_dt</span><span class="p">);</span>      <span class="c1">// phiOld = phi - dt*divF + dt*sqrt(2D*phi)Z</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">advanceEuler</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">phiOld</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>       <span class="c1">// Backward Euler diffusion solve.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-application">
<h2>Example application<a class="headerlink" href="#example-application" title="Permalink to this headline"></a></h2>
<p>An example application of usage of the <code class="docutils literal notranslate"><span class="pre">CdrSolver</span></code> is found in <a class="reference internal" href="../Applications/AdvectionDiffusionModel.html#chap-advectiondiffusionmodel"><span class="std std-ref">Advection diffusion</span></a>.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../Source/GeoCoarsener.html" class="btn btn-neutral float-left" title="GeoCoarsener" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Electrostatics.html" class="btn btn-neutral float-right" title="Electrostatics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>