<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Electrostatic solver &mdash; chombo-discharge  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
      <link rel="stylesheet" type="text/css" href="../_static/my_theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Îto diffusion" href="Ito.html" />
    <link rel="prev" title="Convection-Diffusion-Reaction" href="CDR.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            chombo-discharge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Documentation.html">Using this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Testing.html">Code testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Acknowledgements.html">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Source/DesignOverview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/CellTagger.html">CellTagger</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Source/SpatialDiscretization.html">Spatial discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/MeshData.html">Mesh data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/LinearSolvers.html">Linear solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/VV.html">Verification and validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="CDR.html">Convection-Diffusion-Reaction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Electrostatic solver</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#fieldsolver">FieldSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-fieldsolver">Using FieldSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-the-voltage">Setting the voltage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#domain-boundary-conditions">Domain boundary conditions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-format">General format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simplified-format">Simplified format</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dirichlet">Dirichlet</a></li>
<li class="toctree-l4"><a class="reference internal" href="#neumann">Neumann</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#eb-boundary-conditions">EB boundary conditions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#electrodes">Electrodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dielectrics">Dielectrics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#calling-the-solve-function">Calling the solve function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fieldsolvergmg">FieldSolverGMG</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#solver-configuration">Solver configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-boundary-conditions">Setting boundary conditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#algorithmic-adjustments">Algorithmic adjustments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuning-multigrid-performance">Tuning multigrid performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adjusting-output">Adjusting output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saturation-charge-bc">Saturation charge BC</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#frequency-dependent-permittivity">Frequency dependent permittivity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#convolution-approach">Convolution approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#auxiliary-differential-equation">Auxiliary differential equation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#limitations">Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-application-s">Example application(s)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Ito.html">Îto diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="KineticMonteCarlo.html">Kinetic Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshODESolver.html">Mesh ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="SurfaceODESolver.html">Surface ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="TracerParticles.html">Tracer particles</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multi-physics applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/DischargeInceptionModel.html">Discharge inception model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ItoKMC.html">Îto-KMC plasma model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Single-solver applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection-diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/MeshODEModel.html">Mesh ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/TracerParticleModel.html">Tracer particle model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/DataParser.html">Data parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">LookupTable1D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Electrostatic solver</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Solvers/Electrostatics.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="electrostatic-solver">
<span id="chap-electrostatics"></span><h1>Electrostatic solver<a class="headerlink" href="#electrostatic-solver" title="Permalink to this heading"></a></h1>
<p>Here, we discuss the discretization of the equation</p>
<div class="math notranslate nohighlight" id="equation-poisson">
<span class="eqno">(7)<a class="headerlink" href="#equation-poisson" title="Permalink to this equation"></a></span>\[\nabla\cdot\left(\epsilon_r\nabla\Phi\right) = -\frac{\rho}{\epsilon_0}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi\)</span> is the electric potential, <span class="math notranslate nohighlight">\(\rho\)</span> is the space charge density, and <span class="math notranslate nohighlight">\(\epsilon_0\)</span> is the vacuum permittivity.
The relative permittivity is <span class="math notranslate nohighlight">\(\epsilon_r = \epsilon_r\left(\mathbf{x}\right)\)</span> and can additionally be discontinuous at gas-dielectric interfaces.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All current electrostatic field solvers solve for the potential at the cell center (not the cell centroid).
The code for the electrostatics solver is given in <code class="file docutils literal notranslate"><span class="pre">/Source/Electrostatics</span></code> and <code class="file docutils literal notranslate"><span class="pre">/Source/Elliptic</span></code>.</p>
</div>
<section id="fieldsolver">
<span id="chap-fieldsolver"></span><h2>FieldSolver<a class="headerlink" href="#fieldsolver" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> is an abstract class for electrostatic solves in an EB context and contains most routines required for setting up and solving electrostatic problems.
<code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> can solve over three phases, gas, dielectric, and electrode, and thus it is uses <code class="docutils literal notranslate"><span class="pre">MFAMRCellData</span></code> functionality where data is defined over multiple phases (see <a class="reference internal" href="../Source/MeshData.html#chap-meshdata"><span class="std std-ref">Mesh data</span></a>).</p>
<p>Note that in order to separate the electrostatic solver interface from the implementation, <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> is a pure class without knowledge of numerical discretizations.
Currently, our only supported subclass is <a class="reference internal" href="#chap-fieldsolvergmg"><span class="std std-ref">FieldSolverGMG</span></a>, which supplies a finite-volume discretization that is solved with geometric multigrid.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>See the <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classFieldSolver.html">FieldSolver C++ API</a> for the complete interface.</p>
</div>
<p>On gas-dielectric interfaces we enforce an extra equation</p>
<div class="math notranslate nohighlight" id="equation-gaussbc">
<span class="eqno">(8)<a class="headerlink" href="#equation-gaussbc" title="Permalink to this equation"></a></span>\[\epsilon_1\partial_{n_1}\Phi + \epsilon_2\partial_{n_2}\Phi = \sigma/\epsilon_0\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{n}_1 = -\mathbf{n}_2\)</span> are the normal vectors pointing away from interface, and <span class="math notranslate nohighlight">\(\sigma\)</span> is the surface charge density.</p>
<p>We point out that this equation can be enforced in various formats.
The most common case is that <span class="math notranslate nohighlight">\(\partial_n\Phi\)</span> are free parameters and <span class="math notranslate nohighlight">\(\sigma\)</span> is a fixed parameter.
However, we <em>can</em> also fix <span class="math notranslate nohighlight">\(\partial_n\Phi\)</span> on one side of the boundary and let <span class="math notranslate nohighlight">\(\sigma\)</span> be the free parameter.
When using <code class="docutils literal notranslate"><span class="pre">FieldSolverGMG</span></code> (see <a class="reference internal" href="#chap-fieldsolvergmg"><span class="std std-ref">FieldSolverGMG</span></a>), users can choose between these two natural boundary conditions, see <a class="reference internal" href="#chap-poissonebbc"><span class="std std-ref">EB boundary conditions</span></a>.</p>
</section>
<section id="using-fieldsolver">
<h2>Using FieldSolver<a class="headerlink" href="#using-fieldsolver" title="Permalink to this heading"></a></h2>
<p>Using the <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> is usually straightforward by first constructing the solver and then parsing the class options.
This usually involves several steps, such as instantiating the solver and providing proper references to <a class="reference internal" href="../Source/AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a> and the computational geometry.
In addition, the user must set up a voltage curve and associated boundary conditions.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>A complete example of setting up electrostatic problems and solving them is given in <a class="reference internal" href="../Applications/ElectrostaticsModel.html#chap-electrostaticsmodel"><span class="std std-ref">Electrostatics model</span></a>.</p>
</div>
</section>
<section id="setting-the-voltage">
<h2>Setting the voltage<a class="headerlink" href="#setting-the-voltage" title="Permalink to this heading"></a></h2>
<p>The function signature for setting the voltage on various parts is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Set potential dependence in time. </span>
<span class="cm">  @param[in] a_voltage Function pointer which sets the voltage travel curve. </span>
<span class="cm">  @details If you want something more complex, the voltage can be set individually for each electrode using setElectrodeDirichletFunction.</span>
<span class="cm">*/</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">setVoltage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_voltage</span><span class="p">);</span>
</pre></div>
</div>
<p>This allows setting a time-dependent voltage on electrodes and domain boundaries.
As shown above, one can easily use <code class="docutils literal notranslate"><span class="pre">std::function&lt;Real(const</span> <span class="pre">Real)&gt;</span></code> or lambdas to set the voltage.
It is relatively straightforward to turn tabulated data (see <a class="reference internal" href="../Utilities/LookupTable.html#chap-lookuptable"><span class="std std-ref">LookupTable1D</span></a>) into lambda functions.
A simple example that returns a linearly varying voltage is given below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">FieldSolver</span><span class="o">*</span><span class="w"> </span><span class="n">fieldSolver</span><span class="p">;</span>

<span class="n">Real</span><span class="w"> </span><span class="n">myVoltage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="o">*</span><span class="n">a_time</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">fieldSolver</span><span class="o">-&gt;</span><span class="n">setVoltage</span><span class="p">(</span><span class="n">myVoltage</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="domain-boundary-conditions">
<span id="chap-poissondomainbc"></span><h2>Domain boundary conditions<a class="headerlink" href="#domain-boundary-conditions" title="Permalink to this heading"></a></h2>
<p>Domain boundary conditions for the solver must be set by the user through an input script, whereas the boundary conditions on internal surfaces are Dirichlet by default.
Note that on multifluid-boundaries the boundary condition is enforced by the conventional matching boundary condition that follows from Gauss` law.</p>
<section id="general-format">
<h3>General format<a class="headerlink" href="#general-format" title="Permalink to this heading"></a></h3>
<p>The most general form of setting domain boundary conditions for <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> is to specify a boundary condition <em>type</em> (e.g., Dirichlet) together with a function specifying the value.
Domain boundary condition <em>types</em> are parsed through a member function <code class="docutils literal notranslate"><span class="pre">FieldSolver::parseDomainBc</span></code>.
This function will read string identifiers from the input script, and these identifiers are either in the format <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span> <span class="pre">&lt;float&gt;</span></code> (simplified format) or in the format <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> (general format).
For setting general types of Neumann or Dirichlet BCs on the domain sides, one will specify</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>FieldSolverGMG.bc.x.low  = dirichlet_custom
FieldSolverGMG.bc.x.high = dirichlet_neumann
</pre></div>
</div>
<p>Unfortunately, due to the many degrees of freedom in setting domain boundary conditions, the procedure is a bit convoluted.
We first explain the general procedure.</p>
<p><code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> will always set individual space-time functions on each domain side, and these functions are always in the form</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_position</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bcFunction</span><span class="p">;</span>
</pre></div>
</div>
<p>To set a domain boundary condition function on a side, one can use the following member function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">FieldSolver::setDomainSideBcFunction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_dir</span><span class="p">,</span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="n">Side</span><span class="o">::</span><span class="n">LoHiSide</span><span class="w"> </span><span class="n">a_side</span><span class="p">,</span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_position</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>For a general way of setting the function value on the domain side, one will use the above function together with an identifier <code class="docutils literal notranslate"><span class="pre">dirichlet_custom</span></code> or <code class="docutils literal notranslate"><span class="pre">neumann_custom</span></code> in the input script.
This identifier simply tells <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> to use that function to either specifiy <span class="math notranslate nohighlight">\(\Phi\)</span> or <span class="math notranslate nohighlight">\(\partial_n\Phi\)</span> on the boundary.
These functions are then directly processed by the numerical discretizations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On construction, <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> will set all the domain boundary condition functions to a constant of one (because the functions need to be populated).</p>
</div>
</section>
<section id="simplified-format">
<h3>Simplified format<a class="headerlink" href="#simplified-format" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> also supports a simplified method of setting the domain boundary conditions, in which case the user will specify Neumann or Dirichlet values (rather than functions) for each domain side.
These values are usually, but not necessarily, constant values.</p>
<p>In this case one will use an identifier <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span> <span class="pre">&lt;float&gt;</span></code> in the input script, like so:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>FieldSolverGMG.bc.x.low  = neumann   0.0
FieldSolverGMG.bc.x.high = dirichlet 1.0
</pre></div>
</div>
<p>The floating point number has a slightly different interpretation for the two types of BCs.
Moreover, when using the simplified format the function specified through <code class="docutils literal notranslate"><span class="pre">setDomainSideBcFunction</span></code> will be used as a multiplier rather than being parsed directly into the numerical discretization.
Although this may <em>seem</em> more involved, this procedure is usually easier to use when setting constant Neumann/Dirichlet values on the domain boundaries.
It also automatically provides a link between a specified voltage wave form and the boundary conditions (unlike the general format, where the user must supply that link themselves).</p>
<section id="dirichlet">
<h4>Dirichlet<a class="headerlink" href="#dirichlet" title="Permalink to this heading"></a></h4>
<p>When using simplified parsing of Dirichlet domain BCs, <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> will generate and parse a different function into the discretizations.
This function is <em>not</em> the same function as that which is parsed through <code class="docutils literal notranslate"><span class="pre">setDomainSideBcFunction</span></code>.
In C++ pseudo-code, this function is in the format</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span><span class="w"> </span><span class="n">dirichletFraction</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="p">...](</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voltage</span><span class="p">(</span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dirichletFraction</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">voltage</span></code> is the voltage wave form specified through <code class="docutils literal notranslate"><span class="pre">FieldSolver::setVoltage</span></code>, and <code class="docutils literal notranslate"><span class="pre">dirichletFraction</span></code> is a placeholder for the floating point number specified in the input script, i.e. the floating point number in the input option.
For Dirichlet boundary conditions the solver will always multiply the provided input function by the voltage waveform.
That is, the function <code class="docutils literal notranslate"><span class="pre">func(a_pos,</span> <span class="pre">a_time)</span></code> is the space-time function set through <code class="docutils literal notranslate"><span class="pre">setDomainSideBcFunction</span></code>.
Recall that, by default, this function is set to one so that the default voltage that is parsed into the numerical discretization is simply the specified voltage multiplied by the specified fraction in the input script.
For example, using</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>FieldSolverGMG.bc.y.low  = dirichlet 0.0
FieldSolverGMG.bc.y.high = dirichlet 1.0
</pre></div>
</div>
<p>will the set voltage on the lower y-plane to ground and the voltage on the upper y-plane to the live voltage.
Specifically, on the upper y-plane this specification will generate a potential boundary condition function of the type</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="p">};</span>
<span class="n">dirichletFraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">bc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">func</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">voltage</span><span class="p">(</span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dirichletFraction</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In order to set the voltage on the domain side to also be spatially dependent, one can either use <code class="docutils literal notranslate"><span class="pre">dirichlet_custom</span></code> as an input option, or <code class="docutils literal notranslate"><span class="pre">dirichlet</span> <span class="pre">&lt;float&gt;</span></code> and set a different multiplier on the domain edge (face).
As an example. by specifying <code class="docutils literal notranslate"><span class="pre">bc.y.high</span> <span class="pre">=</span> <span class="pre">dirichlet</span> <span class="pre">1.234</span></code> in the input script AND setting the multiplier on the wall as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">wallFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">fieldSolver</span><span class="o">-&gt;</span><span class="n">setDomainSideBcFunction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Side</span><span class="o">::</span><span class="n">Hi</span><span class="p">,</span><span class="w"> </span><span class="n">wallFunc</span><span class="p">);</span>
</pre></div>
</div>
<p>we end up with a voltage of</p>
<div class="math notranslate nohighlight">
\[V(\mathbf{x},t) = 1.234(1-y)V(t)\]</div>
<p>on the upper y-plane.</p>
</section>
<section id="neumann">
<h4>Neumann<a class="headerlink" href="#neumann" title="Permalink to this heading"></a></h4>
<p>When using simplified parsing of Neumann boundary conditions, the procedure is precisely like that for Dirichlet boundary conditions <em>except</em> that multiplication by the voltage wave form is not made.
I.e. the boundary condition function that is passed into the numerical discretization is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span><span class="w"> </span><span class="n">neumannFraction</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="p">...](</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">neumannFraction</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that since <code class="docutils literal notranslate"><span class="pre">func</span></code> is initialized to one, the floating point number in the input option directly specifies the value of <span class="math notranslate nohighlight">\(\partial_n\Phi\)</span>.</p>
</section>
</section>
</section>
<section id="eb-boundary-conditions">
<span id="chap-poissonebbc"></span><h2>EB boundary conditions<a class="headerlink" href="#eb-boundary-conditions" title="Permalink to this heading"></a></h2>
<section id="electrodes">
<h3>Electrodes<a class="headerlink" href="#electrodes" title="Permalink to this heading"></a></h3>
<p>For the current <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> the natural BC at the EB is Dirichlet with a specified voltage, whereas on dielectrics we enforce <a class="reference internal" href="#equation-gaussbc">Eq. 8</a>.
The voltage on the electrodes are automatically retrieved from the specified voltages on the electrodes in the geometry being used (see <a class="reference internal" href="../Source/ComputationalGeometry.html#chap-computationalgeometry"><span class="std std-ref">ComputationalGeometry</span></a>).
The exception to this is that while <a class="reference internal" href="../Source/ComputationalGeometry.html#chap-computationalgeometry"><span class="std std-ref">ComputationalGeometry</span></a> specifies that an electrode will be at some fraction of a specified voltage, <code class="docutils literal notranslate"><span class="pre">FieldSolverGMG</span></code> uses this fraction <em>and</em> the specified voltage wave form in <code class="docutils literal notranslate"><span class="pre">setVoltage</span></code>.</p>
<p>To understand how the voltage on the electrode is being set, we first remark that our implementation uses a completely general specification of the voltage on each electrode in both space and time.
This voltage has the form</p>
<div class="math notranslate nohighlight">
\[V_i = V_i\left(\mathbf{x}, t\right).\]</div>
<p>where <span class="math notranslate nohighlight">\(V_i\)</span> is the voltage on electrode <span class="math notranslate nohighlight">\(i\)</span>.
It is possible to interact with this function directly, going through all electrodes and setting the electrode to be spatially and temporally varying.
The member function that does this is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Set embedded boundary Dirichlet function on a specific electrode.</span>
<span class="cm">  @param[in] a_electrode electrode index. Follows the same order as ComputationalGeometry. </span>
<span class="cm">  @param[in] a_function  Voltage on the electrode. </span>
<span class="cm">*/</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">setElectrodeDirichletFunction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_electrode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ElectrostaticEbBc</span><span class="o">::</span><span class="n">BcFunction</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_function</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, the type <code class="docutils literal notranslate"><span class="pre">ElectrostaticEbBc::BcFunction</span></code> is just an alias of <code class="docutils literal notranslate"><span class="pre">std::function&lt;Real(const</span> <span class="pre">RealVect</span> <span class="pre">a_position,</span> <span class="pre">const</span> <span class="pre">Real</span> <span class="pre">a_time)&gt;</span></code>.
The voltage on an electrode <span class="math notranslate nohighlight">\(i\)</span> could thus be set as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">electrode</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">myElectrodeVoltage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_position</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Real</span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">fieldSolver</span><span class="o">-&gt;</span><span class="n">setElectrodeDirichletFunction</span><span class="p">(</span><span class="n">electrode</span><span class="p">,</span><span class="w"> </span><span class="n">myElectrodeVoltage</span><span class="p">);</span>
</pre></div>
</div>
<p>where the return value can be replaced by the user function.
In principle, one can then also set spatially varying voltages along an electrode.</p>
<p>In the majority of cases the voltage on electrodes is either a live voltage or ground.
Thus, although the above format is a general way of setting the voltage individually on each electrode (in both space and time) <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> supports a simpler way of generating these voltage waveforms.
When <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code> is instantiated, it will interally generate these functions through simplified expression such that the user only needs to set a single wave form that applies to all electrodes.
The voltages that are set on the various electrodes are thus in the form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">electrode</span><span class="p">;</span>
<span class="n">Real</span><span class="w"> </span><span class="n">voltageFraction</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">voltageWaveForm</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">defaultElectrodeVoltage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...](</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_position</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Real</span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">voltageFraction</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">voltageWaveForm</span><span class="p">(</span><span class="n">a_time</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">fieldSolver</span><span class="o">-&gt;</span><span class="n">setElectrodeDirichletFunction</span><span class="p">(</span><span class="n">electrode</span><span class="p">,</span><span class="w"> </span><span class="n">defaultElectrodeVoltage</span><span class="p">);</span>
</pre></div>
</div>
<p>In summary, the default voltage which is set on an electrode is the voltage <em>fraction</em> specified on the electrodes (in <a class="reference internal" href="../Source/ComputationalGeometry.html#chap-computationalgeometry"><span class="std std-ref">ComputationalGeometry</span></a>) multiplied by a voltage wave form (specified by <code class="docutils literal notranslate"><span class="pre">FieldSolver::setVoltage</span></code>, as discussed above).</p>
</section>
<section id="dielectrics">
<h3>Dielectrics<a class="headerlink" href="#dielectrics" title="Permalink to this heading"></a></h3>
<p>On dielectrics, we enforce the jump boundary condition directly, see <a class="reference internal" href="../Source/LinearSolvers.html#chap-jumpcondition"><span class="std std-ref">Jump conditions</span></a>.</p>
</section>
</section>
<section id="calling-the-solve-function">
<h2>Calling the solve function<a class="headerlink" href="#calling-the-solve-function" title="Permalink to this heading"></a></h2>
<p>The electrostatic solver in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> has a lot of supporting functionality, but essentially relies on only one critical function:
Solving for the potential.
This is encapsulated by the pure member function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Solves Poisson equation onto a_phi using a_rho and a_sigma as right-hand sides. </span>
<span class="cm">  @param[inout] a_potential Potential</span>
<span class="cm">  @param[in]    a_rho Space charge density</span>
<span class="cm">  @param[in]    a_sigma Surface charge density. </span>
<span class="cm">  @param[in]    a_zeroPhi Set a_potential to zero first. </span>
<span class="cm">  @return True if we found a solution and false otherwise. </span>
<span class="cm">  @note a_sigma must be defined on the gas phase. </span>
<span class="cm">*/</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span>
<span class="nf">solve</span><span class="p">(</span><span class="n">MFAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_phi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MFAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_rho</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRIVData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_sigma</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">a_zerophi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a_phi</span></code> is the resulting potential that was computing with the space charge density <code class="docutils literal notranslate"><span class="pre">a_rho</span></code>, and surface charge density <code class="docutils literal notranslate"><span class="pre">a_sigma</span></code>.</p>
</section>
<section id="fieldsolvergmg">
<span id="chap-fieldsolvergmg"></span><h2>FieldSolverGMG<a class="headerlink" href="#fieldsolvergmg" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG</span></code> implements a multigrid routine for solving <a class="reference internal" href="#equation-poisson">Eq. 7</a>, and is currently the only implementation of <code class="docutils literal notranslate"><span class="pre">FieldSolver</span></code>.</p>
<p>The discretization used by <code class="docutils literal notranslate"><span class="pre">FieldSolverGMG</span></code> is described in <a class="reference internal" href="../Source/LinearSolvers.html#chap-linearsolvers"><span class="std std-ref">Linear solvers</span></a>.
The underlying solver type is a Helmholtz solver, but <code class="docutils literal notranslate"><span class="pre">FieldSolverGMG</span></code> considers only the Laplacian term.
For further details on the spatial discretization, see <a class="reference internal" href="../Source/LinearSolvers.html#chap-linearsolvers"><span class="std std-ref">Linear solvers</span></a>.</p>
<section id="solver-configuration">
<h3>Solver configuration<a class="headerlink" href="#solver-configuration" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG</span></code> has a number of switches for determining how it operates.
Some of these switches are intended for parsing boundary conditions, whereas others are settings for operating multigrid or for I/O.
The current list of configuration options are indicated below</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-number">Listing 26 </span><span class="caption-text">Input options for the <code class="docutils literal notranslate"><span class="pre">FieldSolverGMG</span></code> class. Runtime adjustable options are highlighted.</span><a class="headerlink" href="#id1" title="Permalink to this code"></a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># ====================================================================================================
# FieldSolverGMG class options
# ====================================================================================================
<span class="hll">FieldSolverGMG.verbosity             = -1               ## Class verbosity
</span>FieldSolverGMG.jump_bc               = natural          ## Jump BC type (&#39;natural&#39; or &#39;saturation_charge&#39;)
FieldSolverGMG.bc.x.lo               = dirichlet 0.0    ## Bc type (see docs)
FieldSolverGMG.bc.x.hi               = dirichlet 0.0    ## Bc type (see docs)
FieldSolverGMG.bc.y.lo               = dirichlet 0.0    ## Bc type (see docs)
FieldSolverGMG.bc.y.hi               = dirichlet 0.0    ## Bc type (see docs)
FieldSolverGMG.bc.z.lo               = dirichlet 0.0    ## Bc type (see docs)
FieldSolverGMG.bc.z.hi               = dirichlet 0.0    ## Bc type (see docs)
<span class="hll">FieldSolverGMG.plt_vars              = phi rho E        ## Plot variables: &#39;phi&#39;, &#39;rho&#39;, &#39;E&#39;, &#39;res&#39;, &#39;perm&#39;, &#39;sigma&#39;, &#39;Esol&#39;
</span><span class="hll">FieldSolverGMG.use_regrid_slopes     = true             ## Use slopes when regridding or not
</span><span class="hll">FieldSolverGMG.kappa_source          = true             ## Volume weighted space charge density or not (depends on algorithm)
</span>
<span class="hll">FieldSolverGMG.gmg_verbosity                = -1           ## GMG verbosity
</span><span class="hll">FieldSolverGMG.gmg_use_default_settings     = true         ## Use default multigrid settings or not (see documentation)
</span><span class="hll">FieldSolverGMG.gmg_cycle                    = vcycle       ## Cycle type. Only &#39;vcycle&#39; supported for now.
</span><span class="hll">FieldSolverGMG.gmg_smoother                 = red_black    ## Relaxation type. &#39;jacobi&#39;, &#39;multi_color&#39;, or &#39;red_black&#39;
</span><span class="hll">FieldSolverGMG.gmg_relax_factor             = 1.0          ## Adjustable SOR factor
</span><span class="hll">FieldSolverGMG.gmg_pre_smooth               = 12           ## Number of relaxations in downsweep
</span><span class="hll">FieldSolverGMG.gmg_post_smooth              = 12           ## Number of relaxations in upsweep
</span><span class="hll">FieldSolverGMG.gmg_bott_smooth              = 0            ## Number of at bottom level (before dropping to bottom solver)
</span><span class="hll">FieldSolverGMG.gmg_precond_smooth           = 40           ## Number of smoothing steps in the preconditioner
</span><span class="hll">FieldSolverGMG.gmg_min_iter                 = 5            ## Minimum number of iterations
</span><span class="hll">FieldSolverGMG.gmg_max_iter                 = 50           ## Maximum number of iterations
</span><span class="hll">FieldSolverGMG.gmg_exit_tol                 = 1.E-10       ## Residue tolerance
</span><span class="hll">FieldSolverGMG.gmg_exit_hang                = 0.2          ## Solver hang
</span><span class="hll">FieldSolverGMG.gmg_min_cells                = 16           ## Bottom drop
</span><span class="hll">FieldSolverGMG.gmg_drop_order               = 0            ## Drop stencil order to 1 if domain is coarser than this.
</span><span class="hll">FieldSolverGMG.gmg_bc_order                 = 1            ## Boundary condition order for multigrid
</span><span class="hll">FieldSolverGMG.gmg_bc_weight                = 4            ## Boundary condition weights (for least squares)
</span><span class="hll">FieldSolverGMG.gmg_jump_order               = 1            ## Boundary condition order for jump conditions
</span><span class="hll">FieldSolverGMG.gmg_jump_weight              = 4            ## Boundary condition weight for jump conditions (for least squares)
</span><span class="hll">FieldSolverGMG.gmg_reduce_order             = true         ## If true, always use order=1 EB stencils in coarsened cells
</span><span class="hll">FieldSolverGMG.gmg_bottom_solver            = bicgstab     ## Bottom solver type. &#39;simple&#39;, &#39;bicgstab&#39;, or &#39;gmres&#39;
</span><span class="hll">FieldSolverGMG.gmg_bottom_verbosity         = -1           ## Bottom solver verbosity.
</span></pre></div>
</div>
</div>
<p>Note that <em>all</em> options pertaining to IO or multigrid are run-time configurable (see <a class="reference internal" href="../Base/Control.html#chap-runtimeconfig"><span class="std std-ref">Run-time configurations</span></a>).</p>
</section>
<section id="setting-boundary-conditions">
<h3>Setting boundary conditions<a class="headerlink" href="#setting-boundary-conditions" title="Permalink to this heading"></a></h3>
<p>The flags that are in the format <code class="docutils literal notranslate"><span class="pre">bc.coord.side</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">bc.x.low</span></code>) parse the domain boundary condition type to the solver.
See <a class="reference internal" href="#chap-poissondomainbc"><span class="std std-ref">Domain boundary conditions</span></a> for details.</p>
<p>The flag <code class="docutils literal notranslate"><span class="pre">jump_bc</span></code> indicates how the dielectric jump condition is enforced.
See <a class="reference internal" href="#chap-poissondielectricbc"><span class="std std-ref">Saturation charge BC</span></a> for additional details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, we only solve the dielectric jump condition on gas-dielectric interfaces and dielectric-dielectric interfaces are not supported.
If you want to use numerical mock-ups of dielectric-dielectric interfaces, you can change <span class="math notranslate nohighlight">\(\epsilon_r\)</span> inside a dielectric, but note that the dielectric boundary condition <span class="math notranslate nohighlight">\(\partial_{n_1}\Phi + \partial_{n_2}\Phi = \sigma/\epsilon_0\)</span> is <em>not</em> solved in this case.</p>
</div>
</section>
<section id="algorithmic-adjustments">
<h3>Algorithmic adjustments<a class="headerlink" href="#algorithmic-adjustments" title="Permalink to this heading"></a></h3>
<p>By default, the Helmholtz operator uses a diagonally weighting of the operator using the volume fraction as weight.
This means that the quantity that is passed into <code class="docutils literal notranslate"><span class="pre">AMRMultiGrid</span></code> should be weighted by the volume fraction to avoid the small-cell problem of EB grids.
The flag <code class="docutils literal notranslate"><span class="pre">kappa_source</span></code> indicates whether or not we should multiply the right-hand side by the volume fraction before passing it into the solver routine.
If this flag is set to <code class="docutils literal notranslate"><span class="pre">false</span></code>, it is an indication that the user has taken responsibility to perform this weighting prior to calling <code class="docutils literal notranslate"><span class="pre">FieldSolver::solve(...)</span></code>.
If this flag is set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">FieldSolverGMG</span></code> will perform the multiplication before the multigrid solve.</p>
</section>
<section id="tuning-multigrid-performance">
<span id="chap-multigridtuning"></span><h3>Tuning multigrid performance<a class="headerlink" href="#tuning-multigrid-performance" title="Permalink to this heading"></a></h3>
<p>Multigrid operates by coarsening the solution (and the geometry with it) on a hierarchy of grid levels, and smoothing the solution on each level.
There are a number of factors that influence the multigrid performance.
Often the most critical factors are the radius of the cut-cell stencils and how far multigrid is allowed to coarsen.
In addition, the multigrid convergence is improved by increasing the number of smoothings per grid level (up to a certain point), as well as the type of smoother and bottom solver being used.
We explain these options below:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_verbosity</span></code>.
Controls the multigrid verbosity.
Setting it to a number <span class="math notranslate nohighlight">\(&gt; 0\)</span> will print multigrid convergence information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_use_default_settings</span></code>.
Use default multigrid settings.
This tends to make most problems converge.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_pre_smooth</span></code>.
Controls the number of relaxations on each level during multigrid downsweeps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_post_smooth</span></code>.
Controls the number of relaxations on each level during multigrid upsweeps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_bott_smooth</span></code>.
Controls the number of relaxations before entering the bottom solve.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_min_iter</span></code>.
Sets the minimum number of iterations that multigrid will perform.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_max_iter</span></code>.
Sets the maximum number of iterations that multigrid will perform.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_exit_tol</span></code>.
Sets the exit tolerance for multigrid.
Multigrid will exit the iterations if <span class="math notranslate nohighlight">\(r &lt; \lambda r_0\)</span> where <span class="math notranslate nohighlight">\(\lambda\)</span> is the specified tolerance, <span class="math notranslate nohighlight">\(r = |L\Phi -\rho|\)</span> is the residual and <span class="math notranslate nohighlight">\(r_0\)</span> is the residual for <span class="math notranslate nohighlight">\(\Phi = 0\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_exit_hang</span></code>.
Sets the minimum permitted reduction in the convergence rate before exiting multigrid.
Letting <span class="math notranslate nohighlight">\(r^k\)</span> be the residual after <span class="math notranslate nohighlight">\(k\)</span> multigrid cycles, multigrid will abort if the residual between levels is not reduce by at least a factor of <span class="math notranslate nohighlight">\(r^{k+1} &lt; (1-h)r^k\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the “hang” factor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_min_cells</span></code>.
Sets the minimum amount of cells along any coordinate direction for coarsened levels.
Note that this will control how far multigrid will coarsen. Setting a number <code class="docutils literal notranslate"><span class="pre">gmg_min_cells</span> <span class="pre">=</span> <span class="pre">16</span></code> will terminate multigrid coarsening when the domain has 16 cells in any of the coordinate direction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_bc_order</span></code>.
Sets the stencil order for Dirichlet boundary conditions (on electrodes).
Note that this is also the stencil radius.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_bc_weight</span></code>. Sets the least squares stencil weighting factor for least squares gradient reconstruction on EBs.
See <a class="reference internal" href="../Utilities/LeastSquares.html#chap-leastsquares"><span class="std std-ref">Least squares</span></a> for details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_jump_order</span></code>. Sets the stencil order when performing least squares gradient reconstruction on dielectric interfaces.
Note that this is also the stencil radius.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_jump_weight</span></code>.
Sets the least squares stencil weighting factor for least squares gradient reconstruction on dielectric interfaces.
See <a class="reference internal" href="../Utilities/LeastSquares.html#chap-leastsquares"><span class="std std-ref">Least squares</span></a> for details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_bottom_solver</span></code>.
Sets the bottom solver type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_cycle</span></code>.
Sets the multigrid method.
Currently, only V-cycles are supported.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_smoother</span></code>.
Sets the multigrid smoother.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_relax_factor</span></code>.
Sets the multigrid relaxation factor.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Enabling this setting tends to make most problems converge quite well.</p>
</div>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When setting the bottom solver (which by default is a biconjugate gradient stabilized method) to a regular smoother, one must also specify the number of smoothings to perform.
E.g., <code class="docutils literal notranslate"><span class="pre">FieldSolverGMG.gmg_bottom_solver</span> <span class="pre">=</span> <span class="pre">simple</span> <span class="pre">64</span></code>.
Setting the bottom solver to <code class="docutils literal notranslate"><span class="pre">simple</span></code> without specifying the number of smoothings that will be performed will issue a run-time error.</p>
</div>
</section>
<section id="adjusting-output">
<h3>Adjusting output<a class="headerlink" href="#adjusting-output" title="Permalink to this heading"></a></h3>
<p>The user may plot the potential, the space charge, the electric, and the GMG residue as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>FieldSolverGMG.plt_vars  = phi rho E res     # Plot variables. Possible vars are &#39;phi&#39;, &#39;rho&#39;, &#39;E&#39;, &#39;res&#39;
</pre></div>
</div>
</section>
<section id="saturation-charge-bc">
<span id="chap-poissondielectricbc"></span><h3>Saturation charge BC<a class="headerlink" href="#saturation-charge-bc" title="Permalink to this heading"></a></h3>
<p>As mentioned above, on dielectric interfaces the user can choose to specify which “form” of <a class="reference internal" href="#equation-gaussbc">Eq. 8</a> to solve.
If the user wants the natural form in which the surface charge is the free parameter, he can specify</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>FieldSolverGMG.which_jump = natural
</pre></div>
</div>
<p>To use the other format (in which one of the fluxes is specified), use</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>FieldSolverGMG.which_jump = saturation_charge
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">saturation_charge</span></code> option will set the derivative of <span class="math notranslate nohighlight">\(\partial_n\Phi\)</span> to zero on the gas side.
Support for setting <span class="math notranslate nohighlight">\(\partial_n\Phi\)</span> to a specified (e.g., non-zero) value on either side is missing, but is straightforward to implement.</p>
</div>
</section>
</section>
<section id="frequency-dependent-permittivity">
<h2>Frequency dependent permittivity<a class="headerlink" href="#frequency-dependent-permittivity" title="Permalink to this heading"></a></h2>
<p>Frequency-dependent permittivities are fundamentally supported by the <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> elliptic discretization but none of the solvers implement it.
Recall that the polarization (in frequency space) is</p>
<div class="math notranslate nohighlight">
\[\mathbf{P}(\omega) = \epsilon_0\chi(\omega)\mathbf{E}(\omega),\]</div>
<p>where <span class="math notranslate nohighlight">\(\chi(\omega)\)</span> is the dielectric susceptibility.</p>
<p>There are two forms that <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> can support frequency dependent permittivities; through convolution or through auxiliary differential equations (ADEs).</p>
<section id="convolution-approach">
<h3>Convolution approach<a class="headerlink" href="#convolution-approach" title="Permalink to this heading"></a></h3>
<p>In the time domain, the displacement field is.</p>
<div class="math notranslate nohighlight">
\[\mathbf{D}(t_k) = \epsilon_0\mathbf{E}(t_k) + \epsilon_0\int_0^{t_k} \chi(t)\mathbf{E}(t_k-t)\text{d}t.\]</div>
<p>There are various forms of discretizing the integral.
E.g. with the trapezoidal rule then</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\int_0^{t_k}\chi(t)\mathbf{E}(t-t)\text{d}t &amp;= \sum_{n=0}^{k-1} \int_{t_n}^{t_{n+1}}\chi(t)\mathbf{E}(t_k-t)\text{d}t \\
&amp;\approx \frac{1}{2}\sum_{n=0}^{k-1}\Delta t_n\left[\chi(t_n)\mathbf{E}(t_k-t_n) + \chi(t_{n+1})\mathbf{E}(t_k-t_{n+1})\right] \\
&amp;= \frac{\Delta t_0}{2}\chi_0\mathbf{E}(t_k) + \frac{1}{2}\sum_{n=1}^{k-1}\Delta t_n\chi_n\mathbf{E}(t_k-t_n) + \frac{1}{2}\sum_{n=0}^{k-1}\Delta t_n\chi_{n+1}\mathbf{E}(t_k-t_{n+1})
\end{split}\end{split}\]</div>
<p>The Gauss law becomes</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\nabla\cdot\left[\left(1+\frac{\chi_0\Delta t_0}{2}\right)\mathbf{E}(t_k)\right] &amp;= \frac{\rho(t_k)}{\epsilon_0}\\
&amp;- \nabla\cdot\left[\frac{1}{2}\sum_{n=1}^{k-1}\Delta t_n\chi_n\mathbf{E}(t_k-t_n) + \frac{1}{2}\sum_{n=0}^{k-1}\Delta t_n\chi_{n+1}\mathbf{E}(t_k-t_{n+1})\right].
\end{split}\end{split}\]</div>
<p>Note that the dispersion enters as an extra term on the right-hand side, emulating a space charge.
Unfortunately, inclusion of dispersion means that we must store <span class="math notranslate nohighlight">\(\mathbf{E}(t_n)\)</span> for all previous time steps.</p>
</section>
<section id="auxiliary-differential-equation">
<h3>Auxiliary differential equation<a class="headerlink" href="#auxiliary-differential-equation" title="Permalink to this heading"></a></h3>
<p>With the ADE approach we seek a solution to <span class="math notranslate nohighlight">\(\mathbf{P}(\omega) = \epsilon_0\chi(\omega)\mathbf{E}(\omega)\)</span> in the form</p>
<div class="math notranslate nohighlight">
\[\sum_k a_k(i\omega)^k\mathbf{P}(\omega) = \epsilon_0\mathbf{E}(\omega),\]</div>
<p>where <span class="math notranslate nohighlight">\(\sum a_k(i\omega)^k\)</span> is the Taylor series for <span class="math notranslate nohighlight">\(1/\chi(\omega)\)</span>.
This can be written as a partial differential equation</p>
<div class="math notranslate nohighlight">
\[\sum_{k}a_k\partial_t^k\mathbf{P}(t) = \epsilon_0\mathbf{E}(t).\]</div>
<p>This equation can be discretized using finite differences, and centering the solution on <span class="math notranslate nohighlight">\(t_k\)</span> with backward differences yields an expression</p>
<div class="math notranslate nohighlight">
\[\mathbf{P}^k = \epsilon_0C_0^k\mathbf{E}^k - \sum_{m&gt;0} C_m^k\mathbf{P}^{k-m}.\]</div>
<p>where <span class="math notranslate nohighlight">\(C_k\)</span> are stencil coefficients to be worked out for each case.
The displacement field <span class="math notranslate nohighlight">\(\mathbf{D}^k = \epsilon_0 \mathbf{E}^k + \mathbf{P}^k\)</span> is then</p>
<div class="math notranslate nohighlight">
\[\mathbf{D} = \epsilon_0(1 + C_0^k)\mathbf{E} - \sum_{m&gt;0} C_m^k\mathbf{P}^{k-m}.\]</div>
<p>The Gauss law yields</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\left[\left(1 + C_0^k\right)\mathbf{E}^k\right] = \frac{\rho}{\epsilon_0} - \frac{1}{\epsilon_0}\nabla\cdot\sum_{m&gt;0} C_m^k\mathbf{P}^{k-m}.\]</div>
<p>Unlike the convolution approach, this only requires storing terms required for the ADE description.
This depends both on the order of the ADE, as well as it’s discretization.
Normally, the ADE is a low-order PDE and a few terms are sufficient.</p>
</section>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading"></a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>There is currently a bug where having a dielectric interface align <em>completely</em> with a grid face will cause the cell to be identified as an electrode EB.
This bug is due to the way <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> handles cut-cells that align completely with a grid face.
In this case the cell with volume fraction <span class="math notranslate nohighlight">\(\kappa = 1\)</span> will be identified as an irregular cell.
For the opposite phase (i.e., viewing the grids from inside the boundary) the situation is opposite and thus the two “matching cells” can appear in different grid patches.
A fix for this is underway.
In the meantime, a sufficient workaround is simply to displace the dielectric slightly away from the interface (any non-zero displacement will do).</p>
</div>
</section>
<section id="example-application-s">
<h2>Example application(s)<a class="headerlink" href="#example-application-s" title="Permalink to this heading"></a></h2>
<p>Example applications that use the electrostatics capabilities are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../Applications/ElectrostaticsModel.html#chap-electrostaticsmodel"><span class="std std-ref">Electrostatics model</span></a>.</p></li>
<li><p><a class="reference internal" href="../Applications/CdrPlasmaModel.html#chap-cdrplasmamodel"><span class="std std-ref">CDR plasma model</span></a>.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="CDR.html" class="btn btn-neutral float-left" title="Convection-Diffusion-Reaction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Ito.html" class="btn btn-neutral float-right" title="Îto diffusion" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>