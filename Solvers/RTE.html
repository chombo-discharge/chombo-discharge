<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Radiative transfer &mdash; chombo-discharge  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Surface ODE solver" href="SurfaceODESolver.html" />
    <link rel="prev" title="Mesh ODE solver" href="MeshODESolver.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            chombo-discharge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Testing.html">Code testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Acknowledgements.html">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Source/DesignOverview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/CellTagger.html">CellTagger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/GeoCoarsener.html">GeoCoarsener</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Source/SpatialDiscretization.html">Spatial discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/MeshData.html">Mesh data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/Regridding.html">Regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/LinearSolvers.html">Linear solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Source/VV.html">Verification and validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="CDR.html">Convection-Diffusion-Reaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Electrostatics.html">Electrostatic solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="KineticMonteCarlo.html">Kinetic Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshODESolver.html">Mesh ODE solver</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Radiative transfer</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#rtspecies">RtSpecies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rtsolver">RtSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#diffusion-approximation">Diffusion approximation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#eddingtonsp1">EddingtonSP1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equation-of-motion">Equation of motion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stationary-kernel">Stationary kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transient-kernel">Transient kernel</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-conditions">Boundary conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simplified-domain-boundary-conditions">Simplified domain boundary conditions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#custom-domain-boundary-conditions">Custom domain boundary conditions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#embedded-boundaries">Embedded boundaries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boundary-condition-types">Boundary condition types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#solver-configuration">Solver configuration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic-options">Basic options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-boundary-conditions">Setting boundary conditions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuning-multigrid-performance">Tuning multigrid performance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-parameters">Runtime parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#monte-carlo-methods">Monte Carlo methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#photon-particle">photon particle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interaction-with-boundaries">Interaction with boundaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stationary-monte-carlo">Stationary Monte Carlo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transient-monte-carlo">Transient Monte Carlo</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#limitations">Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-application">Example application</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="SurfaceODESolver.html">Surface ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="TracerParticles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ito.html">Îto diffusion</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multi-physics applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/StreamerInceptionModel.html">Streamer inception model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ItoKMC.html">Îto-KMC plasma model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Single-solver applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection-diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/MeshODEModel.html">Mesh ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/TracerParticleModel.html">Tracer particle model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">Lookup tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Radiative transfer</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Solvers/RTE.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="radiative-transfer">
<span id="chap-radiativetransfer"></span><h1>Radiative transfer<a class="headerlink" href="#radiative-transfer" title="Permalink to this heading"></a></h1>
<p>Radiative transfer is supported in the diffusion (i.e. Eddington or Helmholtz) approximation and with Monte Carlo sampling of discrete photons.
The solvers share a common interface (a parent class), but note that the radiative transfer equation is inherently deterministic while Monte Carlo photon transport is inherently stochastic.
The diffusion approximation relies on solving an elliptic equation in the stationary case and a parabolic equation in the time-dependent case, while the Monte-Carlo approach solves solves for fully transient or ‘’stationary’’ transport.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The source code for the radiative transfer solvers reside in <code class="file docutils literal notranslate"><span class="pre">Source/RadiativeTransfer</span></code></p>
</div>
<section id="rtspecies">
<span id="chap-rtspecies"></span><h2>RtSpecies<a class="headerlink" href="#rtspecies" title="Permalink to this heading"></a></h2>
<p>The class <code class="docutils literal notranslate"><span class="pre">RtSpecies</span></code> is an abstract base class for parsing necessary information into radiative transfer solvers.
When creating a radiative transfer solver one will need to pass in a pointer to <code class="docutils literal notranslate"><span class="pre">RtSpecies</span></code> such that the solvers can look up the required infromation.
Currently, <code class="docutils literal notranslate"><span class="pre">RtSpecies</span></code> is a lightweight class where the user needs to implement the function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="nf">RtSpecies::getAbsorptionCoefficient</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The absorption coefficient is used in the diffusion (see <a class="reference internal" href="#chap-diffusionrte"><span class="std std-ref">Diffusion approximation</span></a>) and Monte Carlo (see <a class="reference internal" href="#chap-montecarlorte"><span class="std std-ref">Monte Carlo methods</span></a>) solvers.</p>
<p>One can also assign a name to the species through the member variable <code class="docutils literal notranslate"><span class="pre">RtSpecies::m_name</span></code>.</p>
</section>
<section id="rtsolver">
<span id="chap-rtsolver"></span><h2>RtSolver<a class="headerlink" href="#rtsolver" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">RtSolver</span></code> is the base class for encapsulating a radiative transfer solver.
The source code for the solver is located in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Source/RadiativeTransfer</span></code> and it is a fairly lightweight abstract class.
As with other solvers, <code class="docutils literal notranslate"><span class="pre">RtSolver</span></code> can use a specified <a class="reference internal" href="../Source/Realm.html#chap-realm"><span class="std std-ref">Realm</span></a>.</p>
<p>To use the <code class="docutils literal notranslate"><span class="pre">RtSolver</span></code> interface the user must cast from one of the inherited classes (see <a class="reference internal" href="#chap-diffusionrte"><span class="std std-ref">Diffusion approximation</span></a> or <a class="reference internal" href="#chap-montecarlorte"><span class="std std-ref">Monte Carlo methods</span></a>).
Since most of the <code class="docutils literal notranslate"><span class="pre">RtSolver</span></code> is an interface which is implemented by other radiative transfer solvers, documentation of boundary conditions, kernels and so on are found in the implementation classes.</p>
</section>
<section id="diffusion-approximation">
<span id="chap-diffusionrte"></span><h2>Diffusion approximation<a class="headerlink" href="#diffusion-approximation" title="Permalink to this heading"></a></h2>
<section id="eddingtonsp1">
<h3>EddingtonSP1<a class="headerlink" href="#eddingtonsp1" title="Permalink to this heading"></a></h3>
<p>The first-order diffusion approximation to the radiative transfer equation is encapsulated by the <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> class which implements a first order Eddington approximation of the radiative transfer equation.
<code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> implements <code class="docutils literal notranslate"><span class="pre">RtSolver</span></code> using both stationary and transient advance methods (e.g. for stationary or time-dependent radiative transport).
The source code is located in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/RadiativeTransfer</span></code>.</p>
</section>
<section id="equation-of-motion">
<h3>Equation of motion<a class="headerlink" href="#equation-of-motion" title="Permalink to this heading"></a></h3>
<p>In the diffusion approximation, the radiative transport equation is</p>
<div class="math notranslate nohighlight" id="equation-transientdiffusionrte">
<span class="eqno">(5)<a class="headerlink" href="#equation-transientdiffusionrte" title="Permalink to this equation"></a></span>\[\partial_t\Psi + \kappa\Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi\right) = \frac{\eta}{c},\]</div>
<p>where <span class="math notranslate nohighlight">\(\kappa\)</span> is the absorption coefficient (i.e., inverse absorption length).
Note that in the context below, <span class="math notranslate nohighlight">\(\kappa\)</span> is <em>not</em> the volume fraction of a grid cell.
This is called the Eddington approximation, and the radiative flux is <span class="math notranslate nohighlight">\(F = -\frac{c}{3\kappa}\nabla \Psi\)</span>.</p>
<p>In the stationary case this yields a Helmholtz equation</p>
<div class="math notranslate nohighlight" id="equation-stationarydiffusionrte">
<span class="eqno">(6)<a class="headerlink" href="#equation-stationarydiffusionrte" title="Permalink to this equation"></a></span>\[\kappa\Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi\right) = \frac{\eta}{c},\]</div>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> uses multigrid methods for solving <a class="reference internal" href="#equation-transientdiffusionrte">Eq. 5</a> and <a class="reference internal" href="#equation-stationarydiffusionrte">Eq. 6</a>, see <a class="reference internal" href="../Source/LinearSolvers.html#chap-linearsolvers"><span class="std std-ref">Linear solvers</span></a>.
The class implements <code class="docutils literal notranslate"><span class="pre">RtSolver::advance()</span></code>, which can switch between <a class="reference internal" href="#equation-transientdiffusionrte">Eq. 5</a> and <a class="reference internal" href="#equation-stationarydiffusionrte">Eq. 6</a>.
Note that for both the stationary and time-dependent cases the absorption coefficient <span class="math notranslate nohighlight">\(\kappa\)</span> in <a class="reference internal" href="#equation-transientdiffusionrte">Eq. 5</a> and <a class="reference internal" href="#equation-stationarydiffusionrte">Eq. 6</a> are filled using the <code class="docutils literal notranslate"><span class="pre">RtSpecies</span></code> implementation provided to the solver.
Also note that the absorption coefficient does not need to be constant in space.</p>
<section id="stationary-kernel">
<h4>Stationary kernel<a class="headerlink" href="#stationary-kernel" title="Permalink to this heading"></a></h4>
<p>For the stationary kernel we solve <a class="reference internal" href="#equation-stationarydiffusionrte">Eq. 6</a> directly, using a single multigrid solve.
See <a class="reference internal" href="../Source/LinearSolvers.html#chap-linearsolvers"><span class="std std-ref">Linear solvers</span></a> for discretization details.</p>
</section>
<section id="transient-kernel">
<h4>Transient kernel<a class="headerlink" href="#transient-kernel" title="Permalink to this heading"></a></h4>
<p>For solving <a class="reference internal" href="#equation-transientdiffusionrte">Eq. 5</a>, <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> implements both the backward Euler method and the Twizell-Gumel-Arigu (TGA) scheme.
Explicit discretizations are not available.
The Euler discretization is</p>
<div class="math notranslate nohighlight">
\[\left(1+ \kappa \Delta t\right)\Psi^{k+1} - \Delta t \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi^{k+1}\right) = \Psi^{k} + \frac{\Delta t\eta^{k+1}}{c},\]</div>
<p>Again, this is a Helmholtz equation for <cite>Psi^{k+1}</cite> which is solved using geometric multigrid.
Expressions for the TGA scheme are found in <span id="id1">[<a class="reference internal" href="../ZZReferences.html#id34" title="E. H. Twizell, A. B. Gumel, and M. A. Arigu. Second-order,L 0-stable methods for the heat equation with time-dependent boundary conditions. Advances in Computational Mathematics, 6(1):333–352, 1996. URL: http://link.springer.com/10.1007/BF02127712, doi:10.1007/BF02127712.">Twizell <em>et al.</em>, 1996</a>]</span>, but note that the TGA scheme requires a solution to two elliptic equations (thus it has approximately twice the cost).</p>
</section>
</section>
<section id="boundary-conditions">
<span id="chap-eddingtonsp1bc"></span><h3>Boundary conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this heading"></a></h3>
<section id="simplified-domain-boundary-conditions">
<h4>Simplified domain boundary conditions<a class="headerlink" href="#simplified-domain-boundary-conditions" title="Permalink to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> solver supports the following boundary conditions on domain faces and EBs.
The domain boundary condition <em>type</em>, which is either Dirichlet, Neumann, or Larsen (a special type of Robin boundary condition) is always passed in through the input file.
If the user passes in a value, say <code class="docutils literal notranslate"><span class="pre">neumann</span> <span class="pre">0.0</span></code>, for a particular domain side/face, then the class will use a homogeneous Neumann boundary for the entire domain edge/face.</p>
</section>
<section id="custom-domain-boundary-conditions">
<h4>Custom domain boundary conditions<a class="headerlink" href="#custom-domain-boundary-conditions" title="Permalink to this heading"></a></h4>
<p>It is possible to use more complex boundary conditions by passing in <code class="docutils literal notranslate"><span class="pre">dirichlet_custom</span></code>, <code class="docutils literal notranslate"><span class="pre">neumann_custom</span></code>, or <code class="docutils literal notranslate"><span class="pre">larsen_custom</span></code> options.
In this case the <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> solver will use a specified function at the domain edge/face.
To specify that function, <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> has a member function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">setDomainSideBcFunction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_dir</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">Side</span><span class="o">::</span><span class="n">LoHiSide</span><span class="w"> </span><span class="n">a_side</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_function</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>which species a boundary condition value for one of the edges (faces in 3D).
Note that the boundary condition <em>type</em> is still Dirichlet, Neumann, or Larsen (depending on whether or not <code class="docutils literal notranslate"><span class="pre">dirichlet_custom</span></code>, <code class="docutils literal notranslate"><span class="pre">neumann_custom</span></code>, or <code class="docutils literal notranslate"><span class="pre">larsen_custom</span></code> was passed in).
For example, to set the boundary condition on the left <span class="math notranslate nohighlight">\(x\)</span> face in the domain, one can create a <code class="docutils literal notranslate"><span class="pre">EddingtonSP1DomainBc::BcFunction</span></code> object as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume this has been instantiated.</span>
<span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">EddingtonSP1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">eddingtonSolver</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Make a lambda which we can bind to std::function.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">myValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_time</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">a_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a_time</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Set the domain bc function in the solver.</span>
<span class="n">eddingtonSolver</span><span class="p">.</span><span class="n">setDomainSideBcFunction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Side</span><span class="o">::</span><span class="n">Lo</span><span class="p">,</span><span class="w"> </span><span class="n">myValue</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the user specifies one of the custom boundary conditions but does not set the function, it will issue a run-time error.</p>
</div>
</section>
<section id="embedded-boundaries">
<h4>Embedded boundaries<a class="headerlink" href="#embedded-boundaries" title="Permalink to this heading"></a></h4>
<p>On the EB, we currently only support constant-value boundary conditions.
In the input script, the user can specify</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dirichlet</span> <span class="pre">&lt;value&gt;</span></code> For setting a constant Dirichlet boundary condition everywhere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">neumann</span> <span class="pre">&lt;value&gt;</span></code> For setting a constant Neumann boundary condition everywhere.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">larsen</span> <span class="pre">&lt;value&gt;</span></code> For setting a constant Larsen boundary condition everywhere.</p></li>
</ul>
</section>
<section id="boundary-condition-types">
<h4>Boundary condition types<a class="headerlink" href="#boundary-condition-types" title="Permalink to this heading"></a></h4>
<ol class="arabic">
<li><p><strong>Dirichlet</strong>.
For Dirichlet boundary conditions we specify the value of <span class="math notranslate nohighlight">\(\Psi\)</span> on the boundary.
Note that this involves reconstructing the gradient <span class="math notranslate nohighlight">\(\partial_n\Psi\)</span> on domain faces and edges, see <a class="reference internal" href="../Source/LinearSolvers.html#chap-linearsolverdirichletbc"><span class="std std-ref">Dirichlet</span></a>.</p></li>
<li><p><strong>Neumann</strong>.
For Neumann boundary conditions we specify the value of <span class="math notranslate nohighlight">\(\partial_n\Psi\)</span> on the boundary.
Note that the linear solver interface also supports setting <span class="math notranslate nohighlight">\(B\partial_n\Psi\)</span> on the boundary (where <span class="math notranslate nohighlight">\(B\)</span> is the Helmholtz equation <span class="math notranslate nohighlight">\(B\)</span> coefficient).
However, the <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> solver does not use this functionality.</p></li>
<li><p><strong>Larsen</strong>.
The Larsen boundary condition is an absorbing boundary condition, taking the form of a Robin boundary as follows:</p>
<div class="math notranslate nohighlight">
\[\kappa\partial_n\Psi + \frac{3\kappa^2}{2}\frac{1-3r_2}{1-2r_1}\Psi = g,\]</div>
<p>where <span class="math notranslate nohighlight">\(r_1\)</span> and <span class="math notranslate nohighlight">\(r_2\)</span> are reflection coefficients and <span class="math notranslate nohighlight">\(g\)</span> is a surface source, see <span id="id2">[<a class="reference internal" href="../ZZReferences.html#id51" title="Edward W. Larsen, Guido Thömmes, Axel Klar, Seaid Mohammed, and Thomas Götz. Simplified PN Approximations to the Equations of Radiative Heat Transfer and Applications. Journal of Computational Physics, 183(2):652–675, dec 2002. URL: https://www.sciencedirect.com/science/article/pii/S0021999102972104, doi:10.1006/JCPH.2002.7210.">Larsen <em>et al.</em>, 2002</a>]</span> for details.
Note that when the user specifies the boundary condition value (e.g. by setting the BC function), he is setting the surface sourge <span class="math notranslate nohighlight">\(g\)</span>.
In the majority of cases, however, we will have <span class="math notranslate nohighlight">\(r_1 = r_2 = g = 0\)</span> and the BC becomes</p>
<div class="math notranslate nohighlight">
\[\partial_n\Psi + \frac{3\kappa}{2}\Psi = 0.\]</div>
</li>
</ol>
</section>
</section>
<section id="solver-configuration">
<h3>Solver configuration<a class="headerlink" href="#solver-configuration" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> implementation has a number of configurable options for running the solver, and these are given below:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># ====================================================================================================
# EddingtonSP1 class options
# ====================================================================================================
EddingtonSP1.stationary          = true         # Stationary solver
EddingtonSP1.reflectivity        = 0.           # Reflectivity
EddingtonSP1.use_tga             = false        # Use TGA for integration
EddingtonSP1.kappa_scale         = true         # Kappa scale source or not (depends on algorithm)
EddingtonSP1.plt_vars            = phi src      # Plot variables. Available are &#39;phi&#39; and &#39;src&#39;

EddingtonSP1.ebbc                = larsen 0.0   # Bc on embedded boundaries
EddingtonSP1.bc.x.lo             = larsen 0.0   # Bc on domain side. &#39;dirichlet&#39;, &#39;neuman&#39;, or &#39;larsen&#39;
EddingtonSP1.bc.x.hi             = larsen 0.0   # Bc on domain side. &#39;dirichlet&#39;, &#39;neuman&#39;, or &#39;larsen&#39;
EddingtonSP1.bc.y.lo             = larsen 0.0   # Bc on domain side. &#39;dirichlet&#39;, &#39;neuman&#39;, or &#39;larsen&#39;
EddingtonSP1.bc.y.hi             = larsen 0.0   # Bc on domain side. &#39;dirichlet&#39;, &#39;neuman&#39;, or &#39;larsen&#39;
EddingtonSP1.bc.z.lo             = larsen 0.0   # Bc on domain side. &#39;dirichlet&#39;, &#39;neuman&#39;, or &#39;larsen&#39;
EddingtonSP1.bc.z.hi             = larsen 0.0   # Bc on domain side. &#39;dirichlet&#39;, &#39;neuman&#39;, or &#39;larsen&#39;
EddingtonSP1.bc.z.hi             = larsen 0.0   # Boundary on domain. &#39;neumann&#39; or &#39;larsen&#39;

EddingtonSP1.gmg_verbosity       = -1           # GMG verbosity
EddingtonSP1.gmg_pre_smooth      = 8            # Number of relaxations in downsweep
EddingtonSP1.gmg_post_smooth     = 8            # Number of relaxations in upsweep
EddingtonSP1.gmg_bott_smooth     = 8            # NUmber of relaxations before dropping to bottom solver
EddingtonSP1.gmg_min_iter        = 5            # Minimum number of iterations
EddingtonSP1.gmg_max_iter        = 32           # Maximum number of iterations
EddingtonSP1.gmg_exit_tol        = 1.E-6        # Residue tolerance
EddingtonSP1.gmg_exit_hang       = 0.2          # Solver hang
EddingtonSP1.gmg_min_cells       = 16           # Bottom drop
EddingtonSP1.gmg_bottom_solver   = bicgstab     # Bottom solver type. Valid options are &#39;simple &lt;number&gt;&#39; and &#39;bicgstab&#39;
EddingtonSP1.gmg_cycle           = vcycle       # Cycle type. Only &#39;vcycle&#39; supported for now
EddingtonSP1.gmg_ebbc_weight     = 2            # EBBC weight (only for Dirichlet)
EddingtonSP1.gmg_ebbc_order      = 2            # EBBC order (only for Dirichlet)
EddingtonSP1.gmg_smoother        = red_black    # Relaxation type. &#39;jacobi&#39;, &#39;red_black&#39;, or &#39;multi_color&#39;
</pre></div>
</div>
<section id="basic-options">
<h4>Basic options<a class="headerlink" href="#basic-options" title="Permalink to this heading"></a></h4>
<p>Basic input options to <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.stationary</span></code> for setting whether or not the solver is stationary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.reflectivity</span></code> for controlling the reflectivity in the Larsen boundary conditions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.use_tga</span></code> for switching between backward Euler and TGA time discretizations.
Only relevant if <code class="docutils literal notranslate"><span class="pre">EddingtonSP1.stationary</span> <span class="pre">=</span> <span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.kappa_scale</span></code> Switch for multiplying the source with with the volume fraction or not.
Note that the multigrid Helmholtz solvers require a diagonal weighting of the operator.
If <code class="docutils literal notranslate"><span class="pre">EddingtonSP1.kappa_scale</span> <span class="pre">=</span> <span class="pre">false</span></code> then the solver will assume that this weighting of the source term has already been made.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.plt_vars</span></code> For setting which solver plot variables are included in plot files.</p></li>
</ul>
</section>
<section id="setting-boundary-conditions">
<h4>Setting boundary conditions<a class="headerlink" href="#setting-boundary-conditions" title="Permalink to this heading"></a></h4>
<p>Boundary conditions are parsed through the flags</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.ebbc</span></code> Which sets the boundary conditions on the EBs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.bc.dim.side</span></code> Which sets the boundary conditions on the domain sides, see <a class="reference internal" href="#chap-eddingtonsp1bc"><span class="std std-ref">Boundary conditions</span></a> for details.</p></li>
</ul>
</section>
<section id="tuning-multigrid-performance">
<h4>Tuning multigrid performance<a class="headerlink" href="#tuning-multigrid-performance" title="Permalink to this heading"></a></h4>
<p>All parameters that begin with the form <code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_</span></code> indicate a tuning parameter for geometric multigrid.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_verbosity</span></code>.
Controls the multigrid verbosity.
Setting it to a number <span class="math notranslate nohighlight">\(&gt; 0\)</span> will print multigrid convergence information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_pre_smooth</span></code>.
Controls the number of relaxations on each level during multigrid downsweeps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_post_smooth</span></code>.
Controls the number of relaxations on each level during multigrid upsweeps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_bott_smooth</span></code>.
Controls the number of relaxations before entering the bottom solve.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_min_iter</span></code>.
Sets the minimum number of iterations that multigrid will perform.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_max_iter</span></code>.
Sets the maximum number of iterations that multigrid will perform.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_exit_tol</span></code>.
Sets the exit tolerance for multigrid.
Multigrid will exit the iterations if <span class="math notranslate nohighlight">\(r &lt; \lambda r_0\)</span> where <span class="math notranslate nohighlight">\(\lambda\)</span> is the specified tolerance, <span class="math notranslate nohighlight">\(r = |L\Phi -\rho|\)</span> is the residual and <span class="math notranslate nohighlight">\(r_0\)</span> is the residual for <span class="math notranslate nohighlight">\(\Phi = 0\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_exit_hang</span></code>.
Sets the minimum permitted reduction in the convergence rate before exiting multigrid.
Letting <span class="math notranslate nohighlight">\(r^k\)</span> be the residual after <span class="math notranslate nohighlight">\(k\)</span> multigrid cycles, multigrid will abort if the residual between levels is not reduce by at least a factor of <span class="math notranslate nohighlight">\(r^{k+1} &lt; (1-h)r^k\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the “hang” factor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_min_cells</span></code>.
Sets the minimum amount of cells along any coordinate direction for coarsened levels.
Note that this will control how far multigrid will coarsen. Setting a number <code class="docutils literal notranslate"><span class="pre">gmg_min_cells</span> <span class="pre">=</span> <span class="pre">16</span></code> will terminate multigrid coarsening when the domain has 16 cells in any of the coordinate direction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_bottom_solver</span></code>.
Sets the bottom solver type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_cycle</span></code>.
Sets the multigrid method.
Currently, only V-cycles are supported.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_ebbc_order</span></code>.
Sets the stencil order on EBs when using Dirichlet boundary conditions.
Note that this is also the stencil radius.
See <a class="reference internal" href="../Source/LinearSolvers.html#chap-linearsolvers"><span class="std std-ref">Linear solvers</span></a> for details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_ebbc_weight</span></code>.
Sets the least squares stencil weighting factor for least squares gradient reconstruction on EBs when using Dirichlet boundary conditions.
See <a class="reference internal" href="../Utilities/LeastSquares.html#chap-leastsquares"><span class="std std-ref">Least squares</span></a> for details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_smoother</span></code>.
Sets the multigrid smoother.</p></li>
</ul>
</section>
<section id="runtime-parameters">
<h4>Runtime parameters<a class="headerlink" href="#runtime-parameters" title="Permalink to this heading"></a></h4>
<p>The following parameters for <code class="docutils literal notranslate"><span class="pre">EddingtonSP1</span></code> are run-time configurable:</p>
<ul class="simple">
<li><p>All multigrid tuning parameters, i.e. parameters starting with <code class="docutils literal notranslate"><span class="pre">EddingtonSP1.gmg_</span></code>.</p></li>
<li><p>Plot variables, i.e. <code class="docutils literal notranslate"><span class="pre">EddingtonSP1.plt_vars</span></code>.</p></li>
<li><p>Kappa scaling (for algorithmic adjustments), i.e. <code class="docutils literal notranslate"><span class="pre">EddingtonSP1.kappa_scale</span></code>.</p></li>
</ul>
</section>
</section>
</section>
<section id="monte-carlo-methods">
<span id="chap-montecarlorte"></span><h2>Monte Carlo methods<a class="headerlink" href="#monte-carlo-methods" title="Permalink to this heading"></a></h2>
<p>All types of moment-closed radiative transfer equations contain nonphysical artifacts (which may or may not be acceptable).
For example, in the diffusion approximation the radiative flux is <span class="math notranslate nohighlight">\(F = -\frac{c}{3\kappa}\nabla \Psi\)</span>, implying that photons can leak around boundaries.
I.e. the diffusion approximation does not correctly describe shadows.
It is possible to go beyond the diffusion approximation by also solving for higher-order moments like the radiative flux.
While such methods can describe shadows, they do, contain other nonphysical features.</p>
<p>Both ‘’stationary’’ and transient Monte Carlo methods are offered as an alternative to the diffusion approximation.</p>
<section id="photon-particle">
<h3>photon particle<a class="headerlink" href="#photon-particle" title="Permalink to this heading"></a></h3>
<p>The Îto particle is a computational particle class in <cite>chombo-discharge</cite> which can be used together with the particle tools in <cite>Chombo</cite>.
The following data fields are implemented in the particle:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RealVect</span><span class="w"> </span><span class="n">m_position</span><span class="p">;</span><span class="w"></span>
<span class="n">RealVect</span><span class="w"> </span><span class="n">m_velocity</span><span class="p">;</span><span class="w"></span>
<span class="n">Real</span><span class="w"> </span><span class="n">m_mass</span><span class="p">;</span><span class="w"></span>
<span class="n">Real</span><span class="w"> </span><span class="n">m_kappa</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>To obtain the fields, the user will call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RealVect</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">position</span><span class="p">();</span><span class="w"></span>
<span class="n">RealVect</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">velocity</span><span class="p">();</span><span class="w"></span>
<span class="n">Real</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">mass</span><span class="p">();</span><span class="w"></span>
<span class="n">Real</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">diffusion</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>All functions also have <code class="docutils literal notranslate"><span class="pre">const</span></code> versions.
Note that the field <code class="docutils literal notranslate"><span class="pre">m_mass</span></code> is the same as the <em>weight</em> of the computational particle.
The following functions are used to set the various properties:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">setPosition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_pos</span><span class="p">);</span><span class="w"></span>
<span class="n">setVelocity</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">a_vel</span><span class="p">);</span><span class="w"></span>
<span class="n">setMass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_mass</span><span class="p">);</span><span class="w"></span>
<span class="n">setDiffusion</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">a_diffusion</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="interaction-with-boundaries">
<h3>Interaction with boundaries<a class="headerlink" href="#interaction-with-boundaries" title="Permalink to this heading"></a></h3>
</section>
<section id="stationary-monte-carlo">
<h3>Stationary Monte Carlo<a class="headerlink" href="#stationary-monte-carlo" title="Permalink to this heading"></a></h3>
<p>The stationary Monte Carlo method proceeds as follows.</p>
<ol class="arabic simple">
<li><p>For each cell in the mesh, draw a discrete number of photons <span class="math notranslate nohighlight">\(\mathcal{P}\left(\eta \Delta V\Delta t\right)\)</span> where <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> is a Poisson distribution. The user may also choose to use pseudophotons rather than physical photons by modifying photon weights. Each photon is generated in the cell centroid <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> and given a random propagation direction <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>.</p></li>
<li><p>Draw a propagation distance <span class="math notranslate nohighlight">\(r\)</span> by drawing random numbers from an exponential distribution <span class="math notranslate nohighlight">\(p(r) = \kappa \exp\left(-\kappa r\right)\)</span>. The absorbed position of the photon is <span class="math notranslate nohighlight">\(\mathbf{x} = \mathbf{x}_0 + r\mathbf{n}\)</span>.</p></li>
<li><p>Check if the path from <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> to <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> intersects an internal or domain boundary. If it does, absorb the photon on the boundary. If not, move the photon to <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> or reflect it off symmetry boundaries.</p></li>
<li><p>Rebin the absorbed photons onto the AMR grid. This involves parallel communication.</p></li>
<li><p>Compute the resulting photoionization profile. The user may choose between several different deposition schemes (like e.g. cloud-in-cell).</p></li>
</ol>
<p>The Monte Carlo methods use computational particles for advancing the photons in exactly the same way a Particle-In-Cell method would use them for advancing electrons. Although a computational photon would normally live on the finest grid level that overlaps its position, this is not practical for all particle deposition kernels. For example, for cloud-in-cell deposition schemes it is useful to have the restrict the interpolation kernels to the grid level where the particle lives. In Chombo-speak, we therefore use a buffer region that extends some cells from a refinement boundary where the photons are not allowed to live. Instead, photons in that buffer region are transferred to a coarser level, and their deposition clouds are first interpolated to the fine level before deposition on the fine level happens. Selecting a deposition scheme and adjusting the buffer region is done through an input script associated with the solver.</p>
</section>
<section id="transient-monte-carlo">
<h3>Transient Monte Carlo<a class="headerlink" href="#transient-monte-carlo" title="Permalink to this heading"></a></h3>
<p>The transient Monte Carlo method is almost identical to the stationary method, except that it does not deposit all generated photons on the mesh but tracks them through time. The transient method is implemented as follows:</p>
<ol class="arabic simple">
<li><p>For each cell in the mesh, draw a discrete number of photons <span class="math notranslate nohighlight">\(\mathcal{P}\left(\eta \Delta V\Delta t\right)\)</span> as above, and append these to the already existing photons. Each photon is given a uniformly distributed random creation time within <span class="math notranslate nohighlight">\(\Delta t\)</span>.</p></li>
<li><p>Each photon is advanced over the time step <span class="math notranslate nohighlight">\(\Delta t\)</span> by a sequence of <span class="math notranslate nohighlight">\(N\)</span> substeps (<span class="math notranslate nohighlight">\(N\)</span> may be different for each photon).</p>
<ol class="loweralpha simple">
<li><p>We compute <span class="math notranslate nohighlight">\(N\)</span> such that we sample <span class="math notranslate nohighlight">\(N\Delta \tau = \Delta t\)</span> with <span class="math notranslate nohighlight">\(c\kappa\Delta\tau &lt; 1\)</span>.</p></li>
<li><p>A photon at position <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> is moved a distance <span class="math notranslate nohighlight">\(\Delta \mathbf{x} = c\mathbf{n}\Delta\tau\)</span>. For each step we compute the absorption probability <span class="math notranslate nohighlight">\(p = \kappa\left|\Delta\mathbf{x}\right|\)</span> where <span class="math notranslate nohighlight">\(p\in[0,1]\)</span> is a uniform random number. If the photon is absorbed on this interval, draw a new uniform random number <span class="math notranslate nohighlight">\(r \in [0,1]\)</span> and absorb the photon at the position <span class="math notranslate nohighlight">\(\mathbf{x}_0 + r\Delta\mathbf{x}\)</span>. If the photon is not absorbed, it is moved to position <span class="math notranslate nohighlight">\(\mathbf{x}_0 + r\Delta\mathbf{x}\)</span>.</p></li>
</ol>
</li>
<li><p>Check if the path from <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> to <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> intersects an internal or domain boundary. If it does, absorb the photon on the boundary. If not, move the photon to <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.</p></li>
<li><p>Rebin the absorbed photons onto the AMR grid. This involves parallel communication.</p></li>
<li><p>Compute the resulting photoionization profile. The user may choose between several different deposition schemes (like e.g. cloud-in-cell).</p></li>
</ol>
</section>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading"></a></h2>
</section>
<section id="example-application">
<h2>Example application<a class="headerlink" href="#example-application" title="Permalink to this heading"></a></h2>
<p>An example application of usage of the <code class="docutils literal notranslate"><span class="pre">RtSolver</span></code> is found in <a class="reference internal" href="../Applications/RadiativeTransferModel.html#chap-radiativetransfermodel"><span class="std std-ref">Radiative transfer</span></a>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="MeshODESolver.html" class="btn btn-neutral float-left" title="Mesh ODE solver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="SurfaceODESolver.html" class="btn btn-neutral float-right" title="Surface ODE solver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>