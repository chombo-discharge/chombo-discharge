.. _Chap:Driver:

Driver
======

The ``Driver`` class is the class that runs ``chombo-discharge`` simulations and is defined in :file:`/Source/Driver/CD_Driver.cpp(H)`.
The constructor for this class is

.. code-block:: c++

   Driver(const RefCountedPtr<ComputationalGeometry>& a_compgeom,
          const RefCountedPtr<TimeStepper>&           a_timestepper,
	  const RefCountedPtr<AmrMesh>&               a_amr,
	  const RefCountedPtr<CellTagger>&            a_celltagger = RefCountedPtr<CellTagger>(nullptr),
	  const RefCountedPtr<GeoCoarsener>&          a_geocoarsen = RefCountedPtr<GeoCoarsener>(nullptr));

Observe that the ``Driver`` class does not *require* an instance of :ref:`Chap:CellTagger`.
If users decide to omit a cell tagger, regridding functionality is completely turned off and only the initially generated grids will be used throughout the simulation.

The usage of the ``Driver`` class is primarily object construction with dependency injection of the geometry, the physics (i.e. ``TimeStepper``), the ``AmrMesh`` instance, and possibly a cell tagger.
The ``Driver`` class will retrieve configurations from the input script during construction.

Simulation setup
----------------

Usually, only a single routine is used:

.. code-block:: c++

   void setupAndRun(const std::string a_input_file);

This routine will set up and run a simulation.
Simulation setup depends on the way a simulation is run.

New simulations
_______________

If a simulation starts from the first time step, the ``Driver`` class will perform the following major steps within ``setupAndRun()``.

1. Ask ``ComputationalGeometry`` to generate the cut-cell moments.
2. Collect all the cut-cells and ask ``AmrMesh`` to set up an initial grid.
   This initial grid is always generated by flagging cells for refinement along the boundary.
   Various options are available for configuring this initial grid, see :ref:`Chap:RefinementPhilosophy`. 
   Also note that it is possible to restrict the maximum level that can be generated from the geometric tags, or remove some of the cut-cell refinement flags through the auxiliary class ``GeoCoarsener``.
3. Ask the ``TimeStepper`` to set up relevant solvers and fill them with initial data.
4. Perform the number of initial regrids that the user asks for.

Step 3 and 4 will differ significantly depending on the physics that is solved for.

The full code is given in ``Driver::setupFresh()``. 

Restarting simulations
______________________

If a simulation *does not start* from the first time step, the ``Driver`` class will perform the following major steps within ``setupAndRun(...)``.

1. Ask ``ComputationalGeometry`` to generate the cut-cell moments.
2. Read a checkpoint file that contains the grids and all the data that have been checkpointed by the solvers.
   ``Driver`` will issue an error and abort if the checkpoint file does not exist.
3. Ask the ``TimeStepper`` to perform a "post-checkpoint" step to initialize any remaining data so that a time step can be taken.
   This functionality has been included because not all data in every solver needs to be checkpointed.
   For example, an electric field solver only needs to write the electric potential to the checkpoint file because the electric field is simply obtained by taking the gradient.
4. Perform the number of initial regrids that the user asks for.

Again, step 3 will differ significantly depending on the physics that is solved for.

The full code is given in ``Driver::setupForRestart()``. 

Simulation advancement
----------------------

The algorithm for running a simulation is conceptually simple; the ``Driver`` class simply calls ``TimeStepper`` for computing a reasonable time step for advancing the equations, and then it asks ``TimeStepper`` to actually perform the advance. 
Regrids, plot files, and checkpoint files are written at certain step intervals (or when the ``TimeStepper`` demands them). 
In essence, the algorithm looks like this:

.. code-block:: c++

   Driver::run(...){

      while(KeepRunningTheSimulation){
         if(RegridEverything){
	    Driver->regrid()
	 }

	 TimeStepper->computeTimeStep()
	 TimeStepper->advanceAllEquationsOneStep()

         if(WriteAPlotFile || EndOfSimulation){
	    Driver->writePlotFile();
	 }
	 if(TimeToWriteACheckpointFile || EndOfSimulation){
	    Driver->writeCheckpointFile()
	 }

	 KeepRunningTheSimulation = true or false
      }
   }

Regridding
----------

Regrids are called by the ``Driver`` class and occur as follows in ``Driver::regrid(...)``:

1. Ask ``CellTagger`` to generate tags for grid refinement and coarsening.
2. The ``TimeStepper`` class stores data that is subject to regrids.
   How this happens depends on the solver that is run. 
   For grid-based solvers, e.g. CDR solvers, the scalar :math:`\phi` is copied into a scratch space.
   The reason for this backup is that during the regrid :math:`\phi` will be allocated on the *new* AMR grids, but we must still have access to the previously defined data in order to interpolate to the new grids.
3. If necessary, ``TimeStepper`` can deallocate unecessary storage.
   Implementing a deallocation function for ``TimeStepper``-derived classes is not a requirement, but can in certain cases be useful, for example when using the Berger-Rigoutsous algorithm at large scale.
4. The ``AmrMesh`` class generates the new grids and defines new AMR operators.
5. The ``TimeStepper`` class regrids its solvers and internal data.
6. The ``TimerStepper`` performs a *post-regrid* operation (e.g. filling solvers with auxiliary data). 

In C++ pseudo-code, this looks something like:

.. code-block:: c++

   Driver::regrid(){

      // Tag cells
      CellTagger->tagCellsForRefinement() 

      // Store old data and free up some memory
      TimeStepper->storeOldGridData()
      TimeStepper->deallocateUnneccesaryData()

      // Generate the new grids
      AmrMesh->regrid() 

      // Regrid physics and all solvers
      TimeStepper->regrid()

      // Do a post-regrid step
      TimeStepper->postRegrid()
   }

The full code is defined in ``Driver::regrid()`` in file :file:`$DISCHARGE_HOME/Source/Driver/CD_Driver.cpp`. 


Class options
-------------

Various class options are available for adjusting the behavior of the ``Driver`` class

* ``Driver.verbosity`` controls output will be given to ``pout.n``. We use 2 or 3 - higher values are for debugging. 
* ``Driver.geometry_generation`` controls the grid generation method (see :ref:`Chap:GeometryGeneration`).
  Valid options are *chombo-discharge* or *chombo*. 
* ``Driver.geometry_scan_level``.
  Which refinement level to initiate the ``chombo-discharge`` geometry generation method.
  This entry indicates the number of refinements of the coarsest AMR level used in the simulation.
  E.g. if the ``Driver.geometry_scan_level=1`` and the coarsest AMR level is :math:`128^3` then the signed distance pruning (see :ref:`Chap:GeometryGeneration`) begins at the AMR level :math:`256^3`.
  Note that negative numbers are also permitted, in which case the pruning initiates at a coarsened level.
* ``Driver.ebis_memory_load_balance``. If using Chombo geo-gen, use memory as loads for EBIS generation. Valid options are *true* or *false*. 
* ``Driver.plot_interval``. Time steps between each plot file. 
* ``Driver.checkpoint_interval``. Time steps between each checkpoint file. 
* ``Driver.regrid_interval``. Time steps between each regrid. 
* ``Driver.write_regrid_files``. Write plot files during regrids. Valid options are *true* or *false*. 
* ``Driver.write_restart_files``.Write plot files during restarts. Valid options are *true* or *false*. 
* ``Driver.initial_regrids``. Number of initial regrids to perform when starting (or restarting) a simulation. 
* ``Driver.start_time``. Simulation start time. 
* ``Driver.stop_time``.Simulation stop time. 
* ``Driver.max_steps``. Maximum number of simulation time steps. 
* ``Driver.geometry_only``. If *true*, do not run the simulation and only write the geometry to file. 
* ``Driver.write_memory``. Write MPI memory report. Valid options are *true* or *false*.
* ``Driver.write_loads``.  Write computational loads. Valid options are *true* or *false*.
* ``Driver.output_directory``. Output directory. 
* ``Driver.output_names``. Simulation file names. 
* ``Driver.max_plot_depth``. Maximum plot depth.
  Values :math:`< 0` means all levels. 
* ``Driver.max_chk_depth``.  Maximum checkpoint file depth.
  Values :math:`< 0` means all levels. 
* ``Driver.num_plot_ghost``. Number of ghost cells in plot files. 
* ``Driver.plt_vars``. Plot variables for ``Driver``. Valid options are *tags*, *mpi_rank*, *levelset*. 
* ``Driver.restart``. Restart step (less or equal to 0 implies fresh simulation)
* ``Driver.allow_coarsening``. Allows removal of grid levels if cell tags dont run deep enough.
* ``Driver.grow_geo_tags``. How much to grow boundary cell tags. 
* ``Driver.refine_angles``. Refine cells if the angle between normal vector in neighboring cells exceed this threshold. 
* ``Driver.refine_electrodes``. Refine electrode surfaces. Values :math:`< 0` will refine all the way down. 
* ``Driver.refine_dielectrics``. Refine dielectric surfaces. Values :math:`< 0` will refine all the way down. 

Runtime options
---------------

The following options can be adjusted during runtime:

* ``Driver.verbosity``. 
* ``Driver.plot_interval``.
* ``Driver.checkpoint_interval``.
* ``Driver.regrid_interval``.
* ``Driver.write_regrid_files``.
* ``Driver.write_restart_files``.
* ``Driver.stop_time``.
* ``Driver.max_steps``.
* ``Driver.write_memory``.
* ``Driver.write_loads``. 
* ``Driver.num_plot_ghost``.
* ``Driver.plt_vars``.
* ``Driver.allow_coarsening``.
