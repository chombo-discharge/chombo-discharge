/* chombo-discharge
 * Copyright Â© 2021 SINTEF Energy Research.
 * Please refer to Copyright.txt and LICENSE in the chombo-discharge root directory.
 */

/*!
  @file   CD_TimerImplem.H
  @brief  Implementation of CD_Timer.H
  @author Robert Marskar
*/

#ifndef CD_TimerImplem_H
#define CD_TimerImplem_H

// Std includes
#include <sstream>
#include <iostream>

// Our includes
#include <CD_Timer.H>
#include <CD_NamespaceHeader.H>

inline
Real Timer::wallClock(){

  // TLDR: This just returns the current time in seconds (since an arbitrary time in the past). 
  const auto currentTime       = std::chrono::steady_clock::now();
  const auto durationInSeconds = std::chrono::duration<Real>(currentTime.time_since_epoch());

  return durationInSeconds.count();
}

inline
Timer::Timer(const std::string a_processName) {
  m_processName = a_processName;
  m_events.clear();
}

inline
Timer::~Timer() {
  m_events.clear();
}

inline
void Timer::startEvent(const std::string a_event) noexcept {
  if (m_events.find(a_event) == m_events.end() ) { // Create a new event. 
    const TimePoint startTime   = Clock::now();
    const Duration  elapsedTime = Duration(0.0);
    
    m_events.emplace(a_event, std::make_tuple(false, startTime, elapsedTime));
  }
  else{ // If the event is not new, we just leave the elapsed time intact. 
    //    const TimePoint startTime = Clock::now();
    tuple<bool, TimePoint, Duration>& event = m_events.at(a_event);
    const bool alreadyRunning = std::get<StoppedEvent>(event);

    if(!alreadyRunning){ // Only start the event if it is not already running. 
      const TimePoint  startTime          = Clock::now();
      const Duration& previousElapsedTime = std::get<ElapsedTime>(event);

      event = std::make_tuple(false, startTime, previousElapsedTime);
    }
  }
}

inline
void Timer::stopEvent(const std::string a_event) noexcept {
  if (m_events.find(a_event) != m_events.end()) {
    tuple<bool, TimePoint, Duration>& event = m_events.at(a_event);

    const TimePoint startTime           = std::get<StartClock>(event);
    const TimePoint stopTime            = Clock::now();
    const Duration  curElapsedTime      = stopTime - startTime;
    const Duration  previousElapsedTime = std::get<ElapsedTime>(event);
    const Duration  totalElapsedTime    = previousElapsedTime + curElapsedTime;

    event = std::make_tuple(true, startTime, totalElapsedTime);
  }
  else{
    std::cerr << "Timer::stopEvent -- event '" + a_event + "' has not been started\n";
  }
}

inline
void Timer::printReportHeader() const noexcept {

  std::stringstream header;
  header << "| ---------------------------------------------------------------------------------------------------------|" << "\n"
	 << "| " + m_processName + " kernel report: "                                                                      << "\n"
         << "| ---------------------------------------------------------------------------------------------------------|" << "\n"
	 << "| " << std::left << std::setw(25) << "Event"
	 << "| " << std::right << std::setw(8) << "Loc. (s)"
	 << "| " << std::right << std::setw(8) << "Loc. (%)"    
#ifdef CH_MPI
	 << "| " << std::right << std::setw(8) << "Min. (s)"
	 << "| " << std::right << std::setw(8) << "Max. (s)"
	 << "| " << std::right << std::setw(8) << "Avg. (s)" 
	 << "| " << std::right << std::setw(8) << "Dev. (s)"
	 << "| " << std::right << std::setw(8) << "Min rank"
	 << "| " << std::right << std::setw(8) << "Max rank"
	 << "| " << "\n"
#endif
         << "| ---------------------------------------------------------------------------------------------------------|" << "\n";

  pout() << header.str();
}

inline
void Timer::printReportTail(const std::pair<Real, Real> a_elapsedTime) const noexcept {
  std::stringstream tail;
  
  tail << "| ---------------------------------------------------------------------------------------------------------|" << "\n"
       << "| Local elapsed time  = " << std::fixed << std::setprecision(5) << a_elapsedTime.first  << " seconds"         << "\n"    
       << "| Global elapsed time = " << std::fixed << std::setprecision(5) << a_elapsedTime.second << " seconds"         << "\n"
       << "| ---------------------------------------------------------------------------------------------------------|" << "\n";

  pout() << tail.str();
}

inline
void Timer::eventReport(const bool a_localReportOnly) const noexcept{
  // This routine prints a header, the timing report for the various event, and a tail. All events are included
  // but unfinished ones are not counted towards the elapsed time. 
  
  this->printReportHeader();

  const std::pair<Real, Real> totalTime = this->computeTotalElapsedTime(a_localReportOnly);
  const Real totalTimeLocal  = totalTime.first;
  const Real totalTimeGlobal = totalTime.second;  
    
  for (const auto& e : m_events){

    const std::string& eventName     = e.first;
    const bool         finishedEvent = std::get<StoppedEvent> (e.second);

    std::stringstream ssLocalDuration; 
    std::stringstream ssPercentage;    
    std::stringstream ssMinDuration;
    std::stringstream ssMaxDuration;
    std::stringstream ssAvgDuration;
    std::stringstream ssDevDuration;
    std::stringstream ssMinRank;
    std::stringstream ssMaxRank;    

    if(finishedEvent){
      const Duration localDuration      = std::get<ElapsedTime>(e.second);
      const Real localDurationInSeconds = localDuration.count();

      ssLocalDuration << std::fixed << std::setprecision(5) << localDurationInSeconds;
      ssPercentage    << std::fixed << std::setprecision(5) << 100.*localDurationInSeconds/totalTimeLocal;

#ifdef CH_MPI
      if(!a_localReportOnly){

	const int srcRank = 0;
	const int numRank = numProc();
    
	Vector<Real> allDurations(numRank);
	gather(allDurations, localDurationInSeconds, srcRank);

	// Compute average time and standard deviation
	Real average;
	Real sigma;
      
	Real maxTime = std::numeric_limits<Real>::min();
	Real minTime = std::numeric_limits<Real>::max();

	int minRank;
	int maxRank;
      
	if(procID() == 0){
	
	  average = 0.0;
	  for (int i = 0; i < allDurations.size(); i++){
	    average += allDurations[i];

	    if(allDurations[i] < minTime){
	      minRank = i;
	      minTime = allDurations[i];
	    }
	    if(allDurations[i] > maxTime){
	      maxRank = i;
	      maxTime = allDurations[i];
	    }	  	  
	  }
	  average *= 1./numRank;

	  sigma = 0.0;
	  for (int i = 0; i < allDurations.size(); i++){
	    sigma += std::pow(allDurations[i]-average, 2);
	  }
	  sigma *= 1./numRank;
	}

	broadcast(average, srcRank);
	broadcast(sigma,   srcRank);
	broadcast(maxTime, srcRank);
	broadcast(minTime, srcRank);
	broadcast(minRank, srcRank);
	broadcast(maxRank, srcRank);      

	ssMinDuration << std::fixed << std::setprecision(5) << minTime;
	ssMaxDuration << std::fixed << std::setprecision(5) << maxTime;
	ssAvgDuration << std::fixed << std::setprecision(5) << average;
	ssDevDuration << std::fixed << std::setprecision(5) << sigma;
	ssMinRank     << std::fixed << std::setprecision(5) << minRank;
	ssMaxRank     << std::fixed << std::setprecision(5) << maxRank;
      }
      else{
	ssMinDuration    << " N/A ";
	ssMaxDuration    << " N/A ";
	ssAvgDuration    << " N/A ";
	ssDevDuration    << " N/A ";
	ssMinRank        << " N/A ";
	ssMaxRank        << " N/A ";    
      }
#endif
    }
    else{
      ssLocalDuration  << " - ";
      ssPercentage     << " - ";
      ssMinDuration    << " - ";
      ssMaxDuration    << " - ";
      ssAvgDuration    << " - ";
      ssDevDuration    << " - ";
      ssMinRank        << " - ";
      ssMaxRank        << " - ";    
    }

    std::stringstream outputString;

    // Now print to pout
    outputString << "| " << std::left  << std::setw(25) << eventName
		 << "| " << std::right << std::setw(8)  << ssLocalDuration.str()
		 << "| " << std::right << std::setw(8)  << ssPercentage.str()
#ifdef CH_MPI
		 << "| " << std::right << std::setw(8)  << ssMinDuration.str()
		 << "| " << std::right << std::setw(8)  << ssMaxDuration.str()
		 << "| " << std::right << std::setw(8)  << ssAvgDuration.str()
		 << "| " << std::right << std::setw(8)  << ssDevDuration.str()
		 << "| " << std::right << std::setw(8)  << ssMinRank.str()
		 << "| " << std::right << std::setw(8)  << ssMaxRank.str()
#endif
		 << "| "
		 << "\n";

    pout() << outputString.str();
  }

  this->printReportTail(totalTime);  
}

inline
std::pair<Real, Real> Timer::computeTotalElapsedTime(const bool a_localReportOnly) const noexcept {

  Real elapsedTimeLocal  = 0.0;
  Real elapsedTimeGlobal = 0.0;
  
  for (const auto& e : m_events){
    const bool finishedEvent = std::get<StoppedEvent>(e.second);

    if(finishedEvent){
      const Duration elapsedTime        = std::get<ElapsedTime>(e.second);
      const Real localDurationInSeconds = elapsedTime.count();

      elapsedTimeLocal += localDurationInSeconds;
    }
  }

#ifdef CH_MPI
  if(!a_localReportOnly){
    MPI_Allreduce(&elapsedTimeLocal, &elapsedTimeGlobal, 1, MPI_CH_REAL, MPI_MAX, Chombo_MPI::comm);
  }
  else{
    elapsedTimeGlobal = elapsedTimeLocal;
  }
#else
  elapsedTimeGlobal = elapsedTimeLocal;
#endif        

  return std::make_pair(elapsedTimeLocal, elapsedTimeGlobal);
}
 
#include <CD_NamespaceFooter.H>

#endif
