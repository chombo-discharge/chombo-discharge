/* chombo-discharge
 * Copyright Â© 2026 SINTEF Energy Research.
 * Please refer to Copyright.txt and LICENSE in the chombo-discharge root directory.
 */

/*!
  @file   CD_MFHelmholtzPetsc.H
  @brief  File containing declaration of the MFHelmholtzPetsc class.
  @author Robert Marskar
*/

#ifdef CH_USE_PETSC

#ifndef CD_MFHelmholtzPetsc_H
#define CD_MFHelmholtzPetsc_H

// Chombo includes
#include <LevelData.H>
#include <RefCountedPtr.H>

// Our includes
#include <CD_PetscGrid.H>
#include <CD_PetscStencil.H>
#include <CD_VofUtils.H>
#include <CD_MFMultigridInterpolator.H>
#include <CD_NamespaceHeader.H>

#warning "Must design boundary conditions (should be more sophisticated than FieldSolverGMG)"
#warning "Later, this class should store EB flux stencils to reduce costs when changing the b-coefficients"

/*!
  @brief Class for generating stencils for the finite-volume discretization of the Helmholtz equation.
  @details This class supports generating stencils using the valid cells in the domain only. It supports
  stencil generation across coarse-fine interfaces, including:
  1) Fluxes on embedded boundary.
  2) Jump conditions.
  3) Consistent coarse-fine fluxes.
  4) Domain fluxes.

  All the fluxes are expressed in terms of cells that are also PETSc rows, so that PETSc matrices can be
  built using the stencils generated by this class. 
*/
class MFHelmholtzPetsc
{
public:
  /*!
    @brief Short-hand notation for the required contents on a PETSc row. 
  */
  using PetscColumn = std::pair<PetscStencil, PetscScalar>;

  /*!
    @brief Default constructor. Must subsequently call the define method
  */
  MFHelmholtzPetsc() noexcept;

  /*!
    @brief Full constructor. Calls the define method.
  */
  MFHelmholtzPetsc(const RefCountedPtr<PetscGrid>&                          a_petscGrid,
                   const RealVect&                                          a_probLo,
                   const Real&                                              a_alpha,
                   const Real&                                              a_beta,
                   const bool&                                              a_multRhoByVolFrac,
                   const bool&                                              a_multSigmaByAreaFrac,
                   const Vector<RefCountedPtr<LevelData<MFCellFAB>>>&       a_aCoef,
                   const Vector<RefCountedPtr<LevelData<MFFluxFAB>>>&       a_bCoef,
                   const Vector<RefCountedPtr<LevelData<MFBaseIVFAB>>>&     a_bCoefIrreg,
                   const Vector<RefCountedPtr<LevelData<MFCellFAB>>>&       a_rho,
                   const Vector<RefCountedPtr<LevelData<BaseIVFAB<Real>>>>& a_sigma,
                   const Vector<MFMultigridInterpolator>&                   a_coarseFineInterpolators,
                   const Vector<int>&                                       a_refinementRatios,
                   const Vector<Real>&                                      a_dx,
                   const int&                                               a_finestLevel,
                   const int&                                               a_dirichletEBBCOrder,
                   const int&                                               a_dirichletEBBCWeight,
                   const int&                                               a_robinEBBCOrder,
                   const int&                                               a_robinEBBCWeight,
                   const int&                                               a_jumpOrder,
                   const int&                                               a_jumpWeight,
                   const Location::Cell&                                    a_dataLocation) noexcept;

  /*!
    @brief Destructor
  */
  virtual ~MFHelmholtzPetsc() noexcept;

  /*!
    @brief Check if object is defined or not
  */
  virtual bool
  isDefined() const noexcept;

  /*!
    @brief Define method. Puts object in usable state.
  */
  virtual void
  define(const RefCountedPtr<PetscGrid>&                          a_petscGrid,
         const RealVect&                                          a_probLo,
         const Real&                                              a_alpha,
         const Real&                                              a_beta,
         const bool&                                              a_multRhoByVolFrac,
         const bool&                                              a_multSigmaByAreaFrac,
         const Vector<RefCountedPtr<LevelData<MFCellFAB>>>&       a_aCoef,
         const Vector<RefCountedPtr<LevelData<MFFluxFAB>>>&       a_bCoef,
         const Vector<RefCountedPtr<LevelData<MFBaseIVFAB>>>&     a_bCoefIrreg,
         const Vector<RefCountedPtr<LevelData<MFCellFAB>>>&       a_rho,
         const Vector<RefCountedPtr<LevelData<BaseIVFAB<Real>>>>& a_sigma,
         const Vector<MFMultigridInterpolator>&                   a_coarseFineInterpolators,
         const Vector<int>&                                       a_refinementRatios,
         const Vector<Real>&                                      a_dx,
         const int&                                               a_finestLevel,
         const int&                                               a_dirichletEBBCOrder,
         const int&                                               a_dirichletEBBCWeight,
         const int&                                               a_robinEBBCOrder,
         const int&                                               a_robinEBBCWeight,
         const int&                                               a_jumpOrder,
         const int&                                               a_jumpWeight,
         const Location::Cell&                                    a_dataLocation) noexcept;

  /*!
    @brief Clear this object
  */
  virtual void
  clear() noexcept;

  /*!
    @brief Turn on/off multiplication of rho by the volume fraction.
    @param[in] a_multRhoByVolFrac.
  */
  virtual void
  setMultRhoByVolFrac(const bool a_multRhoByVolFrac) noexcept;

  /*!
    @brief Turn on/off multiplication of sigma by the area fraction.
    @param[in] a_multSigmaByAreaFrac.    
  */
  virtual void
  setMultSigmaByAreaFrac(const bool a_multSigmaByAreaFrac) noexcept;

  /*!
    @brief Reset the Dirichlet EBBC order.
    @param[i] a_order Boundary condition order. Must be > 0.
  */
  virtual void
  setDirichletEBBCOrder(const int a_order) noexcept;

  /*!
    @brief Set the Dirichlet EBBC weighting. Weighting factor = 0 uses unweighted least squares. 
    @param[i] a_weight Weighting factor. Must be >= 0.
  */
  virtual void
  setDirichletEBBCWeight(const int a_weight) noexcept;

  /*!
    @brief Reset the Robin EBBC order.
    @param[i] a_order Boundary condition order. Must be > 0.
  */
  virtual void
  setRobinEBBCOrder(const int a_order) noexcept;

  /*!
    @brief Set the Robin EBBC weighting. Weighting factor = 0 uses unweighted least squares. 
    @param[i] a_weight Weighting factor. Must be >= 0.
  */
  virtual void
  setRobinEBBCWeight(const int a_weight) noexcept;

  /*!
    @brief Reset the jump order.
    @param[i] a_order Boundary condition order. Must be > 0.
  */
  virtual void
  setJumpOrder(const int a_order) noexcept;

  /*!
    @brief Reset the jump weighting. Weighting factor = 0 uses unweighted least squares. 
    @param[i] a_weight Weighting factor. Must be >= 0.
  */
  virtual void
  setJumpWeight(const int a_weight) noexcept;

  /*!
    @brief Externally set the neighborhood search algorithm when computing Dirichlet boundary conditions
    @param[in] a_neigborhoods Neighborhood algorithms. Must have size > 0. 
  */
  virtual void
  setEBDirichletNeighborhoods(const std::vector<VofUtils::Neighborhood>& a_neighborhoods) noexcept;

  /*!
    @brief Externally set the neighborhood search algorithm when computing Robin boundary conditions.
    @param[in] a_neigborhoods Neighborhood algorithms. Must have size > 0. 
  */
  virtual void
  setEBRobinNeighborhoods(const std::vector<VofUtils::Neighborhood>& a_neighborhoods) noexcept;

  /*!
    @brief Externally set the neighborhood search algorithm when computing jump boundary conditions.
    @param[in] a_neigborhoods Neighborhood algorithms. Must have size > 0. 
  */
  virtual void
  setEBJumpNeighborhoods(const std::vector<VofUtils::Neighborhood>& a_neighborhoods) noexcept;

  /*!
    @brief Convenience function for computing stencils for Dirichlet boundary conditions.
    @details This function computes approximations to the gradient through an embedded boundary centroid
    where the value of phi is known at the cut-cell boundary centroid. The stencils take the form

       dphi/dn = w_b * phi_b + sum(w_i * phi_i)

    where phi_b is the value at the boundary point and phi_i are internal degrees of freedom. The stencil
    is calculated using least squares approximations.
  */
  virtual void
  computeEBDirichletStencils() noexcept;

  /*!
    @brief Convenience function for computing and storing all embedded boundary gradient stencils.
    @details This function computes the approximation to grad(phi) on all embedded boundary faces. It
    includes the stencils for the jump conditions. The resulting data is not weighted by either the
    beta or beta-coefficient. Users can later fetch the raw stencil and scale the matrix with the 
    corresponding coefficients, and thus avoid recalculation of the relatively expensive least squares
    reconstructions near the embedded boundary.
  */
  virtual void
  computeEBGradStencils() noexcept;

  /*!
    @brief Convenience function for computing and storing all embedded boundary extrapolation stencils. 
    @details This function computes the extrapolation of phi to the embedded boundary. The stencils are
    not multiplied by either beta or the b-coefficient. Useful when the user wants to pre-compute all
    required stencils for Robin boundary conditions.
  */
  virtual void
  computeEBExtrapStencils() noexcept;

  /*!
    @brief Get a face flux stencil.
    @note This is the EB version. 
  */
  virtual PetscStencil
  computeInteriorFaceFluxStencil(const VolIndex&      a_vof,
                                 const int&           a_phase,
                                 const int&           a_level,
                                 const int            a_dir,
                                 const Side::LoHiSide a_side,
                                 const DataIndex&     a_din) const noexcept;

  /*!
    @brief Get a face flux stencil.
    @note Regular version. If the indicated face is the coarse-face of a coarse-fine boundary, the flux is constructed
    using the sum of the fine-grid fluxes. 
  */
  virtual PetscStencil
  computeInteriorFaceFluxStencil(const IntVect&       a_cell,
                                 const int            a_phase,
                                 const int            a_level,
                                 const int            a_dir,
                                 const Side::LoHiSide a_side,
                                 const DataIndex&     a_din) const noexcept;

  /*!
    @brief Get a Dirichlet stencil on an embedded boundary face.
    @details This will solve the least squares approximation for dphi/dn, assuming that phi is known
    on the EB face. This is representable as a stencil dphi/dn \approx w_b*phi_b + sum_i w_i phi_i,
    where phi_b is the provided value on the embedded boundary. This function returns the weight w_b and
    the corresponding stencil containing the interior points. It is up to the user to later impose w_b*phi_b
    in the assembled matrix/rhs.

    Internally, this function will only use cells that are not covered by a finer grid. Note that it might reach
    into the other phase IF we could not obtain enough cells on the input phase. This operator will first attempt
    to lower the least squares reconstruction order before that happens, however, all the way down to first order.
    If a stencil still can't be found, it will try to reach into the other phase to obtain a direct approximation
    to grad(phi), ignoring the jump condition, and then impose the flux as grad(phi)*n, where n is the normal vector.

    @param[in] a_vof Grid cell
    @param[in] a_phase Phase
    @param[in] a_level Grid level
    @param[in] a_din Grid index.
    @note Calling this function on a grid cell that is not a PETSC-row inside the input grid level and index
    will cause a runtime error. 
  */
  virtual std::pair<PetscScalar, PetscStencil>
  computeEBDirichletStencil(const VolIndex&  a_vof,
                            const int&       a_phase,
                            const int&       a_level,
                            const DataIndex& a_din) const noexcept;

  /*!
    @brief Get a Robin flux stencil on an embedded boundary face.
    @details The Robin BC is assumed to be in the form c1*phi + c2*dphi/dn = c3, so the
    flux is then dphi/dn = c3/c2 - c3/c1 * phi. This routine will turn the right-hand side
    of this expression into the above form    
    @note This should not be called on jump faces.
  */
  virtual PetscStencil
  computeRobinEBGradStencil(const VolIndex&  a_vof,
                            const int&       a_phase,
                            const int&       a_level,
                            const DataIndex& a_din) const noexcept;

  /*!
    @brief Get a Neumann flux stencil on an embedded boundary face.
    @note This should not be called on jump faces.
  */
  virtual PetscScalar
  computeNeumannEBGradStencil(const VolIndex&  a_vof,
                              const int&       a_phase,
                              const int&       a_level,
                              const DataIndex& a_din) const noexcept;

  /*!
    @brief Get the fluxes through either side of a jump-condition cell. 
    @note This should not be called on single-phase EB faces.
  */
  virtual std::pair<PetscColumn, PetscColumn>
  computeJumpFluxStencils(const IntVect&   a_cell,
                          const int&       a_phase,
                          const int&       a_level,
                          const DataIndex& a_din) const noexcept;

  /*!
    @brief Compute a stencil for imposing a Dirichlet domain flux on a domain side.
  */
  virtual std::pair<PetscStencil, PetscScalar>
  computeDirichletDomainGradStencil(const VolIndex&      a_vof,
                                    const int&           a_phase,
                                    const int&           a_level,
                                    const int&           a_dir,
                                    const Side::LoHiSide a_side,
                                    const DataIndex&     a_din) const noexcept;

  /*!
    @brief Compute a stencil for imposing a Robin BC domain flux on a domain side.
  */
  virtual std::pair<PetscStencil, PetscScalar>
  computeRobinDomainGradStencil(const VolIndex&      a_vof,
                                const int&           a_phase,
                                const int&           a_level,
                                const int&           a_dir,
                                const Side::LoHiSide a_side,
                                const DataIndex&     a_din) const noexcept;

  /*!
    @brief Compute a stencil for imposing a Robin BC domain flux on a domain side.
  */
  virtual PetscScalar
  computeNeumannDomainGradStencil(const VolIndex&      a_vof,
                                  const int&           a_phase,
                                  const int&           a_level,
                                  const int&           a_dir,
                                  const Side::LoHiSide a_side,
                                  const DataIndex&     a_din) const noexcept;

  /*!
    @brief Get a PETSc stencil for the given input grid point and phase.
    @details This is the main routine for getting an stencil out of the Helmholtz discretization. Note that this will call
    the other versions and compute the EB and face flux stencils.
    @return This returns a stencil for the given input VoF, and the corresponding constant term which can be put
    into the right-hand side.
  */
  virtual PetscColumn
  computeStencil(const VolIndex& a_vof, const int& a_phase, const int& a_level, const DataIndex& a_din) const noexcept;

protected:
  /*!
    @brief Data location
  */
  Location::Cell m_dataLocation;

  /*!
    @brief Is defined or not.
  */
  bool m_isDefined;

  /*!
    @brief Verbose output on or off.
  */
  bool m_verbose;

  /*!
    @brief Profiling on or off. 
  */
  bool m_profile;

  /*!
    @brief Debugging on or off. 
  */
  bool m_debug;

  /*!
    @brief Multiply or don't multiply rho by kappa when computing stencils.
  */
  bool m_multRhoByVolFrac;

  /*!
    @brief Multiply or don't multiply sigma by the area fraction when computing stencils.
  */
  bool m_multSigmaByAreaFrac;

  /*!
    @brief Lower-left corner of problem domain
  */
  RealVect m_probLo;

  /*!
    @brief Helmholtz alpha-coefficient
  */
  Real m_alpha;

  /*!
    @brief Helmholtz beta-coefficient
  */
  Real m_beta;

  /*!
    @brief Finest grid level
  */
  int m_finestLevel;

  /*!
    @brief Dirichlet EB boundary condition order. 
  */
  int m_dirichletEBBCOrder;

  /*!
    @brief Dirichlet EB boundary condition weighting factor. 
  */
  int m_dirichletEBBCWeight;

  /*!
    @brief Robin EB boundary condition order. 
  */
  int m_robinEBBCOrder;

  /*!
    @brief Robin EB boundary condition weighting factor. 
  */
  int m_robinEBBCWeight;

  /*!
    @brief EB jump condition order.
  */
  int m_jumpOrder;

  /*!
    @brief EB jump condition weighting factor.
  */
  int m_jumpWeight;

  /*!
    @brief Number of valid phases
  */
  int m_numPhases;

  /*!
    @brief List of Dirichlet EB stencil neighborhood priorities
    @details This is a priority list over which types of cells are used when calculating Dirichlet boundary conditions on EBs. This can
    be set externally through the public interface. 
  */
  std::vector<VofUtils::Neighborhood> m_ebDirichletNeighborhoods;

  /*!
    @brief List of Robin EB stencil neighborhood priorities
    @details This is a priority list over which types of cells are used when calculating Robin boundary conditions on EBs. This can be
    set externally through the public interface. 
  */
  std::vector<VofUtils::Neighborhood> m_ebRobinNeighborhoods;

  /*!
    @brief List of jump EB stencil neighborhood priorities
    @details This is a priority list over which types of cells are used when calculating jump conditions on EBs. This can be
    set externally through the public interface. 
  */
  std::vector<VofUtils::Neighborhood> m_ebJumpNeighborhoods;

  /*!
    @brief Reference to the PETSc interface object
  */
  RefCountedPtr<PetscGrid> m_petscGrid;

  /*!
    @brief Helmholtz A-coefficient
  */
  Vector<RefCountedPtr<LevelData<MFCellFAB>>> m_aCoef;

  /*!
    @brief Helmholtz B-coefficient
  */
  Vector<RefCountedPtr<LevelData<MFFluxFAB>>> m_bCoef;

  /*!
    @brief Helmholtz B-coefficient on cut-cell faces.
  */
  Vector<RefCountedPtr<LevelData<MFBaseIVFAB>>> m_bCoefIrreg;

  /*!
    @brief Right-hand side of Helmholtz equation
  */
  Vector<RefCountedPtr<LevelData<MFCellFAB>>> m_rho;

  /*!
    @brief Jump factor on jump condition cells
  */
  Vector<RefCountedPtr<LevelData<BaseIVFAB<Real>>>> m_sigma;

  /*!
    @brief Coarse-fine interpolator objects.
  */
  Vector<MFMultigridInterpolator> m_interpolators;

  /*!
    @brief Refinement ratios
  */
  Vector<int> m_refinementRatios;

  /*!
    @brief Grid resolutions
  */
  Vector<Real> m_dx;

  /*!
    @brief Storage for stencils holding least squares approximations to a Dirichlet boundary condition on cut cells
  */
  Vector<RefCountedPtr<LayoutData<BaseIVFAB<std::pair<PetscScalar, PetscStencil>>>>> m_ebDirichletStencils[2];

  /*!
    @brief Storage for stencils holding approximations to the extrapolation of phi on cut-cell centroids
  */
  Vector<RefCountedPtr<LayoutData<BaseIVFAB<PetscStencil>>>> m_ebExtrapStencils[2];

  /*!
    @brief Storage for stencils holding approximations to grad(phi) on the embedded boundaries. 
  */
  Vector<RefCountedPtr<LayoutData<BaseIVFAB<PetscStencil>>>> m_ebGradStencils[2];

  /*!
    @brief Storage for stencils holding approximations to grad(phi) on jump condition cells.
  */
  Vector<RefCountedPtr<LayoutData<BaseIVFAB<PetscScalar>>>> m_jumpGradStencils[2];
};

#include <CD_NamespaceFooter.H>

#endif

#endif
