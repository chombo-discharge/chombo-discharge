/* chombo-discharge
 * Copyright Â© 2026 SINTEF Energy Research.
 * Please refer to Copyright.txt and LICENSE in the chombo-discharge root directory.
 */

/*!
  @file   CD_MFHelmholtzPetsc.H
  @brief  File containing declaration of the MFHelmholtzPetsc class.
  @author Robert Marskar
*/

#ifdef CH_USE_PETSC

#ifndef CD_MFHelmholtzPetsc_H
#define CD_MFHelmholtzPetsc_H

// Chombo includes
#include <LevelData.H>
#include <RefCountedPtr.H>

// Our includes
#include <CD_PetscGrid.H>
#include <CD_PetscStencil.H>
#include <CD_EBMultigridInterpolator.H>
#include <CD_NamespaceHeader.H>

#warning "Later, this class should store EB flux stencils to reduce costs when changing the b-coefficients"

/*!
  @brief Class for generating stencils for the finite-volume discretization of the Helmholtz equation.
  @details This class supports generating stencils using the valid cells in the domain only. It supports
  stencil generation across coarse-fine interfaces, including:
  1) Fluxes on embedded boundary.
  2) Jump conditions.
  3) Consistent coarse-fine flux.
  4) Domain fluxes.

  All the fluxes are expressed in terms of cells that are also PETSc rows, so that PETSc matrices can be
  built using the stencils generated by this class. 
*/
class MFHelmholtzPetsc
{
public:
  /*!
    @brief Default constructor. Must subsequently call the define method
  */
  MFHelmholtzPetsc() noexcept;

  /*!
    @brief Full constructor. Calls the define method.
  */
  MFHelmholtzPetsc(const RefCountedPtr<PetscGrid>&                          a_petscGrid,
                   const RealVect&                                          a_probLo,
                   const Real&                                              a_alpha,
                   const Real&                                              a_beta,
                   const bool&                                              a_multRhoByVolFrac,
                   const bool&                                              a_multSigmaByAreaFrac,
                   const Vector<RefCountedPtr<LevelData<MFCellFAB>>>&       a_aCoef,
                   const Vector<RefCountedPtr<LevelData<MFFluxFAB>>>&       a_bCoef,
                   const Vector<RefCountedPtr<LevelData<MFBaseIVFAB>>>&     a_bCoefIrreg,
                   const Vector<RefCountedPtr<LevelData<MFCellFAB>>>&       a_rho,
                   const Vector<RefCountedPtr<LevelData<BaseIVFAB<Real>>>>& a_sigma,
                   const Vector<RefCountedPtr<EBMultigridInterpolator>>&    a_coarseFineInterpolators,
                   const Vector<int>&                                       a_refinementRatios,
                   const Vector<Real>&                                      a_dx,
                   const int&                                               a_finestLevel,
                   const int&                                               a_ebbcOrder,
                   const int&                                               a_ebbcWeight,
                   const int&                                               a_jumpOrder,
                   const int&                                               a_jumpWeight,
                   const Location::Cell&                                    a_dataLocation) noexcept;

  /*!
    @brief Destructor
  */
  virtual ~MFHelmholtzPetsc() noexcept;

  /*!
    @brief Define method. Puts object in usable state.
  */
  virtual void
  define(const RefCountedPtr<PetscGrid>&                          a_petscGrid,
         const RealVect&                                          a_probLo,
         const Real&                                              a_alpha,
         const Real&                                              a_beta,
         const bool&                                              a_multRhoByVolFrac,
         const bool&                                              a_multSigmaByAreaFrac,
         const Vector<RefCountedPtr<LevelData<MFCellFAB>>>&       a_aCoef,
         const Vector<RefCountedPtr<LevelData<MFFluxFAB>>>&       a_bCoef,
         const Vector<RefCountedPtr<LevelData<MFBaseIVFAB>>>&     a_bCoefIrreg,
         const Vector<RefCountedPtr<LevelData<MFCellFAB>>>&       a_rho,
         const Vector<RefCountedPtr<LevelData<BaseIVFAB<Real>>>>& a_sigma,
         const Vector<RefCountedPtr<EBMultigridInterpolator>>&    a_coarseFineInterpolators,
         const Vector<int>&                                       a_refinementRatios,
         const Vector<Real>&                                      a_dx,
         const int&                                               a_finestLevel,
         const int&                                               a_ebbcOrder,
         const int&                                               a_ebbcWeight,
         const int&                                               a_jumpOrder,
         const int&                                               a_jumpWeight,
         const Location::Cell&                                    a_dataLocation) noexcept;

  /*!
    @brief Turn on/off multiplication of rho by the volume fraction.
    @param[in] a_multRhoByVolFrac.
  */
  virtual void
  setMultRhoByVolFrac(const bool a_multRhoByVolFrac) noexcept;

  /*!
    @brief Turn on/off multiplication of sigma by the area fraction.
    @param[in] a_multSigmaByAreaFrac.    
  */
  virtual void
  setMultSigmaByAreaFrac(const bool a_multSigmaByAreaFrac) noexcept;

  /*!
    @brief Reset the EBBC order.
    @param[i] a_order Boundary condition order. Must be > 0.
  */
  virtual void
  setEBBCOrder(const int a_order) noexcept;

  /*!
    @brief Set the EBBC weighting. Weighting factor = 0 uses unweighted least squares. 
    @param[i] a_weight Weighting factor. Must be >= 0.
  */
  virtual void
  setEBBCWeight(const int a_weight) noexcept;

  /*!
    @brief Reset the jump order.
    @param[i] a_order Boundary condition order. Must be > 0.
  */
  virtual void
  setJumpOrder(const int a_order) noexcept;

  /*!
    @brief Reset the jump weighting. Weighting factor = 0 uses unweighted least squares. 
    @param[i] a_weight Weighting factor. Must be >= 0.
  */
  virtual void
  setJumpWeight(const int a_weight) noexcept;

  /*!
    @brief Get a PETSc stencil for the given input grid point and phase.
    @details This is the main routine for getting an stencil out of the Helmholtz discretization. Note that this will call
    the other versions and compute the EB and face flux stencils.
    @return This returns a stencil for the given input VoF, and the corresponding constant term which can be put
    into the right-hand side.
  */
  virtual std::pair<PetscStencil, PetscScalar>
  getStencil(const VolIndex& a_vof, const int& a_phase, const int& a_level, const DataIndex& a_dit) const noexcept;

  /*!
    @brief Get a face flux stencil.
  */
  virtual PetscStencil
  getFaceFluxStencil(const FaceIndex& a_face,
                     const int&       a_phase,
                     const int&       a_level,
                     const DataIndex& a_dit) const noexcept;

protected:
  /*!
    @brief Data location
  */
  Location::Cell m_dataLocation;

  /*!
    @brief Is defined or not.
  */
  bool m_isDefined;

  /*!
    @brief Verbose output on or off.
  */
  bool m_verbose;

  /*!
    @brief Profiling on or off. 
  */
  bool m_profile;

  /*!
    @brief Debugging on or off. 
  */
  bool m_debug;

  /*!
    @brief Multiply or don't multiply rho by kappa when computing stencils.
  */
  bool m_multRhoByVolFrac;

  /*!
    @brief Multiply or don't multiply sigma by the area fraction when computing stencils.
  */
  bool m_multSigmaByAreaFrac;

  /*!
    @brief Lower-left corner of problem domain
  */
  RealVect m_probLo;

  /*!
    @brief Helmholtz alpha-coefficient
  */
  Real m_alpha;

  /*!
    @brief Helmholtz beta-coefficient
  */
  Real m_beta;

  /*!
    @brief Finest grid level
  */
  int m_finestLevel;

  /*!
    @brief EB boundary condition order. Relevant for Dirichlet and Robin BCs.
  */
  int m_ebbcOrder;

  /*!
    @brief EB boundary condition weighting factor. Relevant for Dirichlet and Robin BCs.
  */
  int m_ebbcWeight;

  /*!
    @brief EB jump condition order.
  */
  int m_jumpOrder;

  /*!
    @brief EB jump condition weighting factor.
  */
  int m_jumpWeight;

  /*!
    @brief Reference to the PETSc interface object
  */
  RefCountedPtr<PetscGrid> m_petscGrid;

  /*!
    @brief Helmholtz A-coefficient
  */
  Vector<RefCountedPtr<LevelData<MFCellFAB>>> m_aCoef;

  /*!
    @brief Helmholtz B-coefficient
  */
  Vector<RefCountedPtr<LevelData<MFFluxFAB>>> m_bCoef;

  /*!
    @brief Helmholtz B-coefficient on cut-cell faces.
  */
  Vector<RefCountedPtr<LevelData<MFBaseIVFAB>>> m_bCoefIrreg;

  /*!
    @brief Coarse-fine interpolator objects.
  */
  Vector<RefCountedPtr<EBMultigridInterpolator>> m_interpolators;

  /*!
    @brief Refinement ratios
  */
  Vector<int> m_refinementRatios;

  /*!
    @brief Grid resolutions
  */
  Vector<Real> m_dx;
};

#include <CD_NamespaceFooter.H>

#endif

#endif
