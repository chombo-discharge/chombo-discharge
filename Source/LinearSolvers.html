<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Linear solvers &mdash; chombo-discharge  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Verification and validation" href="VV.html" />
    <link rel="prev" title="Realm" href="Realm.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> chombo-discharge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Documentation.html">Using this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Testing.html">Code testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Acknowledgements.html">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="SpatialDiscretization.html">Spatial discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshData.html">Mesh data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Realm.html">Realm</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linear solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#helmholtz-equation">Helmholtz equation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#discretization-and-fluxes">Discretization and fluxes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-conditions">Boundary conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#neumann">Neumann</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dirichlet">Dirichlet</a></li>
<li class="toctree-l4"><a class="reference internal" href="#robin">Robin</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ghost-cell-interpolation">Ghost cell interpolation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relaxation-methods">Relaxation methods</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multiphase-helmholtz-equation">Multiphase Helmholtz equation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#jump-conditions">Jump conditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#discretization">Discretization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#amrmultigrid">AMRMultiGrid</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bottom-solvers">Bottom solvers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="VV.html">Verification and validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="DesignOverview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="CellTagger.html">CellTagger</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeoCoarsener.html">GeoCoarsener</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/CDR.html">Convection-Diffusion-Reaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Electrostatics.html">Electrostatic solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/MeshODESolver.html">Mesh ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Sigma.html">Surface charge solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/TracerParticles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Ito.html">Îto diffusion</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multi-physics applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/StreamerInceptionModel.html">Streamer inception model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Single-solver applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection-diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/MeshODEModel.html">Mesh ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/TracerParticleModel.html">Tracer particle model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#creating-a-geometry">Creating a geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#setting-up-a-timestepper">Setting up a <code class="docutils literal notranslate"><span class="pre">TimeStepper</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">Lookup tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Linear solvers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Source/LinearSolvers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="linear-solvers">
<span id="chap-linearsolvers"></span><h1>Linear solvers<a class="headerlink" href="#linear-solvers" title="Permalink to this heading"></a></h1>
<div class="section" id="helmholtz-equation">
<span id="chap-helmholtz"></span><h2>Helmholtz equation<a class="headerlink" href="#helmholtz-equation" title="Permalink to this heading"></a></h2>
<p>The Helmholtz equation is represented by</p>
<div class="math notranslate nohighlight">
\[\alpha a\left(\mathbf{x}\right)\Phi + \beta\nabla\cdot\left[b\left(\mathbf{x}\right)\nabla\Phi\right] = \rho\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are constants and <span class="math notranslate nohighlight">\(a\left(\mathbf{x}\right)\)</span> and <span class="math notranslate nohighlight">\(b\left(\mathbf{x}\right)\)</span> are spatially dependent and piecewise smooth.</p>
<p>To solve the Helmholtz equation, it is solved in the form</p>
<div class="math notranslate nohighlight">
\[\kappa L\Phi = \kappa\rho,\]</div>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is the Helmholtz operator above.
The preconditioning by the volume fraction <span class="math notranslate nohighlight">\(\kappa\)</span> is done in order to avoid the small-cell problem encountered in finite-volume discretizations on EB grids.</p>
<div class="section" id="discretization-and-fluxes">
<h3>Discretization and fluxes<a class="headerlink" href="#discretization-and-fluxes" title="Permalink to this heading"></a></h3>
<p>The Helmholtz equation is solved by assuming that <span class="math notranslate nohighlight">\(\Phi\)</span> lies on the cell-center.
The <span class="math notranslate nohighlight">\(b\left(\mathbf{x}\right)\)</span>-coefficient lies on face centers and EB faces.
In the general case the cell center might lie inside the embedded boundary, and the cell-centered discretization relies on the concept of an extended state.
Thus, <span class="math notranslate nohighlight">\(\Phi\)</span> does not satisfy a discrete maximum principle.</p>
<div class="figure align-center" id="id1">
<span id="fig-helmholtzfluxes"></span><a class="reference internal image-reference" href="../_images/CutCell.png"><img alt="../_images/CutCell.png" src="../_images/CutCell.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">Location of fluxes for finite volume discretization.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</div>
<p>The finite volume update require fluxes on the face centroids rather than the centers.
These are constructed by first computing the fluxes to second order on the face centers, and then interpolating them to the face centroids.
For example, the flux <span class="math notranslate nohighlight">\(F_3\)</span> in the figure above is</p>
<div class="math notranslate nohighlight">
\[F_3 = \beta b_{i,j+1/2}\frac{\Phi_{i,j+1} - \Phi_{i,j}}{\Delta x}.\]</div>
</div>
<div class="section" id="boundary-conditions">
<h3>Boundary conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this heading"></a></h3>
<p>The finite volume discretization of the Helmholtz equation require fluxes through the EB and domain faces.
Below, we discuss how these are implemented.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> supports spatially dependent boundary conditions</p>
</div>
<div class="section" id="neumann">
<h4>Neumann<a class="headerlink" href="#neumann" title="Permalink to this heading"></a></h4>
<p>Neumann boundary conditions are straightforward since the flux through the EB or domain faces are specified directly.</p>
<p>From the above figure, the fluxes <span class="math notranslate nohighlight">\(F_{\textrm{EB}}\)</span> and <span class="math notranslate nohighlight">\(F_{\textrm{D}}\)</span> are specified.</p>
</div>
<div class="section" id="dirichlet">
<span id="chap-linearsolverdirichletbc"></span><h4>Dirichlet<a class="headerlink" href="#dirichlet" title="Permalink to this heading"></a></h4>
<p>Dirichlet boundary conditions are more involved since only the value at the boundary is prescribed, but the finite volume discretization requires a flux.
On the domain boundaries the fluxes are face-centered and we therefore use finite differencing for obtaining a second order accurate approximation to the flux at the boundary.</p>
<p>On the embedded boundaries the flux is more complicated to compute, and requires us to compute an approximation to the normal gradient <span class="math notranslate nohighlight">\(\partial_n\Phi\)</span> at the boundary.
Our approach is to approximate this flux by expanding the solution as a polynomial around a specified number of grid cells.
By using more grid cells than there are unknown in the Taylor series, we formulate an over-determined system of equations up to some specified order.
As a first approximation we include only those cells in the quadrant or half-space defined by the normal vector, see <a class="reference internal" href="#fig-gradientreconstruction"><span class="std std-numref">Fig. 15</span></a>.
If we can not find enough equations, the strategy is to 1) drop order and 2) include all cells around the cut-cell.</p>
<div class="figure align-center" id="id2">
<span id="fig-gradientreconstruction"></span><a class="reference internal image-reference" href="../_images/GradientReconstruction.png"><img alt="../_images/GradientReconstruction.png" src="../_images/GradientReconstruction.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">Examples of neighborhoods (quadrant and half-space) used for gradient reconstruction on the EB.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</div>
<p>Once the cells used for the gradient reconstruction have been obtained, we use weighted least squares to compute the approximation to the derivative to specified order (for details, see <a class="reference internal" href="../Utilities/LeastSquares.html#chap-leastsquares"><span class="std std-ref">Least squares</span></a>).
The result of the least squares computation is represented as a stencil:</p>
<div class="math notranslate nohighlight" id="eq-dirichletelliptic">
\[\frac{\partial\Phi}{\partial n} = w_{\textrm{B}}\Phi_{\textrm{B}} + \sum_{\mathbf{i}} w_{\mathbf{i}}\Phi_{\mathbf{i}},\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi_{\textrm{B}}\)</span> is the value on the boundary, the <span class="math notranslate nohighlight">\(w\)</span> are weights for grid points <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>, and the sum runs over cells in the domain.</p>
<p>Note that the gradient reconstruction can end up requiring more than one ghost cell layer near the embedded boundaries.
For example, <a class="reference internal" href="#fig-stencilregion"><span class="std std-numref">Fig. 16</span></a> shows a typical stencil region which is built when using second order gradient reconstruction on the EB.
In this case the gradient reconstruction requires a stencil with a radius of 2, but as the cut-cell lies on the refinement boundary the stencil reaches into two layers of ghost cells.
For the same reason, gradient reconstruction near the cut-cells might require interpolation of corner ghost cells on refinement boundaries.</p>
<div class="figure align-center" id="id3">
<span id="fig-stencilregion"></span><a class="reference internal image-reference" href="../_images/StencilRegion.png"><img alt="../_images/StencilRegion.png" src="../_images/StencilRegion.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 16 </span><span class="caption-text">Example of the region of a second order stencil for the Laplacian operator with second order gradient reconstruction on the embedded boundary.</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</div>
</div>
<div class="section" id="robin">
<h4>Robin<a class="headerlink" href="#robin" title="Permalink to this heading"></a></h4>
<p>Robin boundary conditions are in the form</p>
<div class="math notranslate nohighlight">
\[A\partial_n\Phi + B\Phi = C,\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, and <span class="math notranslate nohighlight">\(C\)</span> are constants.
This boundary conditions is enforced through the flux</p>
<div class="math notranslate nohighlight">
\[\partial_n\Phi = \frac{1}{A}\left(C - B\Phi\right),\]</div>
<p>which requires an evaluation of <span class="math notranslate nohighlight">\(\Phi\)</span> on the domain boundaries and the EB.</p>
<p>For domain boundaries we extrapolate the cell-centered solution to the domain edge, using standard first order finite differencing.</p>
<p>On the embedded boundary, we approximate <span class="math notranslate nohighlight">\(\Phi\left(\mathbf{x}_{\text{EB}}\right)\)</span> by linearly interpolating the solution with a least squares fit, using cells which can be reached with a monotone path of radius one around the EB face (see <a class="reference internal" href="../Utilities/LeastSquares.html#chap-leastsquares"><span class="std std-ref">Least squares</span></a> for details).
The Robin boundary condition takes the form</p>
<div class="math notranslate nohighlight">
\[\partial_n\Phi = \frac{C}{A} - \frac{B}{A}\sum_{\mathbf{i}} w_{\mathbf{i}}\Phi_{\mathbf{i}}.\]</div>
<p>Currently, we include the data in the cut-cell itself in the interpolation, and thus also use unweighted least squares.</p>
</div>
</div>
<div class="section" id="ghost-cell-interpolation">
<span id="chap-multigridinterpolation"></span><h3>Ghost cell interpolation<a class="headerlink" href="#ghost-cell-interpolation" title="Permalink to this heading"></a></h3>
<p>With AMR, multigrid requires ghost cells on the refinement boundary.
The interior stencils for the Helmholtz operator have a radius of one and thus only require a single layer of ghost cells (and no corner ghost cells).
These ghost cells are filled using a finite-difference stencil, see <a class="reference internal" href="#fig-multigridinterpolation"><span class="std std-numref">Fig. 17</span></a>.</p>
<div class="figure align-center" id="id4">
<span id="fig-multigridinterpolation"></span><a class="reference internal image-reference" href="../_images/MultigridInterpolation.png"><img alt="../_images/MultigridInterpolation.png" src="../_images/MultigridInterpolation.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">Standard finite-difference stencil for ghost cell interpolation (open circle).
We first interpolate the coarse-grid cells to the centerline (diamond).
The coarse-grid interpolation is then used together with the fine-grid cells (filled circles) for interpolation to the ghost cell (open circle).</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</div>
<p>Embedded boundaries introduce many pathologies for multigrid:</p>
<ol class="arabic simple">
<li><p>Cut-cell stencils may have a large radius (see <a class="reference internal" href="#fig-stencilregion"><span class="std std-numref">Fig. 16</span></a>) and thus require more ghost cell layers.</p></li>
<li><p>The EBs cut the grid in arbitrary ways, leading to multiple pathologies regarding cell availability.</p></li>
</ol>
<p>The pathologies mean that standard finite differencing fails near the EB, mandating a more general approach.
Our way of handling ghost cell interpolation near EBs is to reconstruct the solution (to specified order) in the ghost cells, using the available cells around the ghost cell (see <a class="reference internal" href="../Utilities/LeastSquares.html#chap-leastsquares"><span class="std std-ref">Least squares</span></a> for details).
As per conventional wisdom regarding multigrid interpolation, this reconstruction does <em>not</em> use coarse-level grid cells that are covered by the fine level.</p>
<p>Figure <a class="reference internal" href="#fig-ebmultigridinterpolation"><span class="std std-numref">Fig. 18</span></a> shows a typical interpolation stencil for the stencil in <a class="reference internal" href="#fig-stencilregion"><span class="std std-numref">Fig. 16</span></a>.
Here, the open circle indicates the ghost cell to be interpolated, and we interpolate the solution in this cell using neighboring grid cells (closed circles).
For this particular case there are 10 nearby grid cells available, which is sufficient for second order interpolation (which requirse at least 6 cells in 2D).</p>
<div class="figure align-center" id="id5">
<span id="fig-ebmultigridinterpolation"></span><a class="reference internal image-reference" href="../_images/EBMultigridInterpolation.png"><img alt="../_images/EBMultigridInterpolation.png" src="../_images/EBMultigridInterpolation.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 18 </span><span class="caption-text">Multigrid interpolation for refinement boundaries away from and close to an embedded boundary.</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> implements a fairly general ghost cell interpolation scheme near the EB. The ghost cell values can be reconstructed to specified order (and with specified least squares weights).</p>
</div>
</div>
<div class="section" id="relaxation-methods">
<h3>Relaxation methods<a class="headerlink" href="#relaxation-methods" title="Permalink to this heading"></a></h3>
<p>The Helmholtz equation is solved using multigrid, with various smoothers available on each grid level.
The currently supported smoothers are:</p>
<ol class="arabic simple">
<li><p>Standard point Jacobi relaxation.</p></li>
<li><p>Red-black Gauss-Seidel relaxation in which the relaxation pattern follows that of a checkerboard.</p></li>
<li><p>Multi-colored Gauss-Seidel relaxation in which the relaxation pattern follows quadrants in 2D and octants in 3D.</p></li>
</ol>
<p>Users can select between the various smoothers in solvers that use multigrid.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Multi-colored Gauss-Seidel usually provide the best convergence rates.
However, the multi-colored kernels are twice as expensive as red-black Gauss-Seidel relaxation in 2D, and four times as expensive in 3D.</p>
</div>
</div>
</div>
<div class="section" id="multiphase-helmholtz-equation">
<h2>Multiphase Helmholtz equation<a class="headerlink" href="#multiphase-helmholtz-equation" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> also supports a <em>multiphase version</em> where data exists on both sides of the embedded boundary.
The most common case is that involving discontinuous coefficients, e.g. for</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot\left[b\left(\mathbf{x}\right)\nabla\Phi\left(\mathbf{x}\right)\right] = 0.\]</div>
<p>where <span class="math notranslate nohighlight">\(b\left(\mathbf{x}\right)\)</span> is only piecewise constant.</p>
<div class="section" id="jump-conditions">
<h3>Jump conditions<a class="headerlink" href="#jump-conditions" title="Permalink to this heading"></a></h3>
<p>For the case of discontinous coefficients there is a jump condition on the interface between two materials:</p>
<div class="math notranslate nohighlight">
\[b_1\partial_{n_1}\Phi + b_2\partial_{n_2}\Phi = \sigma,\]</div>
<p>where <span class="math notranslate nohighlight">\(b_1\)</span> and <span class="math notranslate nohighlight">\(b_2\)</span> are the Helmholtz equation coefficients on each side of the interface, and <span class="math notranslate nohighlight">\(n_1 = -n_2\)</span> are the normal vectors pointing away from the interface in each phase.
<span class="math notranslate nohighlight">\(\sigma\)</span> is a jump factor.</p>
<div class="figure align-center" id="id6">
<span id="fig-jumpcondition"></span><a class="reference internal image-reference" href="../_images/JumpCondition.png"><img alt="../_images/JumpCondition.png" src="../_images/JumpCondition.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 19 </span><span class="caption-text">Example of cells and stencils that are involved in discretizing the jump condition. Open and filled circles indicate cells in separate phases.</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</div>
</div>
<div class="section" id="discretization">
<h3>Discretization<a class="headerlink" href="#discretization" title="Permalink to this heading"></a></h3>
<p>To incorporate the jump condition in the Helmholtz discretization, we use a gradient reconstruction to obtain a solution to <span class="math notranslate nohighlight">\(\Phi\)</span> on the boundary, and use this value to impose a Dirichlet boundary condition during multigrid relaxation.
Recalling the gradient reconstruction <span class="math notranslate nohighlight">\(\frac{\partial\Phi}{\partial n} = w_{\textrm{B}}\Phi_{\textrm{B}} + \sum_{\mathbf{i}} w_{\mathbf{i}}\Phi_{\mathbf{i}}\)</span>, the matching condition (see <a class="reference internal" href="#fig-jumpcondition"><span class="std std-numref">Fig. 19</span></a>) can be written as</p>
<div class="math notranslate nohighlight">
\[b_1\left[w_{\textrm{B},1}\Phi_{\textrm{B}} + \sum_{\mathbf{i}} w_{\mathbf{i},1}\Phi_{\mathbf{i},1}\right] + b_2\left[w_{\textrm{B},2}\Phi_{\textrm{B}} + \sum_{\mathbf{i}} w_{\mathbf{i},2}\Phi_{\mathbf{i},2}\right] = \sigma.\]</div>
<p>This equation can be solved for the boundary value <span class="math notranslate nohighlight">\(\Phi_{\textrm{B}}\)</span>, which can then be used to compute the finite-volume fluxes into the cut-cells.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For discontinuous coefficients the gradient reconstruction on one side of the EB does not reach into the other (since the solution is not differentiable across the EB).</p>
</div>
</div>
</div>
<div class="section" id="amrmultigrid">
<h2>AMRMultiGrid<a class="headerlink" href="#amrmultigrid" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">AMRMultiGrid</span></code> is the <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> implementation of the Martin-Cartwright multigrid algorithm.
It takes an “operator factory” as an argument, and the factory can generate objects (i.e., operators) that encapsulate the discretization on each AMR level.</p>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> runs its own operator, and the user can use either of:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EBHelmholtzOpFactory</span></code> for single-phase problems.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MFHelmholtzOpFactory</span></code> for multi-phase problems.</p></li>
</ol>
<p>The source code for these are located in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Source/Elliptic</span></code>.</p>
<div class="section" id="bottom-solvers">
<h3>Bottom solvers<a class="headerlink" href="#bottom-solvers" title="Permalink to this heading"></a></h3>
<p>Chombo provides (at least) three bottom solvers which can be used with <code class="docutils literal notranslate"><span class="pre">AMRMultiGrid</span></code>.</p>
<ol class="arabic simple">
<li><p>A regular smoother (e.g., point Jacobi).</p></li>
<li><p>A biconjugate gradient stabilized method (BiCGStab)</p></li>
<li><p>A generalized minimal residual method (GMRES).</p></li>
</ol>
<p>The user can select between these for the various solvers that use multigrid.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Realm.html" class="btn btn-neutral float-left" title="Realm" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="VV.html" class="btn btn-neutral float-right" title="Verification and validation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>