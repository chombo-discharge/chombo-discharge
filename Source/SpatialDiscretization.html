<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spatial discretization &mdash; chombo-discharge  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Chombo-3 basics" href="ChomboBasics.html" />
    <link rel="prev" title="GeoCoarsener" href="GeoCoarsener.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            chombo-discharge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Testing.html">Code testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Acknowledgements.html">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="DesignOverview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="CellTagger.html">CellTagger</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeoCoarsener.html">GeoCoarsener</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Spatial discretization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cartesian-amr">Cartesian AMR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedded-boundaries">Embedded boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#geometry-representation">Geometry representation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constructive-solid-geometry-csg">Constructive solid geometry (CSG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ebgeometry">EBGeometry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#geometry-generation">Geometry generation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chombo-approach"><code class="docutils literal notranslate"><span class="pre">Chombo</span></code> approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#chombo-discharge-pruning"><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> pruning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mesh-generation">Mesh generation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#berger-rigoutsos-algorithm">Berger-Rigoutsos algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tiled-mesh-refinement">Tiled mesh refinement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cell-refinement-philosophy">Cell refinement philosophy</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshData.html">Mesh data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regridding.html">Regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers.html">Linear solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="VV.html">Verification and validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/CDR.html">Convection-Diffusion-Reaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Electrostatics.html">Electrostatic solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/KineticMonteCarlo.html">Kinetic Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/MeshODESolver.html">Mesh ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/SurfaceODESolver.html">Surface ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/TracerParticles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Ito.html">Îto diffusion</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multi-physics applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/StreamerInceptionModel.html">Streamer inception model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ItoKMC.html">Îto-KMC plasma model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Single-solver applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection-diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/MeshODEModel.html">Mesh ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/TracerParticleModel.html">Tracer particle model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">Lookup tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Spatial discretization</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Source/SpatialDiscretization.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="spatial-discretization">
<span id="chap-spatialdiscretization"></span><h1>Spatial discretization<a class="headerlink" href="#spatial-discretization" title="Permalink to this heading"></a></h1>
<section id="cartesian-amr">
<h2>Cartesian AMR<a class="headerlink" href="#cartesian-amr" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> uses patch-based structured adaptive mesh refinement (AMR) provided by <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> <span id="id1">[<a class="reference internal" href="../ZZReferences.html#id82" title="P Colella, D T Graves, T J Ligocki, G Miller, D Modiano, P O Schwartz, B Van Straalen, J Pilliod, D Trebotich, M Barad, B Keen, A Nonaka, and C Shen. EBChombo software package for cartesian grid, embedded boundary applications. Technical Report, Lawrence Berkeley National Laboratory, 2004.">Colella <em>et al.</em>, 2004</a>]</span>.
In patch-based AMR the domain is subdivided into a collection of hierarchically nested grid levels, see <a class="reference internal" href="#fig-patchbasedamr"><span class="std std-numref">Fig. 2</span></a>.
With Cartesian AMR each patch is a Cartesian block of grid cells.
A <em>grid level</em> is composed of a union of grid patches sharing the same grid resolution, with the additional requirement that the patches on a grid level are <em>non-overlapping</em>.
With AMR, such levels can be hierarchically nested; finer grid levels exist on top of coarser ones.
In patch-based AMR there are only a few fundamental requirements on how such grids are constructed.
For example, a refined grid level must exist completely within the bounds of it’s parent level.
In other words, grid levels <span class="math notranslate nohighlight">\(l-1\)</span> and <span class="math notranslate nohighlight">\(l+1\)</span> are spatially separated by a non-zero number of grid cells on level <span class="math notranslate nohighlight">\(l\)</span>.</p>
<figure class="align-center" id="id6">
<span id="fig-patchbasedamr"></span><a class="reference internal image-reference" href="../_images/PatchBasedAMR.png"><img alt="../_images/PatchBasedAMR.png" src="../_images/PatchBasedAMR.png" style="width: 60%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Cartesian patch-based refinement showing two grid levels.
The fine-grid level lives on top of the coarse level, and consists of two patches (red and blue colors) with two layers of ghost cells (dashed lines and orange shaded region).</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The resolution on level <span class="math notranslate nohighlight">\(l+1\)</span> is typically finer than the resolution on level <span class="math notranslate nohighlight">\(l\)</span> by an integer (usually power of two).
However,</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> only supports refinement factors of 2 and 4.</p>
</div>
</section>
<section id="embedded-boundaries">
<h2>Embedded boundaries<a class="headerlink" href="#embedded-boundaries" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharges</span></code> uses an embedded boundary (EB) formulation for describing complex geometries.
With EBs, the Cartesian grid is directly intersected by the geometry.
This is fundamentally different from unstructured grid where one generates a volume mesh that conforms to the surface mesh of the input geometry.
Since EBs are directly intersected by the geometry, there is no fundamental need for a surface mesh for describing the geometry.
Moreover, Cartesian EBs have a data layout which remains (almost) fully structured.
The connectivity of neighboring grid cells is still trivially found by fundamental strides along the data rows/columns, which allows extending the efficiency of patch-based AMR to complex geometries.
Figure <a class="reference internal" href="#fig-complexpatches"><span class="std std-numref">Fig. 3</span></a> shows an example of patch-based grid refinement for a complex surface.</p>
<figure class="align-center" id="id7">
<span id="fig-complexpatches"></span><a class="reference internal image-reference" href="../_images/ComplexPatches.png"><img alt="../_images/ComplexPatches.png" src="../_images/ComplexPatches.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Patch-based refinement (factor 4 between levels) of a complex surface. Each color shows a patch, which is a rectangular computational unit.</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Since EBs are directly intersected by the geometry, pathological cases can arise where a Cartesian grid cell consists of multiple volumes.
One can easily envision this case by intersecting a thin body with a Cartesian grid, as shown in <a class="reference internal" href="#fig-multicells"><span class="std std-numref">Fig. 4</span></a>.
This figure shows a thin body which is intersected by a Cartesian grid, and this grid is then coarsened.
At the coarsened level, one of the grid cells has two cell fragments on opposite sides of the body.
Such multi-valued cells (a.k.a <em>multi-cells</em>) are fundamentally important for EB applications.
Note that there is no fundamental difference between single-cut and multi-cut grid cells.
This distinction exists primarily due to the fact that if all grid cells were single-cut cells the entire EB data structure would fit in a Cartesian grid block (say, of <span class="math notranslate nohighlight">\(N_x \times N_y \times N_z\)</span> grid cells).
Because of multi-cells, EB data structures are not purely Cartesian.
Data structures need to live on more complex graphs that describe support multi-cells and, furthermore, describe the cell connectivity.
Without multi-cells it would be impossible to describe most complex geometries.
It would also be extremely difficult to obtain performant geometric multigrid methods (which rely on this type of coarsening).</p>
<figure class="align-center" id="id8">
<span id="fig-multicells"></span><a class="reference internal image-reference" href="../_images/MultiCells.png"><img alt="../_images/MultiCells.png" src="../_images/MultiCells.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Example of how multi-valued cells occur during grid coarsening.
Left: Original grid.
Right: Coarsened grid.</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="geometry-representation">
<span id="chap-geometryrepresentation"></span><h2>Geometry representation<a class="headerlink" href="#geometry-representation" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> uses (approximations to) signed distance functions (SDFs) for describing geometries.
Signed distance fields are functions <span class="math notranslate nohighlight">\(f: \mathbb{R}^3\rightarrow \mathbb{R}\)</span> that describe the distance from the object.
These functions are also <em>implicit functions</em>, i.e. <span class="math notranslate nohighlight">\(f\left(\mathbf{x}\right)=0\)</span> describes the surface of the object, <span class="math notranslate nohighlight">\(f\left(\mathbf{x}\right) &gt; 0\)</span> decribes a point inside the object and <span class="math notranslate nohighlight">\(f\left(\mathbf{x}\right) &lt; 0\)</span> describes a point outside the object.</p>
<p>Many EB applications only use the implicit function formulation, but <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> requires (an approximation to) the signed distance field.
There are two reasons for this:</p>
<ol class="arabic simple">
<li><p>The SDF can be used for robustly load balancing the geometry generation with orders of magnitude speedup over naive approaches.</p></li>
<li><p>The SDF is useful for resolving particle collisions with boundaries, using e.g. simple ray tracing of particle paths.</p></li>
</ol>
<p>To illustrate the difference between an SDF and an implicit function, consider the implicit functions for a sphere at the origin with radius <span class="math notranslate nohighlight">\(R\)</span>:</p>
<div class="math notranslate nohighlight">
\begin{align}
d_1\left(\mathbf{x}\right) &amp;= R - \left|\mathbf{x}\right|, \\
d_2\left(\mathbf{x}\right) &amp;= R^2 - \mathbf{x}\cdot\mathbf{x}.
\end{align}</div><p>Here, only <span class="math notranslate nohighlight">\(d_1\left(\mathbf{x}\right)\)</span> is a signed distance function.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>, SDFs can be generated through analytic expressions, constructive solid geometry, or by supplying polygon tesselation.
NURBS geometries are, unfortunately, not supported.
Fundamentally, all geometric objects are described using <code class="docutils literal notranslate"><span class="pre">BaseIF</span></code> objects from <code class="docutils literal notranslate"><span class="pre">Chombo</span></code>, see <a class="reference internal" href="ChomboBasics.html#chap-baseif"><span class="std std-ref">BaseIF</span></a>.</p>
<section id="constructive-solid-geometry-csg">
<h3>Constructive solid geometry (CSG)<a class="headerlink" href="#constructive-solid-geometry-csg" title="Permalink to this heading"></a></h3>
<p>Constructive solid geometry can be used to generate complex shapes from geometric primitives.
For example, to describe the union between two SDFs <span class="math notranslate nohighlight">\(d_1\left(\mathbf{x}\right)\)</span> and <span class="math notranslate nohighlight">\(d_2\left(\mathbf{x}\right)\)</span>:</p>
<div class="math notranslate nohighlight">
\[d\left(\mathbf{x}\right) = \textrm{min}\left(d_1\left(\mathbf{x}\right), d_2\left(\mathbf{x}\right)\right)\]</div>
<p>Note that the resulting is an implicit function but is <em>not</em> an SDF.
However, the union typically approximates the signed distance field quite well near the surface.
<code class="docutils literal notranslate"><span class="pre">Chombo</span></code> natively supports many ways of performing CSG.</p>
</section>
<section id="ebgeometry">
<span id="chap-ebgeometry"></span><h3>EBGeometry<a class="headerlink" href="#ebgeometry" title="Permalink to this heading"></a></h3>
<p>While functions like <span class="math notranslate nohighlight">\(R - \left|\mathbf{x}\right|\)</span> are quick to compute, a polygon surface may consist of hundreds of thousands of primitives (e.g., triangles).
Generating signed distance function from polygon tesselations is quite involved as it requires computing the signed distance to the closest feature, which can be a planar polygon (e.g., a triangle), edge, or a vertex.
<code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> supports such functions through the <a class="reference external" href="https://github.com/rmrsk/EBGeometry">EBGeometry</a> package.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The signed distance function for a polygon surface is only well-defined if it is manifold-2, i.e. it is watertight and does not self-intersect.
<code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> should nonetheless compute the distance field as best as it can, but the final result may not make sense in an EB context.</p>
</div>
<p>Searching through all features (faces, edge, vertices) is unacceptably slow, and <code class="docutils literal notranslate"><span class="pre">EBGeometry</span></code> therefore uses a bounding volume hierarchy for accelerating these searches.
The bounding volume hierarchy is top-down constructed, using a root bounding volume (typically a cube) that encloses all triangles.
Using heuristics, the root bounding volume is then subdivided into two separate bounding volumes that contain roughly half of the primitives each.
The process is then recursed downwards until specified recursion criteria are met.
Additional details are provided in the <a class="reference external" href="https://rmrsk.github.io/EBGeometry/">EBGeometry documentation</a>.</p>
<figure class="align-center" id="id9">
<a class="reference internal image-reference" href="../_images/Armadillo.png"><img alt="../_images/Armadillo.png" src="../_images/Armadillo.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5 </span><span class="caption-text">Example of an SDF reconstruction and cut-cell grid from a surface tesselation in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.</span><a class="headerlink" href="#id9" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="geometry-generation">
<span id="chap-geometrygeneration"></span><h2>Geometry generation<a class="headerlink" href="#geometry-generation" title="Permalink to this heading"></a></h2>
<section id="chombo-approach">
<h3><code class="docutils literal notranslate"><span class="pre">Chombo</span></code> approach<a class="headerlink" href="#chombo-approach" title="Permalink to this heading"></a></h3>
<p>The default geometry generation method in <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> is to locate cut-cells on the finest AMR level first and then generate the coarser levels cells through grid coarsening.
This will look through all cells on the finest level, so for a domain which is effectively <span class="math notranslate nohighlight">\(N\times N\times N\)</span> cells there are <span class="math notranslate nohighlight">\(\mathcal{O}\left(N^3\right)\)</span> implicit function queries (in 2D, the complexity is <span class="math notranslate nohighlight">\(\mathcal{O}\left(N^2\right)\)</span>).
Note that as <span class="math notranslate nohighlight">\(N\)</span> becomes large, say <span class="math notranslate nohighlight">\(N=10^5\)</span>, geometric queries of this type become a bottleneck.</p>
</section>
<section id="chombo-discharge-pruning">
<h3><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> pruning<a class="headerlink" href="#chombo-discharge-pruning" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> has made modifications to the geometry generation routines in <code class="docutils literal notranslate"><span class="pre">Chombo</span></code>, resolving a few bugs and, most importantly, using the signed distance function for load balancing the geometry generation step.
This modification to <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> yields a reduction of the original <span class="math notranslate nohighlight">\(\mathcal{O}\left(N^3\right)\)</span> scaling in <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> grid generation to an <span class="math notranslate nohighlight">\(\mathcal{O}\left(N^2\right)\)</span> scaling in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.
Typically, we find that this makes geometry generation computationally trivial (in the sense that it is very fast compared to the simulation).</p>
<p>To understand this process, note that the SDF satisfies the Eikonal equation</p>
<div class="math notranslate nohighlight">
\begin{equation}
\left|\nabla f\right| = 1,
\end{equation}</div><p>and so it is well-behaved for all <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.
The SDF can thus be used to prune large regions in space where cut-cells don’t exist.
For example, consider a Cartesian grid patch with cell size <span class="math notranslate nohighlight">\(\Delta x\)</span> and cell-centered grid points <span class="math notranslate nohighlight">\(\mathbf{x}_{\mathbf{i}} = \left(\mathbf{i} + \mathbf{\frac{1}{2}}\right)\Delta x\)</span> where <span class="math notranslate nohighlight">\(\mathbf{i} \in \mathbb{Z}^3\)</span> are grid cells in the patch, as shown in <a class="reference internal" href="#fig-pruning"><span class="std std-numref">Fig. 6</span></a>.
We know that cut cells do not exist in the grid patch if <span class="math notranslate nohighlight">\(\left|f\left(\mathbf{x}_{\mathbf{i}}\right)\right| &gt; \frac{1}{2}\Delta x\)</span> for all <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> in the patch.
One can use this to perform a quick scan of the SDF on a <em>coarse</em> grid level first, for example on <span class="math notranslate nohighlight">\(l=0\)</span>, and recurse deeper into the grid hierarchy to locate cut-cells on the other levels.
Typically, a level is decomposed into Cartesian subregions, and each subregion can be scanned independently of the other subregions (i.e. the problem is embarassingly parallel).
Subregions that can’t contain cut-cells are designated as <em>inside</em> or <em>outside</em>, depending on the sign of the SDF.
There is no point in recursively refining these to look for cut-cells at finer grid levels, owing to the nature of the SDF they can be safely pruned from subsequent scans at finer levels.
The subregions that did contain cut-cells are refined and decomposed into sub-subregions.
This procedure recurses until <span class="math notranslate nohighlight">\(l=l_{\text{max}}\)</span>, at which point we have determined all sub-regions in space where cut-cells can exist (on each AMR level), and pruned the ones that don’t.
This process is shown in <a class="reference internal" href="#fig-pruning"><span class="std std-numref">Fig. 6</span></a>.
Once all the grid patches that contain cut-cells have been found, these patches are distributed (i.e., load balanced) to the various MPI ranks for computing the discrete grid information.</p>
<figure class="align-center" id="id10">
<span id="fig-pruning"></span><a class="reference internal image-reference" href="../_images/Pruning.png"><img alt="../_images/Pruning.png" src="../_images/Pruning.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">Pruning cut-cells with the signed distance field.
Red-colored grid patches are grid patches entirely contained inside the EB.
Green-colored grid patches are entirely outside the EB, while blue-colored grid patches contain cut-cells.</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The above load balancing strategy is very simple, and it reduces the original <span class="math notranslate nohighlight">\(O(N^3)\)</span> complexity in 3D to <span class="math notranslate nohighlight">\(O(N^2)\)</span> complexity (in 2D the complexity is reduced from <span class="math notranslate nohighlight">\(O(N^2)\)</span> to <span class="math notranslate nohighlight">\(O(N)\)</span>).
The strategy works for all SDFs although, strictly speaking, an SDF is not fundamentally needed.
If a well-behaved Taylor series can be found for an implicit function, the bounds on the series can also be used to infer the location of the cut-cells, and the same algorithm can be used.
For example, generating compound objects with CSG are typically sufficiently well behaved (provided that the components are SDFs).
However, implicit functions like <span class="math notranslate nohighlight">\(d\left(\mathbf{x}\right) = R^2 - \mathbf{x}\cdot\mathbf{x}\)</span> must be used with caution.</p>
<p>When polygonal surfaces are involved the above process might lead to load imbalance if the input grids to <a class="reference internal" href="#chap-ebgeometry"><span class="std std-ref">EBGeometry</span></a> do not produce well-balanced bounding volume hierarchies (which is often the case).
In this case it might be beneficial to shuffle the cut-cell boxes among the ranks by specifying <code class="docutils literal notranslate"><span class="pre">ScanShop.box_sorting</span> <span class="pre">=</span> <span class="pre">shuffle</span></code>, which will normally lead to well-balanced cut-cell grid generation.
Other options are <code class="docutils literal notranslate"><span class="pre">ScanShop.box_sorting</span> <span class="pre">=</span> <span class="pre">morton</span></code> and <code class="docutils literal notranslate"><span class="pre">ScanShop.box_sorting</span> <span class="pre">=</span> <span class="pre">std</span></code>.
The default behavior is to use a Morton space-filling curve for organizing the cut-cell patches among the ranks.</p>
</section>
</section>
<section id="mesh-generation">
<span id="chap-meshgeneration"></span><h2>Mesh generation<a class="headerlink" href="#mesh-generation" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> supports two algorithm for AMR grid generation:</p>
<ol class="arabic simple">
<li><p>The classical Berger-Rigoutsos algorithm <span id="id3">[<a class="reference internal" href="../ZZReferences.html#id38" title="Marsha Berger and Isidore Rigoutsos. An Algorithm for Point Clustering and Grid Generation. IEEE Transactions on Systems, Man and Cybernetics, 1991. doi:10.1109/21.120081.">Berger and Rigoutsos, 1991</a>]</span>.</p></li>
<li><p>A <em>tiled</em> algorithm <span id="id4">[<a class="reference internal" href="../ZZReferences.html#id164" title="Brian T.N. Gunney and Robert W. Anderson. Advances in patch-based adaptive mesh refinement scalability. Journal of Parallel and Distributed Computing, 2016. doi:10.1016/j.jpdc.2015.11.005.">Gunney and Anderson, 2016</a>]</span>.</p></li>
</ol>
<p>Both algorithms work by taking a set of flagged cells on each grid level and generating new boxes that cover the flags.
Only <em>properly nested</em> grids are generated, in which case two grid levels <span class="math notranslate nohighlight">\(l-1\)</span> and <span class="math notranslate nohighlight">\(l+1\)</span> are separated by a non-zero number of grid cells on level <span class="math notranslate nohighlight">\(l\)</span>.
This requirement is not fundamentally required for quad- and oct-tree grids, but is nevertheless usually imposed.
For patch based AMR, the rationale for this requirement is that stencils on level <span class="math notranslate nohighlight">\(l+1\)</span> should should only reach into grid cells on levels <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(l+1\)</span>.
For example, ghost cells on level <span class="math notranslate nohighlight">\(l+1\)</span> can then be interpolated from data only on levels <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(l+1\)</span>.</p>
<section id="berger-rigoutsos-algorithm">
<h3>Berger-Rigoutsos algorithm<a class="headerlink" href="#berger-rigoutsos-algorithm" title="Permalink to this heading"></a></h3>
<p>The Berger-Rigoustous grid algorithm is implemented in <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> and is called by <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.
The classical Berger-Rigoustous algorithm is inherently serial in the sense that is collects the flagged cells onto each MPI rank and then generates the boxes, see <span id="id5">[<a class="reference internal" href="../ZZReferences.html#id38" title="Marsha Berger and Isidore Rigoutsos. An Algorithm for Point Clustering and Grid Generation. IEEE Transactions on Systems, Man and Cybernetics, 1991. doi:10.1109/21.120081.">Berger and Rigoutsos, 1991</a>]</span> for implementation details.
Typically, it is not used at large scale in 3D due to its memory consumption.</p>
<figure class="align-center" id="id11">
<span id="brmeshrefine"></span><a class="reference internal image-reference" href="../_images/BRMeshRefine.png"><img alt="../_images/BRMeshRefine.png" src="../_images/BRMeshRefine.png" style="width: 25%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">Classical cartoon of patch-based refinement. Bold lines indicate entire grid blocks.</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="tiled-mesh-refinement">
<h3>Tiled mesh refinement<a class="headerlink" href="#tiled-mesh-refinement" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> also supports a tiled algorithm where the grid boxes on each block are generated according to a predefined tiled pattern.
If a tile contains a single tag, the entire tile is flagged for refinement.
The tiled algorithm produces grids that are visually similar to octrees, but is slightly more general since it also supports refinement factors other than 2 and is not restricted to domain extensions that are an integer factor of 2 (e.g. <span class="math notranslate nohighlight">\(2^{10}\)</span> cells in each direction).
Moreover, the algorithm is extremely fast and has low memory consumption even at large scales.</p>
<figure class="align-center" id="id12">
<span id="tiledmeshrefine"></span><a class="reference internal image-reference" href="../_images/TiledMeshRefine.png"><img alt="../_images/TiledMeshRefine.png" src="../_images/TiledMeshRefine.png" style="width: 25%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8 </span><span class="caption-text">Classical cartoon of tiled patch-based refinement. Bold lines indicate entire grid blocks.</span><a class="headerlink" href="#id12" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="cell-refinement-philosophy">
<span id="chap-refinementphilosophy"></span><h2>Cell refinement philosophy<a class="headerlink" href="#cell-refinement-philosophy" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> can flag cells for refinement using various methods:</p>
<ol class="arabic simple">
<li><p>Refine all embedded boundaries down to a specified refinement level.</p></li>
<li><p>Refine embedded boundaries based on estimations of the surface curvature in the cut-cells.</p></li>
<li><p>Manually add refinement flags (by specifying boxes where cells will be refined).</p></li>
<li><p>Physics-based or data-based refinement where the user fetches data from solver classes (e.g., discretization errors, the electric field) and uses that for refinement.</p></li>
</ol>
<p>The first two cases are covered by the <code class="docutils literal notranslate"><span class="pre">Driver</span></code> class in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> (see <a class="reference internal" href="Driver.html#chap-driver"><span class="std std-ref">Driver</span></a>).
In the first case the <code class="docutils literal notranslate"><span class="pre">Driver</span></code> class will simply fetch arguments from an input script which specifies the refinement depth for the embedded boundaries.
In the second case, the <code class="docutils literal notranslate"><span class="pre">Driver</span></code> class will visit every cut-cell and check if the normal vectors in neighboring cut-cell deviate by more than a specified threshold angle.
Given two normal vectors <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{n}^\prime\)</span>, the cell is refined if</p>
<div class="math notranslate nohighlight">
\[\mathbf{n}\cdot\mathbf{n}^\prime \geq \cos\theta_c,\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta_c\)</span> is a threshold angle for grid refinent.</p>
<p>The other two cases are more complicated, and are covered by the <a class="reference internal" href="GeoCoarsener.html#chap-geocoarsener"><span class="std std-ref">GeoCoarsener</span></a> and <a class="reference internal" href="CellTagger.html#chap-celltagger"><span class="std std-ref">CellTagger</span></a> classes.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="GeoCoarsener.html" class="btn btn-neutral float-left" title="GeoCoarsener" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ChomboBasics.html" class="btn btn-neutral float-right" title="Chombo-3 basics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>