<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spatial discretization &mdash; chombo-discharge latest documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Chombo-3 basics" href="ChomboBasics.html" />
    <link rel="prev" title="Controlling chombo-discharge" href="../Base/Control.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> chombo-discharge
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Documentation.html">Using this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html"><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/GettingStarted.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Spatial discretization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cartesian-amr">Cartesian AMR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedded-boundaries">Embedded boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#geometry-representation">Geometry representation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constructive-solid-geometry-csg">Constructive solid geometry (CSG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polygon-surfaces">Polygon surfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#geometry-generation">Geometry generation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chombo-approach"><code class="docutils literal notranslate"><span class="pre">Chombo</span></code> approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#chombo-discharge-pruning"><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> pruning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mesh-generation">Mesh generation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#berger-rigoutsos-algorithm">Berger-Rigoutsos algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tiled-mesh-refinement">Tiled mesh refinement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cell-refinement-philosophy">Cell refinement philosophy</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshData.html">Mesh data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers.html">Linear solvers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="CellTagger.html">CellTagger</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeoCoarsener.html">GeoCoarsener</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/CDR.html">Convection-Diffusion-Reaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Electrostatics.html">Electrostatics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Sigma.html">Surface charge solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Ito.html">Îto diffusion</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ImplementedModels.html">Implemented models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#creating-a-geometry">Creating a geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#setting-up-a-timestepper">Setting up a <code class="docutils literal notranslate"><span class="pre">TimeStepper</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">Lookup tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/ComplexGeometries.html">Complex geometries</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Spatial discretization</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Source/SpatialDiscretization.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="spatial-discretization">
<span id="chap-spatialdiscretization"></span><h1>Spatial discretization<a class="headerlink" href="#spatial-discretization" title="Permalink to this headline"></a></h1>
<div class="section" id="cartesian-amr">
<h2>Cartesian AMR<a class="headerlink" href="#cartesian-amr" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> uses patch-based structured adaptive mesh refinement (AMR) provided by <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> <span id="id1">[<a class="reference internal" href="../ZZReferences.html#id82" title="P Colella, D T Graves, T J Ligocki, G Miller, D Modiano, P O Schwartz, B Van Straalen, J Pilliod, D Trebotich, M Barad, B Keen, A Nonaka, and C Shen. EBChombo software package for cartesian grid, embedded boundary applications. Technical Report, Lawrence Berkeley National Laboratory, 2004.">4</a>]</span>.
In patch-based AMR the domain is subdivided into a collection of hierarchically nested grid levels.
With Cartesian AMR each patch is a Cartesian block of grid cells.
A <em>grid level</em> is composed of a union of grid patches sharing the same grid resolution, with the additional requirement that the patches on a grid level are <em>non-overlapping</em>.
With AMR, such levels can be hierarchically nested; finer grid levels exist on top of coarser ones.
In patch-based AMR there are only a few fundamental requirements on how such grids are constructed.
For example, a refined grid level must exist completely within the bounds of it’s parent level.
In other words, grid levels <span class="math notranslate nohighlight">\(l-1\)</span> and <span class="math notranslate nohighlight">\(l+1\)</span> are spatially separated by a non-zero number of grid cells on level <span class="math notranslate nohighlight">\(l\)</span>.</p>
<p>The resolution on level <span class="math notranslate nohighlight">\(l+1\)</span> is typically finer than the resolution on level <span class="math notranslate nohighlight">\(l\)</span> by an integer (usually power of two).
However,</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> only supports refinement factors of 2 and 4.</p>
</div>
</div>
<div class="section" id="embedded-boundaries">
<h2>Embedded boundaries<a class="headerlink" href="#embedded-boundaries" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharges</span></code> uses an embedded boundary (EB) formulation for describing complex geometries.
With EBs, the Cartesian grid is directly intersected by the geometry.
This is fundamentally different from unstructured grid where one generates a volume mesh that conforms to the surface mesh of the input geometry.
Since EBs are directly intersected by the geometry, there is no fundamental need for a surface mesh for describing the geometry.
Moreover, Cartesian EBs have a data layout which remains (almost) fully structured.
The connectivity of neighboring grid cells is still trivially found by fundamental strides along the data rows/columns, which allows extending the efficiency of patch-based AMR to complex geometries.
Figure <a class="reference internal" href="#fig-complexpatches"><span class="std std-numref">Fig. 2</span></a> shows an example of patch-based grid refinement for a complex surface.</p>
<div class="figure align-center" id="id2">
<span id="fig-complexpatches"></span><a class="reference internal image-reference" href="../_images/ComplexPatches.png"><img alt="../_images/ComplexPatches.png" src="../_images/ComplexPatches.png" style="width: 360px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Patch-based refinement (factor 4 between levels) of a complex surface. Each color shows a patch, which is a rectangular computational unit.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</div>
<p>Since EBs are directly intersected by the geometry, pathological cases can arise where a Cartesian grid cell consists of multiple volumes.
One can easily envision this case by intersecting a thin body with a Cartesian grid, as shown in <a class="reference internal" href="#fig-multicells"><span class="std std-numref">Fig. 3</span></a>.
This figure shows a thin body which is intersected by a Cartesian grid, and this grid is then coarsened.
At the coarsened level, one of the grid cells has two cell fragments on opposite sides of the body.
Such multi-valued cells (a.k.a <em>multi-cells</em>) are fundamentally important for EB applications.
Note that there is no fundamental difference between single-cut and multi-cut grid cells.
This distinction exists primarily due to the fact that if all grid cells were single-cut cells the entire EB data structure would fit in a Cartesian grid block (say, of <span class="math notranslate nohighlight">\(N_x \times N_y \times N_z\)</span> grid cells).
Because of multi-cells, EB data structures are not purely Cartesian.
Data structures need to live on more complex graphs that describe support multi-cells and, furthermore, describe the cell connectivity.
Without multi-cells it would be impossible to describe most complex geometries.
It would also be extremely difficult to obtain performant geometric multigrid methods (which rely on this type of coarsening).</p>
<div class="figure align-center" id="id3">
<span id="fig-multicells"></span><a class="reference internal image-reference" href="../_images/MultiCells.png"><img alt="../_images/MultiCells.png" src="../_images/MultiCells.png" style="width: 360px;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Example of how multi-valued cells occur during grid coarsening.
Left: Original grid.
Right: Coarsened grid.</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</div>
</div>
<div class="section" id="geometry-representation">
<span id="chap-geometryrepresentation"></span><h2>Geometry representation<a class="headerlink" href="#geometry-representation" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> uses (approximations to) signed distance functions (SDFs) for describing geometries.
Signed distance fields are functions <span class="math notranslate nohighlight">\(f: \mathbb{R}^3\rightarrow \mathbb{R}\)</span> that describe the distance from the object.
These functions are also <em>implicit functions</em>, i.e. <span class="math notranslate nohighlight">\(f\left(\mathbf{x}\right)=0\)</span> describes the surface of the object, <span class="math notranslate nohighlight">\(f\left(\mathbf{x}\right) &gt; 0\)</span> decribes a point inside the object and <span class="math notranslate nohighlight">\(f\left(\mathbf{x}\right) &lt; 0\)</span> describes a point outside the object.</p>
<p>Many EB applications only use the implicit function formulation, but <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> requires (an approximation to) the signed distance field.
There are two reasons for this:</p>
<ol class="arabic simple">
<li><p>The SDF can be used for robustly load balancing the geometry generation with orders of magnitude speedup over naive approaches.</p></li>
<li><p>The SDF is useful for resolving particle collisions with boundaries, using e.g. simple ray tracing of particle paths.</p></li>
</ol>
<p>To illustrate the difference between an SDF and an implicit function, consider the implicit functions for a sphere at the origin with radius <span class="math notranslate nohighlight">\(R\)</span>:</p>
<div class="math notranslate nohighlight">
\begin{align}
d_1\left(\mathbf{x}\right) &amp;= R - \left|\mathbf{x}\right|, \\
d_2\left(\mathbf{x}\right) &amp;= R^2 - \mathbf{x}\cdot\mathbf{x}.
\end{align}</div><p>Here, only <span class="math notranslate nohighlight">\(d_1\left(\mathbf{x}\right)\)</span> is a signed distance function.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>, SDFs can be generated through analytic expressions, constructive solid geometry, or by supplying polygon tesselation.
NURBS geometries are, unfortunately, not supported.
Fundamentally, all geometric objects are described using <code class="docutils literal notranslate"><span class="pre">BaseIF</span></code> objects from <code class="docutils literal notranslate"><span class="pre">Chombo</span></code>, see <a class="reference internal" href="ChomboBasics.html#chap-baseif"><span class="std std-ref">BaseIF</span></a>.
Support for polygon surfaces differ from analytic functions only in how we implement the <code class="docutils literal notranslate"><span class="pre">BaseIF::value</span></code> function (see <a class="reference internal" href="ChomboBasics.html#chap-baseif"><span class="std std-ref">BaseIF</span></a>).</p>
<div class="section" id="constructive-solid-geometry-csg">
<h3>Constructive solid geometry (CSG)<a class="headerlink" href="#constructive-solid-geometry-csg" title="Permalink to this headline"></a></h3>
<p>Constructive solid geometry can be used to generate complex shapes from geometric primitives.
For example, to describe the union between two SDFs <span class="math notranslate nohighlight">\(d_1\left(\mathbf{x}\right)\)</span> and <span class="math notranslate nohighlight">\(d_2\left(\mathbf{x}\right)\)</span>:</p>
<div class="math notranslate nohighlight">
\[d\left(\mathbf{x}\right) = \textrm{min}\left(d_1\left(\mathbf{x}\right), d_2\left(\mathbf{x}\right)\right)\]</div>
<p>Note that the resulting is an implicit function but is <em>not</em> an SDF.
However, the union typically approximates the signed distance field quite well near the surface.
<code class="docutils literal notranslate"><span class="pre">Chombo</span></code> natively supports many ways of performing CSG.</p>
</div>
<div class="section" id="polygon-surfaces">
<h3>Polygon surfaces<a class="headerlink" href="#polygon-surfaces" title="Permalink to this headline"></a></h3>
<p>While functions like <span class="math notranslate nohighlight">\(R - \left|\mathbf{x}\right|\)</span> are quick to compute, a polygon surface may consist of hundreds of thousands of primitives (e.g., triangles).
Generating signed distance function from polygon tesselations is quite involved as it requires computing the signed distance to the closest feature, which can be a planar polygon (e.g., a triangle), edge, or a vertex.
<code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> supports such functions.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The signed distance function for a polygon surface is only well-defined if it is manifold-2, i.e. it is watertight and does not self-intersect.
<code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> should nonetheless compute the distance field as best as it can, but the final result may not make sense in an EB context.</p>
</div>
<p>Searching through all features (faces, edge, vertices) is unacceptably slow, and <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> therefore uses a bounding volume hierarchy for accelerating these searches.
The bounding volume hierarchy is top-down constructed, using a root bounding volume (typically a cube) that encloses all triangles.
Using heuristics, the root bounding volume is then subdivided into two separate bounding volumes that contain roughly half of the primitives each.
The process is then recursed downwards until specified recursion criteria are met.
Additional details are provided in <a class="reference internal" href="../Utilities/ComplexGeometries.html#chap-complexgeometries"><span class="std std-ref">Complex geometries</span></a>.</p>
<p>Some options are available for tuning this process:</p>
<ul class="simple">
<li><p>The user can choose between Cartesian bounding volumes or bounding spheres.</p></li>
<li><p>The implementation uses polymorphic lambdas for subdividing primitives into new bounding volumes.
Users are free to construct new types of bounding volumes (e.g., object-oriented boxes).</p></li>
<li><p>The implementation uses the same type of polymorphic functions for supplying stopping criteria (e.g., terminating at a certain depth).</p></li>
</ul>
<p>Users can choose to use the default implementations for both sub-division and stopping.
For example, three default partitioning functions are supported.
One can sub-divide primitives into two sub-volumes based on their centroids, or such that the volume between the two halves are minimized.</p>
<div class="figure align-center" id="id4">
<a class="reference internal image-reference" href="../_images/Armadillo.png"><img alt="../_images/Armadillo.png" src="../_images/Armadillo.png" style="width: 360px;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Example of an SDF reconstruction and cut-cell grid from a surface tesselation in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The polygon functionality is currently limited to PLY files.
Contributions that provide plugins to other file formats are encouraged.</p>
</div>
</div>
</div>
<div class="section" id="geometry-generation">
<span id="chap-geometrygeneration"></span><h2>Geometry generation<a class="headerlink" href="#geometry-generation" title="Permalink to this headline"></a></h2>
<div class="section" id="chombo-approach">
<h3><code class="docutils literal notranslate"><span class="pre">Chombo</span></code> approach<a class="headerlink" href="#chombo-approach" title="Permalink to this headline"></a></h3>
<p>The default geometry generation method in <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> is to locate cut-cells on the finest AMR level first.
This scan looks through all cells on that level, so for a domain which is effectively <span class="math notranslate nohighlight">\(N\times N\times N\)</span> cells there are at least <span class="math notranslate nohighlight">\(N^3\)</span> implicit function queries (in 2D, the complexity is <span class="math notranslate nohighlight">\(N^2\)</span>).
Note that as <span class="math notranslate nohighlight">\(N\)</span> becomes large, say <span class="math notranslate nohighlight">\(N=10^5\)</span>, geometric queries of this type become a bottleneck.
For example, even if the SDF evaluation for an arbitrary point <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> only took <span class="math notranslate nohighlight">\(10^{-7}\)</span> seconds to evaluate, and the application was parallelized over 10,000 cores, it would take at least twenty hours to figure out where the cut-cells are located.</p>
</div>
<div class="section" id="chombo-discharge-pruning">
<h3><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> pruning<a class="headerlink" href="#chombo-discharge-pruning" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> has made modifications to the geometry generation routines in <code class="docutils literal notranslate"><span class="pre">Chombo</span></code>, resolving a few bugs and, most importantly, using the signed distance function for load balancing the geometry generation step.
This modification to <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> is motivated by the reduction of the <span class="math notranslate nohighlight">\(N^3\)</span> scaling in the native <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> grid generation to an <span class="math notranslate nohighlight">\(N^2\)</span> scaling in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.
Typically, we find that this makes geometry generation computationally trivial (in the sense that it becomes extremely fast).</p>
<p>The SDF satisfies the Eikonal equation</p>
<div class="math notranslate nohighlight">
\begin{equation}
\left|\nabla f\right| = 1,
\end{equation}</div><p>and so it is well-behaved for all <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>, and can be used to prune large regions in space where cut-cells don’t exist.
For example, consider a Cartesian grid patch with cell size <span class="math notranslate nohighlight">\(\Delta x\)</span> and cell-centered grid points <span class="math notranslate nohighlight">\(\mathbf{x}_{\mathbf{i}} = \left(\mathbf{i} + \mathbf{\frac{1}{2}}\right)\Delta x\)</span> where <span class="math notranslate nohighlight">\(\mathbf{i} \in \mathbb{Z}^3\)</span> are grid cells in the patch, like that shown in <a class="reference internal" href="#fig-pruning"><span class="std std-numref">Fig. 5</span></a>.
We know that cut cells do not exist in the grid patch if <span class="math notranslate nohighlight">\(\left|f\left(\mathbf{x}_{\mathbf{i}}\right)\right| &gt; \frac{1}{2}\Delta x\)</span> for all <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> in the patch.
One can use this to perform a quick scan of the SDF on a <em>coarse</em> grid level first, for example on <span class="math notranslate nohighlight">\(l=0\)</span>, and recurse deeper into the grid hierarchy to locate cut-cells on the other levels.
Typically, a level is decomposed into Cartesian subregions, and each subregion can be scanned independently of the other subregions (i.e. the problem is embarassingly parallel).
Subregions that can’t contain cut-cells are designated as <em>inside</em> or <em>outside</em>, depending on the sign of the SDF.
There is no point in recursively refining these to look for cut-cells at finer grid levels, owing to the nature of the SDF they can be safely pruned from subsequent scans at finer levels.
The subregions that did contain cut-cells are refined and decomposed into sub-subregions.
This procedure recurses until <span class="math notranslate nohighlight">\(l=l_{\text{max}}\)</span>, at which point we have determined all sub-regions in space where cut-cells can exist (on each AMR level), and pruned the ones that don’t.
This process is shown in <a class="reference internal" href="#fig-pruning"><span class="std std-numref">Fig. 5</span></a>.
Once all the grid patches that contain cut-cells have been found, these patches can be distributed (i.e. load balanced) to the various MPI ranks or threads for computing the discrete information.</p>
<div class="figure align-center" id="id5">
<span id="fig-pruning"></span><a class="reference internal image-reference" href="../_images/Pruning.png"><img alt="../_images/Pruning.png" src="../_images/Pruning.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Pruning cut-cells with the signed distance field.
Red-colored grid patches are grid patches entirely contained inside the EB.
Green-colored grid patches are entirely outside the EB, while blue-colored grid patches contain cut-cells.</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</div>
<p>The above load balancing strategy is very simple, and it reduces the original <span class="math notranslate nohighlight">\(O(N^3)\)</span> complexity in 3D to <span class="math notranslate nohighlight">\(O(N^2)\)</span> complexity (in 2D the complexity is reduced from <span class="math notranslate nohighlight">\(O(N^2)\)</span> to <span class="math notranslate nohighlight">\(O(N)\)</span>).
The strategy works for all SDFs although, strictly speaking, an SDF is not fundamentally needed.
If a well-behaved Taylor series can be found for an implicit function, the bounds on the series can also be used to infer the location of the cut-cells, and the same algorithm can be used.
For example, generating compound objects with CSG are typically sufficiently well behaved (provided that the components are SDFs).
However, implicit functions like <span class="math notranslate nohighlight">\(d\left(\mathbf{x}\right) = R^2 - \mathbf{x}\cdot\mathbf{x}\)</span> must be used with caution.</p>
</div>
</div>
<div class="section" id="mesh-generation">
<span id="chap-meshgeneration"></span><h2>Mesh generation<a class="headerlink" href="#mesh-generation" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> offers two algorithm for AMR grid generation, the classical Berger-Rigoutsos algorithm and a <em>tiled</em> algorithm.
Both algorithms work by taking a set of flagged cells on each grid level and generating new boxes that cover the flags.</p>
<div class="section" id="berger-rigoutsos-algorithm">
<h3>Berger-Rigoutsos algorithm<a class="headerlink" href="#berger-rigoutsos-algorithm" title="Permalink to this headline"></a></h3>
<p>The Berger-Rigoustous grid algorithm is implemented in <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> and is called by <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.
The classical Berger-Rigoustous algorithm is inherently serial in the sense that is collects the flagged cells onto each MPI rank and then generates the boxes.
Typically, it is not used at large scale in 3D due to its memory consumption.</p>
<div class="figure align-center" id="id6">
<span id="brmeshrefine"></span><a class="reference internal image-reference" href="../_images/BRMeshRefine.png"><img alt="../_images/BRMeshRefine.png" src="../_images/BRMeshRefine.png" style="width: 240px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Classical cartoon of patch-based refinement. Bold lines indicate entire grid blocks.</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</div>
</div>
<div class="section" id="tiled-mesh-refinement">
<h3>Tiled mesh refinement<a class="headerlink" href="#tiled-mesh-refinement" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> also supports a tiled algorithm where the grid boxes on each block are generated according to a predefined tiled pattern.
If a tile contains a single tag, the entire tile is flagged for refinement.
The tiled algorithm produces grids that are visually similar to octrees, but is more general since it also supports refinement factors other than 2 and is not restricted to domain extensions that are an integer factor of 2 (e.g. <span class="math notranslate nohighlight">\(2^{10}\)</span> cells in each direction).
Moreover, the algorithm is extremely fast and has low memory consumption even at large scales.</p>
<div class="figure align-center" id="id7">
<span id="tiledmeshrefine"></span><a class="reference internal image-reference" href="../_images/TiledMeshRefine.png"><img alt="../_images/TiledMeshRefine.png" src="../_images/TiledMeshRefine.png" style="width: 240px;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Classical cartoon of tiled patch-based refinement. Bold lines indicate entire grid blocks.</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</div>
</div>
</div>
<div class="section" id="cell-refinement-philosophy">
<span id="chap-refinementphilosophy"></span><h2>Cell refinement philosophy<a class="headerlink" href="#cell-refinement-philosophy" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> can flag cells for refinement using various methods:</p>
<ol class="arabic simple">
<li><p>Refine all embedded boundaries down to a specified refinement level.</p></li>
<li><p>Refine embedded boundaries based on estimations of the surface curvature in the cut-cells.</p></li>
<li><p>Manually add refinement flags (by specifying boxes where cells will be refined).</p></li>
<li><p>Physics-based or data-based refinement where the user fetches data from solver classes (e.g., discretization errors, the electric field) and uses that for refinement.</p></li>
</ol>
<p>The first two cases are covered by the <code class="docutils literal notranslate"><span class="pre">Driver</span></code> class in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> (see <a class="reference internal" href="Driver.html#chap-driver"><span class="std std-ref">Driver</span></a>).
In the first case the <code class="docutils literal notranslate"><span class="pre">Driver</span></code> class will simply fetch arguments from an input script which specifies the refinement depth for the embedded boundaries.
In the second case, the <code class="docutils literal notranslate"><span class="pre">Driver</span></code> class will visit every cut-cell and check if the normal vectors in neighboring cut-cell deviate by more than a specified threshold angle.
Given two normal vectors <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{n}^\prime\)</span>, the cell is refined if</p>
<div class="math notranslate nohighlight">
\[\mathbf{n}\cdot\mathbf{n}^\prime \geq \cos\theta_c,\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta_c\)</span> is a threshold angle for grid refinent.</p>
<p>The other two cases are more complicated, and are covered by the <a class="reference internal" href="GeoCoarsener.html#chap-geocoarsener"><span class="std std-ref">GeoCoarsener</span></a> and <a class="reference internal" href="CellTagger.html#chap-celltagger"><span class="std std-ref">CellTagger</span></a> classes.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../Base/Control.html" class="btn btn-neutral float-left" title="Controlling chombo-discharge" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ChomboBasics.html" class="btn btn-neutral float-right" title="Chombo-3 basics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>