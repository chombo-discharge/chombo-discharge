<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Particles &mdash; chombo-discharge  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
      <link rel="stylesheet" type="text/css" href="../_static/my_theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Realm" href="Realm.html" />
    <link rel="prev" title="Mesh data" href="MeshData.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            chombo-discharge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Documentation.html">Using this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Testing.html">Code testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Acknowledgements.html">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="DesignOverview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="CellTagger.html">CellTagger</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="SpatialDiscretization.html">Spatial discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshData.html">Mesh data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Particles</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#genericparticle">GenericParticle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-particles">Custom particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#particlecontainer">ParticleContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-structures">Data structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#list-p-and-listbox-p">List&lt;P&gt; and ListBox&lt;P&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="#listiterator-p">ListIterator&lt;P&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="#particledata-p">ParticleData&lt;P&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amrparticles-p">AMRParticles&lt;P&gt;</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#basic-usage">Basic usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#getting-the-particles">Getting the particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iterating-over-particles">Iterating over particles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sorting-particles">Sorting particles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sorting-by-cell">Sorting by cell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sorting-by-patch">Sorting by patch</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#allocating-particles">Allocating particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#particle-mapping">Particle mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#regridding">Regridding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#masked-particles">Masked particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-interaction">Boundary interaction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#signed-distance-function">Signed distance function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#domain-edges">Domain edges</a></li>
<li class="toctree-l3"><a class="reference internal" href="#particle-intersection">Particle intersection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#particle-mesh">Particle-mesh</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#particle-deposition">Particle deposition</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#base-deposition">Base deposition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coarse-fine-deposition">Coarse-fine deposition</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#particle-interpolation">Particle interpolation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#particle-visualization">Particle visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#superparticles">Superparticles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#kd-trees">kD-trees</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers.html">Linear solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="VV.html">Verification and validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/CDR.html">Convection-Diffusion-Reaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Electrostatics.html">Electrostatic solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Ito.html">Îto diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/KineticMonteCarlo.html">Kinetic Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/MeshODESolver.html">Mesh ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/SurfaceODESolver.html">Surface ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/TracerParticles.html">Tracer particles</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multi-physics applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/DischargeInceptionModel.html">Discharge inception model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ItoKMC.html">Îto-KMC plasma model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Single-solver applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection-diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/MeshODEModel.html">Mesh ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/TracerParticleModel.html">Tracer particle model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/DataParser.html">Data parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">LookupTable1D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Particles</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Source/Particles.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="particles">
<span id="chap-particles"></span><h1>Particles<a class="headerlink" href="#particles" title="Permalink to this heading"></a></h1>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> supports computational particles using native <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> particle data.
The source code for the particle functionality resides in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Source/Particle</span></code>.
Particle support contains the following basic features:</p>
<ul class="simple">
<li><p>Particle-mesh operations, i.e., deposition and interpolation of particle variables to/from the mesh.</p></li>
<li><p>Particle distribution and remapping with MPI.</p></li>
<li><p>Rudimentary particle output to H5Part files.</p></li>
</ul>
<p>Particle support is generally speaking templated, so that users can define new particle types that contain a desired set of variables.
Typically, these will are derived from <a class="reference internal" href="#chap-genericparticle"><span class="std std-ref">GenericParticle</span></a>, which is discussed below.</p>
<section id="genericparticle">
<span id="chap-genericparticle"></span><h2>GenericParticle<a class="headerlink" href="#genericparticle" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">GenericParticle</span></code> is a default particle usable by the <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> particle library.
The particle type is essentially a template</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericParticle</span>
<span class="p">{</span>
<span class="k">public</span>
<span class="w">   </span><span class="n">RealVect</span><span class="o">&amp;</span>
<span class="w">   </span><span class="nf">position</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">   </span><span class="n">RealVect</span><span class="w"> </span><span class="n">m_position</span><span class="p">;</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_scalars</span><span class="p">;</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">RealVcet</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_vectors</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">M</span></code> and <code class="docutils literal notranslate"><span class="pre">N</span></code> are the number of <code class="docutils literal notranslate"><span class="pre">Real</span></code> and <code class="docutils literal notranslate"><span class="pre">RealVect</span></code> variables for the particle.
The <code class="docutils literal notranslate"><span class="pre">GenericParticle</span></code> always stores the position of the particle, which is available through <code class="docutils literal notranslate"><span class="pre">GenericParticle&lt;M,N&gt;::position</span></code>.</p>
<p>To fetch the <code class="docutils literal notranslate"><span class="pre">Real</span></code> and <code class="docutils literal notranslate"><span class="pre">RealVect</span></code> variables, <code class="docutils literal notranslate"><span class="pre">GenericParticle</span></code> has member functions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Real</span><span class="o">&amp;</span>
<span class="n">GenericParticle</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;::</span><span class="n">real</span><span class="p">();</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">RealVect</span><span class="o">&amp;</span>
<span class="n">GenericParticle</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;::</span><span class="n">vect</span><span class="p">();</span>
</pre></div>
</div>
<p>If using <code class="docutils literal notranslate"><span class="pre">GenericParticle</span></code> directly, the correct C++ way of fetching one of these variables is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GenericParticle</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>

<span class="n">Real</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="k">template</span><span class="w"> </span><span class="n">real</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>Note that one must include the template keyword.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The <code class="docutils literal notranslate"><span class="pre">GenericParticle</span></code> C++ API is found at <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classGenericParticle.html">https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classGenericParticle.html</a>.</p>
</div>
</section>
<section id="custom-particles">
<h2>Custom particles<a class="headerlink" href="#custom-particles" title="Permalink to this heading"></a></h2>
<p>To create a simple custom particle class with more sane signatures, one can inherit from <code class="docutils literal notranslate"><span class="pre">GenericParticle</span></code> and specify new function signatures that return the appropriate fields.
An example of this is given in the code-block below, where we define <code class="docutils literal notranslate"><span class="pre">KineticParticle</span></code> to be a particle that contains the th5ree additional fields on top of <code class="docutils literal notranslate"><span class="pre">GenericParticle</span></code> (weight, velocity, and acceleration).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">KineticParticle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">GenericParticle</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">   </span><span class="kr">inline</span>
<span class="w">   </span><span class="n">Real</span><span class="o">&amp;</span><span class="w"> </span><span class="n">weight</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">real</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="kr">inline</span>
<span class="w">   </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">velocity</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">vect</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="kr">inline</span>
<span class="w">   </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">acceleration</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">vect</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There are many particles in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>, see the <code class="docutils literal notranslate"><span class="pre">GenericParticle</span></code> C++ API for more information.</p>
</section>
<section id="particlecontainer">
<span id="chap-particlecontainer"></span><h2>ParticleContainer<a class="headerlink" href="#particlecontainer" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> is a template class that</p>
<ol class="arabic simple">
<li><p>Stores computational particles of type <code class="docutils literal notranslate"><span class="pre">P</span></code> over an AMR hierchy.</p></li>
<li><p>Provides infrastructure for remapping particles.</p></li>
<li><p>Provides functionality for getting a list of particles within a specified grid patch.</p></li>
<li><p>Provides functionality that is required during regrids.</p></li>
<li><p>Other types of functionality, like grouping particles into grid cells, set and get functions for assigning particle variables, etcl.</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> uses the <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> structure <code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code> under the hood, and therefore has template constraints on <code class="docutils literal notranslate"><span class="pre">P</span></code>.
The simplest way to use <code class="docutils literal notranslate"><span class="pre">ParticleContainer</span></code> for a new type of particle is to let <code class="docutils literal notranslate"><span class="pre">P</span></code> inherit from <a class="reference internal" href="#chap-genericparticle"><span class="std std-ref">GenericParticle</span></a>, which will fulfill all template constraints.</p>
</section>
<section id="data-structures">
<h2>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this heading"></a></h2>
<section id="list-p-and-listbox-p">
<h3>List&lt;P&gt; and ListBox&lt;P&gt;<a class="headerlink" href="#list-p-and-listbox-p" title="Permalink to this heading"></a></h3>
<p>At the lowest level the particles are always stored in a linked list <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code>.
The class can be simply be through of as a regular list of <code class="docutils literal notranslate"><span class="pre">P</span></code> with non-random access.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ListBox&lt;P&gt;</span></code> consists of a <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> <em>and</em> a <code class="docutils literal notranslate"><span class="pre">Box</span></code>.
The latter specifies the grid patch that the particles are assigned to.</p>
<p>To get the list of particles from a <code class="docutils literal notranslate"><span class="pre">ListBox&lt;P&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ListBox</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myListBox</span><span class="p">;</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">myList</span> <span class="o">=</span> <span class="n">myListBox</span><span class="o">.</span><span class="n">listItems</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="listiterator-p">
<h3>ListIterator&lt;P&gt;<a class="headerlink" href="#listiterator-p" title="Permalink to this heading"></a></h3>
<p>In order to iterate over particles, use an iterator <code class="docutils literal notranslate"><span class="pre">ListIterator&lt;P&gt;</span></code> (which is not random access):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myParticles</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lit</span><span class="p">(</span><span class="n">myParticles</span><span class="p">);</span><span class="w"> </span><span class="n">lit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">lit</span><span class="p">){</span>
<span class="w">   </span><span class="n">P</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lit</span><span class="p">();</span>

<span class="w">   </span><span class="c1">// ... do something with this particle</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="particledata-p">
<h3>ParticleData&lt;P&gt;<a class="headerlink" href="#particledata-p" title="Permalink to this heading"></a></h3>
<p>On each grid level, <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> stores the particles in a <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> class <code class="docutils literal notranslate"><span class="pre">ParticleData</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="o">&gt;</span>
<span class="n">ParticleData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">P</span></code> is the particle type.
<code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code> can be thought of as a <code class="docutils literal notranslate"><span class="pre">LevelData&lt;ListBox&lt;P&gt;&gt;</span></code>, although it actually inherits from <code class="docutils literal notranslate"><span class="pre">LayoutData&lt;ListBox&lt;P&gt;&gt;</span></code>.
Each grid patch contains a <code class="docutils literal notranslate"><span class="pre">ListBox&lt;P&gt;</span></code> of particles.</p>
</section>
<section id="amrparticles-p">
<h3>AMRParticles&lt;P&gt;<a class="headerlink" href="#amrparticles-p" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AMRParticles&lt;P&gt;</span></code> is our AMR version of <code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code>.
It is a simply a typedef of a vector of pointers to <code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code> on each level:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">AMRParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">ParticleData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Again, the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> indicates the AMR level and the <code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code> is a distributed data holder that holds the particles on each AMR level.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMRParticles&lt;P&gt;</span></code> always lives within <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code>, and is the class member of <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> that actually holds the particles.</p>
</section>
</section>
<section id="basic-usage">
<h2>Basic usage<a class="headerlink" href="#basic-usage" title="Permalink to this heading"></a></h2>
<p>Here, we give some examples of basic usage of <code class="docutils literal notranslate"><span class="pre">ParticleContainer</span></code>.
For the full API, see the <code class="docutils literal notranslate"><span class="pre">ParticleContainer</span></code> C++ API <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classParticleContainer.html">https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classParticleContainer.html</a>.</p>
<section id="getting-the-particles">
<h3>Getting the particles<a class="headerlink" href="#getting-the-particles" title="Permalink to this heading"></a></h3>
<p>To get the particles from a <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> one can call <code class="docutils literal notranslate"><span class="pre">AMRParticles&lt;P&gt;&amp;</span> <span class="pre">ParticleContainer&lt;P&gt;::getParticles()</span></code> which will provide the particles:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">;</span>

<span class="n">AMRParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">myParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getParticles</span><span class="p">();</span>
</pre></div>
</div>
<p>Alternatively, one can fetch directly from a specified grid level as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">lvl</span><span class="p">;</span>
<span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">;</span>

<span class="n">ParticleData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">levelParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">[</span><span class="n">lvl</span><span class="p">];</span>
</pre></div>
</div>
</section>
<section id="iterating-over-particles">
<h3>Iterating over particles<a class="headerlink" href="#iterating-over-particles" title="Permalink to this heading"></a></h3>
<p>To do something basic with the particle in a <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code>, one will typically iterate over the particles in all grid levels and patches.</p>
<p>The code bit below shows a typical example of how the particles can be moved, and then remapped onto the correct grid patches and ranks if they fall off their original one.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">;</span>

<span class="c1">// Iterate over grid levels</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getFinestLevel</span><span class="p">();</span><span class="w"> </span><span class="n">lvl</span><span class="o">++</span><span class="p">){</span>

<span class="w">   </span><span class="c1">// Get the grid on this level.</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DisjointBoxLayout</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dbl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getGrids</span><span class="p">(</span><span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getRealm</span><span class="p">())[</span><span class="n">lvl</span><span class="p">];</span>

<span class="w">   </span><span class="c1">// Get the distributed particles on this level</span>
<span class="w">   </span><span class="n">ParticleData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">levelParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">[</span><span class="n">lvl</span><span class="p">]</span>

<span class="w">   </span><span class="c1">// Iterate over grid patches on this level</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">DataIterator</span><span class="w"> </span><span class="n">dit</span><span class="p">(</span><span class="n">dbl</span><span class="p">);</span><span class="w"> </span><span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">dit</span><span class="p">){</span>

<span class="w">      </span><span class="c1">// Get the particles in the current patch.</span>
<span class="w">      </span><span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">patchParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levelParticles</span><span class="p">[</span><span class="n">dit</span><span class="p">()].</span><span class="n">listItems</span><span class="p">();</span>

<span class="w">      </span><span class="c1">// Iterate over the particles in the current patch.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lit</span><span class="p">(</span><span class="n">patchParticles</span><span class="p">);</span><span class="w"> </span><span class="n">lit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">lit</span><span class="p">){</span>
<span class="w">         </span><span class="n">P</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lit</span><span class="p">();</span>

<span class="w">         </span><span class="c1">// Move the particle</span>
<span class="w">         </span><span class="n">p</span><span class="p">.</span><span class="n">position</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Remap particles onto new patches and ranks (they may have moved off their original ones)</span>
<span class="n">myParticleContainer</span><span class="p">.</span><span class="n">remap</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="sorting-particles">
<h2>Sorting particles<a class="headerlink" href="#sorting-particles" title="Permalink to this heading"></a></h2>
<section id="sorting-by-cell">
<h3>Sorting by cell<a class="headerlink" href="#sorting-by-cell" title="Permalink to this heading"></a></h3>
<p>The particles can also be sorted by cell by calling <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">ParticleContainer&lt;P&gt;::sortParticleByCell()</span></code>, like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">;</span>

<span class="n">myParticleContainer</span><span class="p">.</span><span class="n">sortParticlesByCell</span><span class="p">();</span>
</pre></div>
</div>
<p>Internally in <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code>, this will place the particles in another container which can be iterated over on a per-cell basis.
This is different from <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">ListBox&lt;P&gt;</span></code> above, which contained particles stored on a per-patch basis with no internal ordering of the particles.</p>
<p>The per-cell particle container is a <code class="docutils literal notranslate"><span class="pre">Vector&lt;RefCountedPtr&lt;LayoutData&lt;BinFab&lt;P&gt;&gt;&gt;&gt;</span></code> type where again the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> holds the particles on each AMR level and the <code class="docutils literal notranslate"><span class="pre">LayoutData&lt;BinFab&gt;</span></code> holds one <code class="docutils literal notranslate"><span class="pre">BinFab</span></code> on each grid patch.
The <code class="docutils literal notranslate"><span class="pre">BinFab</span></code> is also a template, and it holds a <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> in each grid cell.
Thus, this data structure stores the particles per cell rather than per patch.
Due to the horrific template depth, this container is typedef’ed as <code class="docutils literal notranslate"><span class="pre">AMRCellParticles&lt;P&gt;</span></code>.</p>
<p>To get cell-sorted particles one can call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AMRCellParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">cellSortedParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getCellParticles</span><span class="p">();</span>
</pre></div>
</div>
<p>Iteration over cell-sorted particles is mostly the same as for patch-sorted particles, except that we also need to explicitly iterate over the grid cells in each grid patch:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Iterate over all AMR levels</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getFinestLevel</span><span class="p">();</span><span class="w"> </span><span class="n">lvl</span><span class="o">++</span><span class="p">){</span>

<span class="w">   </span><span class="c1">// Get the grids on this level</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DisjointBoxLayout</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dbl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getGrids</span><span class="p">(</span><span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getRealm</span><span class="p">())[</span><span class="n">lvl</span><span class="p">];</span>

<span class="w">   </span><span class="c1">// Iterate over grid patches on this level</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">DataIterator</span><span class="w"> </span><span class="n">dit</span><span class="p">(</span><span class="n">dbl</span><span class="p">);</span><span class="w"> </span><span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">dit</span><span class="p">){</span>

<span class="w">      </span><span class="c1">// Get the Cartesian box for the current grid aptch</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">Box</span><span class="w"> </span><span class="n">cellBox</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dbl</span><span class="p">[</span><span class="n">dit</span><span class="p">()];</span>

<span class="w">      </span><span class="c1">// Get the particles in the current grid patch.</span>
<span class="w">      </span><span class="n">BinFab</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">cellSortedBoxParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">cellSortedParticles</span><span class="p">[</span><span class="n">lvl</span><span class="p">])[</span><span class="n">dit</span><span class="p">()];</span>

<span class="w">      </span><span class="c1">// Iterate over all cells in the current box</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">BoxIterator</span><span class="w"> </span><span class="n">bit</span><span class="p">(</span><span class="n">cellBox</span><span class="p">);</span><span class="w"> </span><span class="n">bit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">bit</span><span class="p">){</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">IntVect</span><span class="w"> </span><span class="n">iv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bit</span><span class="p">();</span>

<span class="w">         </span><span class="c1">// Get the particles in the current grid cell.</span>
<span class="w">         </span><span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">cellParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cellSortedBoxParticles</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span><span class="w"> </span><span class="n">comp</span><span class="p">);</span>

<span class="w">         </span><span class="c1">// Do something with cellParticles</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lit</span><span class="p">(</span><span class="n">cellParticles</span><span class="p">);</span><span class="w"> </span><span class="n">lit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">lit</span><span class="p">){</span>
<span class="w">            </span><span class="n">P</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lit</span><span class="p">();</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="sorting-by-patch">
<h3>Sorting by patch<a class="headerlink" href="#sorting-by-patch" title="Permalink to this heading"></a></h3>
<p>If the particles need to return to patch-sorted particles:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">;</span>

<span class="n">myParticleContainer</span><span class="p">.</span><span class="n">sortParticlesByPatch</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>If particles are sorted by cell, calling <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> member functions that fetch particles by patch will issue an error.
This is done by design since the patch-sorted particles have been moved to a different container.
Note that remapping particles also requires that the particles are patch-sorted.
Calling <code class="docutils literal notranslate"><span class="pre">remap()</span></code> with cell-sorted particles will issue a run-time error.</p>
</div>
</section>
</section>
<section id="allocating-particles">
<h2>Allocating particles<a class="headerlink" href="#allocating-particles" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">AmrMesh</span></code> has a very simple function for allocating a <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Template class for generic allocation of particle containers. </span>
<span class="cm">  @param[out] a_container Particle container to be allocated</span>
<span class="cm">  @param[out] a_realm     Realm on which the particles will be allocated. </span>
<span class="cm">*/</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">allocate</span><span class="p">(</span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_container</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">a_realm</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>which will allocate a <code class="docutils literal notranslate"><span class="pre">ParticleContainer</span></code> on the realm <code class="docutils literal notranslate"><span class="pre">a_realm</span></code>.</p>
</section>
<section id="particle-mapping">
<span id="chap-particlemapping"></span><h2>Particle mapping<a class="headerlink" href="#particle-mapping" title="Permalink to this heading"></a></h2>
<p>Particles that move off their original grid patch must be remapped in order to ensure that they are assigned to the correct grid.
The remapping function for <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Remap over the entire AMR hierarchy</span>
<span class="cm">*/</span>
<span class="kt">void</span>
</pre></div>
</div>
<p>This is simply used as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticles</span><span class="p">;</span>

<span class="n">myParticles</span><span class="o">.</span><span class="n">remap</span><span class="p">();</span>
</pre></div>
</div>
<p>During remapping, the following steps are performed for each MPI rank:</p>
<ol class="arabic simple">
<li><p>Collect all particles from this rank onto thread-local particles (if using OpenMP).</p></li>
<li><p>Iterate through those particles and locate their position in the AMR hierarchy (level, grid index, and owning MPI rank).</p></li>
<li><p>The particles that will move off each MPI rank are put in separate data containers.</p></li>
<li><p>Assign local particles first, i.e., particles that moved off a grid patch into another grid patch owned by the same rank.</p></li>
<li><p>Scatter the particles with MPI.</p></li>
<li><p>Assign the scattered particles to each MPI rank.</p></li>
</ol>
</section>
<section id="regridding">
<h2>Regridding<a class="headerlink" href="#regridding" title="Permalink to this heading"></a></h2>
<p>As with mesh data, <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> requires storing the old-grid data before assigning data on the new grids.
This is relatively simple to achieve, and is done as follows:</p>
<ol class="arabic">
<li><p><em>Before</em> creating the new grids, each MPI rank collects <em>all</em> particles on a single <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> by calling</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Cache particles before calling regrid. </span>
<span class="cm">  @param[in] a_base Coarsest grid level which will not change. </span>
<span class="cm">*/</span>
<span class="kt">void</span>
</pre></div>
</div>
<p>This will pull the particles off their current grids and collect them in a single list (on a per-rank basis).</p>
</li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> regrids, each rank adds his <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> back into the internal particle containers.</p>
<p>This is done by calling the <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> regrid function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Regrid function. a_base is the coarsest grid level which did not change</span>
<span class="cm">  @param[in] a_grids          AMR grids</span>
<span class="cm">  @param[in] a_domains        AMR domains</span>
<span class="cm">  @param[in] a_dx             Grid resolutions</span>
<span class="cm">  @param[in] a_refRat         Refinement ratios</span>
<span class="cm">  @param[in] a_validMask      Valid cells</span>
<span class="cm">  @param[in] a_levelTiles     Tiled AMR grids</span>
<span class="cm">  @param[in] a_base           Coarsest grid level that did not change. </span>
<span class="cm">  @param[in] a_newFinestLevel New finest grid level</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="n">regrid</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">DisjointBoxLayout</span><span class="o">&gt;&amp;</span><span class="w">         </span><span class="n">a_grids</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">ProblemDomain</span><span class="o">&gt;&amp;</span><span class="w">             </span><span class="n">a_domains</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;&amp;</span><span class="w">                      </span><span class="n">a_dx</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w">                       </span><span class="n">a_refRat</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">ValidMask</span><span class="o">&gt;&amp;</span><span class="w">                 </span><span class="n">a_validMask</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">LevelTiles</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">a_levelTiles</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w">                                </span><span class="n">a_base</span><span class="p">,</span>
</pre></div>
</div>
</li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>One <em>must</em> call <code class="docutils literal notranslate"><span class="pre">preRegrid</span></code> before the <code class="docutils literal notranslate"><span class="pre">regrid</span></code>.
Failure to do so will lead to loss of all particles.</p>
</div>
</section>
<section id="masked-particles">
<span id="chap-maskedparticles"></span><h2>Masked particles<a class="headerlink" href="#masked-particles" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> also supports the concept of <em>masked particles</em>, where one can fetch a subset of particles that live only in specified grid cells.
Typically, this “specified region” is the refinement boundary, but the functionality is generic and might prove useful also in other cases.
This functionality is unlikely to be used directly by users of chombo-discharge, but it is nonetheless fruitful to understand the concept in order to more easily fathom how deposition across refinement boundaries proceed.</p>
<p>When <em>masked particles</em> are used, the user can provide a boolean mask over the AMR hierarchy and obtain the subset of particles that live in regions where the mask evaluates to true.
This functionality is for example used for some of the particle deposition methods in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> where we deposit particles that live near the refinement boundary with special deposition functions.</p>
<p>To fill the masked particles, <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> has members functions for copying the particles into internal data containers which the user can later fetch.
The function signatures for this is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Copy particles to mask particle data holder.</span>
<span class="cm">  @param[in] a_mask Mask</span>
<span class="cm">  @note If the mask is nullptr on any of the levels, those levels will be ignored. </span>
<span class="cm">*/</span>
<span class="kt">void</span>
</pre></div>
</div>
<p>The argument <code class="docutils literal notranslate"><span class="pre">a_mask</span></code> holds a bool at each cell in the AMR hierarchy.
Particles that live in cells where <code class="docutils literal notranslate"><span class="pre">a_mask</span></code> is true will be copied to an internal data holder in <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> which can be retrieved through a call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Get the mask particles. </span>
<span class="cm">  @return m_maskParticles</span>
<span class="cm">*/</span>
<span class="n">AMRParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span>
</pre></div>
</div>
<p>In the above functions the mask particles are <em>copied</em>, and the original particles are left untouched.
After the user is done with the particles, they should be deleted through the function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Clear the &quot;mask&quot; particles. </span>
<span class="cm">*/</span>
<span class="kt">void</span>
</pre></div>
</div>
<p>An example pseudocode for working with masked particles is given below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AmrMask</span><span class="w"> </span><span class="n">myMask</span><span class="p">;</span>
<span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myParticles</span><span class="p">;</span>

<span class="c1">// Copy mask particles</span>
<span class="n">myParticles</span><span class="p">.</span><span class="n">copyMaskParticles</span><span class="p">(</span><span class="n">myMask</span><span class="p">);</span>

<span class="c1">// Do something with the mask particles</span>
<span class="n">AMRParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">maskParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getMaskParticles</span><span class="p">();</span>

<span class="c1">// Release the mask particles</span>
<span class="n">myParticles</span><span class="p">.</span><span class="n">clearMaskParticles</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="boundary-interaction">
<span id="chap-particleeb"></span><h2>Boundary interaction<a class="headerlink" href="#boundary-interaction" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> is EB-agnostic and has no information about the embedded boundary and only partial information about the domain boundary.
This means the following:</p>
<ol class="arabic simple">
<li><p>Particles remap just as if the embedded boundary was not there.</p></li>
<li><p>Particles that completely fall off the domain are deleted when calling the remapping function.</p></li>
</ol>
<p>Interaction with the EB is done via the implicit function or discrete information, as well as modifications in the interpolation and deposition steps.</p>
<section id="signed-distance-function">
<h3>Signed distance function<a class="headerlink" href="#signed-distance-function" title="Permalink to this heading"></a></h3>
<p>When signed distance functions are used, one can always query how far a particle is from a boundary:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">particles</span><span class="p">;</span>
<span class="n">BaseIF</span><span class="w"> </span><span class="n">distanceFunction</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lit</span><span class="p">(</span><span class="n">particles</span><span class="p">);</span><span class="w"> </span><span class="n">lit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">lit</span><span class="p">){</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">P</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">lit</span><span class="p">();</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">position</span><span class="p">();</span>

<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w"> </span><span class="n">distanceToBoundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distanceFunction</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the particle is inside the EB then the signed distance function will be positive, and the particle can then be removed from the simulation.
The distance function can also be used to detect collisions between particles and the EB.
E.g, the intersection point can be computed and the particle can be deposited on the boundary, or bounced off it.
See <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a> for details on how to obtain the distance function.</p>
</section>
<section id="domain-edges">
<h3>Domain edges<a class="headerlink" href="#domain-edges" title="Permalink to this heading"></a></h3>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">ParticleContainer</span></code> remapping function will discard particles that fall outside of the domain.
The user can also check if this happen by checking if the particle position is outside the computational domain:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GenericParticle</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>

<span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">pos</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">position</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">probLo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getProbLo</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w"> </span><span class="n">probHi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getProbHi</span><span class="p">();</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">outside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SpaceDim</span><span class="p">;</span><span class="w"> </span><span class="n">dir</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">probLo</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">pos</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">probHi</span><span class="p">[</span><span class="n">dir</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">outside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="particle-intersection">
<span id="chap-particleintersection"></span><h3>Particle intersection<a class="headerlink" href="#particle-intersection" title="Permalink to this heading"></a></h3>
<p>It is occasionally useful to catch particles that hit an EB or crossed a domain side.
Assuming that the particle type <code class="docutils literal notranslate"><span class="pre">P</span></code> also has a member function that stores the starting position of the particle, one can compute the intersection point between the particle trajectory and the EB or domain sides.
Currently, <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a> supports two methods for computing this</p>
<ul class="simple">
<li><p>Using a bisection algorithm with a user-specified step.</p></li>
<li><p>Using a ray-casting algorithm.</p></li>
</ul>
<p>These algorithms differ in the sense that the bisection approach will check for a particle crossing between two positions <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> using a pre-defined tolerance.
The ray-casting algorithm will check if the particle can move from <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span> towards <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> by using a variable step along the particle trajectory.
This step is selected from the signed distance from the particle position to the EB such that it uses a large step if the particle is far away from the EB.
Conversely, if the particle is close to the EB a small step will be used.</p>
<p>The algorithm that intersect the particles are a part of <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a>, and are called as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Particle intersection algorithm based on ray-casting.</span>
<span class="cm">  @details This routine will iterate through all the particles and check if they intersect the geometry. The template</span>
<span class="cm">  parameter indicates the particle type -- it MUST have const RealVec&amp; position() const and  const RealVect&amp; oldPosition() const </span>
<span class="cm">  functions that determine the start and stop position of the particle trajectory. This routine uses a ray-casting method</span>
<span class="cm">  to check for intersections with the EB (the domain side is much easier). If the particles are closer to the EB than</span>
<span class="cm">  a_tolerance, they are absorbed and placed on the EB. Their position are updated and they are placed in the </span>
<span class="cm">  a_ebParticles argument. This routine uses a ray-casting method where it computes the distance from the EB</span>
<span class="cm">  (assuming that the implicit function is a signed distance function). Particles are then moved that</span>
<span class="cm">  distance along their trajectory and we then update the new distance to the EB. This is done recursively until the particles</span>
<span class="cm">  have either moved the entire length or been absorbed by the EB or domain side. </span>
<span class="cm">  @param[inout] a_activeParticles     Particles to be intersected with geometry</span>
<span class="cm">  @param[out]   a_ebParticles         Particles that intersected with the EB</span>
<span class="cm">  @param[out]   a_domainParticles     Particles that intersected with the domain faces</span>
<span class="cm">  @param[in]    a_phase               Phase where the input particles live</span>
<span class="cm">  @param[in]    a_bisectionStep       Length of the bisection step</span>
<span class="cm">  @param[in]    a_deleteParticles     If true, particles will be removed from a_activeParticles if they intersect the geometry.</span>
<span class="cm">  @param[in]    a_nonDeletionModifier Optional input argument for letting the user manipulate particles that were intersected but not deleted</span>
<span class="cm">*/</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">intersectParticlesRaycastIF</span><span class="p">(</span>
<span class="w">  </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">         </span><span class="n">a_activeParticles</span><span class="p">,</span>
<span class="w">  </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">         </span><span class="n">a_ebParticles</span><span class="p">,</span>
<span class="w">  </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">         </span><span class="n">a_domainParticles</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="w">      </span><span class="n">a_phase</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w">                    </span><span class="n">a_tolerance</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w">                    </span><span class="n">a_deleteParticles</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_nonDeletionModifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">P</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">})</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="cm">/*!</span>
<span class="cm">  @brief Particle intersection algorithm based on bisection. </span>
<span class="cm">  @details This routine will iterate through all the particles and check if they intersect the geometry. The template</span>
<span class="cm">  parameter indicates the particle type -- it MUST have const RealVec&amp; position() const and  const RealVect&amp; oldPosition() const </span>
<span class="cm">  functions that determine the start and stop position of the particle trajectory. This routine uses a bisection method</span>
<span class="cm">  to check for intersections with the EB (the domain side is much easier). Their position are updated and they are placed</span>
<span class="cm">  in the a_ebParticles argument. </span>
<span class="cm">  @param[inout] a_activeParticles     Particles to be intersected with geometry</span>
<span class="cm">  @param[out]   a_ebParticles         Particles that intersected with the EB</span>
<span class="cm">  @param[out]   a_domainParticles     Particles that intersected with the domain faces</span>
<span class="cm">  @param[in]    a_phase               Phase where the input particles live</span>
<span class="cm">  @param[in]    a_bisectionStep       Length of the bisection step</span>
<span class="cm">  @param[in]    a_deleteParticles     If true, particles will be removed from a_activeParticles if they intersect the geometry.</span>
<span class="cm">  @param[in]    a_nonDeletionModifier Optional input argument for letting the user manipulate particles that were intersected but not deleted</span>
<span class="cm">*/</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">intersectParticlesBisectIF</span><span class="p">(</span>
<span class="w">  </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">         </span><span class="n">a_activeParticles</span><span class="p">,</span>
<span class="w">  </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">         </span><span class="n">a_ebParticles</span><span class="p">,</span>
<span class="w">  </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">         </span><span class="n">a_domainParticles</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="w">      </span><span class="n">a_phase</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w">                    </span><span class="n">a_bisectionStep</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w">                    </span><span class="n">a_deleteParticles</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_nonDeletionModifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">P</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">})</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>The above two functions take as input/output arguments the particles to be iterated through (<code class="docutils literal notranslate"><span class="pre">a_activeParticles</span></code>).
When calling the intersection functions, the intersected particles are put into EB-intersected particels (<code class="docutils literal notranslate"><span class="pre">a_ebParticles</span></code>) and domain-intersected particles (<code class="docutils literal notranslate"><span class="pre">a_domainParticles</span></code>).
The user can choose whether or not to remove intersected particles from <code class="docutils literal notranslate"><span class="pre">a_activeParticles</span></code> by adjusting <code class="docutils literal notranslate"><span class="pre">a_deleteParticles</span></code>.
The final argument lets the user supply a lambda that modifies particles that were intersected.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The intersection functions require that <code class="docutils literal notranslate"><span class="pre">P</span></code> has a member function <code class="docutils literal notranslate"><span class="pre">oldPosition</span></code> which supplies the starting position of the particle.</p>
</div>
<p>Both the bisection and ray-casting algorithm have weaknesses.
The bisection algorithm algorithm requires a user-supplied step in order to operate efficiently, while the ray-casting algorithm is very slow when the particle is close to the EB and moves tangentially along it.
Future versions of <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> will likely include more sophisticated algorithms.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><code class="docutils literal notranslate"><span class="pre">AmrMesh</span></code> also stores the implicit function on the mesh, which could also be used to resolved particle collisions with the EB/domain.</p>
</div>
</section>
</section>
<section id="particle-mesh">
<span id="chap-particlemesh"></span><h2>Particle-mesh<a class="headerlink" href="#particle-mesh" title="Permalink to this heading"></a></h2>
<p>Particle-mesh operations are required when particles interact with the mesh and vice-versa.
There are two main operations involved:</p>
<ol class="arabic simple">
<li><p><em>Deposition</em>, where particle properties are transferred to the mesh.</p></li>
<li><p><em>Interpolation</em>, where mesh properties are transferred to the particles.</p></li>
</ol>
<section id="particle-deposition">
<h3>Particle deposition<a class="headerlink" href="#particle-deposition" title="Permalink to this heading"></a></h3>
<p>To deposit particles on the mesh, the user can call the templated function <code class="docutils literal notranslate"><span class="pre">AmrMesh::depositParticles</span></code> which have a signatures</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Deposit scalar particle quantities on the mesh.</span>
<span class="cm">  @details P is the particle type, Ret is the returned value of the particle member function, and must be a Real or a</span>
<span class="cm">  RealVect. MemFunc is a pointer to a member function of P. E.g., depositParticles&lt;P, const RealVect&amp;, &amp;P::position&gt;.    </span>
<span class="cm">  @param[out] a_meshData             Mesh data. Must have exactly one compnent. </span>
<span class="cm">  @param[in]  a_realm                Realm where data is registered.</span>
<span class="cm">  @param[in]  a_phase                Phase where data is registered.</span>
<span class="cm">  @param[in]  a_particles            Particle container. Must be in &quot;usable state&quot; for deposition.</span>
<span class="cm">  @param[in]  a_depositionType       Specification of deposition kernel (e.g., CIC)</span>
<span class="cm">  @param[in]  a_coarseFineDeposition Specification of handling of coarse-fine boundaries.</span>
<span class="cm">  @param[in]  a_forceIrregNGP        Force NGP deposition in irregular cells or not. </span>
<span class="cm">*/</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Ret</span><span class="p">,</span><span class="w"> </span><span class="n">Ret</span><span class="w"> </span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">MemberFunc</span><span class="p">)()</span><span class="w"> </span><span class="k">const</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">depositParticles</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w">              </span><span class="n">a_meshData</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w">          </span><span class="n">a_realm</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="o">&amp;</span><span class="w">   </span><span class="n">a_phase</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_particles</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">DepositionType</span><span class="w">        </span><span class="n">a_depositionType</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">CoarseFineDeposition</span><span class="w">  </span><span class="n">a_coarseFineDeposition</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w">                  </span><span class="n">a_forceIrregNGP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="cm">/*!</span>
<span class="cm">  @brief Deposit scalar particle quantities on the mesh.</span>
<span class="cm">  @details P is the particle type, Ret is the returned value of the particle member function, and must be a Real or a</span>
<span class="cm">  const Real&amp;. MemFunc is a pointer to a member function of P. E.g., depositParticles&lt;P, const Real&amp;, &amp;P::weight&gt;.        </span>
<span class="cm">  @param[out] a_meshData   Mesh data. MUST have exactly one compnent. </span>
<span class="cm">  @param[in]  a_realm      Realm where data is registered.</span>
<span class="cm">  @param[in]  a_phase      Phase where data is registered.</span>
<span class="cm">  @param[in]  a_particles  Particle container. Must be in &quot;usable state&quot; for deposition.</span>
<span class="cm">*/</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Ret</span><span class="p">,</span><span class="w"> </span><span class="n">Ret</span><span class="w"> </span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">MemberFunc</span><span class="p">)()</span><span class="w"> </span><span class="k">const</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">depositParticles</span><span class="p">(</span><span class="n">EBAMRIVData</span><span class="o">&amp;</span><span class="w">                </span><span class="n">a_meshData</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w">          </span><span class="n">a_realm</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="o">&amp;</span><span class="w">   </span><span class="n">a_phase</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_particles</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, the template parameter <code class="docutils literal notranslate"><span class="pre">P</span></code> is the particle type and the template parameter <code class="docutils literal notranslate"><span class="pre">MemberFunc</span></code> is a C++ pointer-to-member-function that returns <code class="docutils literal notranslate"><span class="pre">Ret</span></code>, which must either be a <code class="docutils literal notranslate"><span class="pre">Real</span></code> or a <code class="docutils literal notranslate"><span class="pre">RealVect</span></code>.
In addition, the function will accept <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Real&amp;</span></code> or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">RealVect&amp;</span></code>.
The pointer-to-member <code class="docutils literal notranslate"><span class="pre">MemberFunc</span></code> indicates the variable to be deposited on the mesh, and must have return type <code class="docutils literal notranslate"><span class="pre">Ret</span></code>.
This function pointer does not need to return a member in the particle class, but it must be marked <code class="docutils literal notranslate"><span class="pre">const</span></code>.</p>
<p>Next, the input arguments to <code class="docutils literal notranslate"><span class="pre">depositParticles</span></code> are the output mesh data holder (must have exactly one or <code class="docutils literal notranslate"><span class="pre">SpaceDim</span></code> components), the realm and phase where the particles live, and the particles themselves (<code class="docutils literal notranslate"><span class="pre">a_particles</span></code>).
Finally, the flag <code class="docutils literal notranslate"><span class="pre">a_forceIrregNGP</span></code> permits the user to enforce nearest grid-point deposition in cut-cells.
This option is motivated by the fact that some applications might require hard mass conservation, and the user can then ensure that mass is never deposited into covered grid cells.</p>
<p>The input argument <code class="docutils literal notranslate"><span class="pre">a_depositionType</span></code> indicates the deposition method, while <code class="docutils literal notranslate"><span class="pre">a_coarseFineDeposition</span></code> deposition modifications near refinement boundaries.
These are discussed below.</p>
<section id="base-deposition">
<h4>Base deposition<a class="headerlink" href="#base-deposition" title="Permalink to this heading"></a></h4>
<p>The base deposition scheme is specified by an enum <code class="docutils literal notranslate"><span class="pre">DepositionType</span></code> with valid values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DepositionType::NGP</span></code> (Nearest grid-point).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DepositionType::CIC</span></code> (Cloud-In-Cell).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DepositionType::TSC</span></code> (Triangle-Shaped Cloud).</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> supports all of the above methods, which can be combined with various types of modifications near refinement boundaries.</p>
</section>
<section id="coarse-fine-deposition">
<h4>Coarse-fine deposition<a class="headerlink" href="#coarse-fine-deposition" title="Permalink to this heading"></a></h4>
<p>The input argument <code class="docutils literal notranslate"><span class="pre">a_coarseFineDeposition</span></code> determines how deposition near the coarse-fine deposition is handled.
Refinement boundaries introduce additional complications in the deposition scheme due to</p>
<ol class="arabic simple">
<li><p>Fine-grid particles whose deposition clouds hang over the refinement boundary and onto the coarse level.</p></li>
<li><p>Coarse-grid particles whose deposition clouds stick underneath the fine-level.</p></li>
</ol>
<p>In addition, there can be complicated near physical boundaries, such as domain or embedded boundaries.</p>
<figure class="align-center" id="id1">
<span id="fig-particledeposition"></span><a class="reference internal image-reference" href="../_images/ParticleDeposition.png"><img alt="../_images/ParticleDeposition.png" src="../_images/ParticleDeposition.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 11 </span><span class="caption-text">Sketch of deposition schemes near refinement boundaries and cut-cells.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> support various ways of handling deposition across the refinement boundary.
In all of these methods, the mass on the fine grid particles whose deposition clouds hang over the refinement boundaries is simply added to the coarse grid.
The main modifications to the deposition scheme is performed for the coarse-grid particles that live around the refinement boundary (see <a class="reference internal" href="#fig-halomask"><span class="std std-numref">Fig. 12</span></a>).
For the coarse-grid particles the following processes then occur:</p>
<figure class="align-center" id="id2">
<span id="fig-halomask"></span><a class="reference internal image-reference" href="../_images/HaloMask.png"><img alt="../_images/HaloMask.png" src="../_images/HaloMask.png" style="width: 40%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 12 </span><span class="caption-text">Example regions containing coarse-grid particles that deposit with custom deposition rules.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The following coarse-fine deposition methods are currently supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::Interp</span></code>
This method permits the coarse-grid particles to deposit into the region underneath the fine grid.
The deposited mass that falls underneath the fine grid is then interpolated from the coarse grid to the fine grid.
For example, see the indicated coarse-grid particle cloud in the left panel <a class="reference internal" href="#fig-particledeposition"><span class="std std-numref">Fig. 11</span></a>.
While this particle has a width given by the coarse-grid cell size, it will deposit into the coarse grid cells underneath the fine grid.
The mass that ends up in these cells is interpolated to the fine grid, which in this case will inject mass into two layers of fine-grid cells.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::Halo</span></code>
This method extracts the coarse-grid particles that live on the refinement boundary and deposit them with their original width on both the coarse and fine levels.
This is done by first depositing the particles on the coarse level, and then transferring them to the fine level and redepositing them there with the original particle width.
Taking the left panel in <a class="reference internal" href="#fig-particledeposition"><span class="std std-numref">Fig. 11</span></a> as an example, the green particle will then deposit into the coarse-grid cell as well as the first layer of fine-grid cells.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::HaloNGP</span></code>
Similar to <code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::Halo</span></code> discussed above, this method also extracts the coarse-grid particles on the coarse side of the refinement boundary.
However, rather than using the original deposition scheme, these particles are deposited with an NGP scheme.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::Transition</span></code>
This is a method that was developed in order to minimize spurious gradients in the density across the EB.
This method operates by extracting the coarse-grid particles that live around the refinement zone (within some radius), and <em>depositing them with the fine-grid particle width</em>.</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Most coarse-fine particle deposition schemes exhibit some artifacts around the refinement boundary, especially when the particle width exceeds the grid cell size (e.g., for TSC).
The <code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::Transition</span></code> method is the one that we recommend, especially when used with CIC, as it eliminates spurious gradients across the refinement boundary.</p>
</div>
</section>
</section>
<section id="particle-interpolation">
<h3>Particle interpolation<a class="headerlink" href="#particle-interpolation" title="Permalink to this heading"></a></h3>
<p>To interpolate mesh data onto a particle property, the user can call the <code class="docutils literal notranslate"><span class="pre">AmrMesh</span></code> member functions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Interpolate mesh data onto a particle position.</span>
<span class="cm">  @details P is the particle type, Ret is the returned value of the particle member function, and must be a Real&amp; or a</span>
<span class="cm">  RealVect&amp;. MemFunc is a pointer to a member function of P. E.g., interpolate&lt;P, Real&amp;, &amp;P::weight&gt;.        </span>
<span class="cm">  @param[inout] a_particles            Particles to be interpolated. </span>
<span class="cm">  @param[in]    a_realm                Realm where data is registered.</span>
<span class="cm">  @param[in]    a_phase                Phase where data is registered.</span>
<span class="cm">  @param[in]    a_meshScalarField      Scalar field on the mesh </span>
<span class="cm">  @param[in]    a_interpType           Interpolation type. </span>
<span class="cm">  @param[in]    a_forceIrregNGP        Force NGP interpolation in cut-cells. </span>
<span class="cm">*/</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Ret</span><span class="p">,</span><span class="w"> </span><span class="n">Ret</span><span class="w"> </span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">MemberFunc</span><span class="p">)()</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">interpolateParticles</span><span class="p">(</span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span><span class="w">     </span><span class="n">a_particles</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w">        </span><span class="n">a_realm</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_phase</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w">      </span><span class="n">a_meshScalarField</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">DepositionType</span><span class="w">      </span><span class="n">a_interpType</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w">                </span><span class="n">a_forceIrregNGP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The function signature for particle interpolation is pretty much the same as for particle deposition, with the exception of the interpolated field.
The template parameter <code class="docutils literal notranslate"><span class="pre">P</span></code> still indicates the particle type, but the user can interpolate onto either a scalar particle variable or a vector variable.
For example, in order to interpolate the particle acceleration, the particle class (let’s call it <code class="docutils literal notranslate"><span class="pre">MyParticleClass</span></code>) will typically have a member function <code class="docutils literal notranslate"><span class="pre">RealVect&amp;</span> <span class="pre">acceleration()</span></code>, and in this case one can interpolate the acceleration by</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">AmrMesh</span><span class="o">&gt;</span><span class="w"> </span><span class="n">amr</span><span class="p">;</span>

<span class="n">amr</span><span class="o">-&gt;</span><span class="n">interpolateParticles</span><span class="o">&lt;</span><span class="n">MyParticleClass</span><span class="p">,</span><span class="w"> </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MyParticleClass</span><span class="o">::</span><span class="n">acceleration</span><span class="o">&gt;</span><span class="p">(...)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the user interpolates onto a scalar variable, the mesh variable must have exactly one component.
Likewise, if interpolating a vector variable, the mesh variable must have <code class="docutils literal notranslate"><span class="pre">SpaceDim</span></code> components.</p>
</div>
</section>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this heading"></a></h3>
<p>Assume that we have some particle class <code class="docutils literal notranslate"><span class="pre">KineticParticle</span></code> defined as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">KineticParticle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">GenericParticle</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">   </span><span class="kr">inline</span>
<span class="w">   </span><span class="n">Real</span><span class="o">&amp;</span><span class="w"> </span><span class="n">weight</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">real</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="kr">inline</span>
<span class="w">   </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">velocity</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">vect</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="kr">inline</span>
<span class="w">   </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">acceleration</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">vect</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="kr">inline</span>
<span class="w">   </span><span class="n">RealVect</span><span class="w"> </span><span class="n">momentum</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">velocity</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To deposit the weight, velocity, and momentum on the grid we would call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">AmrMesh</span><span class="o">&gt;</span><span class="w"> </span><span class="n">amr</span><span class="p">;</span>

<span class="n">amr</span><span class="o">-&gt;</span><span class="n">depositParticles</span><span class="o">&lt;</span><span class="n">KineticParticle</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="o">&amp;</span><span class="p">,</span><span class="w">     </span><span class="o">&amp;</span><span class="n">KineticParticle</span><span class="o">::</span><span class="n">mass</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(...);</span>
<span class="n">amr</span><span class="o">-&gt;</span><span class="n">depositParticles</span><span class="o">&lt;</span><span class="n">KineticParticle</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">KineticParticle</span><span class="o">::</span><span class="n">velocity</span><span class="o">&gt;</span><span class="p">(...);</span>
<span class="n">amr</span><span class="o">-&gt;</span><span class="n">depositParticles</span><span class="o">&lt;</span><span class="n">KineticParticle</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">KineticParticle</span><span class="o">::</span><span class="n">momentum</span><span class="o">&gt;</span><span class="p">(...);</span>
</pre></div>
</div>
<p>Likewise, to interpolate onto these fields we can call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">AmrMesh</span><span class="o">&gt;</span><span class="w"> </span><span class="n">amr</span><span class="p">;</span>

<span class="n">amr</span><span class="o">-&gt;</span><span class="n">interpolateParticles</span><span class="o">&lt;</span><span class="n">KineticParticle</span><span class="p">,</span><span class="w"> </span><span class="n">Real</span><span class="o">&amp;</span><span class="p">,</span><span class="w">     </span><span class="o">&amp;</span><span class="n">KineticParticle</span><span class="o">::</span><span class="n">mass</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(...);</span>
<span class="n">amr</span><span class="o">-&gt;</span><span class="n">interpolateParticles</span><span class="o">&lt;</span><span class="n">KineticParticle</span><span class="p">,</span><span class="w"> </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">KineticParticle</span><span class="o">::</span><span class="n">velocity</span><span class="o">&gt;</span><span class="p">(...);</span>
</pre></div>
</div>
</section>
</section>
<section id="particle-visualization">
<span id="chap-particlevisualization"></span><h2>Particle visualization<a class="headerlink" href="#particle-visualization" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Particle visualization is currently a work in progress with limited functionality.</p>
</div>
<p>Simple particle visualization can be performed by writing <code class="docutils literal notranslate"><span class="pre">H5Part</span></code> compatible files which can be read by VisIt.
This is done through the function <code class="docutils literal notranslate"><span class="pre">writeH5Part</span></code> in the <code class="docutils literal notranslate"><span class="pre">DischargeIO</span></code> namespace, with the following signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Write a particle container to an H5Part file. Good for quick and dirty visualization of particles</span>
<span class="cm">  @details Use case is pretty straightforward but the user might need to cast particle types. E.g. call</span>

<span class="cm">  writeH5Part&lt;M,N&gt;(a_filename, (const ParticleContainer&lt;GenericParticle&lt;M,N&gt;&gt;&amp;) a_particles, ...)</span>

<span class="cm">  Template substitution is not straightforward for this one. </span>
<span class="cm">  @param[in] a_filename  File name</span>
<span class="cm">  @param[in] a_particles Particles. Particle type must derive from GenericParticle&lt;M, N&gt;</span>
<span class="cm">  @param[in] a_realVars  Variable names for the M real variables</span>
<span class="cm">  @param[in] a_vectVars  Variable names for the N vector variables</span>
<span class="cm">  @param[in] a_shift     Particle position shift</span>
<span class="cm">  @param[in] a_shift     Time </span>
<span class="cm">*/</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">writeH5Part</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w">                               </span><span class="n">a_filename</span><span class="p">,</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">GenericParticle</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">a_particles</span><span class="p">,</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w">                  </span><span class="n">a_realVars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(),</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w">                  </span><span class="n">a_vectVars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(),</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="w">                                  </span><span class="n">a_shift</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">RealVect</span><span class="o">::</span><span class="n">Zero</span><span class="p">,</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">Real</span><span class="w">                                      </span><span class="n">a_time</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>This routine permits particles to be written (in parallel, when using MPI) into a file readable by VisIt.
The optional arguments <code class="docutils literal notranslate"><span class="pre">a_realVars</span></code> and <code class="docutils literal notranslate"><span class="pre">a_vectVars</span></code> permit the user to set the output variable names for the <code class="docutils literal notranslate"><span class="pre">M</span></code> scalar variables and the <code class="docutils literal notranslate"><span class="pre">N</span></code> vector variables.
The argument <code class="docutils literal notranslate"><span class="pre">a_shift</span></code> will simply shift the particle positions in the output HDF5 file.</p>
</section>
<section id="superparticles">
<span id="chap-superparticles"></span><h2>Superparticles<a class="headerlink" href="#superparticles" title="Permalink to this heading"></a></h2>
<p>Often, merging or splitting of particles is required.
In the most general case, users can simply interact directly with the particle list to modify the particles, which can be done either on a per-patch basis or within individual grid cells.
In each case one starts with a list <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> that needs to be modified.</p>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> has rather elementary support for handling superparticles.
Currently, we only support reinitialization of particles, or agglomeration of particles using kD-trees, as discussed below.</p>
<section id="kd-trees">
<h3>kD-trees<a class="headerlink" href="#kd-trees" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> has functionality for spatially partitioning particles using kD-trees, which can be used as a basis for particle merging and splitting.
kD-trees operate by partitioning a set of input primitives into spatially coherent subsets.
At each level in the tree recursion one chooses an axis for partitioning one subset into two new subsets, and the recursion continues until the partitioning is complete.
<a class="reference internal" href="#fig-partitionkd"><span class="std std-numref">Fig. 13</span></a> shows an example where a set of initial particles are partitioned using such a tree.</p>
<figure class="align-center" id="id3">
<span id="fig-partitionkd"></span><a class="reference internal image-reference" href="../_images/PartitionKD.png"><img alt="../_images/PartitionKD.png" src="../_images/PartitionKD.png" style="width: 90%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 13 </span><span class="caption-text">Example of a kD-tree partitioning of particles in a single cell.</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The source code for the kD-tree functionality is given in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Source/Particle/CD_SuperParticles.H</span></code>.</p>
</div>
<p>The kD-tree partitioner requires a user-supplied criterion for particle partitioning.
Only the partitioner <code class="docutils literal notranslate"><span class="pre">PartitionEqualWeight</span></code> is currently supported, and this partitioner will divide the original subset into two new subsets such that the particle weights in the two halves differs by at most one physical particle.
This partitioner is imlemented as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="n">Real</span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">weight</span><span class="p">)(),</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">RealVect</span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">position</span><span class="p">)()</span><span class="w"> </span><span class="k">const</span><span class="o">&gt;</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">KDNode</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;::</span><span class="n">Partitioner</span><span class="w"> </span><span class="n">PartitionEqualWeight</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">P</span></code> is the particle type, and this class <em>must</em> have function members <code class="docutils literal notranslate"><span class="pre">Real&amp;</span> <span class="pre">P::weight()</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">RealVect&amp;</span> <span class="pre">P::position()</span></code> which return the particle weight and position.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">PartitionEqualWeight</span></code> will usually split particles to ensure that the weight in the two subsets are the same (thus creating new particles).
In this case any other members in the particle type are copied over into the new particles.</p>
</div>
<p>The particles in each leaf of the kD-tree can then be merged into new particles.
Since the weight in the nodes of the tree differ by at most one, the resulting computational particles also have weights that differ by at most one.</p>
<figure class="align-center" id="id4">
<span id="fig-superkd"></span><a class="reference internal image-reference" href="../_images/SuperKD.png"><img alt="../_images/SuperKD.png" src="../_images/SuperKD.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 14 </span><span class="caption-text">kD-tree partitioning of particles into new particles whose weight differ by at most one.
Left: Original particles with weights between 1 and 100.
Right: Merged particles.</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="MeshData.html" class="btn btn-neutral float-left" title="Mesh data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Realm.html" class="btn btn-neutral float-right" title="Realm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>