<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Particles &mdash; chombo-discharge  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Realm" href="Realm.html" />
    <link rel="prev" title="Mesh data" href="MeshData.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> chombo-discharge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Documentation.html">Using this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Testing.html">Code testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Acknowledgements.html">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="SpatialDiscretization.html">Spatial discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshData.html">Mesh data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Particles</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#particlecontainer">ParticleContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-structures">Data structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#list-p-and-listbox-p">List&lt;P&gt; and ListBox&lt;P&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="#listiterator-p">ListIterator&lt;P&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="#particledata-p">ParticleData&lt;P&gt;</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amrparticles-p">AMRParticles&lt;P&gt;</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#basic-use">Basic use</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#getting-the-particles">Getting the particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iterating-over-particles">Iterating over particles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sorting-particles">Sorting particles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sorting-by-cell">Sorting by cell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sorting-by-patch">Sorting by patch</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#allocating-particles">Allocating particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mapping-and-remapping">Mapping and remapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mapping-particles-with-particlevalidregion">Mapping particles with ParticleValidRegion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#remapping-particles">Remapping particles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#regridding">Regridding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#masked-particles">Masked particles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-particle-halo-masks">Creating particle halo masks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#embedded-boundaries">Embedded boundaries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#signed-distance-function">Signed distance function</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#particle-depositon">Particle depositon</a></li>
<li class="toctree-l2"><a class="reference internal" href="#particle-interpolation">Particle interpolation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers.html">Linear solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="VV.html">Verification and validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="CellTagger.html">CellTagger</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeoCoarsener.html">GeoCoarsener</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/CDR.html">Convection-Diffusion-Reaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Electrostatics.html">Electrostatic solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/MeshODESolver.html">Mesh ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Sigma.html">Surface charge solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/TracerParticles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Ito.html">Îto diffusion</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ImplementedModels.html">Implemented models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection-diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/MeshODEModel.html">Mesh ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/TracerParticleModel.html">Tracer particle model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#creating-a-geometry">Creating a geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorials/Tutorial.html#setting-up-a-timestepper">Setting up a <code class="docutils literal notranslate"><span class="pre">TimeStepper</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">Lookup tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Particles</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Source/Particles.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="particles">
<span id="chap-particles"></span><h1>Particles<a class="headerlink" href="#particles" title="Permalink to this heading"></a></h1>
<p><code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> supports computational particles using native <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> particle data.
The source code for the particle functionality resides in <code class="file docutils literal notranslate"><span class="pre">$DISCHARGE_HOME/Source/Particle</span></code>.</p>
<div class="section" id="particlecontainer">
<h2>ParticleContainer<a class="headerlink" href="#particlecontainer" title="Permalink to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> is a template class that</p>
<ol class="arabic simple">
<li><p>Stores computational particles of type <code class="docutils literal notranslate"><span class="pre">P</span></code> over an AMR hierchy.</p></li>
<li><p>Provides infrastructure for mapping and remapping.</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> uses the <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> structure <code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code> under the hood, and therefore has template constraints on <code class="docutils literal notranslate"><span class="pre">P</span></code>.
The simplest way to use <code class="docutils literal notranslate"><span class="pre">ParticleContainer</span></code> for a new type of particle is to let <code class="docutils literal notranslate"><span class="pre">P</span></code> inherit from the <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> class <code class="docutils literal notranslate"><span class="pre">BinItem</span></code>.
<code class="docutils literal notranslate"><span class="pre">BinItem</span></code> only has a single member variable which is its position, but derived classes will contain more and must therefore also add new linearization functions if the new member variables should be communicated.
There are many examples of <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> particles, see e.g. <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classTracerParticle.html">TracerParticle</a> or <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classPhoton.html">Photon</a>.
Please refer to the <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> design document for complete specification on the template constraints of <code class="docutils literal notranslate"><span class="pre">P</span></code>, or see some of the examples in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.</p>
</div>
<div class="section" id="data-structures">
<h2>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this heading"></a></h2>
<div class="section" id="list-p-and-listbox-p">
<h3>List&lt;P&gt; and ListBox&lt;P&gt;<a class="headerlink" href="#list-p-and-listbox-p" title="Permalink to this heading"></a></h3>
<p>At the lowest level the particles are always stored in a linked list <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code>.
The class can be simply be through of as a regular list of <code class="docutils literal notranslate"><span class="pre">P</span></code> with non-random access.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ListBox&lt;P&gt;</span></code> consists of a <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> <em>and</em> a <code class="docutils literal notranslate"><span class="pre">Box</span></code>.
The latter specifies the grid patch that the particles are assigned to.</p>
<p>To get the list of particles from a <code class="docutils literal notranslate"><span class="pre">ListBox&lt;P&gt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ListBox</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myListBox</span><span class="p">;</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">myList</span> <span class="o">=</span> <span class="n">myListBox</span><span class="o">.</span><span class="n">listItems</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="listiterator-p">
<h3>ListIterator&lt;P&gt;<a class="headerlink" href="#listiterator-p" title="Permalink to this heading"></a></h3>
<p>In order to iterate over particles, use an iterator <code class="docutils literal notranslate"><span class="pre">ListIterator&lt;P&gt;</span></code> (which is not random access):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticles</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">lit</span><span class="p">(</span><span class="n">myParticles</span><span class="p">);</span> <span class="n">lit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">lit</span><span class="p">){</span>
   <span class="n">P</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lit</span><span class="p">();</span>

   <span class="c1">// ... do something with this particle</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="particledata-p">
<h3>ParticleData&lt;P&gt;<a class="headerlink" href="#particledata-p" title="Permalink to this heading"></a></h3>
<p>On each grid level, <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> stores the particles in a <code class="docutils literal notranslate"><span class="pre">Chombo</span></code> class <code class="docutils literal notranslate"><span class="pre">ParticleData</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="o">&gt;</span>
<span class="n">ParticleData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">P</span></code> is the particle type.
<code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code> can be thought of as a <code class="docutils literal notranslate"><span class="pre">LevelData&lt;ListBox&lt;P&gt;</span> <span class="pre">&gt;</span></code>, although it actually inherits from <code class="docutils literal notranslate"><span class="pre">LayoutData&lt;ListBox&lt;P&gt;</span> <span class="pre">&gt;</span></code>.
Each grid patch contains a <code class="docutils literal notranslate"><span class="pre">ListBox&lt;P&gt;</span></code> of particles.</p>
</div>
<div class="section" id="amrparticles-p">
<h3>AMRParticles&lt;P&gt;<a class="headerlink" href="#amrparticles-p" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AMRParticles&lt;P&gt;</span></code> is our AMR version of <code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code>.
It is a simply a typedef of a vector of pointers to <code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code> on each level:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">AMRParticles</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">ParticleData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Again, the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> indicates the AMR level and the <code class="docutils literal notranslate"><span class="pre">ParticleData&lt;P&gt;</span></code> is a distributed data holder that holds the particles on each AMR level.</p>
</div>
</div>
<div class="section" id="basic-use">
<h2>Basic use<a class="headerlink" href="#basic-use" title="Permalink to this heading"></a></h2>
<p>Here, we give some examples of basic use of <code class="docutils literal notranslate"><span class="pre">ParticleContainer</span></code>.
For the full API, see the <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classParticleContainer.html">ParticleContainer doxygen documentation</a>.</p>
<div class="section" id="getting-the-particles">
<h3>Getting the particles<a class="headerlink" href="#getting-the-particles" title="Permalink to this heading"></a></h3>
<p>To get the particles from a <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> one can call <code class="docutils literal notranslate"><span class="pre">AMRParticles&lt;P&gt;&amp;</span> <span class="pre">ParticleContainer&lt;P&gt;::getParticles()</span></code> which will provide the particles:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticleContainer</span><span class="p">;</span>

<span class="n">AMRParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">myParticles</span> <span class="o">=</span> <span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getParticles</span><span class="p">();</span>
</pre></div>
</div>
<p>Alternatively, one can fetch directly from a specified grid level as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">lvl</span><span class="p">;</span>
<span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticleContainer</span><span class="p">;</span>

<span class="n">ParticleData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">levelParticles</span> <span class="o">=</span> <span class="n">myParticleContainer</span><span class="p">[</span><span class="n">lvl</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="iterating-over-particles">
<h3>Iterating over particles<a class="headerlink" href="#iterating-over-particles" title="Permalink to this heading"></a></h3>
<p>To do something basic with the particle in a <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code>, one will typically iterate over the particles in all grid levels and patches.</p>
<p>The code bit below shows a typical example of how the particles can be moved, and then remapped onto the correct grid patches and ranks if they fall off their original one.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticleContainer</span><span class="p">;</span>

<span class="c1">// Iterate over grid levels</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lvl</span> <span class="o">&lt;=</span> <span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getFinestLevel</span><span class="p">();</span> <span class="n">lvl</span><span class="o">++</span><span class="p">){</span>

   <span class="c1">// Get the grid on this level.</span>
   <span class="k">const</span> <span class="n">DisjointBoxLayout</span><span class="o">&amp;</span> <span class="n">dbl</span> <span class="o">=</span> <span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getGrids</span><span class="p">(</span><span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getRealm</span><span class="p">())[</span><span class="n">lvl</span><span class="p">];</span>

   <span class="c1">// Get the distributed particles on this level</span>
   <span class="n">ParticleData</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">levelParticles</span> <span class="o">=</span> <span class="n">myParticleContainer</span><span class="p">[</span><span class="n">lvl</span><span class="p">]</span>

   <span class="c1">// Iterate over grid patches on this level</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">DataIterator</span> <span class="n">dit</span><span class="p">(</span><span class="n">dbl</span><span class="p">);</span> <span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">dit</span><span class="p">){</span>

      <span class="c1">// Get the particles in the current patch.</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">patchParticles</span> <span class="o">=</span> <span class="n">levelParticles</span><span class="p">[</span><span class="n">dit</span><span class="p">()].</span><span class="n">listItems</span><span class="p">();</span>

      <span class="c1">// Iterate over the particles in the current patch.</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">lit</span><span class="p">(</span><span class="n">patchParticles</span><span class="p">);</span> <span class="n">lit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">lit</span><span class="p">){</span>
         <span class="n">P</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lit</span><span class="p">();</span>

         <span class="c1">// Move the particle</span>
         <span class="n">p</span><span class="p">.</span><span class="n">position</span><span class="p">()</span> <span class="o">=</span> <span class="p">...</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Remap particles onto new patches and ranks (they may have moved off their original ones)</span>
<span class="n">myParticleContainer</span><span class="p">.</span><span class="n">remap</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sorting-particles">
<h2>Sorting particles<a class="headerlink" href="#sorting-particles" title="Permalink to this heading"></a></h2>
<div class="section" id="sorting-by-cell">
<h3>Sorting by cell<a class="headerlink" href="#sorting-by-cell" title="Permalink to this heading"></a></h3>
<p>The particles can also be sorted by cell by calling <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">ParticleContainer&lt;P&gt;::sortParticleByCell()</span></code>, like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticleContainer</span><span class="p">;</span>

<span class="n">myParticleContainer</span><span class="p">.</span><span class="n">sortParticlesByCell</span><span class="p">();</span>
</pre></div>
</div>
<p>Internally in <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code>, this will place the particles in another container which can be iterated over on a per-cell basis.
This is different from <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">ListBox&lt;P&gt;</span></code> above, which contained particles stored on a per-patch basis with no internal ordering of the particles.</p>
<p>The per-cell particle container is a <code class="docutils literal notranslate"><span class="pre">Vector&lt;RefCountedPtr&lt;LayoutData&lt;BinFab&lt;P&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code> type where again the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> holds the particles on each AMR level and the <code class="docutils literal notranslate"><span class="pre">LayoutData&lt;BinFab&gt;</span></code> holds one <code class="docutils literal notranslate"><span class="pre">BinFab</span></code> on each grid patch.
The <code class="docutils literal notranslate"><span class="pre">BinFab</span></code> is also a template, and it holds a <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> in each grid cell.
Thus, this data structure stores the particles per cell rather than per patch.
Due to the horrific template depth, this container is typedef’ed as <code class="docutils literal notranslate"><span class="pre">AMRCellParticles&lt;P&gt;</span></code>.</p>
<p>To get cell-sorted particles one can call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AMRCellParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">cellSortedParticles</span> <span class="o">=</span> <span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getCellParticles</span><span class="p">();</span>
</pre></div>
</div>
<p>Iteration over cell-sorted particles is mostly the same as for patch-sorted particles, except that we also need to explicitly iterate over the grid cells in each grid patch:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Iterate over all AMR levels</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lvl</span> <span class="o">&lt;=</span> <span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getFinestLevel</span><span class="p">();</span> <span class="n">lvl</span><span class="o">++</span><span class="p">){</span>

   <span class="c1">// Get the grids on this level</span>
   <span class="k">const</span> <span class="n">DisjointBoxLayout</span><span class="o">&amp;</span> <span class="n">dbl</span> <span class="o">=</span> <span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">getGrids</span><span class="p">(</span><span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getRealm</span><span class="p">())[</span><span class="n">lvl</span><span class="p">];</span>

   <span class="c1">// Iterate over grid patches on this level</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">DataIterator</span> <span class="n">dit</span><span class="p">(</span><span class="n">dbl</span><span class="p">);</span> <span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">dit</span><span class="p">){</span>

      <span class="c1">// Get the Cartesian box for the current grid aptch</span>
      <span class="k">const</span> <span class="n">Box</span> <span class="n">cellBox</span> <span class="o">=</span> <span class="n">dbl</span><span class="p">[</span><span class="n">dit</span><span class="p">()];</span>

      <span class="c1">// Get the particles in the current grid patch.</span>
      <span class="n">BinFab</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">cellSortedBoxParticles</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">cellSortedParticles</span><span class="p">[</span><span class="n">lvl</span><span class="p">])[</span><span class="n">dit</span><span class="p">()];</span>

      <span class="c1">// Iterate over all cells in the current box</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">BoxIterator</span> <span class="n">bit</span><span class="p">(</span><span class="n">cellBox</span><span class="p">);</span> <span class="n">bit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">bit</span><span class="p">){</span>
         <span class="k">const</span> <span class="n">IntVect</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">bit</span><span class="p">();</span>

         <span class="c1">// Get the particles in the current grid cell.</span>
         <span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">cellParticles</span> <span class="o">=</span> <span class="n">cellSortedBoxParticles</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>

         <span class="c1">// Do something with cellParticles</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">lit</span><span class="p">(</span><span class="n">cellParticles</span><span class="p">);</span> <span class="n">lit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">lit</span><span class="p">){</span>
            <span class="n">P</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lit</span><span class="p">();</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sorting-by-patch">
<h3>Sorting by patch<a class="headerlink" href="#sorting-by-patch" title="Permalink to this heading"></a></h3>
<p>If the particles need to return to patch-sorted particles:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticleContainer</span><span class="p">;</span>

<span class="n">myParticleContainer</span><span class="p">.</span><span class="n">sortParticlesByPatch</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>If particles are sorted by cell, calling <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> member functions that fetch particles by patch will issue an error.
This is done by design since the patch-sorted particles have been moved to a different container.
Note that remapping particles also requires that the particles are patch-sorted.
Calling <code class="docutils literal notranslate"><span class="pre">remap()</span></code> with cell-sorted particles will issue a run-time error.</p>
</div>
</div>
</div>
<div class="section" id="allocating-particles">
<h2>Allocating particles<a class="headerlink" href="#allocating-particles" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">AmrMesh</span></code> has a very simple function for allocating a <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">P</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">allocate</span><span class="p">(</span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">a_container</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a_pvrBuffer</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a_realm</span><span class="p">);</span>
</pre></div>
</div>
<p>which will allocate a <code class="docutils literal notranslate"><span class="pre">ParticleContainer</span></code> on realm <code class="docutils literal notranslate"><span class="pre">a_realm</span></code> with a buffer zone of <code class="docutils literal notranslate"><span class="pre">a_pvrBuffer</span></code>.
This buffer zone adjusts if particles on the fine side of a refinement boundary map to the coarse grid or the fine grid (see <a class="reference internal" href="#chap-particlemapping"><span class="std std-ref">Mapping and remapping</span></a>).</p>
</div>
<div class="section" id="mapping-and-remapping">
<span id="chap-particlemapping"></span><h2>Mapping and remapping<a class="headerlink" href="#mapping-and-remapping" title="Permalink to this heading"></a></h2>
<div class="section" id="mapping-particles-with-particlevalidregion">
<h3>Mapping particles with ParticleValidRegion<a class="headerlink" href="#mapping-particles-with-particlevalidregion" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ParticleValidRegion</span></code> (PVR) allows particles to be transferred to coarser grid levels if they are within a specified number of grid cells from the refinement boundary.
There are two reasons why such a functionality is useful:</p>
<ol class="arabic simple">
<li><p>Particles that live in the first strip of cells on the fine side of a refinement boundary have deposition clouds that hang over the boundary and into ghost cells.
This mass must be added to the coarse level, which adds algorithmic complexity (<code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> can handle this complexity).</p></li>
<li><p>Deposition and interpolation kernels can be entirely contained within a grid level.
It might be useful to keep the kernel on a specific AMR level for a certain number of time step.</p></li>
</ol>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="../_images/ParticleValidRegion.png"><img alt="../_images/ParticleValidRegion.png" src="../_images/ParticleValidRegion.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">The <code class="docutils literal notranslate"><span class="pre">ParticleValidRegion</span></code> allows particles whose position fall into a fine grid patch to be moved to a coarser level if they are within a specified distance from the refinement boundary.
In this case, the green particles that overlap with the fine-level grid are remapped to the coarse level.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</div>
<p>The PVR is automatically allocated through the particle constructor by specifying the <code class="docutils literal notranslate"><span class="pre">a_pvrBuffer</span></code> flag.
If you do not want to use PVR functionality, simply set <code class="docutils literal notranslate"><span class="pre">a_pvrBuffer</span> <span class="pre">=</span> <span class="pre">0</span></code> for your <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code>.
In this case the particles will live on the grid patch that contains them.</p>
</div>
<div class="section" id="remapping-particles">
<h3>Remapping particles<a class="headerlink" href="#remapping-particles" title="Permalink to this heading"></a></h3>
<p>Particles that move off their original grid patch must be remapped in order to ensure that they are assigned to the correct grid.
The remapping function for <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> is <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">ParticleContainer&lt;P&gt;::remap()</span></code>, which is simply used as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticles</span><span class="p">;</span>

<span class="n">myParticles</span><span class="o">.</span><span class="n">remap</span><span class="p">();</span>
</pre></div>
</div>
<p>Note that if a PVR region is set, the particle container remapping will respect it.</p>
</div>
</div>
<div class="section" id="regridding">
<h2>Regridding<a class="headerlink" href="#regridding" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> is comparatively simple to regrid, and this is done in two steps:</p>
<ol class="arabic">
<li><p>Each MPI rank collects <em>all</em> particles on a single <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> by calling</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;::</span><span class="n">preRegrid</span><span class="p">(</span><span class="kt">int</span> <span class="n">a_base</span><span class="p">)</span>
</pre></div>
</div>
<p>This will pull the particles off their current grids and collect them in a single list (on a per-rank basis).</p>
</li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> regrids, each rank adds his <code class="docutils literal notranslate"><span class="pre">List&lt;P&gt;</span></code> back into the internal particle containers.</p></li>
</ol>
<p>The use case typically looks like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticleContainer</span><span class="p">;</span>

<span class="c1">// Each rank caches his particles</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">baseLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">myParticleContainer</span><span class="p">.</span><span class="n">preRegrid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// Driver does a regrid.</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>

<span class="c1">// After the regrid we fetch grids from AmrMesh:</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">DisjointBoxLayout</span><span class="o">&gt;</span> <span class="n">grids</span><span class="p">;</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">ProblemDomain</span><span class="o">&gt;</span> <span class="n">domains</span><span class="p">;</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="n">dx</span><span class="p">;</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">refinement_ratios</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">base</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">newFinestLevel</span><span class="p">;</span>

<span class="n">myParticleContainer</span><span class="p">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">domains</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">refinement_ratios</span><span class="p">,</span> <span class="n">baseLevel</span><span class="p">,</span> <span class="n">newFinestLevel</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">baseLevel</span></code> is the finest level that didn’t change and <code class="docutils literal notranslate"><span class="pre">newFinestLevel</span></code> is the finest AMR level after the regrid.</p>
</div>
<div class="section" id="masked-particles">
<span id="chap-maskedparticles"></span><h2>Masked particles<a class="headerlink" href="#masked-particles" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> also supports the concept of <em>masked particles</em>, where one can fetch a subset of particles that live only in specified regions in space.
Typically, this “specified region” is the refinement boundary, but the functionality is generic and might prove useful also in other cases.</p>
<p>When <em>masked particles</em> are used, the user can provide a boolean mask over the AMR hierarchy and obtain the subset of particles that live in regions where the mask evaluates to true.
This functionality is for example used for some of the particle deposition methods in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> where we deposit particles that live near the refinement boundary with special deposition functions.</p>
<p>To fill the masked particles, <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> has members functions for copying the particles into internal data containers which the user can later fetch.
The function signatures for these are</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">AmrMask</span> <span class="o">=</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">LevelData</span><span class="o">&lt;</span><span class="n">BaseFab</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">copyMaskParticles</span><span class="p">(</span><span class="k">const</span> <span class="n">AmrMask</span><span class="o">&amp;</span> <span class="n">a_mask</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">copyNonMaskParticles</span><span class="p">(</span><span class="k">const</span> <span class="n">AmrMask</span><span class="o">&amp;</span> <span class="n">a_mask</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The argument <code class="docutils literal notranslate"><span class="pre">a_mask</span></code> holds a bool at each cell in the AMR hierarchy.
Particles that live in cells where <code class="docutils literal notranslate"><span class="pre">a_mask</span></code> is true will be copied to an internal data holder in <code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> which can be retried through a call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AMRParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">maskParticles</span> <span class="o">=</span> <span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getMaskParticles</span><span class="p">();</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">copyNonMaskParticles</span></code> is just like <code class="docutils literal notranslate"><span class="pre">copyMaskParticles</span></code> except that the bools in <code class="docutils literal notranslate"><span class="pre">a_mask</span></code> have been flipped.</p>
<p>Note that the mask particles are <em>copied</em>, and the original particles are left untouched.
After the user is done with the particles, they should be deleted through the functions <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">clearMaskParticles()</span></code> and <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">clearNonMaskParticles</span></code>, like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AmrMask</span> <span class="n">myMask</span><span class="p">;</span>
<span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">myParticles</span><span class="p">;</span>

<span class="c1">// Copy mask particles</span>
<span class="n">myParticles</span><span class="p">.</span><span class="n">copyMaskParticles</span><span class="p">(</span><span class="n">myMask</span><span class="p">);</span>

<span class="c1">// Do something with the mask particles</span>
<span class="n">AMRParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">maskParticles</span> <span class="o">=</span> <span class="n">myParticleContainer</span><span class="p">.</span><span class="n">getMaskParticles</span><span class="p">();</span>

<span class="c1">// Release the mask particles</span>
<span class="n">myParticles</span><span class="p">.</span><span class="n">clearMaskParticles</span><span class="p">();</span>
</pre></div>
</div>
<div class="section" id="creating-particle-halo-masks">
<h3>Creating particle halo masks<a class="headerlink" href="#creating-particle-halo-masks" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AmrMesh</span></code> can register a <em>halo</em> mask with a specified width:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">registerMask</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a_mask</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a_buffer</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a_realm</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a_mask</span></code> must be <code class="docutils literal notranslate"><span class="pre">&quot;s_particle_halo&quot;</span></code>.
This will register a mask which is false everywhere except in coarse-grid cells that are within a distance a_buffer from the refinement boundary, see <a class="reference internal" href="#fig-halomask"><span class="std std-numref">Fig. 12</span></a>.</p>
<div class="figure align-center" id="id2">
<span id="fig-halomask"></span><a class="reference internal image-reference" href="../_images/HaloMask.png"><img alt="../_images/HaloMask.png" src="../_images/HaloMask.png" style="width: 40%;" /></a>
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">Example of a particle halo mask (shaded green color) surrounding refined grid levels.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</div>
</div>
</div>
<div class="section" id="embedded-boundaries">
<h2>Embedded boundaries<a class="headerlink" href="#embedded-boundaries" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ParticleContainer&lt;P&gt;</span></code> is EB-agnostic and has no information about the embedded boundary.
This means that particles remap just as if the EB was not there.
Interaction with the EB is done via the implicit function or discrete information, as well as modifications in the interpolation and deposition steps.</p>
<div class="section" id="signed-distance-function">
<h3>Signed distance function<a class="headerlink" href="#signed-distance-function" title="Permalink to this heading"></a></h3>
<p>When signed distance functions are used, one can always query how far a particle is from a boundary:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">List</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">particles</span><span class="p">;</span>
<span class="n">BaseIF</span> <span class="n">distanceFunction</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">lit</span><span class="p">(</span><span class="n">particles</span><span class="p">);</span> <span class="n">lit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">lit</span><span class="p">){</span>
   <span class="k">const</span> <span class="n">P</span><span class="o">&amp;</span> <span class="n">p</span>          <span class="o">=</span> <span class="n">lit</span><span class="p">();</span>
   <span class="k">const</span> <span class="n">RealVect</span><span class="o">&amp;</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">position</span><span class="p">();</span>

   <span class="k">const</span> <span class="n">Real</span> <span class="n">distanceToBoundary</span> <span class="o">=</span> <span class="n">distanceFunction</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the particle is inside the EB then the signed distance function will be positive and the particle can be removed from the simulation.
The distance function can also be used to detect collisions between particles and the EB.</p>
</div>
</div>
<div class="section" id="particle-depositon">
<h2>Particle depositon<a class="headerlink" href="#particle-depositon" title="Permalink to this heading"></a></h2>
<p>To deposit particles on the mesh, the user can call the templated function <code class="docutils literal notranslate"><span class="pre">AmrMesh::depositParticles</span></code> which has a signature</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span><span class="o">&amp;</span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">particleScalarField</span><span class="p">)()</span> <span class="k">const</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">depositParticles</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span>              <span class="n">a_meshData</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>          <span class="n">a_realm</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="o">&amp;</span>   <span class="n">a_phase</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">a_particles</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">DepositionType</span>        <span class="n">a_depositionType</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">CoarseFineDeposition</span>  <span class="n">a_coarseFineDeposition</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">bool</span>                  <span class="n">a_forceIrregNGP</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">const</span> <span class="n">RealVect</span><span class="o">&amp;</span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">particleVectorField</span><span class="p">)()</span> <span class="k">const</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">depositParticles</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span>              <span class="n">a_meshData</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>          <span class="n">a_realm</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="o">&amp;</span>   <span class="n">a_phase</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span> <span class="n">a_particles</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">DepositionType</span>        <span class="n">a_depositionType</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">CoarseFineDeposition</span>  <span class="n">a_coarseFineDeposition</span><span class="p">,</span>
                      <span class="k">const</span> <span class="kt">bool</span>                  <span class="n">a_forceIrregNGP</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, the template parameter <code class="docutils literal notranslate"><span class="pre">P</span></code> is the particle type and the template parameter <code class="docutils literal notranslate"><span class="pre">particleScalarField</span></code> is a C++ pointer-to-member-function.
This function must have the indicated signature <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Real&amp;</span> <span class="pre">P::particleScalarField()</span> <span class="pre">const</span></code> <em>or</em> the signature <code class="docutils literal notranslate"><span class="pre">Real</span> <span class="pre">P::particleScalarField()</span> <span class="pre">const</span></code>.
The pointer-to-member <code class="docutils literal notranslate"><span class="pre">particleScalarField</span></code> indicates the variable to be deposited on the mesh.
This function pointer does not need to return a member in the particle class.</p>
<p>Note that when depositing vector-quantities (such as electric currents), one must call the version which takes <code class="docutils literal notranslate"><span class="pre">RealVect</span> <span class="pre">P::particleVectorField()</span> <span class="pre">const</span></code> as a template parameter.
The supplied function must return a <code class="docutils literal notranslate"><span class="pre">RealVect</span></code> and <code class="docutils literal notranslate"><span class="pre">a_meshData</span></code> must have <code class="docutils literal notranslate"><span class="pre">SpaceDim</span></code> components.</p>
<p>Next, the input arguments to <code class="docutils literal notranslate"><span class="pre">depositParticles</span></code> are the output mesh data holder (must have exactly one or <code class="docutils literal notranslate"><span class="pre">SpaceDim</span></code> components), the realm and phase where the particles live, and the particles themselves (<code class="docutils literal notranslate"><span class="pre">a_particles</span></code>).
The enum <code class="docutils literal notranslate"><span class="pre">DepositionType</span></code> and input argument <code class="docutils literal notranslate"><span class="pre">a_depositionType</span></code> indicates the deposition method.
Valid arguments are</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DepositionType::NGP</span></code> (Nearest grid-point).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DepositionType::CIC</span></code> (Cloud-In-Cell).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DepositionType::TSC</span></code> (Triangle-Shaped Cloud).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DepositionType::W4</span></code>  (Fourth order weighted).</p></li>
</ul>
<p>The input argument <code class="docutils literal notranslate"><span class="pre">a_coarseFineDeposition</span></code> determines how coarse-fine deposition is handled.
Strictly speaking, this argument only affects how the particle mass is deposited from the coarse level to the fine level.
Valid input arguments are</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::PVR</span></code> This uses a standard PVR formulation.
When the particles near the refinement boundary deposit on the mesh, some of the mass from the coarse-side particles will end up underneath the fine grid.
This mass is interpolated to the fine grid using piecewise constant interpolation.
If the fine-level particles also have particle clouds that hang over the refinement boundary, the hanging mass will be added to the coarse level.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::Halo</span></code> This uses a what we call <em>halo</em> particles.
Instead of interpolating the mass from the invalid coarse region onto the fine level, the particles near the refinement boundary (i.e., the <em>halo</em> particles) deposit directly into the fine level but with 2x or 4x the particle width.
So, if a coarse-level particle lives right next to the fine grid and the refinement factor between the grids is <span class="math notranslate nohighlight">\(r\)</span>, it will deposit both into the fine grid with <span class="math notranslate nohighlight">\(r\)</span> times the particle width compared to the coarse grid.
Again, if the fine-level particles also have particle clouds that hang over the refinement boundary, the hanging mass will be added to the coarse level.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoarseFineDeposition::HaloNGP</span></code> This uses halo particles, but the particles along the refinement boundary are deposited with an NGP scheme.</p></li>
</ul>
<p>Finally, the flag <code class="docutils literal notranslate"><span class="pre">a_forceIrregNGP</span></code> permits the user to enforce nearest grid-point deposition in cut-cells.
This option is motivated by the fact that some applications might require hard mass conservation, and the user can ensure that mass is never deposited into covered grid cells.</p>
<p>As an example, if the particle type <code class="docutils literal notranslate"><span class="pre">P</span></code> needs to deposit a computational mass on the mesh, the particle class will at least contain the following member functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">P</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BinItem</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="k">const</span> <span class="n">Real</span><span class="o">&amp;</span> <span class="n">mass</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">m_mass</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">Real</span> <span class="n">mass2</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">m_mass</span><span class="o">*</span><span class="n">m_mass</span><span class="p">.</span>
   <span class="p">}</span>

   <span class="n">RealVect</span> <span class="n">momentum</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">m_mass</span><span class="o">*</span><span class="n">m_velocity</span><span class="p">;</span>
   <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>

   <span class="n">Real</span> <span class="n">m_mass</span><span class="p">;</span>

   <span class="n">Real</span> <span class="n">m_velocity</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, we have included an extra member function <code class="docutils literal notranslate"><span class="pre">mass()</span></code> which returns the squared mass.
Note that the function does not return a member variable but an r-value.
When depositing the mass on the mesh the user will e.g. call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">AmrMesh</span><span class="o">&gt;</span> <span class="n">amr</span><span class="p">;</span>

<span class="n">amr</span><span class="o">-&gt;</span><span class="n">depositParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">P</span><span class="o">::</span><span class="n">mass</span> <span class="o">&gt;</span><span class="p">(...);</span>
<span class="n">amr</span><span class="o">-&gt;</span><span class="n">depositParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">P</span><span class="o">::</span><span class="n">mass2</span><span class="o">&gt;</span><span class="p">(...);</span>
</pre></div>
</div>
<p>When depositing momentum, use</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">amr</span><span class="o">-&gt;</span><span class="n">depositParticles</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">P</span><span class="o">::</span><span class="n">momentum</span><span class="o">&gt;</span><span class="p">(...).</span>
</pre></div>
</div>
</div>
<div class="section" id="particle-interpolation">
<h2>Particle interpolation<a class="headerlink" href="#particle-interpolation" title="Permalink to this heading"></a></h2>
<p>To interpolate a field onto a particle position, the user can call the <code class="docutils literal notranslate"><span class="pre">AmrMesh</span></code> member functions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="n">Real</span><span class="o">&amp;</span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">particleScalarField</span><span class="p">)()</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">interpolateParticles</span><span class="p">(</span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span>      <span class="n">a_particles</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>         <span class="n">a_realm</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="o">&amp;</span>  <span class="n">a_phase</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span>       <span class="n">a_meshScalarField</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">DepositionType</span>       <span class="n">a_interpType</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">bool</span>                 <span class="n">a_forceIrregNGP</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="n">RealVect</span><span class="o">&amp;</span><span class="p">(</span><span class="n">P</span><span class="o">::*</span><span class="n">particleVectorField</span><span class="p">)()</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">interpolateParticles</span><span class="p">(</span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&amp;</span>      <span class="n">a_particles</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>         <span class="n">a_realm</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="o">&amp;</span>  <span class="n">a_phase</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span>       <span class="n">a_meshVectorField</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">DepositionType</span>       <span class="n">a_interpType</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">bool</span>                 <span class="n">a_forceIrregNGP</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The function signature for particle interpolation is pretty much the same as for particle deposition, with the exception of the interpolated field.
The template parameter <code class="docutils literal notranslate"><span class="pre">P</span></code> still indicates the particle type, but the user can interpolate onto either a scalar particle variable or a vector variable.
For example, in order to interpolate the particle acceleration, the particle class (let’s call it <code class="docutils literal notranslate"><span class="pre">MyParticleClass</span></code>) will typically have a member function <code class="docutils literal notranslate"><span class="pre">RealVect&amp;</span> <span class="pre">acceleration()</span></code>, and in this case one can interpolate the acceleration by</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">AmrMesh</span><span class="o">&gt;</span> <span class="n">amr</span><span class="p">;</span>

<span class="n">amr</span><span class="o">-&gt;</span><span class="n">interpolateParticles</span><span class="o">&lt;</span><span class="n">MyParticleClass</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyParticleClass</span><span class="o">::</span><span class="n">acceleration</span><span class="o">&gt;</span><span class="p">(...)</span>
</pre></div>
</div>
<p>Note that if the user interpolates onto a scalar variable, the mesh variable must have exactly one component.
Likewise, if interpolating a vector variable, the mesh variable must have exact <code class="docutils literal notranslate"><span class="pre">SpaceDim</span></code> components.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="MeshData.html" class="btn btn-neutral float-left" title="Mesh data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Realm.html" class="btn btn-neutral float-right" title="Realm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>