<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mesh data &mdash; chombo-discharge  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
      <link rel="stylesheet" type="text/css" href="../_static/my_theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Particles" href="Particles.html" />
    <link rel="prev" title="Chombo-3 basics" href="ChomboBasics.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            chombo-discharge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Base/Documentation.html">Using this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Testing.html">Code testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Base/Acknowledgements.html">Acknowledgements</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="DesignOverview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="ComputationalGeometry.html">ComputationalGeometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepper.html">TimeStepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrMesh.html">AmrMesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="CellTagger.html">CellTagger</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Discretization</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="SpatialDiscretization.html">Spatial discretization</a></li>
<li class="toctree-l1"><a class="reference internal" href="ChomboBasics.html"><code class="docutils literal notranslate"><span class="pre">Chombo-3</span></code> basics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Mesh data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#allocating-mesh-data">Allocating mesh data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterating-over-the-amr-hierarchy">Iterating over the AMR hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterating-over-cells">Iterating over cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coarsening-data">Coarsening data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filling-ghost-cells">Filling ghost cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interpolating-from-the-coarse-grid">Interpolating from the coarse grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="#computing-gradients">Computing gradients</a></li>
<li class="toctree-l2"><a class="reference internal" href="#copying-data">Copying data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dataops">DataOps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers.html">Linear solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="VV.html">Verification and validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Solvers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/CDR.html">Convection-Diffusion-Reaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Electrostatics.html">Electrostatic solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/Ito.html">Îto diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/KineticMonteCarlo.html">Kinetic Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/MeshODESolver.html">Mesh ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/SurfaceODESolver.html">Surface ODE solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Solvers/TracerParticles.html">Tracer particles</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multi-physics applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/CdrPlasmaModel.html">CDR plasma model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/DischargeInceptionModel.html">Discharge inception model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ItoKMC.html">Îto-KMC plasma model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Single-solver applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Applications/AdvectionDiffusionModel.html">Advection-diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/BrownianWalkerModel.html">Brownian walker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/ElectrostaticsModel.html">Electrostatics model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/GeometryModel.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/MeshODEModel.html">Mesh ODE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/RadiativeTransferModel.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Applications/TracerParticleModel.html">Tracer particle model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/DataParser.html">Data parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LookupTable.html">LookupTable1D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/RandomNumbers.html">Random numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/LeastSquares.html">Least squares</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/Contributions.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contrib/CodeStandard.html">Code standard</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ZZReferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">chombo-discharge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Mesh data</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Source/MeshData.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="mesh-data">
<span id="chap-meshdata"></span><h1>Mesh data<a class="headerlink" href="#mesh-data" title="Permalink to this heading"></a></h1>
<p>Mesh data structures of the type discussed in <a class="reference internal" href="SpatialDiscretization.html#chap-spatialdiscretization"><span class="std std-ref">Spatial discretization</span></a> are derived from a class <code class="docutils literal notranslate"><span class="pre">EBAMRData&lt;T&gt;</span></code> which holds a <code class="docutils literal notranslate"><span class="pre">T</span></code> in every grid patch across the AMR hiearchy.
A requirement on the datatype <code class="docutils literal notranslate"><span class="pre">T</span></code> is that it must be linearizable so that it can be communicated across MPI ranks.
Internally, the data is stored as a <code class="docutils literal notranslate"><span class="pre">Vector&lt;RefCountedPtr&lt;LevelData&lt;T&gt;&gt;&gt;</span></code>.
Here, the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> holds data on each AMR level; the data is allocated with a smart pointer called <code class="docutils literal notranslate"><span class="pre">RefCountedPtr</span></code> which points to a <code class="docutils literal notranslate"><span class="pre">LevelData</span></code> template structure, see <a class="reference internal" href="ChomboBasics.html#chap-basics"><span class="std std-ref">Chombo-3 basics</span></a>.
The first entry in the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> is base AMR level and finer levels follow later in the <code class="docutils literal notranslate"><span class="pre">Vector</span></code>.
<a class="reference internal" href="#fig-ebamrdata"><span class="std std-numref">Fig. 9</span></a> shows a sketch of the data layout in a two-level AMR hierarchy.</p>
<figure class="align-center" id="id2">
<span id="fig-ebamrdata"></span><a class="reference internal image-reference" href="../_images/PatchBasedAMR.png"><img alt="../_images/PatchBasedAMR.png" src="../_images/PatchBasedAMR.png" style="width: 60%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9 </span><span class="caption-text">Cartesian patch-based refinement showing two grid levels.
The finer level consists of two patches (red and blue zones), and these zones each have a ghost cell layer 2 cells wide.
The data lies on top of a coarse-grid data, i.e., data simultaneously exists on both the fine and the coarse levels.
This data type is encapsulated by <code class="docutils literal notranslate"><span class="pre">EBAMRData&lt;T&gt;</span></code>.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The reason for having class encapsulation of mesh data is due to <a class="reference internal" href="Realm.html#chap-realm"><span class="std std-ref">Realm</span></a>, so that we can only keep track on which <code class="docutils literal notranslate"><span class="pre">Realm</span></code> the mesh data is defined.
Users will interact with <code class="docutils literal notranslate"><span class="pre">EBAMRData&lt;T&gt;</span></code> through application code, or interacting with the core AMR functionality in <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a> (such as computing gradients, interpolating ghost cells etc.).
<a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a> has functionality for constructing most <code class="docutils literal notranslate"><span class="pre">EBAMRData&lt;T&gt;</span></code> types on a <code class="docutils literal notranslate"><span class="pre">Realm</span></code>, and <code class="docutils literal notranslate"><span class="pre">EBAMRData&lt;T&gt;</span></code> itself it typically not used anywhere elsewhere within <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.</p>
<p>A number of explicit template specifications exist and are frequently used.
These are outlined below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">EBCellFAB</span><span class="o">&gt;</span><span class="w">        </span><span class="n">EBAMRCellData</span><span class="p">;</span><span class="w">  </span><span class="c1">// Cell-centered single-phase data</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">EBFluxFAB</span><span class="o">&gt;</span><span class="w">        </span><span class="n">EBAMRFluxData</span><span class="p">;</span><span class="w">  </span><span class="c1">// Face-centered data in all coordinate direction</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">EBFaceFAB</span><span class="o">&gt;</span><span class="w">        </span><span class="n">EBAMRFaceData</span><span class="p">;</span><span class="w">  </span><span class="c1">// Face-centered in a single coordinate direction</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">BaseIVFAB</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">EBAMRIVData</span><span class="p">;</span><span class="w">    </span><span class="c1">// Data on irregular data centroids</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">DomainFluxIFFAB</span><span class="o">&gt;</span><span class="w">  </span><span class="n">EBAMRIFData</span><span class="p">;</span><span class="w">    </span><span class="c1">// Data on domain phases</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">BaseFab</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w">   </span><span class="n">EBAMRBool</span><span class="p">;</span><span class="w">      </span><span class="c1">// For holding bool at every cell</span>

<span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">MFCellFAB</span><span class="o">&gt;</span><span class="w">        </span><span class="n">MFAMRCellData</span><span class="p">;</span><span class="w">  </span><span class="c1">// Cell-centered multifluid data</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">MFFluxFAB</span><span class="o">&gt;</span><span class="w">        </span><span class="n">MFAMRFluxData</span><span class="p">;</span><span class="w">  </span><span class="c1">// Face-centered multifluid data</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">MFBaseIVFAB</span><span class="o">&gt;</span><span class="w">      </span><span class="n">MFAMRIVData</span><span class="p">;</span><span class="w">    </span><span class="c1">// Irregular face multifluid data</span>
</pre></div>
</div>
<p>For example, <code class="docutils literal notranslate"><span class="pre">EBAMRCellData</span></code> is a <code class="docutils literal notranslate"><span class="pre">Vector&lt;RefCountedPtr&lt;LevelData&lt;EBCellFAB&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></code>, describing cell-centered data across the entire AMR hierarchy.
There are many more data structures in place, but the above data structures are the most commonly used ones.
Here, <code class="docutils literal notranslate"><span class="pre">EBAMRFluxData</span></code> is precisely like <code class="docutils literal notranslate"><span class="pre">EBAMRCellData</span></code>, except that the data is stored on <em>cell faces</em> rather than cell centers.
Likewise, <code class="docutils literal notranslate"><span class="pre">EBAMRIVData</span></code> is a data holder that holds data on each EB centroid (or boundary centroid) across the entire AMR hierachy.
In the same way, <code class="docutils literal notranslate"><span class="pre">EBAMRIFData</span></code> holds data on each face of all cut-cells in the hierarchy.</p>
<section id="allocating-mesh-data">
<h2>Allocating mesh data<a class="headerlink" href="#allocating-mesh-data" title="Permalink to this heading"></a></h2>
<p>To allocate data over a particular <code class="docutils literal notranslate"><span class="pre">Realm</span></code>, the user will interact with <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numComps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">EBAMRCellData</span><span class="w"> </span><span class="n">myData</span><span class="p">;</span>
<span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">(</span><span class="n">myData</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;myRealm&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">gas</span><span class="p">,</span><span class="w"> </span><span class="n">numComps</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">numCOmps</span></code> determine the number of data components.
Note that it <em>does</em> matter on which <code class="docutils literal notranslate"><span class="pre">Realm</span></code> and on which <code class="docutils literal notranslate"><span class="pre">phase</span></code> the data is defined.
See <a class="reference internal" href="Realm.html#chap-realm"><span class="std std-ref">Realm</span></a> for details.</p>
<p>The user <em>can</em> specify a number of ghost cells for his/hers application code directly in the <code class="docutils literal notranslate"><span class="pre">AmrMesh::allocate</span></code> routine, like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">numComps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">EBAMRCellData</span><span class="w"> </span><span class="n">myData</span><span class="p">;</span>
<span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">(</span><span class="n">myData</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;myRealm&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">gas</span><span class="p">,</span><span class="w"> </span><span class="n">numComps</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">*</span><span class="n">IntVect</span><span class="o">::</span><span class="n">Unit</span><span class="p">);</span>
</pre></div>
</div>
<p>If the user does not specify the number of ghost cells when calling <code class="docutils literal notranslate"><span class="pre">AmrMesh::allocate</span></code>, <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a> will use the default number of ghost cells specified in the input file.</p>
</section>
<section id="iterating-over-the-amr-hierarchy">
<span id="chap-meshiteration"></span><h2>Iterating over the AMR hierarchy<a class="headerlink" href="#iterating-over-the-amr-hierarchy" title="Permalink to this heading"></a></h2>
<p>To iterate over data in an AMR hierarchy, you will first iterate over levels and then the patches on each level:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">myData</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">lvl</span><span class="o">++</span><span class="p">){</span>
<span class="w">   </span><span class="n">LevelData</span><span class="o">&lt;</span><span class="n">EBCellFAB</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">levelData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">myData</span><span class="p">[</span><span class="n">lvl</span><span class="p">];</span>

<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DisjointBoxLayout</span><span class="o">&amp;</span><span class="w"> </span><span class="n">levelGrids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levelData</span><span class="p">.</span><span class="n">disjointBoxLayout</span><span class="p">();</span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">DataIterator</span><span class="w"> </span><span class="n">dit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levelGrids</span><span class="p">.</span><span class="n">dataIterator</span><span class="p">();</span><span class="w"> </span><span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">dit</span><span class="p">){</span>
<span class="w">      </span><span class="n">EBCellFAB</span><span class="o">&amp;</span><span class="w"> </span><span class="n">patchData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levelData</span><span class="p">[</span><span class="n">dit</span><span class="p">()];</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Throughout <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> it will be common to see the above implemented explicitly as a loop that supports OpenMP:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lvl</span> <span class="o">&lt;</span> <span class="n">myData</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">lvl</span><span class="o">++</span><span class="p">){</span>
   <span class="n">LevelData</span><span class="o">&lt;</span><span class="n">EBCellFAB</span><span class="o">&gt;&amp;</span> <span class="n">levelData</span> <span class="o">=</span> <span class="o">*</span><span class="n">myData</span><span class="p">[</span><span class="n">lvl</span><span class="p">];</span>

   <span class="n">const</span> <span class="n">DisjointBoxLayout</span><span class="o">&amp;</span> <span class="n">levelGrids</span> <span class="o">=</span> <span class="n">levelData</span><span class="o">.</span><span class="n">disjointBoxLayout</span><span class="p">();</span>
   <span class="n">const</span> <span class="n">DataIterator</span><span class="o">&amp;</span> <span class="n">dataIterator</span>    <span class="o">=</span> <span class="n">levelGrids</span><span class="o">.</span><span class="n">dataIterator</span><span class="p">();</span>

   <span class="n">const</span> <span class="nb">int</span> <span class="n">numBoxes</span> <span class="o">=</span> <span class="n">dataIterator</span><span class="o">.</span><span class="n">size</span><span class="p">();</span>

<span class="c1">#pragma omp parallel for schedule(runtime)</span>
   <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">currentBox</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">currentBox</span> <span class="o">&lt;</span> <span class="n">numBoxes</span><span class="p">;</span> <span class="n">currentBox</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">const</span> <span class="n">DataIndex</span><span class="o">&amp;</span> <span class="n">dataIndex</span> <span class="o">=</span> <span class="n">dataIterator</span><span class="p">[</span><span class="n">currentBox</span><span class="p">];</span>

      <span class="n">EBCellFAB</span><span class="o">&amp;</span> <span class="n">patchData</span> <span class="o">=</span> <span class="n">levelData</span><span class="p">[</span><span class="n">dataIndex</span><span class="p">];</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="iterating-over-cells">
<h2>Iterating over cells<a class="headerlink" href="#iterating-over-cells" title="Permalink to this heading"></a></h2>
<p>For single-valued data, <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code> uses standard loops (in column-major order) for iterating over data.
For example, the standard loops for iterating over cell-centered data are</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">BoxLoops</span><span class="w"> </span><span class="p">{</span>

<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Functor</span><span class="o">&gt;</span>
<span class="w">   </span><span class="n">ALWAYS_INLINE</span><span class="w"> </span><span class="kt">void</span>
<span class="w">   </span><span class="n">loop</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Box</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_computeBox</span><span class="p">,</span><span class="w"> </span><span class="n">Functor</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">IntVect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntVect</span><span class="o">::</span><span class="n">Unit</span><span class="p">);</span>

<span class="w">   </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Functor</span><span class="o">&gt;</span>
<span class="w">   </span><span class="n">ALWAYS_INLINE</span><span class="w"> </span><span class="kt">void</span>
<span class="w">   </span><span class="n">loop</span><span class="p">(</span><span class="n">VoFIterator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_iter</span><span class="p">,</span><span class="w"> </span><span class="n">Functor</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a_kernel</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, the <code class="docutils literal notranslate"><span class="pre">Functor</span></code> argument is a C++ lambda or <code class="docutils literal notranslate"><span class="pre">std::function</span></code> which takes a grid cell as a single argument.
For the first loop, we iterate over all grid cells in <code class="docutils literal notranslate"><span class="pre">a_computeBox</span></code>.
Iterating over the cut-cells in a patch data holder (like the <code class="docutils literal notranslate"><span class="pre">EBCellFAB</span></code>) can be done with a <code class="docutils literal notranslate"><span class="pre">VoFIterator</span></code>, which can iterate through cells on an <code class="docutils literal notranslate"><span class="pre">EBCellFAB</span></code> that are not covered by the geometry.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lvl</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">myData</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">lvl</span><span class="o">++</span><span class="p">){</span>
<span class="w">   </span><span class="n">LevelData</span><span class="o">&lt;</span><span class="n">EBCellFAB</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">levelData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">myData</span><span class="p">[</span><span class="n">lvl</span><span class="p">];</span>

<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DisjointBoxLayout</span><span class="o">&amp;</span><span class="w"> </span><span class="n">levelGrids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levelData</span><span class="p">.</span><span class="n">disjointBoxLayout</span><span class="p">();</span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">DataIterator</span><span class="w"> </span><span class="n">dit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">levelGrids</span><span class="p">.</span><span class="n">dataIterator</span><span class="p">();</span><span class="w"> </span><span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">dit</span><span class="p">){</span>
<span class="w">      </span><span class="n">EBCellFAB</span><span class="o">&amp;</span><span class="w"> </span><span class="n">patchData</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">levelData</span><span class="p">[</span><span class="n">dit</span><span class="p">()];</span>
<span class="w">      </span><span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">regularData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">patchData</span><span class="p">.</span><span class="n">getSingleValuedFab</span><span class="p">();</span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">regularKernel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">IntVect</span><span class="o">&amp;</span><span class="w"> </span><span class="n">iv</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="n">regularData</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">      </span><span class="p">};</span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">irregularKernel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">VolIndex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vof</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="n">patchData</span><span class="p">(</span><span class="n">vof</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">      </span><span class="p">};</span>

<span class="w">      </span><span class="c1">// Kernel regions (defined by user)</span>
<span class="w">      </span><span class="n">Box</span><span class="w"> </span><span class="n">computeBox</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
<span class="w">      </span><span class="n">VoFIterator</span><span class="w"> </span><span class="n">vofit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>

<span class="w">      </span><span class="n">BoxLoops</span><span class="o">::</span><span class="n">loop</span><span class="p">(</span><span class="n">computeBox</span><span class="p">,</span><span class="w"> </span><span class="n">regularKernel</span><span class="p">);</span>
<span class="w">      </span><span class="n">BoxLoops</span><span class="o">::</span><span class="n">loop</span><span class="p">(</span><span class="n">vofit</span><span class="p">,</span><span class="w"> </span><span class="n">irregularKernel</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are loops available for other types of data (e.g., face-centered data), see the <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/CD__BoxLoops_8H.html">BoxLoop documentation</a>.</p>
</section>
<section id="coarsening-data">
<span id="chap-coarsening"></span><h2>Coarsening data<a class="headerlink" href="#coarsening-data" title="Permalink to this heading"></a></h2>
<p>Coarsening of data implies replacing the coarse-grid data that lies underneath a fine grid by some average of the fine-grid data.
We currently support the following coarsening algorithms:</p>
<ul class="simple">
<li><p>Arithmetic coarsening, in which the coarse-grid value is simply the average of the fine-grid values.</p></li>
<li><p>Conservative coarsening, in which the coarse-grid value is the conservative average of the fine-grid values.
This implies that the total mass on the coarse-grid cell is identical to the total mass in the fine-grid cells from which one coarsened.</p></li>
<li><p>Harmonic, in which the coarse-grid value is the harmonic average of the fine-grid cell values.</p></li>
</ul>
<p>These functions are available for both cell-centered data, cut-cell data, and face-centered data.
Multiply signatures for this functionality exists, see the code-block below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Average multifluid data over a specified realm</span>
<span class="cm">  @param[inout] a_data    Data to be coarsened.</span>
<span class="cm">  @param[in]    a_realm   Realm name</span>
<span class="cm">  @param[in]    a_average Averaging method</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">average</span><span class="p">(</span><span class="n">MFAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">a_realm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Average</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_average</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="cm">/*!</span>
<span class="cm">  @brief Average multifluid data over a specified realm</span>
<span class="cm">  @param[inout] a_data    Data to be coarsened.</span>
<span class="cm">  @param[in]    a_realm   Realm name</span>
<span class="cm">  @param[in]    a_average Averaging method</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">average</span><span class="p">(</span><span class="n">MFAMRFluxData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">a_realm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Average</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_average</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="cm">/*!</span>
<span class="cm">  @brief Average down on specific realm and phase. </span>
<span class="cm">  @param[inout] a_data  Data to be coarsened.</span>
<span class="cm">  @param[in]    a_realm Realm name</span>
<span class="cm">  @param[in]    a_phase Phase (gas or solid)</span>
<span class="cm">  @param[in]    a_average Averaging method</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">average</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w">           </span><span class="n">a_data</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w">        </span><span class="n">a_realm</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="w"> </span><span class="n">a_phase</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">Average</span><span class="o">&amp;</span><span class="w">           </span><span class="n">a_average</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>See the <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classAmrMesh.html">AmrMesh API</a> for further details.</p>
</section>
<section id="filling-ghost-cells">
<span id="chap-ghostcells"></span><h2>Filling ghost cells<a class="headerlink" href="#filling-ghost-cells" title="Permalink to this heading"></a></h2>
<p>Filling ghost cells is done using the <code class="docutils literal notranslate"><span class="pre">interpGhost(...)</span></code> functions in <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a>.
This process adheres to the following rules:</p>
<ol class="arabic simple">
<li><p>Within a grid level, cells are always filled from neighboring grid patches without interpolation.</p></li>
<li><p>Around the halo zone (see <a class="reference internal" href="#fig-ebamrdata"><span class="std std-numref">Fig. 9</span></a>), ghost cells are filled using slope-limited interpolation <em>from the coarse grid only</em>.
Currently, this slope is calculated with a minmod limiter, although support for superbee, piecewise constant, and van Leer limiters are also implemented.</p></li>
</ol>
<p>The signatures for updating the ghost cells are:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Interpolate ghost vectors over a realm, using the default ghost cell interpolation method. </span>
<span class="cm">  @param[inout] a_data  Data to be interpolated.</span>
<span class="cm">  @param[in]    a_realm Realm name</span>
<span class="cm">  @param[in]    a_phase Phase (gas or solid)</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">interpGhost</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">a_realm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="w"> </span><span class="n">a_phase</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>As one alternative, one can update ghost cells on a single grid level:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Interpolate ghost cells over a realm, using the default ghost cell interpolation method on a specific level. </span>
<span class="cm">  @param[inout] a_fineData Fine grid data</span>
<span class="cm">  @param[inout] a_coarData Coarse grid data</span>
<span class="cm">  @param[in]    a_level    The grid level corresponding to a_fineData</span>
<span class="cm">  @param[in]    a_realm    Realm name</span>
<span class="cm">  @param[in]    a_phase    Phase (gas or solid)</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">interpGhost</span><span class="p">(</span><span class="n">LevelData</span><span class="o">&lt;</span><span class="n">EBCellFAB</span><span class="o">&gt;&amp;</span><span class="w">       </span><span class="n">a_fineData</span><span class="p">,</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">LevelData</span><span class="o">&lt;</span><span class="n">EBCellFAB</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_coarData</span><span class="p">,</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w">                   </span><span class="n">a_level</span><span class="p">,</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w">           </span><span class="n">a_realm</span><span class="p">,</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="w">    </span><span class="n">a_phase</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Strictly speaking it is also possible to update ghost cells using the multigrid interpolator, but this will only fill a single layer of ghost cells around the halo zone (except near the cut-cells where additional cells are filled).</p>
</section>
<section id="interpolating-from-the-coarse-grid">
<span id="chap-coarsegridinterpolation"></span><h2>Interpolating from the coarse grid<a class="headerlink" href="#interpolating-from-the-coarse-grid" title="Permalink to this heading"></a></h2>
<p>Coarse-grid interpolation occurs, e.g., when the AMR hierarchy changes.
If one needs data on a grid level where no data already exists, it is possible to fill this data by interpolating from the coarse grid to a finer one.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>This type of interpolation is distinctly different from the ghost cell interpolation, as it affects data across the whole grid patch.</p>
</div>
<p>The interpolation function that fill fine-grid data from a coarse grid has the following signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Interpolate data to new grids</span>
<span class="cm">  @details This is called when requiring data to be interpolated to new grids. Takes old data as argument</span>
<span class="cm">  and fills the new grid data with an interpolation of the old grid data. </span>
<span class="cm">  @param[out] a_newData        New grid data.</span>
<span class="cm">  @param[in]  a_oldData        Old grid data.</span>
<span class="cm">  @param[in]  a_phase          Phase on which we regrid. </span>
<span class="cm">  @param[in]  a_lmin           Coarsest level that did not change (but distribution may have changed). </span>
<span class="cm">  @param[in]  a_oldFinestLevel Previous finest level.</span>
<span class="cm">  @param[in]  a_newFinestLevel New finest level. </span>
<span class="cm">  @param[in]  a_type Interpolation type</span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">interpToNewGrids</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w">                   </span><span class="n">a_newData</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w">             </span><span class="n">a_oldData</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="w">         </span><span class="n">a_phase</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w">                        </span><span class="n">a_lmin</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w">                        </span><span class="n">a_oldFinestLevel</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w">                        </span><span class="n">a_newFinestLevel</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="n">EBCoarseToFineInterp</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">a_type</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, the user must supply both the old data and the new data, as well as on which grid levels the interpolation will take place.
The final argument <code class="docutils literal notranslate"><span class="pre">a_type</span></code> is the interpolation type.
We currently support the following interpolation methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type::PWC</span></code>, which is piecewise-constant interpolation where the fine-cell data is filled with the coarse-cell values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Type::ConservativePWC</span></code>, which is a piecewise-constant interpolation that is also conservative (i.e., volume-weighted).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Type::ConservativeMinMod</span></code>, which is a conservative interpolation method that uses the minmod limiter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Type::ConservativeMonotonizedCentral</span></code>, which is a conservative interpolation method that uses the van Leer limiter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Type::Superbee</span></code>, which is a conservative interpolation method that uses the superbeed limiter.</p></li>
</ul>
<p>Note that there is “correct” interpolation method, but we note that we typically use a conservative minmod limiter in <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>.</p>
</section>
<section id="computing-gradients">
<span id="chap-gradients"></span><h2>Computing gradients<a class="headerlink" href="#computing-gradients" title="Permalink to this heading"></a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">chombo-discharge</span></code>, gradients are computed using a standard second-order stencil based on finite differences.
This is true everywhere except near the EB where the coarse-side stencil will avoid using the coarsened data beneath the fine level.
This is shown in <a class="reference internal" href="#fig-ebgradient"><span class="std std-numref">Fig. 10</span></a> which shows the typical 5-point stencil in regular grid regions, and also a much larger and more complex stencil.</p>
<p>In <a class="reference internal" href="#fig-ebgradient"><span class="std std-numref">Fig. 10</span></a> we have shown two regular 5-point stencils (red and green).
The coarse stencil (red) reaches underneath the fine level and uses the data defined by coarsening of the fine-level data.
The coarsened data in this case is just a conservative average of the fine-level data.
Likewise, the green stencil reaches over the refinement boundary and into one of the ghost cells on the coarse level.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is up to the user to ensure that ghost cells are filled prior to computing the gradient.
This can be done either using multigrid interpolation (see <a class="reference internal" href="LinearSolvers.html#chap-multigridinterpolation"><span class="std std-ref">Multigrid ghost cell interpolation</span></a>), or standard interpolation (see <a class="reference internal" href="#chap-ghostcells"><span class="std std-ref">Filling ghost cells</span></a>).</p>
</div>
<p><a class="reference internal" href="#fig-ebgradient"><span class="std std-numref">Fig. 10</span></a> also shows a much larger stencil (blue stencil) on the coarse side of the refinement interface.
The larger stencil is necessary because computing the <span class="math notranslate nohighlight">\(y\)</span> component of the gradient using a regular 5-point stencil would have the stencil reach underneath the fine level and into coarse data that is also irregular data.
Since there is no unique way (that we know of) for coarsening the cut-cell fine-level data onto the coarse cut-cell without introducing spurious artifacts into the gradient, we reconstruct the gradient using a least squares procedure that entirely avoids using coarsened data.
In this case we fetch a sufficiently large neighborhood of cells for computing a least squares minimization of a local solution reconstruction in the neighborhood of the coarse cell.
In order to avoid fetching potentially badly coarsened data, this neighborhood of cells only uses <em>valid</em> grid cells, i.e., the stencil does not reach underneath the fine level at all.
Once this neighborhood of cells is obtained, we compute the gradient using the procedure in <a class="reference internal" href="../Utilities/LeastSquares.html#chap-leastsquares"><span class="std std-ref">Least squares</span></a>.</p>
<figure class="align-center" id="id3">
<span id="fig-ebgradient"></span><a class="reference internal image-reference" href="../_images/EBGradient.png"><img alt="../_images/EBGradient.png" src="../_images/EBGradient.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10 </span><span class="caption-text">Example of stencils for computing gradients near embedded boundaries.
The red stencil shows a regular 5-point stencil for computing the gradient on the coarse side of the refinement boundary; it reaches into the coarsened data beneath the fine level.
The green stencil shows a similar 5-point stencil on the fine side of the refinement boundary; the stencil reaches over the refinement boundary and into one ghost cell.
The blue stencils shows a much more complex stencil which is computed using a least squares reconstruction procedure.</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>To compute gradients of a scalar, one can simply call <code class="docutils literal notranslate"><span class="pre">AmrMesh::computeGradient(...)</span></code> functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Compute cell-centered gradient over an AMR hierarchy. </span>
<span class="cm">  @param[out] a_gradient Cell centered gradient. </span>
<span class="cm">  @param[in]  a_phi      The scalar for which the gradient is computed. </span>
<span class="cm">  @param[in]  a_realm    Name of the realm where the data lives. </span>
<span class="cm">  @param[in]  a_phase    Phase on which the data lives. </span>
<span class="cm">  @note This routine will reach into ghost cells and across refinement boundaries. The user must make sure that </span>
<span class="cm">  ghost cells are updated before using this routine. </span>
<span class="cm">*/</span>
<span class="kt">void</span>
<span class="nf">computeGradient</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w">           </span><span class="n">a_gradient</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRCellData</span><span class="o">&amp;</span><span class="w">     </span><span class="n">a_phi</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w">        </span><span class="n">a_realm</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">phase</span><span class="o">::</span><span class="n">which_phase</span><span class="w"> </span><span class="n">a_phase</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>We reiterate that ghost cells must be updated <em>before</em> calling this routine.
See <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a> or refer to the <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classAmrMesh.html">AmrMesh API</a> for further details.</p>
</section>
<section id="copying-data">
<span id="chap-copyingdata"></span><h2>Copying data<a class="headerlink" href="#copying-data" title="Permalink to this heading"></a></h2>
<p>To copy data between data holders, one may use the <code class="docutils literal notranslate"><span class="pre">AmrMesh&lt;T&gt;::copyData(...)</span></code> function <em>or</em> <code class="docutils literal notranslate"><span class="pre">DataOps::copy</span></code> (see <a class="reference internal" href="#chap-dataops"><span class="std std-ref">DataOps</span></a>).</p>
<p>The simplest way of copying data between data holders is via <code class="docutils literal notranslate"><span class="pre">DataOps::copy</span></code>, which does a <em>local-only</em> direct copy that also includes ghost cells.
This version requires that the source and destination data holders are defined on the same realm, and does not invoke MPI calls.</p>
<p>A more general version is supplied by <a class="reference internal" href="AmrMesh.html#chap-amrmesh"><span class="std std-ref">AmrMesh</span></a>, and has the following structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm">  @brief Method for copying from a source container to a destination container. User supplies information</span>
<span class="cm">  @param[inout] a_dst        Destination data </span>
<span class="cm">  @param[in]    a_src        Source data</span>
<span class="cm">  @param[in]    a_dstComps   Destination components</span>
<span class="cm">  @param[in]    a_srcComps   Source components</span>
<span class="cm">  @param[in]    a_toRegion   Region we copy into</span>
<span class="cm">  @param[in]    a_fromRegion Region we copy from</span>
<span class="cm">  @note If the user requests copying into ghosted regions, the Copiers MUST USE THE CORRECT NUMBER OF GHOST CELLS</span>
<span class="cm">  @note This routine will not work if copying between grids before/after regrids. </span>
<span class="cm">*/</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span>
<span class="n">copyData</span><span class="p">(</span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w">       </span><span class="n">a_dst</span><span class="p">,</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">EBAMRData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_src</span><span class="p">,</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">Interval</span><span class="o">&amp;</span><span class="w">     </span><span class="n">a_dstComps</span><span class="p">,</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">Interval</span><span class="o">&amp;</span><span class="w">     </span><span class="n">a_srcComps</span><span class="p">,</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">CopyStrategy</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_toRegion</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">CopyStrategy</span><span class="o">::</span><span class="n">Valid</span><span class="p">,</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="n">CopyStrategy</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_fromRegion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CopyStrategy</span><span class="o">::</span><span class="n">Valid</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>In the above code, <code class="docutils literal notranslate"><span class="pre">a_dst</span></code> and <code class="docutils literal notranslate"><span class="pre">a_src</span></code> are the destination and source data holders for the copy.
These need not be defined on the same <a class="reference internal" href="Realm.html#chap-realm"><span class="std std-ref">Realm</span></a>.
Similarly, the <code class="docutils literal notranslate"><span class="pre">a_dstComps</span></code> and <code class="docutils literal notranslate"><span class="pre">a_srcComps</span></code> indicate the source and destination variables to be copied, which must have the same size.
The final two arguments indicate which regions will be copied from.
These are enums that are either <code class="docutils literal notranslate"><span class="pre">CopyStrategy::Valid</span></code> or <code class="docutils literal notranslate"><span class="pre">CopyStrategy::ValidGhost</span></code>, and indicates whether or not we will perform the copy only into <em>valid</em> cells (<code class="docutils literal notranslate"><span class="pre">CopyStrategy::Valid</span></code>) or also into the ghost cells (<code class="docutils literal notranslate"><span class="pre">CopyStrategy::ValidGhost</span></code>).</p>
</section>
<section id="dataops">
<span id="chap-dataops"></span><h2>DataOps<a class="headerlink" href="#dataops" title="Permalink to this heading"></a></h2>
<p>We have prototyped functions for many common data operations in a static class <code class="docutils literal notranslate"><span class="pre">DataOps</span></code>.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For the full <code class="docutils literal notranslate"><span class="pre">DataOps</span></code> API, see the <a class="reference external" href="https://chombo-discharge.github.io/chombo-discharge/doxygen/html/classDataOps.html">DataOps documentation</a>.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DataOps</span></code> contains numerous functions for operating on various template specializations of <code class="docutils literal notranslate"><span class="pre">EBAMRData&lt;T&gt;</span></code> (see <a class="reference internal" href="#chap-meshdata"><span class="std std-ref">Mesh data</span></a>).
For example, <code class="docutils literal notranslate"><span class="pre">DataOps</span></code> contains functions for scaling data, incrementing data, averaging cell-centered data onto faces, and many more.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p><code class="docutils literal notranslate"><span class="pre">DataOps</span></code> is designed to operate only within a single realm.
This means that <em>all</em> arguments into the <code class="docutils literal notranslate"><span class="pre">DataOps</span></code> functions <em>must</em> be defined on the same realm.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ChomboBasics.html" class="btn btn-neutral float-left" title="Chombo-3 basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Particles.html" class="btn btn-neutral float-right" title="Particles" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, SINTEF Energy Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>