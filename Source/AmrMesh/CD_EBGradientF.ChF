#include "CONSTANTS.H"

      subroutine gradient(
     &     chf_fra[grad],
     &     chf_const_fra1[phi],
     &     chf_const_real[dx],
     &     chf_box[region])


      integer chf_ddecl[i;j;k]
      real_t inv_2dx
      integer spacedim, idir	

      spacedim = CH_SPACEDIM

      inv_2dx = 1.0/(2.0*dx)

#if CH_SPACEDIM==3
      do k=CHF_LBOUND[region;2], CHF_UBOUND[region;2]
#endif
        do j=CHF_LBOUND[region;1], CHF_UBOUND[region;1]
           do i=CHF_LBOUND[region;0], CHF_UBOUND[region;0]
               grad(chf_ix[i;j;k],0) = (phi(chf_ix[i+1;j  ;k  ]) - phi(chf_ix[i-1;j  ;k]  ))*inv_2dx
               grad(chf_ix[i;j;k],1) = (phi(chf_ix[  i;j+1;k  ]) - phi(chf_ix[i  ;j-1;k  ]))*inv_2dx
#if CH_SPACEDIM==3
               grad(chf_ix[i;j;k],2) = (phi(chf_ix[i  ;j  ;k+1]) - phi(chf_ix[i  ;j  ;k-1]))*inv_2dx
#endif
           enddo
      enddo
#if CH_SPACEDIM==3
      enddo
#endif
      
      return
      end

      subroutine facegradient(
     &     chf_fra[grad],
     &     chf_const_fra1[phi],
     &     chf_const_int[dir],     
     &     chf_const_real[dx],
     &     chf_box[facebox])


      integer chf_ddecl[i;j;k]
      integer chf_ddecl[ioff ; joff ; koff ]
      integer chf_ddecl[ioff1; joff1; koff1]
      integer chf_ddecl[ioff2; joff2; koff2]      
      real_t inv_dx, inv_2dx, tanDerivLo, tanDerivHi
      integer tanDir1, tanDir2

c TLDR: This routine computes the face gradient using a 6-point stencil in 2D. On faces that are normal to the face direction
c       we use centered differencing using the two cells on the opposite sides of the faces. For components that are tangential
c       to the face direction we compute the tangential derivative on the two cell centers that connect the face. We then average
c       those derivatives to obtain the value on the face. 

c Offsets for face direction. 
      chf_dterm[
         ioff=chf_id(0, dir);
         joff=chf_id(1, dir);
         koff=chf_id(1, dir)]

c Offsets for tangential directions
      tanDir1 = mod(dir + 1, CH_SPACEDIM)
      chf_dterm[
         ioff1=chf_id(0, tanDir1);
         joff1=chf_id(1, tanDir1);
         koff1=chf_id(1, tanDir1)]
	 
#if CH_SPACEDIM==3
      tanDir2 = mod(dir + 2, CH_SPACEDIM)
      chf_dterm[
         ioff2=chf_id(0, tanDir2);
         joff2=chf_id(1, tanDir2);
         koff2=chf_id(1, tanDir2)]      
#endif	

      inv_dx  = 1.0/dx
      inv_2dx = 1.0/(2.0*dx)

      chf_multido[facebox; i;j;k]
         grad(chf_ix[i;j;k], dir) = inv_dx  * (phi(chf_ix[i;j;k]) - phi(chf_ix[i-ioff;j-joff;k-koff]))

         tanDerivHi = inv_2dx * (phi(chf_ix[i+ioff1     ; j+joff1     ; k+koff1     ]) - phi(chf_ix[i-ioff1     ; j-joff1     ; k-koff1     ]))
         tanDerivLo = inv_2dx * (phi(chf_ix[i+ioff1-ioff; j+joff1-joff; k+koff1-koff]) - phi(chf_ix[i-ioff1-ioff; j-joff1-joff; k-koff1-koff])) 

         grad(chf_ix[i;j;k], tanDir1) = half * (tanDerivHi + tanDerivLo)

#if CH_SPACEDIM==3
         tanDerivHi = inv_2dx * (phi(chf_ix[i+ioff2     ; j+joff2     ; k+koff2     ]) + phi(chf_ix[i-ioff2     ; j-joff2     ; k-koff2     ]))
         tanDerivLo = inv_2dx * (phi(chf_ix[i+ioff2-ioff; j+joff2-joff; k+koff2-koff]) + phi(chf_ix[i-ioff2-ioff; j-joff2-joff; k-koff2-koff]))

         grad(chf_ix[i;j;k], tanDir2) = half * (tanDerivHi - tanDerivLo)
#endif
      chf_enddo
      return
      end

      subroutine coarsenfacegradient(
     &     chf_fra1[gradCoar],
     &     chf_const_fra1[gradFine],
     &     chf_const_int[dir],
     &     chf_const_int[refRat],     
     &     chf_box[coarFaceBox])

      integer chf_ddecl[ido; jdo; kdo]
      integer chf_ddecl[icc; jcc; kcc]
      integer chf_ddecl[iff; jff; kff]
      integer chf_ddecl[i;   j;   k  ]

      real_t refScale, coarSum

c Compute the scaling factor for coarsening. This is inverse of the number of faces that we iterate over.
      refScale = one
      do i=1, (CH_SPACEDIM-1)
         refScale = refScale/(one*refRat)
      enddo

c Trick for ensuring that we ignore one of the coordinates when iterating over the fine faces that are refinements of the coarse face.
c So, for a coarse face with direction dir, we only want to iterate over the fine faces that are also oriented along dir and that are
c refinements of the coarse face. 
      CHF_DTERM[
         ido = 1 - chf_id(dir, 0);
         jdo = 1 - chf_id(dir, 0);
         kdo = 1 - chf_id(dir, 0)]

c Iterate over all coarse cell faces. 
      chf_multido[coarFaceBox; icc; jcc; kcc]
         coarSum = zero

c Iterate over the corresponding fine cell faces. In 3D this will be a 2D loop (over the refRat^2 number of fine faces) while in 2D this
c will be a 1D loop (over the refRat number of fine faces).
#if CH_SPACEDIM==3
         do k=0,(refRat-1)*kdo
#endif
            do j=0,(refRat-1)*jdo
               do i=0,(refRat-1)*ido
                  chf_dterm[
                     iff = icc*refRat + i;
                     jff = jcc*refRat + j;
                     kff = kcc*refRat + k]

                  coarSum = coarSum + gradFine(chf_ix[iff; jff; kff])
               enddo	       
            enddo
#if CH_SPACEDIM==3
         enddo
#endif
         gradCoar(chf_ix[icc; jcc; kcc]) = coarSum * refScale
      chf_enddo
      end

      subroutine facenormalderivative(
     &     chf_fra1[grad],
     &     chf_const_fra1[phi],
     &     chf_const_int[dir],     
     &     chf_const_real[dx],
     &     chf_box[interiorFaces])

      integer chf_ddecl[i;   j;   k   ]
      integer chf_ddecl[ioff;joff;koff]
      real_t invDx

      invDx = one/dx

      CHF_DTERM[
         ioff = chf_id(dir, 0);
         joff = chf_id(dir, 1);
         koff = chf_id(dir, 2)]    

      chf_multido[interiorFaces; i; j; k]
         grad(chf_ix[i;j;k]) = invDx * (phi(chf_ix[i;j;k]) - phi(chf_ix[i-ioff;j-joff;k-koff]))
      chf_enddo
      
      return
      end
